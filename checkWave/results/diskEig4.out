Usage: `mpirun -np N cgWave [-noplot] [file.cmd] [-g=<gridName>]'
Look for Overture configuration file=[/home/henshw/.overturerc]
Successfully opened /home/henshw/Overture.g/overturerc for reading
User commands are being saved in the file `cgWave.cmd'
 ***** Mounting file grids/sice2.order4.ng3.hdf****
getFromADataBase: number of CompositeGrid(s) found =1, name[0]=sic
Time to read in the grid is 1.93e-02(s)
CgWave::setup SETTING orderOfAccuracy=4
#
#  cgWave: Compute to some "known" solutions
#
#   cgWave [-noplot] known.cmd -g=<grid-name> -known=[pw|gpw|boxHelmholtz|polyPeriodic|squareEig|diskEig|annulusEig|sphereEig]
#           -upwind=[0|1] -computeErrors=[0|1]
#           -setKnownOnBoundaries=[0|1] -bcApproach=[cbc|lcbc|oneSided] -assignInterpNeighbours=[extrap|interp]
#           -meApproach=[std,ha|stencil]
#           -ts=[explicit|implicit] -rectangular=[implicit|explicit]
#
#   pw = plane wave
#   gpw = Gaussian plane wave
$known="planeWave";
$amp=1; $kx=1.0; $ky=0; $kz=0; $omega=3.;
$beta=20; $x0=.5; $y0=.0; $z0=.0; $k0=0.; # for Gaussian plane wave
# $ad4=0;   # old
$upwind=0;
$debug=3;  $go="halt"; $bc="d"; $dissFreq=1;
$bcApproach="oneSided"; # bc Approach : cbc, lcbc, oneSided
$useKnownFirstStep=0; $checkKnown=0;
$computeErrors=1; $plotScatteredField=0;
$setKnownOnBoundaries=-1; #-1 : use default
$tf=5.; $tp=.05; $cfl=.9;
$ts="explicit"; $dtMax=1e10; $implicitUpwind=0;
$rectangular="implicit"; # for ts=implicit, set rectangular=explicit to treat rectangular grids explicitly
$beta2=.5; $beta4=0.; $beta6=0.; $beta8=0.; # weights in implicit time-stepping
$meApproach="std"; # or "ha"
$orderInTime=-1;  # -1 = use default
$degreeInSpace=2; $degreeInTime=2;
$assignInterpNeighbours="extrap"; # by default extrap interp neighbours
$nBessel=1; $mTheta=1;
$mPhi=1; $mr=1;
$show=""; $flushFrequency=10;
$solveri="yale"; $maxiti=2000; $rtoli=1.0e-10; $atoli=1.0e-10; # parameters for implicit time-stepping solver
GetOptions( "cfl=f"=>\$cfl,"amp=f"=>\$amp,"kx=f"=>\$kx,"ky=f"=>\$ky,"kz=f"=>\$kz,"debug=i"=>\$debug,            "tf=f"=>\$tf,"tp=f"=>\$tp,"bc=s"=>\$bc,"dissFreq=i"=>\$dissFreq,"omega=f"=>\$omega,"beta2=f"=>\$beta2,"beta4=f"=>\$beta4,            "known=s"=>\$known,"orderInTime=i"=>\$orderInTime,"ts=s"=>\$ts,"dtMax=f"=>\$dtMax,"upwind=i"=>\$upwind,            "x0=f"=>\$x0,"y0=f"=>\$y0,"z0=f"=>\$z0,"k0=f"=>\$k0,"beta=f"=>\$beta,"computeErrors=i"=>\$computeErrors,            "setKnownOnBoundaries=s"=>\$setKnownOnBoundaries,"show=s"=>\$show,"useKnownFirstStep=i"=>\$useKnownFirstStep,            "flushFrequency=i"=>\$flushFrequency,"bcApproach=s"=>\$bcApproach,"meApproach=s"=>\$meApproach,            "nBessel=i"=>\$nBessel,"mPhi=i"=>\$mPhi,"mTheta=i"=>\$mTheta,"mr=i"=>\$mr,"rectangular=s"=>\$rectangular,            "solveri=s"=>\$solveri,"rtoli=f"=>\$rtoli,"atoli=f"=>\$atoli,"maxiti=i"=>\$maxiti,"plotScatteredField=i"=>\$plotScatteredField,            "assignInterpNeighbours=s"=>\$assignInterpNeighbours,"checkKnown=s"=>\$checkKnown,"implicitUpwind=i"=>\$implicitUpwind,"go=s"=>\$go );
#
#
if( $bc eq "d" ){ $bc="dirichlet"; }
if( $bc eq "n" ){ $bc="neumann"; }
if( $bc eq "e" ){ $bc="exact"; }
# if( $bc eq "e" ){ $bc="evenSymmetry"; }
if( $bc eq "r" ){ $bc="radiation"; }
# by default we do NOT set known on boundaries for these solutions:
if( $setKnownOnBoundaries eq "-1" && ($known eq "diskEig" || $known eq "squareEig" || $known eq "annulusEig" || $known eq "sphereEig") ){ $setKnownOnBoundaries=0; }
if( $setKnownOnBoundaries eq "-1" ){ $setKnownOnBoundaries=1; }
# if( $known eq "annulusEig" ){ $setKnownOnBoundaries=0; }
# if( $known eq "sphereEig" ){ $setKnownOnBoundaries=0; }
# time-stepping: (explicit or implicit)
$ts
# pause
tFinal $tf
Setting tFinal=0.1
tPlot $tp
 tPlot=0.1
cfl $cfl
setting cfl=0.9
dtMax $dtMax
Setting dtMax=1e+10
debug $debug
Setting debug=3
omega $omega
Setting omega=3 (and frequencyArray(0))
Answer=omega 3 found in getWaveHoltzOption
set known on boundaries $setKnownOnBoundaries
Setting applyKnownSolutionAtBoundaries=0 (1=apply known solution on boundaries).
Answer=set known on boundaries 0 found in getBoundaryConditionOption
use known for first step $useKnownFirstStep
Setting useKnownSolutionForFirstStep (use known solution for first time step if possible).
compute errors $computeErrors
Setting computeErrors=1 (1=compute errors for TZ or known solutions.
plot scattered field $plotScatteredField
Setting plotScatteredField=0.
if( $orderInTime > 0 ){ $cmd="orderInTime $orderInTime"; }else{ $cmd="#"; }
$cmd
if( $show ne "" ){ $cmd="show file name $show\n save show file 1\n flush frequency $flushFrequency"; }else{ $cmd="#"; }
$cmd
#
$cmd="#";
if( $bcApproach eq "oneSided" ){ $cmd="useOneSidedBCs"; }
if( $bcApproach eq "cbc"      ){ $cmd="useCompatibilityBCs"; }
if( $bcApproach eq "lcbc"     ){ $cmd="useLocalCompatibilityBCs"; }
$cmd
Setting approach for boundary conditions to useCompatibilityBCs
Answer=useCompatibilityBCs found in getBoundaryConditionOption
#
bc=$bc
Setting all boundary conditions to bc=[dirichlet]
Answer=bc=dirichlet found in getBoundaryConditionOption
#
$cmd="#";
if( $meApproach eq "std" ){ $cmd="standard modified equation"; }
if( $meApproach eq "ha" ){ $cmd="hierarchical modified equation"; }
if( $meApproach eq "stencil" ){ $cmd="stencil modified equation"; }
$cmd
Setting modifiedEquationApproach=standard modified equation
#
if( $ts eq "implicit" ){ $cmd="choose grids for implicit\n  rectangular=$rectangular\n done"; }else{ $cmd="#"; }
$cmd
# implicitUpwind = 1 : include upwinding in implicit matrix
implicit upwind $implicitUpwind
Setting implicitUpwind=0 (1=include upwinding in implicit matrix when implicit time-stepping
# beta2=0 : trap, beta2=.5 = FW
implicit weights $beta2 $beta4
Setting implicit time-stepping weights to beta2=0.5, beta4=0, beta6=0, beta8=0
#
if( $assignInterpNeighbours eq "interp" ){ $cmd="interpolateInterpNeighbours"; }else{ $cmd="#"; }
$cmd
#
if( $known eq "boxHelmholtz" ){ $cmd="helmholtzForcing\n user defined forcing...\n box Helmholtz\n exit"; }else{ $cmd="#"; }
if( $known eq "polyPeriodic" ){ $cmd="helmholtzForcing\n user defined forcing...\n poly periodic\n exit"; }
$cmd
#
user defined known solution...
if( $known eq "gpw" ){ $cmd="gaussian plane wave\n wave numbers: $kx $ky $kz\n beta: $beta\n k0: $k0\n offset: $x0 $y0 $z0"; }
if( $known eq "planeWave" || $known eq "pw" ){ $cmd="plane wave\n $amp $kx $ky $kz"; }
if( $known eq "boxHelmholtz"){ $cmd="box helmholtz\n $omega $kx $ky $kz"; }
$degreeInSpaceForPolyPeriodic=1;
if( $known eq "polyPeriodic"){ $cmd="poly periodic\n $omega $degreeInSpaceForPolyPeriodic"; }
# -- disk eigenfunction:
# n,m,a,amp,bcOpt
$rad=1;
if( $bc eq "dirichlet" ){ $bcOpt=0; }else{ $bcOpt=1; }
if( $bc eq "exact" ){ $bcOpt=0; }
if( $known eq "diskEig" ){ $cmd="disk eigenfunction\n $nBessel $mTheta $rad $amp $bcOpt"; }
if( $known eq "annulusEig" ){ $cmd="annulus eigenfunction\n $nBessel $mTheta $amp $bcOpt"; }
if( $known eq "sphereEig" ){ $cmd="sphere eigenfunction\n $mPhi $mTheta $mr $rad $amp $bcOpt"; }
if( $known eq "squareEig" ){ $cmd="square eigenfunction\n $kx $ky $kz"; }
$cmd
disk eigenfunction
--- Eigenfunction for the Wave Equation in the unit disk ---
    u = cos( c*lambda_{m,n} *t ) * Jn(lambda_m*r) * cos(n*theta)  [2D, Dirichlet BCs]
    n = angular number, n=0,1,2,
    m = radial number (m'th zero of Bessel Jn(lambda*a)=0 
    a = radius of the disk
    amp = amplitude
    bcOpt : 0=Dirichlet, 1=Neumann BCs on the annulus.
1 1 1 4 0
Disk eigenfuncton: n=1, m=1, a=1, amp=4, bcOpt=0
done
#
# if( $ad4>0. ){ $upwind=1; }# for backward compatibility
upwind dissipation $upwind
Setting upwind=1 (upwind dissipation is on or off).
#
if( $ts eq "implicit" ){ $cmd="include $ENV{CGWAVE}/runs/include/implicitOptions.h"; }else{ $cmd="#"; }
$cmd
#
# artificial dissipation $ad4
dissipation frequency $dissFreq
ERROR:setTextLabel: label [dissipation frequency] not found!
   Valid labels are
[tFinal]
[cfl]
[show file name]
[flush frequency]
[orderInTime]
[degreeInSpace]
[degreeInTime]
[trig frequencies]
[tPlot]
[tol]
[debug]
[interactiveMode]
[dissipationFrequency]
[dtMax]
[damp]
[implicit weights]
Setting dissipationFrequency=1 (dissipation is applied every this many steps)
exit
CgWave::initialize and assign forcing... numberOfFrequencies=1
CgWave::getTimeStep: c=1, cfl=0.9, timeSteppingMethod=0
getTimeStep: grid=0 : dx= 5.00e-02, dy= 5.00e-02, dt=3.182e-02
getTimeStep: grid=1, dxMin= 3.09e-02, dxMax= 3.85e-02, dt=2.780e-02
getTimeStep: grid=0: gridCFL = c/dx =  2.83e+01, gridCFL*dt=  7.86e-01
getTimeStep: grid=1: gridCFL = c/dx =  3.24e+01, gridCFL*dt=  9.00e-01
CgWave::initialize: dt=0.0277951

*********************************************************************************
           CgWave : Wave Equation Solver                    
           -----------------------------                  
 tFinal=0.100000, dt=2.780e-02, tPlot=1.000e-01 cfl=0.90, damp=0
 modifiedEquationApproach = standard modified equation
 orderOfAccuracy=4, orderOfAccuracyInTime=4 
 timeSteppingMethod = explicit (modified equation)
 upwind dissipation is on, dissipationFrequency=1
 upwind dissipation: preComputeUpwindUt=0 
                     true=precompute Ut in upwind dissipation,
                     false=compute Ut inline in Gauss-Seidel fashion)
 implicitUpwind=0 : if true, include upwinding in implicit matrix when implicit time-stepping.
 assignInterpNeighbours = interpolate (for wider upwind stencil)
 twilightZone = polynomial, degreeInSpace=2, degreeInTime=2
 knownSolutionOption=userDefinedKnownSolution, userKnownSolution=diskEigenfunction
 useKnownSolutionForFirstStep=0, applyKnownSolutionAtBoundaries=0
 BC approach = useCompatibilityBCs. [useDefault|useOneSided|useCompatibility|useLocalCompatibility]
 useSuperGrid=0, superGridWidth=0.2
 solveHelmholtz=0 (1= we are solving a Helmholtz problem).
 computeEigenmodes=0 (1= solve from eigenvalues and eigenvectors using the WaveHoltz algorithm).
 forcingOption=noForcing.
 computeErrors=1
 number of processors=1

 Grid: grids/sice2.order4.ng3.hdf 
               Grid Data
               ---------
grid     name       gridIndexRange(0:1,0:2)           gridPoints        hmx      hmn   time-stepping
   0:  square   ([ 0:   30],[ 0:   30],[ 0:    0])           961   5.00e-02 5.00e-02    explicit
   1: Annulus   ([ 0:  104],[ 0:    7],[ 0:    0])           840   3.85e-02 3.09e-02    explicit
 total number of grid points =1801, min(hmn)=3.09e-02, max(hmn)=5.00e-02, max(hmx)=5.00e-02,  

 grid   name      side axis    boundary condition and name
 ----   ----      ---- ----    ---------------------------
    0:  square     0    0      0 : none 
    0:  square     1    0      0 : none 
    0:  square     0    1      0 : none 
    0:  square     1    1      0 : none 
    1: Annulus     0    0     -1 : periodic 
    1: Annulus     1    0     -1 : periodic 
    1: Annulus     0    1      0 : none 
    1: Annulus     1    1      1 : dirichlet 
*********************************************************************************

if( $checkKnown eq "1" ){ $cmd="check known solution\n "; }else{ $cmd="#"; }
$cmd
#
solve
CgWave:advance: nextTimeToPlot=1.000e-01, numPlotSteps=4, new dt=2.500e-02 (dtMax=2.780e-02)
++++++++++++ getInitialConditions current=0, t=0.000e+00, dt=2.500e-02 ++++++++++++++ 
++++++ getTimeDerivative=0, initialConditionOption=2 ++++++
Disk: Bessel function solution: a=1, n=1, m=1, lambda=7.015587e+00, bcOpt=0 
Disk: Bessel function solution: a=1, n=1, m=1, lambda=7.015587e+00, bcOpt=0 
CgWave: done initial conditions
Overture::checkMemoryUsage: Interpolant::explicitInterpolate:after periodic and updateGhost, myid=0: memory usage has increased to 40.7031 (Mb)
>>> INFO CgWave::applyBC: allocate uTemp1 and utemp2 for order 4 CBC: numElements=1665
*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=2.500e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=2.500e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=2 ++++++
Disk: Bessel function solution: a=1, n=1, m=1, lambda=7.015587e+00, bcOpt=0 
Disk: Bessel function solution: a=1, n=1, m=1, lambda=7.015587e+00, bcOpt=0 
CgWave: done initial conditions
Disk: Bessel function solution: a=1, n=1, m=1, lambda=7.015587e+00, bcOpt=0 
Disk: Bessel function solution: a=1, n=1, m=1, lambda=7.015587e+00, bcOpt=0 
cgWave:FD44u t=0.000e+00 (0 steps) dt=2.500e-02 maxErr= 1.15e-05, ||u||= 5.80e-01, cpu= 0.00e+00(s)
Skip first step since set to exact, or used time-periodic
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.00E+00 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=   0   0   0   0  -1  -1
abcWave: t=0: DO NOTHING since past time is not known 
 bcOptWave: grid=   1 gridType= 1 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.00E+00 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=  -1  -1   0   1  -1  -1
abcWave: t=0: DO NOTHING since past time is not known 
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.25E-01 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=   0   0   0   0  -1  -1
 bcOptWave: grid=   1 gridType= 1 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.25E-01 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=  -1  -1   0   1  -1  -1
advWave: option=   0 grid=   0
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 2.500E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 7.071E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
XX advWave XX: grid=  0 gridType= 0 orderOfAccuracy= 4 useImplicitUpwindDissipation= 0
         : t=  2.50E-02 dt=  2.500000E-02
advWave: option=   0 grid=   1
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 2.500E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 8.095E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
XX advWave XX: grid=  1 gridType= 1 orderOfAccuracy= 4 useImplicitUpwindDissipation= 0
         : t=  2.50E-02 dt=  2.500000E-02
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.50E-01 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=   0   0   0   0  -1  -1
 bcOptWave: grid=   1 gridType= 1 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.50E-01 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=  -1  -1   0   1  -1  -1
advWave: option=   1 grid=   0
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 1 (1= add upwind dissipation in this stage)
advWave: t= 5.000E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 7.071E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
XX advWave XX: grid=  0 gridType= 0 orderOfAccuracy= 4 useImplicitUpwindDissipation= 0
         : t=  5.00E-02 dt=  2.500000E-02
  ****** useSosupDissipation *******
         : upwindDissipationCoefficient=  5.5243E-04 adSosupOld/(c*dt)=         NaN
         : useSosupDissipation= 1 sosupParameter=  1.00E+00 preComputeUpwindUt= 0
         : adxSosup  5.524272E-03  5.524272E-03  2.762136E-04
addUpwindDiss: UPWIND DISS using u.t=Dztu dim=2 order=4 grid=rectangular... t=  0.50E-01
 useSimplifiedDissipation= 0 adxSosup=  5.5243E-03  5.5243E-03  2.7621E-04
advWave: option=   0 grid=   0
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 5.000E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 7.071E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
XX advWave XX: grid=  0 gridType= 0 orderOfAccuracy= 4 useImplicitUpwindDissipation= 0
         : t=  5.00E-02 dt=  2.500000E-02
advWave: option=   1 grid=   1
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 1 (1= add upwind dissipation in this stage)
advWave: t= 5.000E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 8.095E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
XX advWave XX: grid=  1 gridType= 1 orderOfAccuracy= 4 useImplicitUpwindDissipation= 0
         : t=  5.00E-02 dt=  2.500000E-02
  ****** useSosupDissipation *******
         : upwindDissipationCoefficient=  5.5243E-04 adSosupOld/(c*dt)=         NaN
         : useSosupDissipation= 1 sosupParameter=  1.00E+00 preComputeUpwindUt= 0
addUpwindDiss: UPWIND DISS using u.t=Dztu dim=2 order=4 grid=curvilinear... t=  0.50E-01
 useSimplifiedDissipation= 0 adSosup=  5.5243E-04
advWave: option=   0 grid=   1
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 5.000E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 8.095E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
XX advWave XX: grid=  1 gridType= 1 orderOfAccuracy= 4 useImplicitUpwindDissipation= 0
         : t=  5.00E-02 dt=  2.500000E-02
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.75E-01 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=   0   0   0   0  -1  -1
 bcOptWave: grid=   1 gridType= 1 orderOfAccuracy= 4 uc=  0 twilightZone= 0
  addForcingBC=   0 forcingOption=   0 assignKnownSolutionAtBoundaries=   0
  t=  0.75E-01 dt=  0.25E-01 knownSolutionOption=1000 REAL_MIN=  0.22-307
  useUpwindDissipation= 1 numGhost= 3
  assignBCForImplicitForImplicit=   0 bcApproach=   2
  boundaryCondition=  -1  -1   0   1  -1  -1
advWave: option=   1 grid=   0
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 1 (1= add upwind dissipation in this stage)
advWave: t= 7.500E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 7.071E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
addUpwindDiss: UPWIND DISS using u.t=Dztu dim=2 order=4 grid=rectangular... t=  0.75E-01
 useSimplifiedDissipation= 0 adxSosup=  5.5243E-03  5.5243E-03  2.7621E-04
cgWave:FD44u t=1.000e-01 (4 steps) dt=2.500e-02 maxErr= 1.47e-05, ||u||= 4.43e-01, cpu= 1.82e-03(s)

              -------------------CgWave Summary----------------- 
                       Wed Jul 12 20:34:00 2023
               Grid:   grids/sice2.order4.ng3.hdf 
  ==== final time= 1.00e-01, numberOfStepsTaken =        4, grids=2, gridpts =1801, interp pts=456, processors=1, clock=2.99 GHz ==== 
  ==== memory per-proc: [min=41.7852,ave=41.7852,max=41.7852](Mb), max-recorded=41.7852 (Mb), total=41.7852 (Mb)
 applyBoundaryConditions called 5 times
   Timings:         (ave-sec/proc:)   seconds    sec/step   sec/step/pt     %     [max-s/proc] [min-s/proc]
total time..........................  4.94e-03    1.23e-03    6.86e-07   100.000   4.940e-03   4.940e-03
setup and initialize................  6.16e-04    1.54e-04    8.55e-08    12.470   6.160e-04   6.160e-04
initialize BCs......................  7.34e-04    1.84e-04    1.02e-07    14.858   7.340e-04   7.340e-04
initial conditions..................  1.20e-03    2.99e-04    1.66e-07    24.211   1.196e-03   1.196e-03
advance.............................  2.38e-03    5.95e-04    3.31e-07    48.198   2.381e-03   2.381e-03
  advance rectangular grids.........  2.24e-04    5.60e-05    3.11e-08     4.534   2.240e-04   2.240e-04
  advance curvilinear grids.........  2.33e-04    5.82e-05    3.23e-08     4.717   2.330e-04   2.330e-04
    implicit solve..................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  add dissipation...................  2.84e-04    7.10e-05    3.94e-08     5.749   2.840e-04   2.840e-04
  boundary conditions...............  3.56e-04    8.90e-05    4.94e-08     7.206   3.560e-04   3.560e-04
  interpolation.....................  1.86e-04    4.65e-05    2.58e-08     3.765   1.860e-04   1.860e-04
  update ghost (parallel)...........  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  add forcing.......................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  time integral.....................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  get errors........................  1.08e-03    2.71e-04    1.51e-07    21.964   1.085e-03   1.085e-03
  plotting..........................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
output results......................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
waiting (not counted)...............  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
--------------------------------------------------------------------------------------------------------
 Memory usage: reals/grid-point = 3041.01.
--------------------------------------------------------------------------------------------------------
 ======== Parallel Distribution for CgWave (np=1)============
 numberOfGrids=2, gridDistributionList.size()=2l 
  grid=0: procs=1 [0,0], proc-decomp=[1]x[1]x[1], pts=1406=[37]x[38]x[1], pts/proc=1406=[37]x[38]x[1], ratio=38/37=  1, ghost=[0,0,0]
  grid=1: procs=1 [0,0], proc-decomp=[1]x[1]x[1], pts=1665=[111]x[15]x[1], pts/proc=1665=[111]x[15]x[1], ratio=111/15=  7, ghost=[0,0,0]

 >>>> See the file mx.log for further timings, memory usage and other statistics <<<< 

#
contour
#   plot contour lines (toggle)
exit
#
if( $go eq "go" ){ $cmd="exit"; }else{ $cmd="#"; }
$cmd
advWave: option=   0 grid=   0
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 7.500E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 7.071E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
advWave: option=   1 grid=   1
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 1 (1= add upwind dissipation in this stage)
advWave: t= 7.500E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 8.095E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
addUpwindDiss: UPWIND DISS using u.t=Dztu dim=2 order=4 grid=curvilinear... t=  0.75E-01
 useSimplifiedDissipation= 0 adSosup=  5.5243E-04
advWave: option=   0 grid=   1
advWave: orderOfAccuracy= 4 orderInTime= 4
advWave: addForcing= 0 forcingOption= 0
advWave: useUpwindDissipation= 1 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 7.500E-02 dt= 2.500E-02 c=  1.00E+00 omega= 3.000E+00 gridCFL= 8.095E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 0 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
