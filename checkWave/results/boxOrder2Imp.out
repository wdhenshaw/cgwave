Usage: `mpirun -np N cgWave [-noplot] [file.cmd] [-g=<gridName>]'
Look for Overture configuration file=[/home/henshw/.overturerc]
Successfully opened /home/henshw/Overture.g/overturerc for reading
User commands are being saved in the file `cgWave.cmd'
 ***** Mounting file grids/box1.order2.hdf****
getFromADataBase: number of CompositeGrid(s) found =1, name[0]=box
Time to read in the grid is 6.13e-04(s)
CgWave::setup SETTING orderOfAccuracy=2
#
#  cgWave: test twilightZone
#     cgWave [-noplot] tz.cmd -g=<grid-name> -bc=[d|n|e] -cfl=<f> -tz=[polyl|trig] -degreeInSpace=<i> -degreeInTime=<i> ...
#                              -upwind=[0|1] -fx= -fy= -fz= -ft= -ts=[explicit|implicit] -rectangular=[implicit|explicit] -debug=<i>
#                              -bcApproach=[cbc|lcbc|oneSided] -meApproach=[std|ha|stencil] -implicitUpwind=[0|1]
#
# $aa=1./15.;
# printf("aa=%24.20e\n",$aa);
$omega=30.1; $x0=0; $y0=0; $z0=0; $beta=400; $numPeriods=1; $omegaSOR=1; $tol=1.e-3;
# $ad4=0; # OLD
$upwind=0; # new
$debug=3; $debugmg=1; $debugOges=0;
$ts="explicit"; $implicitUpwind=0;
$rectangular="implicit"; # for ts=implicit, set rectangular=explicit to treat rectangular grids explicitly
$beta2=.5; $beta4=0.; $beta6=0.; $beta8=0.; # weights in implicit time-stepping
$dtMax=1e10; $damp=0;
$bc="d";
$bcApproach="oneSided"; # bc Approach : cbc, lcbc, oneSided
$meApproach="std"; # or "ha"
$useKnownFirstStep=0; $takeImplicitFirstStep=0;
$orderInTime=-1;  # -1 = use default
$tz="polynomial";
$tf=1.; $tp=.1; $cfl=.9; $go="halt; "
$degreeInSpace=2; $degreeInTime=2;
$fx=2.; $fy=-1; $fz=-1; $ft=-1; # -1 : set equal to $fx
$solveri="yale"; $maxiti=2000; $rtoli=1.0e-10; $atoli=1.0e-10; # parameters for implicit time-stepping solver
GetOptions( "tz=s"=>\$tz,"degreeInSpace=i"=>\$degreeInSpace, "degreeInTime=i"=>\$degreeInTime,"cfl=f"=>\$cfl,            "x0=f"=>\$x0,"y0=f"=>\$y0,"z0=f"=>\$z0,"beta=f"=>\$beta,"debug=i"=>\$debug,"orderInTime=i"=>\$orderInTime,            "omegaSOR=f"=>\$omegaSOR,"tol=f"=>\$tol,"bc=s"=>\$bc,"tf=f"=>\$tf,"tp=f"=>\$tp,"ts=s"=>\$ts,"dtMax=f"=>\$dtMax,            "fx=f"=>\$fx,"fy=f"=>\$fy,"fz=f"=>\$fz,"ft=f"=>\$ft,"rectangular=s"=>\$rectangular,            "beta2=f"=>\$beta2,"beta4=f"=>\$beta4,"beta6=f"=>\$beta6,"upwind=i"=>\$upwind,"bcApproach=s"=>\$bcApproach,            "useKnownFirstStep=i"=>\$useKnownFirstStep,"meApproach=s"=>\$meApproach,"implicitUpwind=i"=>\$implicitUpwind,            "solveri=s"=>\$solveri,"rtoli=f"=>\$rtoli,"atoli=f"=>\$atoli,"maxiti=i"=>\$maxiti,"debugmg=i"=>\$debugmg,"debugOges=i"=>\$debugOges,            "takeImplicitFirstStep=i"=>\$takeImplicitFirstStep,"damp=f"=>\$damp,"go=s"=>\$go );
#
if( $tz eq "trig" ){ $tz="trigonometric"; }
if( $tz eq "poly" ){ $tz="polynomial"; }
if( $fy eq -1 ){ $fy=$fx; }
if( $fz eq -1 ){ $fz=$fx; }
if( $ft eq -1 ){ $ft=$fx; }
#
# time-stepping: (explicit or implicit)
$ts
#
cfl $cfl
setting cfl=0.9
tPlot $tp
 tPlot=0.1
tFinal $tf
Setting tFinal=0.2
dtMax $dtMax
Setting dtMax=0.1
damp $damp
Setting damp=0 (coefficient of linear damping)
#
$cmd="#";
if( $bcApproach eq "oneSided" ){ $cmd="useOneSidedBCs"; }
if( $bcApproach eq "cbc"      ){ $cmd="useCompatibilityBCs"; }
if( $bcApproach eq "lcbc"     ){ $cmd="useLocalCompatibilityBCs"; }
$cmd
Setting approach for boundary conditions to useOneSidedBCs
Answer=useOneSidedBCs found in getBoundaryConditionOption
#
$cmd="#";
if( $meApproach eq "std" ){ $cmd="standard modified equation"; }
if( $meApproach eq "ha" ){ $cmd="hierarchical modified equation"; }
if( $meApproach eq "stencil" ){ $cmd="stencil modified equation"; }
# printf("meApproach=$meApproach\n");
# printf("cmd=$cmd\n");
# pause
$cmd
Setting modifiedEquationApproach=standard modified equation
#
#  Set options for implicit time-stepping:
if( $ts eq "implicit" ){ $cmd="include $ENV{CGWAVE}/runs/include/implicitOptions.h"; }else{ $cmd="#"; }
$cmd
Pushing the current command file onto a stack
#
#  Include file to set options for implicit time-stepping
#
# ---- set defaults:  *finish me*
#
if( $ts eq "" ){ $ts="implicit"; }
if( $implicitUpwind eq "" ){ $implicitUpwind=0; }
if( $solveri eq "" ){ $solveri="yale"; }
# weights in implicit time-stepping:
if( $beta2 eq "" ){ $beta2=0.5; }
if( $beta4 eq "" ){ $beta4=0; }
if( $beta6 eq "" ){ $beta6=0; }
if( $beta8 eq "" ){ $beta8=0; }
if( $rtoli eq "" ){ $rtoli=1.e-8; }
if( $atoli eq "" ){ $atoli=1.e-8; }
if( $maxiti eq "" ){ $maxiti=500; }
if( $mgMaxIts eq "" ){ $mgMaxIts=15; } # max MG iterations
if( $debugmg eq "" ){ $debugmg=0; }
if( $debugOges eq "" ){ $debugOges=0; }
if( $rectangular eq "" ){ $rectangular="implicit"; } # set  $rectangular="explicit" to treat rectangular grids explicitly
#
if( $ts eq "implicit" ){ $cmd="choose grids for implicit\n  rectangular=$rectangular\n done"; }else{ $cmd="#"; }
$cmd
choose grids for implicit
Set grids to be implicit, or explicit. Type 'done' to finish. 
 Examples: (type `help' for more examples)
  square=explicit 
  annulus=implicit 
  all=implicit 
rectangular=implicit
Setting time stepping to be implicit for grid box
done
# implicitUpwind = 1 : include upwinding in implicit matrix
implicit upwind $implicitUpwind
Setting implicitUpwind=0 (1=include upwinding in implicit matrix when implicit time-stepping
#
implicit weights $beta2 $beta4 $beta6 $beta8
Setting implicit time-stepping weights to beta2=0.5, beta4=0, beta6=0, beta8=0
#
# $solveri="multigrid";
# $solveri="yale";
implicit solver parameters
Set the Oges parameters for the implicit solver.
# NOTE: bcgs = bi-CG stab
if( $solveri ne "yale" ){ $cmd="choose best iterative solver\n $solveri"; }else{ $cmd="choose best direct solver"; }
$cmd
Choosing: yale, solver=[direct sparse solver, no pivoting + ]
number of incomplete LU levels
3
number of GMRES vectors
20
maximum number of iterations
#
$maxiti
relative tolerance
$rtoli
absolute tolerance
$atoli
debug
$debugOges
Setting Oges::debug=0
#
multigrid parameters
choose good parameters: 1
choose good parameters: 0=OFF, 1=ON, 2=Use more robust parameters. Setting value to 1
OgesParameters: relativeTolerance=1.000000e-03 
residual tolerance $rtoli
absolute tolerance $atoli
maximum number of iterations
$mgMaxIts
debug
$debugmg
if( $debugmg > 1 ){ $cmdmg="show smoothing rates"; }else{ $cmdmg="#"; }
$cmdmg
# printf("debugmg=$debugmg, cmdmg = $cmdmg\n");
# pause
# maximum number of extra levels
#  1
#
# do not average coarse grid equations
# pause
# Coarse level solver:
Oges parameters
choose best direct solver
Choosing: yale, solver=[direct sparse solver, no pivoting + ]
# choose best iterative solver
relative tolerance
1.e-10
absolute tolerance
1.e-10
number of incomplete LU levels
3
# debug
#   7
minimum number of iterations
2
exit
OgmgParameters::display direct solver ogesParameters:
name = yale, solver=[direct sparse solver, no pivoting + ]
solverType = yale
solverMethod = direct sparse solver, no pivoting
parallel solverMethod = direct sparse solver, no pivoting
preconditioner = incomplete LU preconditioner
parallelPreconditioner = block Jacobi preconditioner
matrix ordering = reverse Cuthill-McKee ordering
maximumNumberOfIterations = 100
minimumNumberOfIterations = 2
relativeTolerance = 1.00e-10
absoluteTolerance = 1.00e-10
maximumAllowableIncreaseInResidual = 1.00e+05
compatibilityConstraint = 0
gmresRestartLength = 20
numberOfIncompleteLULevels = 3
incompleteLUExpectedFill = 20
minimumNumberOfIterations = 20
maximumNumberOfIterations = 20
solveForTranspose = 20
rescaleRowNorms = 1
matrixCutoff= 0.00e+00
fixupRightHandSide= 1
zeroRatio    = 0.00e+00
fillinRatio  = 0.00e+00
fillinRatio2 = 0.00e+00
harwellPivotingTolerance = 1.00e-01
nullVectorScaling = 1.00e+00
maximumInterpolationWidth = 100
iterativeImprovement = 0
sorOmega = 1.01e+00
userSuppliedCompatibilityConstraint = 0
userSuppliedEquations = 0
exit
#pause
exit
readLineFromCommandFile:End of file or a null line was read.
pop the stack of read command files...
take implicit first step $takeImplicitFirstStep
Setting takeImplicitFirstStep=0 (1=take an implicit first step when implicit time-stepping
#
debug $debug
Setting debug=3
if( $orderInTime > 0 ){ $cmd="orderInTime $orderInTime"; }else{ $cmd="#"; }
$cmd
#
if( $bc eq "d" ){ $cmd="bc=dirichlet"; }elsif( $bc eq "n" ){ $cmd="bc=neumann"; }elsif( $bc eq "e" ){ $cmd="bc=exact"; }elsif( $bc eq "a" ){ $cmd="bc=absorbing"; }else{ $cmd="bc=dirichlet"; }
$cmd
Setting all boundary conditions to bc=[dirichlet]
Answer=bc=dirichlet found in getBoundaryConditionOption
turn on forcing 1
twilightZoneForcing
$tz
#
use known for first step $useKnownFirstStep
Setting useKnownSolutionForFirstStep (use known solution for first time step if possible).
#
degreeInSpace $degreeInSpace
Setting degreeInSpace=2
degreeInTime $degreeInTime
Setting degreeInTime=2
#
trig frequencies $fx $fy $fz $ft
Setting trig frequencies: fx=2, fy=2, fz=2, ft=2
#
#Gaussian params $beta $x0 $y0 0 (beta,x0,y0,z0)
# omega $omega
# omegaSOR $omegaSOR
# if( $ad4>0. ){ $upwind=1; }# for backward compatibility
upwind dissipation $upwind
Setting upwind=0 (upwind dissipation is on or off).
implicit upwind $implicitUpwind
Setting implicitUpwind=0 (1=include upwinding in implicit matrix when implicit time-stepping
# artificial dissipation $ad4
# tol $tol
# number of periods $numPeriods
exit
CgWave::initialize and assign forcing... numberOfFrequencies=1

 $$$$$$$ setup TZ: build OGPolyFunction: numCompTz=1 degreeSpace=2, degreeTime=2 ndp=5 $$$$
timeCoefficientsForTZ
    (   0) (   1) (   2) (   3) (   4) 
(0)  1.000  0.500  0.333  0.000  0.000 
CgWave::getTimeStep: c=1, cfl=0.9, timeSteppingMethod=1
getTimeStep: grid=0 : dx= 1.00e-01, dy= 1.00e-01, dt=5.196e-02
cgWave::getTimeStep: cfl=0.9, explicit dt= 5.20e-02, implicit dt= 1.00e-01, ratio=  1.92
cgWave:chooseTimeStep: chooseImplicitTimeStepFromCFL : setting dt= 5.20e-02, cfl=0.9
getTimeStep: grid=0: gridCFL = c/dx =  1.73e+01, gridCFL*dt=  9.00e-01
CgWave::initialize: dt=0.0519615

*********************************************************************************
           CgWave : Wave Equation Solver                    
           -----------------------------                  
 tFinal=0.200000, dt=5.196e-02, tPlot=1.000e-01 cfl=0.90, damp=0
 modifiedEquationApproach = standard modified equation
 orderOfAccuracy=2, orderOfAccuracyInTime=2 
 timeSteppingMethod = implicit
 ---- implicit time stepping parameters ----
   implict solver=yale, solver=[direct sparse solver, no pivoting + ]
   implicit solver: rtol= 1.00e-10, atol= 1.00e-10
   All grids are implicit.
   takeImplicitFirstStep = 0.
   implicit time-stepping weights: cImp(-1,0)=0.25, cImp(0,0)=0.5, cImp(1,0)=0.25 (2nd-order term)
                                 : cImp(-1,1)=0.0833333, cImp(0,1)=0, cImp(1,1)=0.0833333 (4th-order term)
   chooseImplicitTimeStepFromCFL=1 (1=choose implicit dt from cfl, 0=choose dt from dtMax)
 upwind dissipation is off, dissipationFrequency=1
 upwind dissipation: preComputeUpwindUt=0 
                     true=precompute Ut in upwind dissipation,
                     false=compute Ut inline in Gauss-Seidel fashion)
 implicitUpwind=0 : if true, include upwinding in implicit matrix when implicit time-stepping.
 assignInterpNeighbours = interpolate (for wider upwind stencil)
 twilightZone = polynomial, degreeInSpace=2, degreeInTime=2
 knownSolutionOption=noKnownSolution
 useKnownSolutionForFirstStep=0, applyKnownSolutionAtBoundaries=0
 BC approach = useOneSidedBCs. [useDefault|useOneSided|useCompatibility|useLocalCompatibility]
 useSuperGrid=0, superGridWidth=0.2
 solveHelmholtz=0 (1= we are solving a Helmholtz problem).
 computeEigenmodes=0 (1= solve from eigenvalues and eigenvectors using the WaveHoltz algorithm).
 forcingOption=twilightZoneForcing.
 computeErrors=1
 Twilightzone flow is on. number of processors=1

 Grid: grids/box1.order2.hdf 
               Grid Data
               ---------
grid     name   gridIndexRange(0:1,0:2)           gridPoints        hmx      hmn   time-stepping
   0: box   ([ 0:   10],[ 0:   10],[ 0:   10])          1331   1.00e-01 1.00e-01    implicit
 total number of grid points =1331, min(hmn)=1.00e-01, max(hmn)=1.00e-01, max(hmx)=1.00e-01,  

 grid   name  side axis    boundary condition and name
 ----   ----  ---- ----    ---------------------------
    0: box     0    0      1 : dirichlet 
    0: box     1    0      1 : dirichlet 
    0: box     0    1      1 : dirichlet 
    0: box     1    1      1 : dirichlet 
    0: box     0    2      1 : dirichlet 
    0: box     1    2      1 : dirichlet 
*********************************************************************************

#
solve
CgWave:advance: nextTimeToPlot=1.000e-01, numPlotSteps=2, new dt=5.000e-02 (dtMax=5.196e-02)
++++++++++++ getInitialConditions current=0, t=0.000e+00, dt=5.000e-02 ++++++++++++++ 
++++++ getTimeDerivative=0, initialConditionOption=1 ++++++
$$$$ Get TZ initial conditions: t=0.000e+00, getTimeDerivative=0 $$$
$$$$ Get TZ initial conditions: ntd=0 $$$
CgWave: done initial conditions
Overture::checkMemoryUsage: Interpolant::explicitInterpolate:after periodic and updateGhost, myid=0: memory usage has increased to 39.2852 (Mb)
++++++++++++ getInitialConditions current=1, t=5.000e-02, dt=5.000e-02 ++++++++++++++ 
++++++ getTimeDerivative=0, initialConditionOption=1 ++++++
$$$$ Get TZ initial conditions: t=5.000e-02, getTimeDerivative=0 $$$
$$$$ Get TZ initial conditions: ntd=0 $$$
CgWave: done initial conditions
cgWave:FD22 t=0.000e+00 (0 steps) dt=5.000e-02 maxErr= 0.00e+00, ||u||= 4.07e+00, cpu= 0.00e+00(s)
Skip first step since set to exact, or used time-periodic

 ==================== FORM MATRIX FOR IMPLICIT TIME-STEPPING ===================
   c=1, dt=5.000e-02, orderOfAccuracy=2, orderOfAccuracyInTime=2  bcApproach=1
 upwind=0, add upwinding to implicit matrix=0, useSuperGrid=0
 ================================================================================
CgWave::formImplicitTimeSteppingMatrix: Changing the implicit solver parameters. 

 === Implicit Time-Stepping Solver:
 yale, solver=[direct sparse solver, no pivoting + ]
 =====

 >>>>>>> CgWave::implicitSolver: use predfined equations <<<<<<< 

CgWave::implicitSolver: A = I -alpha (c*dt)^2 Delta, c=1, dt= 5.00e-02
***Oges:Increasing fillinRatio for workspace to 3.800000e+01
  (to over-ride this value you should explicitly set the fillin ratio)
Oges::allocateWorkSpace: numberOfNonzeros=10347 fillinRatio=3.800000e+01
allocateWorkSpace: numberOfEquations=3375, nsp = 393186, fillinRatio= 38, numberOfNonzeros = 10347
cgWave:FD22 t=1.000e-01 (2 steps) dt=5.000e-02 maxErr= 5.33e-15, ||u||= 4.29e+00, cpu= 9.30e-03(s)
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 2 uc=  0 twilightZone= 1
  addForcingBC=   1 forcingOption=   1 assignKnownSolutionAtBoundaries=   0
  t=  0.00E+00 dt=  0.50E-01 knownSolutionOption=   0 REAL_MIN=  0.22-307
abcWave: c=  0.100000E+01 cEM2=  0.100000E+01
  useUpwindDissipation= 0 numGhost= 1
  assignBCForImplicit=   0 bcApproach=   1
  boundaryCondition=   1   1   1   1   1   1
abcWave: t=0: DO NOTHING since past time is not known 
advWave: option=   0 grid=   0
advWave: orderOfAccuracy= 2 orderInTime= 2
advWave: addForcing= 1 forcingOption= 1
advWave: useUpwindDissipation= 0 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 5.000E-02 dt= 5.000E-02 c=  1.00E+00 omega= 3.010E+01 gridCFL= 8.660E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 1 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
  Implicit coeff: cImp(-1:1,0) =   2.50E-01   5.00E-01   2.50E-01 (for 2nd-order)
  Implicit coeff: cImp(-1:1,1) =   8.33E-02   0.00E+00   8.33E-02 (for 4th-order)
XX advWave XX: grid=  0 gridType= 0 orderOfAccuracy= 2 useImplicitUpwindDissipation= 0
         : t=  5.00E-02 dt=  5.000000E-02
advWave: ADVANCE IMPLICIT dim=3 order=2 orderInTime=2, grid=rectangular, t=  0.50E-01
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 2 uc=  0 twilightZone= 1
  addForcingBC=   1 forcingOption=   1 assignKnownSolutionAtBoundaries=   0
  t=  0.10E+00 dt=  0.50E-01 knownSolutionOption=   0 REAL_MIN=  0.22-307
abcWave: c=  0.100000E+01 cEM2=  0.100000E+01
  useUpwindDissipation= 0 numGhost= 1
  assignBCForImplicit=   1 bcApproach=   1
  boundaryCondition=   1   1   1   1   1   1
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 2 uc=  0 twilightZone= 1
  addForcingBC=   1 forcingOption=   1 assignKnownSolutionAtBoundaries=   0
  t=  0.10E+00 dt=  0.50E-01 knownSolutionOption=   0 REAL_MIN=  0.22-307
abcWave: c=  0.100000E+01 cEM2=  0.100000E+01
  useUpwindDissipation= 0 numGhost= 1
  assignBCForImplicit=   0 bcApproach=   1
  boundaryCondition=   1   1   1   1   1   1
advWave: option=   0 grid=   0
advWave: orderOfAccuracy= 2 orderInTime= 2
advWave: addForcing= 1 forcingOption= 1
advWave: useUpwindDissipation= 0 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 1.000E-01 dt= 5.000E-02 c=  1.00E+00 omega= 3.010E+01 gridCFL= 8.660E-01
advWave: damp=  0.0000000000E+00
advWave: gridIsImplicit= 1 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
  Implicit coeff: cImp(-1:1,0) =   2.50E-01   5.00E-01   2.50E-01 (for 2nd-order)
  Implicit coeff: cImp(-1:1,1) =   8.33E-02   0.00E+00   8.33E-02 (for 4th-order)
XX advWave XX: grid=  0 gridType= 0 orderOfAccuracy= 2 useImplicitUpwindDissipation= 0
         : t=  1.00E-01 dt=  5.000000E-02
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 2 uc=  0 twilightZone= 1
  addForcingBC=   1 forcingOption=   1 assignKnownSolutionAtBoundaries=   0
  t=  0.15E+00 dt=  0.50E-01 knownSolutionOption=   0 REAL_MIN=  0.22-307
abcWave: c=  0.100000E+01 cEM2=  0.100000E+01
  useUpwindDissipation= 0 numGhost= 1
  assignBCForImplicit=   1 bcApproach=   1
  boundaryCondition=   1   1   1   1   1   1
 bcOptWave: grid=   0 gridType= 0 orderOfAccuracy= 2 uc=  0 twilightZone= 1
  addForcingBC=   1 forcingOption=   1 assignKnownSolutionAtBoundaries=   0
  t=  0.15E+00 dt=  0.50E-01 knownSolutionOption=   0 REAL_MIN=  0.22-307
abcWave: c=  0.100000E+01 cEM2=  0.100000E+01
  useUpwindDissipation= 0 numGhost= 1
  assignBCForImplicit=   0 bcApproach=   1
  boundaryCondition=   1   1   1   1   1   1
advWave: option=   0 grid=   0
advWave: orderOfAccuracy= 2 orderInTime= 2
advWave: addForcing= 1 forcingOption= 1
advWave: useUpwindDissipation= 0 (explicit), useImplicitUpwindDissipation= 0 (implicit)
advWave: useSosupDissipation= 0 (1= add upwind dissipation in this stage)
advWave: t= 1.500E-01 dt= 5.000E-02 c=  1.00E+00 omega= 3.010E+01 gridCFL= 8.660E-01
advWave: damp=  0.0000000000E+00
cgWave:FD22 t=2.000e-01 (4 steps) dt=5.000e-02 maxErr= 8.88e-15, ||u||= 4.54e+00, cpu= 1.25e-02(s)

              -------------------CgWave Summary----------------- 
                       Wed Jul 12 20:33:54 2023
               Grid:   grids/box1.order2.hdf 
  ==== final time= 2.00e-01, numberOfStepsTaken =        4, grids=1, gridpts =1331, interp pts=0, processors=1, clock=2.99 GHz ==== 
  ==== memory per-proc: [min=42.793,ave=42.793,max=42.793](Mb), max-recorded=42.793 (Mb), total=42.793 (Mb)
 applyBoundaryConditions called 4 times
   Timings:         (ave-sec/proc:)   seconds    sec/step   sec/step/pt     %     [max-s/proc] [min-s/proc]
total time..........................  1.32e-02    3.30e-03    2.48e-06   100.000   1.322e-02   1.322e-02
setup and initialize................  5.03e-03    1.26e-03    9.44e-07    38.029   5.027e-03   5.027e-03
initialize BCs......................  2.12e-04    5.30e-05    3.98e-08     1.604   2.120e-04   2.120e-04
initial conditions..................  1.96e-04    4.90e-05    3.68e-08     1.483   1.960e-04   1.960e-04
advance.............................  1.26e-02    3.15e-03    2.37e-06    95.287   1.260e-02   1.260e-02
  advance rectangular grids.........  3.56e-03    8.90e-04    6.68e-07    26.916   3.558e-03   3.558e-03
  advance curvilinear grids.........  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
    implicit solve..................  8.14e-03    2.04e-03    1.53e-06    61.616   8.145e-03   8.145e-03
  add dissipation...................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  boundary conditions...............  2.44e-04    6.10e-05    4.58e-08     1.846   2.440e-04   2.440e-04
  interpolation.....................  8.90e-05    2.23e-05    1.67e-08     0.673   8.900e-05   8.900e-05
  update ghost (parallel)...........  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  add forcing.......................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  time integral.....................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  get errors........................  3.55e-04    8.87e-05    6.67e-08     2.686   3.550e-04   3.550e-04
  plotting..........................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
output results......................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
waiting (not counted)...............  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
--------------------------------------------------------------------------------------------------------
 Memory usage: reals/grid-point = 4214.09.
--------------------------------------------------------------------------------------------------------
 ======== Parallel Distribution for CgWave (np=1)============
 numberOfGrids=1, gridDistributionList.size()=1l 
  grid=0: procs=1 [0,0], proc-decomp=[1]x[1]x[1], pts=3375=[15]x[15]x[15], pts/proc=3375=[15]x[15]x[15], ratio=15/15=  1, ghost=[0,0,0]

 >>>> See the file mx.log for further timings, memory usage and other statistics <<<< 

contour
----------------------------------------------------------------------------------------
The 3D contour plotter can display
 1. contour planes : contours on a plane that cuts the entire grid.
            The contour plane is defined by a normal vector and a point on the plane.
 2. coordinate surface: contours on a surface on a single component grid corresponding 
                to i1=const or i2=const or i3=const
 3. iso-surface : surface defined by u=constant.
 4. 2D contours on coordinate planes: contours on a coordinate plane i1=const, i2=const
                or i3=const. These plots are in the 2d parameter space of the plane.
-----------------------------------------------------------------------------------------
exit
if( $go eq "go" ){ $cmd="exit"; }else{ $cmd="#"; }
$cmd
advWave: gridIsImplicit= 1 takeImplicitFirstStep= 0
advWave: adjustOmega= 0 solveHelmholtz= 0 adjustHelmholtz= 1
  Implicit coeff: cImp(-1:1,0) =   2.50E-01   5.00E-01   2.50E-01 (for 2nd-order)
  Implicit coeff: cImp(-1:1,1) =   8.33E-02   0.00E+00   8.33E-02 (for 4th-order)
