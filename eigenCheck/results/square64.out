Usage: `mpirun -np N cgwh [-noplot] [file.cmd] [-g=<gridName>]'
Look for Overture configuration file=[/home/henshw/.overturerc]
Successfully opened /home/henshw/Overture.g/overturerc for reading
User commands are being saved in the file `cgWaveHoltz.cmd'
Searching for grids in locations specified by the `OvertureGridDirectories' environment variable
look for /home/henshw/Overture.g/sampleGrids/square64.order2 
look for /home/henshw/grids/square64.order2 
 ***** Mounting file /home/henshw/grids/square64.order2.hdf****
getFromADataBase: number of CompositeGrid(s) found =1, name[0]=square64.order2
Time to read in the grid is 8.71e-03(s)
#
#  cgWaveHoltz command script:
#
#     cgwh eig.cmd -g=<grid-name> -x0=<f> -y0=<f> -omega=<f> -solver=[none|fixedPoint|krylov] -tol=<f> -tp=<f> ...
#                         -kx=<f> -ky=<f> -kz=<f> -forcing=[gaussian|sine] -adjustOmega=[0|1] -maxIterations=<>
#                          -upwind=[0|1] -imode=[0|1] -bcApproach=[cbc|lcbc|oneSided] -go=[go|og|halt]
#                          -eigenSolver=[default|KrylovSchur|Arnoldi]
#
#   -solver=[fixedPoint|krylov] : fixed-point or Krylov
#   -imode=1 : do not wait in cgWave
#   -maxIterations=<>
#
$go="go"; $forcing="gaussian";
$omega=30.1;
# $beta=50.; # $x0=0.5; $y0=0.5; $z0=0.5;
@beta= (); @amp = (); @x0 = (); @y0 = (); @z0 = (); # this must be null for GetOptions to work, defaults are given below
$t0=0.;
# $amp=1.;
$numPeriods=1; $omegaSOR=1; $tol=1.e-3;
$minStepsPerPeriod=10;   # min is 5
$numberOfFrequencies=1;
@freq = ();  # this must be null for GetOptions to work, defaults are given below
# beta2=0 = TRAP, beta2=.5 = Full weighting
$beta2=.0; $beta4=0.; $beta6=0.; $beta8=0.; # weights in implicit time-stepping
$upwind=0; # new way
$tp=.5; $imode=0;
$solver="fixedPoint";  $kx=1; $ky=1; $kz=1; $maxIterations=100; $adjustOmega=0;
$matlab="cgWaveHoltz"; $show="gaussian.show";
$cfl=.9; $bc="d"; $ts="explicit"; $dtMax=1;
$bcApproach="oneSided"; # bc Approach : cbc, lcbc, oneSided
$orderInTime=-1;  # -1 = use default
$deflateWaveHoltz=0; $numToDeflate=1; $eigenVectorFile="eigenVectors.hdf"; $computeEigs=1; $numRitz=20; $assignRitzFrequency=1000;
$numEigs=1; $numArnoldi=-1;
$setInitialVectors=1; # provide initial vectors for eigenSolver
$useAccurateInnerProduct=0; # use accurate inner product for Rayleigh Quotient
$takeImplicitFirstStep=0;
$eigenSolver="default";  # [default|KrylovSchur|Arnoldi]
$minStepsPerPeriod=10; # do this for eigs
$eigTol=1.e-5;  # tolerance for detecting multiple eigs
$bc1=""; $bc2=""; $bc3=""; $bc4=""; $bc5=""; $bc6="";
#
$solverh="yale"; $maxith=2000; $rtolh=1.e-6; $atolh=1.e-5; $restart=50; $iluh=5; # parameters for direct Helmholtz solver
$solveri="yale"; $maxiti=2000; $rtoli=1.e-6; $atoli=1.e-5; # parameters for implicit time-stepping solver
#
GetOptions( "omega=f"=>\$omega,"x0=f{1,}"=>\@x0,"y0=f{1,}"=>\@y0,"z0=f{1,}"=>\@z0,"beta=f{1,}"=>\@beta,"numPeriods=i"=>\$numPeriods,            "omegaSOR=f"=>\$omegaSOR,"tol=f"=>\$tol,"cfl=f"=>\$cfl,"tp=f"=>\$tp,"iMode=i"=>\$imode,            "solver=s"=>\$solver,"kx=f"=>\$kx,"ky=f"=>\$ky,"kz=f"=>\$kz,"maxIterations=i"=>\$maxIterations,"matlab=s"=>\$matlab,            "go=s"=>\$go,"forcing=s"=>\$forcing,"bc=s"=>\$bc,"ts=s"=>\$ts,"orderInTime=i"=>\$orderInTime,            "dtMax=f"=>\$dtMax,"adjustOmega=i"=>\$adjustOmega,"amp=f{1,}"=>\@amp,"show=s"=>\$show,            "bcApproach=s"=>\$bcApproach,"upwind=i"=>\$upwind,"beta2=f"=>\$beta2,"beta4=f"=>\$beta4,"beta6=f"=>\$beta6,            "numberOfFrequencies=i"=>\$numberOfFrequencies,"nf=i"=>\$numberOfFrequencies,"freq=f{1,}"=>\@freq,            "solverh=s"=>\$solverh,"rtolh=f"=>\$rtolh,"atolh=f"=>\$atolh,"maxith=i"=>\$maxith,"restart=i"=>\$restart,"iluh=i"=>\$iluh,            "solveri=s"=>\$solveri,"rtoli=f"=>\$rtoli,"atoli=f"=>\$atoli,"maxiti=i"=>\$maxiti,            "deflateWaveHoltz=i"=>\$deflateWaveHoltz,"numToDeflate=i"=>\$numToDeflate,"computeEigs=i"=>\$computeEigs,"numArnoldi=i"=>\$numArnoldi,            "eigenVectorFile=s"=>\$eigenVectorFile,"minStepsPerPeriod=i"=>\$minStepsPerPeriod,"numRitz=i"=>\$numRitz,            "assignRitzFrequency=i"=>\$assignRitzFrequency,"numEigs=i"=>\$numEigs,"minStepsPerPeriod=i"=>\$minStepsPerPeriod,            "eigenSolver=s"=>\$eigenSolver,"setInitialVectors=i"=>\$setInitialVectors,"eigTol=f"=>\$eigTol,            "useAccurateInnerProduct=i"=>\$useAccurateInnerProduct,"takeImplicitFirstStep=i"=>\$takeImplicitFirstStep,            "bc1=s"=>\$bc1,"bc2=s"=>\$bc2,"bc3=s"=>\$bc3,"bc4=s"=>\$bc4,"bc5=s"=>\$bc5,"bc6=s"=>\$bc6 );
#
if( $bc eq "d" ){ $bc="dirichlet"; }
if( $bc eq "n" ){ $bc="neumann"; }
if( $bc eq "e" ){ $bc="evenSymmetry"; }
if( $bc eq "r" ){ $bc="radiation"; }
if( $amp[0] eq "" ){ @amp=(1,1,1,1,1,1,1,1,1); }
if( $beta[0] eq "" ){ @beta=(50,50,50,50,50,50,50,50); }
if( $x0[0] eq ""  ){ @x0=(0,0,0,0,0,0,0,0); }
if( $y0[0] eq ""  ){ @y0=(0,0,0,0,0,0,0,0); }
if( $z0[0] eq ""  ){ @z0=(0,0,0,0,0,0,0,0); }
if( $freq[0] eq "" ){ @freq=(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15); }
#
$omega = $freq[0];
#
# pause
## Gaussian params $beta $x0 $y0 0 (beta,x0,y0,z0)
omega $omega
Setting omega=10
maximum number of iterations $maxIterations
Setting maximumNumberOfIterations=60
tol $tol
Setting tol=1e-14 (tolerence for Krylov solvers)
number of periods $numPeriods
Setting numPeriods=1
adjust omega $adjustOmega
Setting adjustOmega=0: 1=adjust omega for the discrete symbol pf D+t D-t 
 This will make WaveHoltz solution be closer to the discrete Helhmhotz problem
number of frequencies $numberOfFrequencies
Setting numberOfFrequencies=1
frequencies $freq[0] $freq[1] $freq[2] $freq[3] $freq[4] $freq[5] $freq[6] $freq[7] $freq[8] $freq[9] $freq[10] $freq[11]] $freq[12]
Setting frequency 0 = 1.000000e+01
matlab filename: $matlab
Setting matlabFileName=[cgWaveHoltz]
# choose parameters for the direct Helmholtz solver
direct solver parameters
Set the Oges parameters for the direct Helmholtz solver
if( $solverh ne "yale" ){ $cmd="choose best iterative solver\n $solverh"; }else{ $cmd="choose best direct solver"; }
$cmd
Choosing: yale, solver=[direct sparse solver, no pivoting + ]
number of incomplete LU levels
$iluh
number of GMRES vectors
$restart
maximum number of iterations
#
$maxith
relative tolerance
$rtolh
absolute tolerance
$atolh
# gmres restart length
#   30
# pause
#  PETSc
exit
# pause
exit
cgWaveHoltz::setup: numberOfFrequencies=1
CgWave::setup SETTING orderOfAccuracy=2
# ------ Start cgWave setup ------
# time-stepping : explicit/implicit
$ts
if( $orderInTime > 0 ){ $cmd="orderInTime $orderInTime"; }else{ $cmd="#"; }
$cmd
Setting orderOfAccuracyInTime=2 (-1 means use same as order in space)
take implicit first step $takeImplicitFirstStep
Setting takeImplicitFirstStep=1 (1=take an implicit first step when implicit time-stepping
dtMax $dtMax
Setting dtMax=1
implicit weights $beta2 $beta4 $beta6 $beta8
Setting implicit time-stepping weights to beta2=0, beta4=0, beta6=0, beta8=0
cfl $cfl
setting cfl=100000
interactiveMode $imode
Setting interactiveMode=1 (0=normal, 1=advance and finish)
tPlot $tp
 tPlot=0.5
# -- Here is input for cgWave
#
$cmd="#";
if( $bcApproach eq "oneSided" ){ $cmd="useOneSidedBCs"; }
if( $bcApproach eq "cbc"      ){ $cmd="useCompatibilityBCs"; }
if( $bcApproach eq "lcbc"     ){ $cmd="useLocalCompatibilityBCs"; }
$cmd
Setting approach for boundary conditions to useOneSidedBCs
Answer=useOneSidedBCs found in getBoundaryConditionOption
#
bc=$bc
Setting all boundary conditions to bc=[dirichlet]
Answer=bc=dirichlet found in getBoundaryConditionOption
$cmd="#";
if( $bc1 ne "" ){ $cmd .="\n bcNumber1=$bc1"; }
if( $bc2 ne "" ){ $cmd .="\n bcNumber2=$bc2"; }
if( $bc3 ne "" ){ $cmd .="\n bcNumber3=$bc3"; }
if( $bc4 ne "" ){ $cmd .="\n bcNumber4=$bc4"; }
if( $bc5 ne "" ){ $cmd .="\n bcNumber5=$bc5"; }
if( $bc6 ne "" ){ $cmd .="\n bcNumber6=$bc6"; }
printf('cmd=$cmd\n");')
$cmd
#
# if( $ad4>0. ){ $upwind=1; }# for backward compatibility
upwind dissipation $upwind
Setting upwind=0 (upwind dissipation is on or off).
#
deflate WaveHoltz $deflateWaveHoltz
Setting deflateWaveHoltz=0 (1=apply deflate to WaveHoltz iteration
Answer=deflate WaveHoltz 0 found in getWaveHoltzOption
number to deflate $numToDeflate
Setting numToDeflate=0 (deflate this many eigenvectors for WaveHoltz)
Answer=number to deflate 0 found in getWaveHoltzOption
eigenVectorFile $eigenVectorFile
Setting eigenVectorFile=/home/henshw/runs/cgWaveHoltz/eig/square64EigsEv20.show (file holding eigenvectors for deflation)
Answer=eigenVectorFile /home/henshw/runs/cgWaveHoltz/eig/square64EigsEv20.show found in getEigenWaveOption
min steps per period $minStepsPerPeriod
Setting minStepsPerPeriod=10 (for WaveHoltz)
Answer=min steps per period 10 found in getEigenWaveOption
#
compute eigenModes $computeEigs
 computeEigenmodes: Use the WaveHoltz algorithm to compute eigenvalues and eigenvectors.
Answer=compute eigenModes 1 found in getEigenWaveOption
number of eigenvalues $numEigs
Setting numEigsToCompute=12 (compute this many eigenpairs when using Arnoldi)
Answer=number of eigenvalues 12 found in getEigenWaveOption
num Arnoldi vectors $numArnoldi
Setting numArnoldiVectors=-1 (number of vectors in the Arnoldi column space)
Answer=num Arnoldi vectors -1 found in getEigenWaveOption
number of Ritz vectors $numRitz
Setting numberOfRitzVectors=20 (max. number of Rayleigh Ritz vectors, used to accelerate EigenWave)
Answer=number of Ritz vectors 20 found in getEigenWaveOption
assign Ritz frequency $assignRitzFrequency
Setting assignRitzFrequency=1000 (set solution to latest Ritz vector every this many steps (EigenWave)
Answer=assign Ritz frequency 1000 found in getEigenWaveOption
# for implicit tyime-stepping and WaveHoltz:
min steps per period $minStepsPerPeriod
Setting minStepsPerPeriod=10 (for WaveHoltz)
Answer=min steps per period 10 found in getEigenWaveOption
# choose the method used by SLEPc:
printf("eigenSolver=$eigenSolver\n");
if( $eigenSolver eq "default" ){ $eigenSolver="defaultEigenSolver"; }
$eigenSolver
Setting eigenSolver = defaultEigenSolver
Answer=defaultEigenSolver found in getEigenWaveOption
#
initial vectors for eigenSolver $setInitialVectors
Setting initialVectorsForEigenSolver=1 (vectors used in Arnolid etc.)
Answer=initial vectors for eigenSolver 1 found in getEigenWaveOption
# use accurate inner product for Rayleigh Quotient
use accurate inner product $useAccurateInnerProduct
Setting useAccurateInnerProduct=0 (for computing the Rayleigh Quotient)
Answer=use accurate inner product 0 found in getEigenWaveOption
#
eig multiplicity tol $eigTol
Setting eigenValueTolForMultiplicity=1e-05 (tolerence for detecting mutiple eigenvalues)
Answer=eig multiplicity tol 1e-05 found in getEigenWaveOption
#
compute errors 0
Setting computeErrors=0 (1=compute errors for TZ or known solutions.
# pause
#
implicit solver parameters
Set the Oges parameters for the implicit solver.
# NOTE: bcgs = bi-CG stab
if( $solveri ne "yale" ){ $cmd="choose best iterative solver\n $solveri"; }else{ $cmd="choose best direct solver"; }
$cmd
Choosing: yale, solver=[direct sparse solver, no pivoting + ]
number of incomplete LU levels
3
number of GMRES vectors
20
maximum number of iterations
#
$maxiti
relative tolerance
$rtoli
absolute tolerance
$atoli
#
multigrid parameters
choose good parameters: 1
choose good parameters: 0=OFF, 1=ON, 2=Use more robust parameters. Setting value to 1
OgesParameters: relativeTolerance=1.000000e-03 
residual tolerance $rtoli
absolute tolerance $atoli
# debug
#   1
# show smoothing rates
# Coarse level solver:
Oges parameters
choose best direct solver
Choosing: yale, solver=[direct sparse solver, no pivoting + ]
# choose best iterative solver
relative tolerance
1.e-10
absolute tolerance
1.e-10
number of incomplete LU levels
3
exit
OgmgParameters::display direct solver ogesParameters:
name = yale, solver=[direct sparse solver, no pivoting + ]
solverType = yale
solverMethod = direct sparse solver, no pivoting
parallel solverMethod = direct sparse solver, no pivoting
preconditioner = incomplete LU preconditioner
parallelPreconditioner = block Jacobi preconditioner
matrix ordering = reverse Cuthill-McKee ordering
maximumNumberOfIterations = 100
minimumNumberOfIterations = 0
relativeTolerance = 1.00e-10
absoluteTolerance = 1.00e-10
maximumAllowableIncreaseInResidual = 1.00e+05
compatibilityConstraint = 0
gmresRestartLength = 20
numberOfIncompleteLULevels = 3
incompleteLUExpectedFill = 20
minimumNumberOfIterations = 20
maximumNumberOfIterations = 20
solveForTranspose = 20
rescaleRowNorms = 1
matrixCutoff= 0.00e+00
fixupRightHandSide= 1
zeroRatio    = 0.00e+00
fillinRatio  = 0.00e+00
fillinRatio2 = 0.00e+00
harwellPivotingTolerance = 1.00e-01
nullVectorScaling = 1.00e+00
maximumInterpolationWidth = 100
iterativeImprovement = 0
sorOmega = 1.01e+00
userSuppliedCompatibilityConstraint = 0
userSuppliedEquations = 0
exit
#pause
exit
# artificial dissipation $ad4
#
helmholtzForcing
solve Helmholtz 1
 solveHelmholtz=true: CgWave is being used to solve the Helmholtz equation (time-periodic wave equation)
 using CgWaveHoltz
Answer=solve Helmholtz 1 found in getWaveHoltzOption
#
# ------ Gaussian sources ----
# amp, beta, omega, p,
# $amp = 10.*$omega*$omega;
#
$numTerms=1; # each source has 1 term
$p=1;        # power in exponent
$cmd =  "user defined forcing...\n"       . " gaussian sources\n";
for( $i=0; $i<$numberOfFrequencies; $i++ ){   $cmd .= "$numTerms\n $amp[$i] $beta[$i] $omega $p $x0[$i] $y0[$i] $z0[$i] $t0\n";}
$cmd .= "exit";
#
#   --- eigenmode-like exact solution : sin(kx*x)*sin(ky*y)*cos(omega*t)
if( $forcing eq "sine" ){  $cmd = " user defined known solution...\n"       . " box helmholtz\n"       . "  $omega $kx $ky $kz\n"       . " done\n"       . " user defined forcing...\n"       . "   box Helmholtz\n"       . " exit\n"; }
$cmd
user defined forcing...
gaussian sources
The Gaussian source in 2D is of the form:
 u(x,y,t) = a*cos(omega*(t-t0) )*exp( -beta*[ (x-x0)^2 + (y-y0)^2 ]^p )
1
1 50 10 1 0 0 0 0
Gaussian source 0, freq=0: setting a=1.00e+00, beta=5.00e+01, omega=1.00e+01, p=1.00e+00, x0=0.00e+00, y0=0.00e+00, z0=0.00e+00, t0=0.00e+00
exit
#
exit
CgWave::initialize and assign forcing... numberOfFrequencies=1
CgWave::getTimeStep: c=1, cfl=100000, timeSteppingMethod=1
getTimeStep: grid=0 : dx= 1.56e-02, dy= 1.56e-02, dt=1.105e+03
cgWave::getTimeStep: cfl=100000, explicit dt= 1.00e+00, implicit dt= 1.00e+00, ratio=  1.00
cgWave:chooseTimeStep: chooseImplicitTimeStepFromCFL : setting dt= 1.00e+00, cfl=100000
getTimeStep: grid=0: gridCFL=  9.05e+01
CgWave::initialize: dt=1

*********************************************************************************
           CgWave : Wave Equation Solver                    
           -----------------------------                  
 tFinal=1.000000, dt=1.000e+00, tPlot=5.000e-01 cfl=100000.00
 modifiedEquationApproach = standard modified equation
 orderOfAccuracy=2, orderOfAccuracyInTime=2 
 timeSteppingMethod = implicit
 ---- implicit time stepping parameters ----
   implict solver=yale, solver=[direct sparse solver, no pivoting + ]
   implicit solver: rtol= 1.00e-06, atol= 1.00e-05
   All grids are implicit.
   takeImplicitFirstStep = 1.
   implicit time-stepping weights: cImp(-1,0)=0.5, cImp(0,0)=0, cImp(1,0)=0.5 (2nd-order term)
                                 : cImp(-1,1)=0.208333, cImp(0,1)=0, cImp(1,1)=0.208333 (4th-order term)
   chooseImplicitTimeStepFromCFL=1 (1=choose implicit dt from cfl, 0=choose dt from dtMax)
 upwind dissipation is off, dissipationFrequency=1
 upwind dissipation: preComputeUpwindUt=0 
                     true=precompute Ut in upwind dissipation,
                     false=compute Ut inline in Gauss-Seidel fashion)
 implicitUpwind=0 : if true, include upwinding in implicit matrix when implicit time-stepping.
 assignInterpNeighbours = interpolate (for wider upwind stencil)
 twilightZone = polynomial, degreeInSpace=2, degreeInTime=2
 useKnownSolutionForFirstStep = 0 (use known solution for first step step, if possible)
 BC approach = useOneSidedBCs. [useDefault|useOneSided|useCompatibility|useLocalCompatibility]
 solveHelmholtz=1 (1= we are solving a Helmholtz problem).
   **** solveHelmholtz=true : Solving the Helmholtz problem, adjustOmega=0 (for discrete symbol of D+tD-t) ****
   computeTimeIntegral=1
   adjust Helmholtz for upwinding=1. Minimum time-steps per period=10.
   deflateWaveHoltz=0, numToDeflate=0, eigenVectorFile=[/home/henshw/runs/cgWaveHoltz/eig/square64EigsEv20.show]
 computeEigenmodes=1 (1= solve from eigenvalues and eigenvectors using the WaveHoltz algorithm).
   numEigsToCompute=12, numArnoldiVectors=-1.
   computeTimeIntegral=1
   numberOfRitzVectors=20 (maximum number of vectors to use for Rayleigh-Ritz)
   assignRitzFrequency=1000 (assign Ritz solution this often)
   eigenVectorForcingFactor=0 (scale factor for eigenvector forcing)
   eigenVectorFile=[/home/henshw/runs/cgWaveHoltz/eig/square64EigsEv20.show]
 forcingOption=helmholtzForcing.
 computeErrors=0
 number of processors=1

 Grid: /home/henshw/grids/square64.order2.hdf 
               Grid Data
               ---------
grid     name      gridIndexRange(0:1,0:2)           gridPoints        hmx      hmn   time-stepping
   0: square   ([ 0:   64],[ 0:   64],[ 0:    0])          4225   1.56e-02 1.56e-02    implicit
 total number of grid points =4225, min(hmn)=1.56e-02, max(hmn)=1.56e-02, max(hmx)=1.56e-02,  

 grid   name     side axis    boundary condition and name
 ----   ----     ---- ----    ---------------------------
    0: square     0    0      1 : dirichlet 
    0: square     1    0      1 : dirichlet 
    0: square     0    1      1 : dirichlet 
    0: square     1    1      1 : dirichlet 
*********************************************************************************

# --- end cgWave setup  ---
show file $show
Setting nameOfShowFile=gaussian.show
# contour
# exit
random initial condition
if( $solver eq "fixedPoint" ){ $cmd="compute with fixed-point"; }elsif( $solver eq "krylov" ){ $cmd="compute with petsc"; }else{ $cmd="#" };
if( $go eq "go" && $cmd ne "#" ){ $cmd .= "compute \n exit"; }
if( $go eq "dk"  ){ $cmd="solve Helmholtz directly\n zero initial condition\n compute with krylov\nexit"; }
if( $go eq "dks"  ){ $cmd="solve Helmholtz directly\n zero initial condition\n compute with krylov\n save to show\n exit"; }
if( $go eq "fk" ){ $cmd="zero initial condition\ncompute with fixed-point\n zero initial condition\n compute with krylov\nexit"; }
if( $go eq "dfk" ){ $cmd="solve Helmholtz directly\n zero initial condition\ncompute with fixed-point\n zero initial condition\n compute with krylov\nexit"; }
if( $go eq "ks"  ){ $cmd="compute\n save to show\n exit"; }
if( $go eq "k"  ){ $cmd="compute\n exit"; }
$cmd
compute

 ==== INITIALIZE DEFLATION =====
  deflateWaveHoltz=0, numToDeflate=0, computeEigenmodes=1, eigenVectorFile=[/home/henshw/runs/cgWaveHoltz/eig/square64EigsEv20.show]
---- Read show file=[/home/henshw/runs/cgWaveHoltz/eig/square64EigsEv20.show] with eigenvectors and process -----
mount the showfile: /home/henshw/runs/cgWaveHoltz/eig/square64EigsEv20.show
mount the showfile... done. (file created with version Overture.v27, current version is Overture.v27)
ShowFileReader::open: File descriptor limits = 1024, 1048576, setting maxNumberOfOpenFiles=512.
FrameSeries : defaultFrameSeries : 20 frames, 0 sequences found , is not a moving grid problem
ShowFileReader : getting general parameters for root directory
ShowFileReader : getting general parameters for defaultFrameSeries
There are 20 solutions and 20 frames
--SFR-- locateFramesInFiles: frames are not in standard order (restart?). Make a list:        frame 0 is in file 0
        frame 1 is in file 0
        frame 2 is in file 0
        frame 3 is in file 0
        frame 4 is in file 0
        frame 5 is in file 0
        frame 6 is in file 0
        frame 7 is in file 0
        frame 8 is in file 0
        frame 9 is in file 0
        frame 10 is in file 0
        frame 11 is in file 0
        frame 12 is in file 0
        frame 13 is in file 0
        frame 14 is in file 0
        frame 15 is in file 0
        frame 16 is in file 0
        frame 17 is in file 0
        frame 18 is in file 0
        frame 19 is in file 0
--SFR-- getFrame: solution 1 found in file 0.
multiplicity
    (0) (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11) (12) (13) (14) (15) (16) (17) (18) (19) (20) (21) (22) (23) (24) (25) (26) (27) (28) (29) (30) (31) (32) (33) (34) (35) (36) (37) (38) (39) 
(0)  1 2 2 1 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 1
--SFR-- getFrame: solution 1 found in file 0.
--SFR-- getFrame: solution 1 found in file 0.
--SFR-- getFrame: solution 2 found in file 0.
--SFR-- getFrame: solution 3 found in file 0.
--SFR-- getFrame: solution 4 found in file 0.
--SFR-- getFrame: solution 5 found in file 0.
--SFR-- getFrame: solution 6 found in file 0.
--SFR-- getFrame: solution 7 found in file 0.
--SFR-- getFrame: solution 8 found in file 0.
--SFR-- getFrame: solution 9 found in file 0.
--SFR-- getFrame: solution 10 found in file 0.
--SFR-- getFrame: solution 11 found in file 0.
--SFR-- getFrame: solution 12 found in file 0.
--SFR-- getFrame: solution 13 found in file 0.
--SFR-- getFrame: solution 14 found in file 0.
--SFR-- getFrame: solution 15 found in file 0.
--SFR-- getFrame: solution 16 found in file 0.
--SFR-- getFrame: solution 17 found in file 0.
--SFR-- getFrame: solution 18 found in file 0.
--SFR-- getFrame: solution 19 found in file 0.
--SFR-- getFrame: solution 20 found in file 0.
>> There are 20 eigenvectors
Eigenvalue   0 : k=    4.4424368914 (after square root)
Eigenvalue   1 : k=    7.0224170959 (after square root)
Eigenvalue   2 : k=    7.0224170959 (after square root)
Eigenvalue   3 : k=    8.8821978250 (after square root)
Eigenvalue   4 : k=    9.9264118963 (after square root)
Eigenvalue   5 : k=    9.9264118963 (after square root)
Eigenvalue   6 : k=   11.3186902718 (after square root)
Eigenvalue   7 : k=   11.3186902718 (after square root)
Eigenvalue   8 : k=   12.9334684329 (after square root)
Eigenvalue   9 : k=   12.9334684329 (after square root)
Eigenvalue  10 : k=   13.3166084547 (after square root)
Eigenvalue  11 : k=   14.0304562306 (after square root)
Eigenvalue  12 : k=   14.0304562306 (after square root)
Eigenvalue  13 : k=   15.6867145478 (after square root)
Eigenvalue  14 : k=   15.6867145478 (after square root)
Eigenvalue  15 : k=   15.9803503277 (after square root)
Eigenvalue  16 : k=   15.9803503277 (after square root)
Eigenvalue  17 : k=   16.8804826036 (after square root)
Eigenvalue  18 : k=   16.8804826036 (after square root)
Eigenvalue  19 : k=   17.7429976575 (after square root)
 i=  0 : eig=  4.442437e+00, multiplicity=1 (eigTol= 1.00e-05)
 i=  1 : eig=  7.022417e+00, multiplicity=2 (eigTol= 1.00e-05)
 i=  2 : eig=  7.022417e+00, multiplicity=2 (eigTol= 1.00e-05)
 i=  3 : eig=  8.882198e+00, multiplicity=1 (eigTol= 1.00e-05)
 i=  4 : eig=  9.926412e+00, multiplicity=2 (eigTol= 1.00e-05)
 i=  5 : eig=  9.926412e+00, multiplicity=2 (eigTol= 1.00e-05)
 i=  6 : eig=  1.131869e+01, multiplicity=2 (eigTol= 1.00e-05)
 i=  7 : eig=  1.131869e+01, multiplicity=2 (eigTol= 1.00e-05)
 i=  8 : eig=  1.293347e+01, multiplicity=2 (eigTol= 1.00e-05)
 i=  9 : eig=  1.293347e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 10 : eig=  1.331661e+01, multiplicity=1 (eigTol= 1.00e-05)
 i= 11 : eig=  1.403046e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 12 : eig=  1.403046e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 13 : eig=  1.568671e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 14 : eig=  1.568671e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 15 : eig=  1.598035e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 16 : eig=  1.598035e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 17 : eig=  1.688048e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 18 : eig=  1.688048e+01, multiplicity=2 (eigTol= 1.00e-05)
 i= 19 : eig=  1.774300e+01, multiplicity=1 (eigTol= 1.00e-05)
CgWaveHoltz::solveSLEPC: setting tFinal = Tperiod*numPeriods = 6.283e-01 (numPeriods=1) 
getActivePointIndex: I1=[1,63] I2=[1,63] I3=[0,0]
solveSLEPC:Make a Matrix Free Shell: numEquations=3969
solveSLEPc: supply 1 initial conditions

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=0
 **************** MatVec for SLEPc iteration=0 *************


 >>>>>>>>>>>>>>>>> CgWave:advance solve a Helmholtz Problem <<<<<<<<<<<<<<<<<<<<<<<
 it=0, dt=  6.283185307180e-02, omega=  1.000000000000e+01,  tFinal=  6.283185307180e-01
 adjustOmega=0, adjustHelmholtzForUpwinding=0 
 freq=0 frequency=  1.000000000000e+01 period=  6.283185307180e-01, numberOfPeriods=1
 nextTimeToPlot=6.283e-01, numPlotSteps=10, new dt=6.283e-02 (dtMax=1.000e+00)
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 3.73e-02, cpu= 0.00e+00(s)

 ==================== FORM MATRIX FOR IMPLICIT TIME-STEPPING ===================
   c=1, dt=6.283e-02, orderOfAccuracy=2, orderOfAccuracyInTime=2 addUpwinding=0, bcApproach=1
 ================================================================================
CgWave::formImplicitTimeSteppingMatrix: Changing the implicit solver parameters. 

 === Implicit Time-Stepping Solver:
 yale, solver=[direct sparse solver, no pivoting + ]
 =====

 >>>>>>> CgWave::implicitSolver: use predfined equations <<<<<<< 

CgWave::implicitSolver: A = I -alpha (c*dt)^2 Delta, c=1, dt= 6.28e-02
Oges::allocateWorkSpace: numberOfNonzeros=21429 fillinRatio=2.000000e+01
allocateWorkSpace: numberOfEquations=4761, nsp = 428580, fillinRatio= 20, numberOfNonzeros = 21429
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.31e-02, cpu= 9.23e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=1
 **************** MatVec for SLEPc iteration=1 *************


 >>>>>>>>>>>>>>>>> CgWave:advance solve a Helmholtz Problem <<<<<<<<<<<<<<<<<<<<<<<
 it=1, dt=  6.283185307180e-02, omega=  1.000000000000e+01,  tFinal=  6.283185307180e-01
 adjustOmega=0, adjustHelmholtzForUpwinding=0 
 freq=0 frequency=  1.000000000000e+01 period=  6.283185307180e-01, numberOfPeriods=1
 nextTimeToPlot=6.283e-01, numPlotSteps=10, new dt=6.283e-02 (dtMax=1.000e+00)
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 3.41e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.71e-02, cpu= 2.68e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=2
 **************** MatVec for SLEPc iteration=2 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 3.43e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.04e-02, cpu= 2.65e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=3
 **************** MatVec for SLEPc iteration=3 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.10e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.17e-02, cpu= 2.66e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=4
 **************** MatVec for SLEPc iteration=4 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.46e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.28e-02, cpu= 2.64e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=5
 **************** MatVec for SLEPc iteration=5 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.81e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.71e-02, cpu= 2.61e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=6
 **************** MatVec for SLEPc iteration=6 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.00e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.72e-02, cpu= 2.62e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=7
 **************** MatVec for SLEPc iteration=7 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.11e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.61e-02, cpu= 2.62e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=8
 **************** MatVec for SLEPc iteration=8 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.28e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.56e-02, cpu= 2.61e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=9
 **************** MatVec for SLEPc iteration=9 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.71e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.14e-02, cpu= 2.60e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=10
 **************** MatVec for SLEPc iteration=10 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.00e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.37e-02, cpu= 2.60e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=11
 **************** MatVec for SLEPc iteration=11 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 7.29e-02, cpu= 1.00e-06(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.28e-02, cpu= 2.59e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=12
 **************** MatVec for SLEPc iteration=12 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.31e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.15e-02, cpu= 2.59e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=13
 **************** MatVec for SLEPc iteration=13 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.92e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.58e-02, cpu= 2.60e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=14
 **************** MatVec for SLEPc iteration=14 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.89e-02, cpu= 1.00e-06(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.29e-02, cpu= 2.58e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=15
 **************** MatVec for SLEPc iteration=15 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.20e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.93e-02, cpu= 2.57e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=16
 **************** MatVec for SLEPc iteration=16 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.93e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.65e-02, cpu= 2.58e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=17
 **************** MatVec for SLEPc iteration=17 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.20e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.65e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=18
 **************** MatVec for SLEPc iteration=18 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.44e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.01e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=19
 **************** MatVec for SLEPc iteration=19 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.40e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.41e-02, cpu= 2.57e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=20
 **************** MatVec for SLEPc iteration=20 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.45e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.58e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=21
 **************** MatVec for SLEPc iteration=21 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.11e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.11e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=22
 **************** MatVec for SLEPc iteration=22 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.29e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.86e-02, cpu= 2.55e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=23
 **************** MatVec for SLEPc iteration=23 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.79e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.37e-02, cpu= 2.55e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=24
 **************** MatVec for SLEPc iteration=24 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.01e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.32e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=25
 **************** MatVec for SLEPc iteration=25 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.30e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.34e-02, cpu= 2.58e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=26
 **************** MatVec for SLEPc iteration=26 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.52e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 1.95e-02, cpu= 2.57e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=27
 **************** MatVec for SLEPc iteration=27 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.70e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.94e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=28
 **************** MatVec for SLEPc iteration=28 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.18e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.30e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=29
 **************** MatVec for SLEPc iteration=29 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.84e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.99e-02, cpu= 2.55e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=30
 **************** MatVec for SLEPc iteration=30 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.61e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.01e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=31
 **************** MatVec for SLEPc iteration=31 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.57e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.87e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=32
 **************** MatVec for SLEPc iteration=32 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.44e-02, cpu= 1.00e-06(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.99e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=33
 **************** MatVec for SLEPc iteration=33 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.07e-02, cpu= 1.00e-06(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.77e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=34
 **************** MatVec for SLEPc iteration=34 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.96e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.48e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=35
 **************** MatVec for SLEPc iteration=35 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.93e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.71e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=36
 **************** MatVec for SLEPc iteration=36 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.04e-02, cpu= 1.00e-06(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.62e-02, cpu= 2.55e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=37
 **************** MatVec for SLEPc iteration=37 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.48e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.62e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=38
 **************** MatVec for SLEPc iteration=38 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.76e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.85e-02, cpu= 2.57e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=39
 **************** MatVec for SLEPc iteration=39 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.45e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.69e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=40
 **************** MatVec for SLEPc iteration=40 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.38e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 2.76e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=41
 **************** MatVec for SLEPc iteration=41 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.38e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.22e-02, cpu= 2.57e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=42
 **************** MatVec for SLEPc iteration=42 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.42e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.12e-02, cpu= 2.55e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=43
 **************** MatVec for SLEPc iteration=43 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.91e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.54e-02, cpu= 2.58e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=44
 **************** MatVec for SLEPc iteration=44 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.82e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.15e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=45
 **************** MatVec for SLEPc iteration=45 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.13e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.47e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=46
 **************** MatVec for SLEPc iteration=46 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.21e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.83e-02, cpu= 2.57e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=47
 **************** MatVec for SLEPc iteration=47 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.12e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.02e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=48
 **************** MatVec for SLEPc iteration=48 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.59e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 5.38e-02, cpu= 2.55e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=49
 **************** MatVec for SLEPc iteration=49 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 4.93e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.03e-02, cpu= 2.60e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=50
 **************** MatVec for SLEPc iteration=50 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.33e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 5.31e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=51
 **************** MatVec for SLEPc iteration=51 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.02e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.22e-02, cpu= 2.60e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=52
 **************** MatVec for SLEPc iteration=52 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.56e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.17e-02, cpu= 2.65e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=53
 **************** MatVec for SLEPc iteration=53 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.44e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.33e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=54
 **************** MatVec for SLEPc iteration=54 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.25e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 4.22e-02, cpu= 2.64e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=55
 **************** MatVec for SLEPc iteration=55 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.16e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.18e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=56
 **************** MatVec for SLEPc iteration=56 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 5.26e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 5.09e-02, cpu= 2.55e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=57
 **************** MatVec for SLEPc iteration=57 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.04e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.45e-02, cpu= 2.56e-03(s)

 ++++++++ EigenWave Matrix vector multiply routine: eigenWaveMatrixVectorMultiply called iteration=58
 **************** MatVec for SLEPc iteration=58 *************


 ++++ CgWave::advance: Set forcing to v for computing eigenmodes eigenVectorForcingFactor=0+++++

*******  CgWave::takeFirstStep t=0.000e+00, cur=0, dt=6.283e-02 *************
++++++++++++ getInitialConditions current=2, t=0.000e+00, dt=6.283e-02 ++++++++++++++ 
++++++ getTimeDerivative=1, initialConditionOption=0 ++++++
CgWave: done initial conditions

 **** takeFirstStep: IMPLICIT FIRST STEP : save time-derivative at t=0 *****

cgWave:FD22 t=0.000e+00 (0 steps) dt=6.283e-02 ||u||= 6.24e-02, cpu= 0.00e+00(s)
cgWave:FD22 t=6.283e-01 (10 steps) dt=6.283e-02 ||u||= 3.99e-02, cpu= 2.55e-03(s)
>>Solution method: krylovschur
>>Number of requested eigenvalues: 12
>>Number of converged eigenvalues= 12
>>Number of iterations of the method: 4
WaveHoltz eigenvalue beta 0 : k=9.93144092593504e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 1 : k=9.93144092593503e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 2 : k=9.64723953127796e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 3 : k=9.64723953127794e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 4 : k=8.61887714130221e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 5 : k=8.61887714130218e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 6 : k=8.44897449265370e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 7 : k=8.11868659752968e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 8 : k=7.06405723084569e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 9 : k=7.06405723084567e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 10 : k=4.62746825154569e-01 + 0.00000000000000e+00 I 
WaveHoltz eigenvalue beta 11 : k=4.62746825154566e-01 + 0.00000000000000e+00 I 

 -----------------------------------------------------------------------------
 ---------------------- EigenWave SUMMARY (SLEPc solver) ---------------------
 omega=  1.0000e+01, grid=/home/henshw/grids/square64.order2.hdf
 eigenSolver = KrylovSchur
 provide initial vector(s) for eigenSolver = 1
 timeSteppingMethod = implicit, minStepsPerPeriod=10
 tol= 1.00e-14, numIterations=59, provide initial vectors=1
 num eigs requested=12, number eigs converged=12, numArnoldiVectors=25
 -----------------------------------------------------------------------------
iperm
    (   0) (   1) (   2) (   3) (   4) (   5) (   6) (   7) (   8) (   9) (  10) (  11) 
(0)     10     11      6      2      3      1      0      5      4      7      8      9 
>>> Reorder eigenVectors: number of assignments to reorder=14
 i=0: lamRQ = 7.0224170959e+00,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  6.16e-13
 i=1: lamRQ = 7.0224170959e+00,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  5.16e-13
 i=2: lamRQ = 8.8821978250e+00,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  2.15e-13
 i=3: lamRQ = 9.9264118963e+00,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  1.91e-13
 i=4: lamRQ = 9.9264118963e+00,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  2.32e-13
 i=5: lamRQ = 1.1318690272e+01,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  1.38e-13
 i=6: lamRQ = 1.1318690272e+01,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  1.75e-13
 i=7: lamRQ = 1.2933468433e+01,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  1.07e-13
 i=8: lamRQ = 1.2933468433e+01,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  1.29e-13
 i=9: lamRQ = 1.3316608455e+01,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  9.68e-14
 i=10: lamRQ = 1.4030456231e+01,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  9.28e-14
 i=11: lamRQ = 1.4030456231e+01,  rel-resid = || L v + lamRQ^2 v ||/lamRQ^2 =  1.26e-13

 -----------------------------------------------------------------------------
 ------------------------- EigenWave SUMMARY ---------------------------------
 omega=  1.0000e+01, orderOfAccuracy=2, grid=square64
 eigenSolver = KrylovSchur (SLEPc solver)
 Provide initial vector(s) for eigenSolver = 1, eigenValueTolForMultiplicity=1e-05
 Use accurate inner product = 0.
 Time stepping = implicit, cfl=100000.00, dt=6.283e-02, minStepsPerPeriod=10, Np=1, numberOfStepsPerSolve=10, 
  totalTimeStepsStaken=590, aveItsPerImplicitSolve=  0.0
 implict solver=yale, solver=[direct sparse solver, no pivoting + ]
 implicit solver: rtol= 1.00e-06, atol= 1.00e-05
 tol= 1.00e-14, number of wave-solves (mat-vecs) = 59, cpu= 2.38e-01(s)
 num eigs requested=12, number eigs converged =12, numArnoldiVectors=25
 numberOfIterations=0, iterationStartRR=5, assignRitzFrequency=1000, numberOfRitzVectors=20 (for fixed-point)
 -----------------------------------------------------------------------------

  ie     lambda      [eig]   lamTrue     mult  eig-err  evect-err  eig-res
 .............................................................................
  0  7.02241710e+00  [ 2]=7.02241710e+00   2  1.14e-15  1.37e-14  6.16e-13
  1  7.02241710e+00  [ 2]=7.02241710e+00   2  1.01e-15  1.22e-14  5.16e-13
  2  8.88219783e+00  [ 3]=8.88219783e+00   1  2.00e-16  4.50e-14  2.15e-13
  3  9.92641190e+00  [ 4]=9.92641190e+00   2  1.79e-16  1.61e-14  1.91e-13
  4  9.92641190e+00  [ 5]=9.92641190e+00   2  8.95e-16  4.58e-13  2.32e-13
  5  1.13186903e+01  [ 7]=1.13186903e+01   2  0.00e+00  1.95e-14  1.38e-13
  6  1.13186903e+01  [ 7]=1.13186903e+01   2  7.85e-16  1.29e-14  1.75e-13
  7  1.29334684e+01  [ 8]=1.29334684e+01   2  1.65e-15  3.83e-13  1.07e-13
  8  1.29334684e+01  [ 8]=1.29334684e+01   2  1.24e-15  9.13e-14  1.29e-13
  9  1.33166085e+01  [10]=1.33166085e+01   1  2.00e-15  2.31e-14  9.68e-14
 10  1.40304562e+01  [11]=1.40304562e+01   2  8.86e-16  1.14e-13  9.28e-14
 11  1.40304562e+01  [12]=1.40304562e+01   2  6.33e-16  2.39e-13  1.26e-13
 .............................................................................
 Note:  relative-errors, eig-res = || Lv+lamRQ^2 v ||/lamRQ^2
Wrote results to LaTeX file [cgWaveHoltzKrylov.tex]
Wrote results to the check file [eigenWave.check]
saveMatlab: dt=6.283e-02
CgWaveHoltz::saved results in matlab file=[cgWaveHoltzKrylov.m]
exit

              -------------------CgWave Summary----------------- 
                       Tue May 23 15:54:17 2023
               Grid:   /home/henshw/grids/square64.order2.hdf 
  ==== final time= 6.28e-01, numberOfStepsTaken =      590, grids=1, gridpts =4225, interp pts=0, processors=1, clock=2.99 GHz ==== 
  ==== memory per-proc: [min=51.8789,ave=51.8789,max=51.8789](Mb), max-recorded=0 (Mb), total=51.8789 (Mb)
   Timings:         (ave-sec/proc:)   seconds    sec/step   sec/step/pt     %     [max-s/proc] [min-s/proc]
total time..........................  1.75e-01    2.97e-04    7.03e-08   100.000   1.753e-01   1.753e-01
setup and initialize................  1.33e-03    2.26e-06    5.34e-10     0.760   1.332e-03   1.332e-03
initialize BCs......................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
initial conditions..................  7.23e-04    1.23e-06    2.90e-10     0.412   7.230e-04   7.230e-04
advance.............................  1.61e-01    2.73e-04    6.46e-08    91.903   1.611e-01   1.611e-01
  advance rectangular grids.........  1.39e-02    2.35e-05    5.57e-09     7.919   1.388e-02   1.388e-02
  advance curvilinear grids.........  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
    implicit solve..................  9.90e-02    1.68e-04    3.97e-08    56.498   9.904e-02   9.904e-02
  add dissipation...................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  boundary conditions...............  1.80e-02    3.05e-05    7.23e-09    10.281   1.802e-02   1.802e-02
  interpolation.....................  2.62e-03    4.43e-06    1.05e-09     1.492   2.615e-03   2.615e-03
  update ghost (parallel)...........  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  add forcing.......................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  time integral.....................  1.99e-02    3.37e-05    7.98e-09    11.344   1.989e-02   1.989e-02
  get errors........................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
  plotting..........................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
output results......................  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
waiting (not counted)...............  0.00e+00    0.00e+00    0.00e+00     0.000   0.000e+00   0.000e+00
--------------------------------------------------------------------------------------------------------
 Memory usage: reals/grid-point = 1609.44.
--------------------------------------------------------------------------------------------------------
 ======== Parallel Distribution for CgWave (np=1)============
 numberOfGrids=1, gridDistributionList.size()=1l 
  grid=0: procs=1 [0,0], proc-decomp=[1]x[1]x[1], pts=4761=[69]x[69]x[1], pts/proc=4761=[69]x[69]x[1], ratio=69/69=  1, ghost=[0,0,0]
cmd=$cmd\n");eigenSolver=default

 >>>> See the file mx.log for further timings, memory usage and other statistics <<<< 

 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
 advWave: TAKE IMPLICIT FIRST STEP 
