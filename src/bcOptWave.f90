! This file automatically generated from bcOptWave.bf90 with bpp.
! ==================================================================================
!
!        Optimized Assign Boundary Conditions for CgWave
!        -----------------------------------------------
!
! ==================================================================================


! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
! Use this next macro to declare the statement functions that are defined below
! To include derivatives of rx use OPTION=RX


! Define statement functions for difference approximations of order 2 
! To include derivatives of rx use OPTION=RX
! To include derivatives of rx use OPTION=RX



! Use this next macro to declare the statement functions that are defined below
! To include derivatives of rx use OPTION=RX


! Define statement functions for difference approximations of order 4 
! To include derivatives of rx use OPTION=RX
! To include derivatives of rx use OPTION=RX



! define macros to evaluate higher derivatives (from maple/makeGetDerivativesMacros.maple)
! ****** File written by makeGetDerivativesMacros.maple  ******



! =======================================================
!  Macro to compute Third derivatives in 2 dimensions 
!  OPTION : evalMetrics : evaluate the derivatives of the metrics
!          (metrics need only be evaluated once when using discrete delta to get coeffs)
! =======================================================

! =======================================================
!  Macro to compute Third derivatives in 3 dimensions 
!  OPTION : evalMetrics : evaluate the derivatives of the metrics
!          (metrics need only be evaluated once when using discrete delta to get coeffs)
! =======================================================

! define macros to evaluate derivatives for the 6th order method (from maple/makeGetDerivativesMacros.maple)
! ****** File written by makeGetDerivativesMacros.maple  ******



! =======================================================
!  Macro to compute Sixth derivatives in 2 dimensions 
!  OPTION : evalMetrics : evaluate the derivatives of the metrics
!          (metrics need only be evaluated once when using discrete delta to get coeffs)
! =======================================================

! =======================================================
!  Macro to compute Sixth derivatives in 3 dimensions 
!  OPTION : evalMetrics : evaluate the derivatives of the metrics
!          (metrics need only be evaluated once when using discrete delta to get coeffs)
! =======================================================


! From bcOptSmFOS.bf
! DataBase *pdb = &parameters.dbase;
! double precision pdb  ! pointer to data base
! ====================================================================
! Look up an integer parameter from the data base
! ====================================================================

! ====================================================================
! Look up a real parameter from the data base
! ====================================================================



! General begin loops macro











! ----- define extrapolation formulae ------











! ************************************************************************************************
!  This macro is used for looping over the faces of a grid to assign booundary conditions
!
! extra: extra points to assign
!          Case 1: extra=numberOfGhostPoints -- for assigning extended boundaries
!          Case 2: extra=-1 -- for assigning ghost points but not including extended boundaries
! numberOfGhostPoints : number of ghost points (1 for 2nd order, 2 for fourth-order ...)
!
!
! Output:
!  n1a,n1b,n2a,n2b,n3a,n3b : from gridIndexRange
!  nn1a,nn1b,nn2a,nn2b,nn3a,nn3b : includes "extra" points
! 
! ***********************************************************************************************







! =================================================================================
!   Assign values in the corners in 2D (see bcMaxwellCorners.bf)
!
!  Set the normal component of the solution on the extended boundaries (points N in figure)
!  Set the corner points "C" 
!              |
!              X
!              |
!        N--N--X--X----
!              |
!        C  C  N
!              |
!        C  C  N
!
! ORDER: 2 or 4
! GRIDTYPE: rectangular, curvilinear
! FORCING: none, twilightZone
! =================================================================================







! =========================================================================
! Compute the normal on a curvilinear grid.
!
! Assumes is=1-2*side is defined. 
! =========================================================================

! ========================================================================================
!  Assign ghost points outside corners
! ========================================================================================




! ===================================================================================================
! Macro: Extrapolate Ghost Points 
! ORDER : 2,4,6,8
! ===================================================================================================


! ============================================================================================
! Macro: evaluate the solution on the boundary for Dirichlet BCs
! ============================================================================================

! ===================================================================================================
! Macro: Assign boundary and ghost points on Dirichlet boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================


! ============================================================================================
! Macro: evaluate the solution on the boundary for Dirichlet BCs
!    Solving
!        u_tt = c^2 * Delta( u ) + f(x,y,z,t)
!        u = g
! For TZ at order=2:
!    ff = ue_tt - c^2*Delta(ue) 
!    gtt = g_tt = uett
!  order=4:
!    fLap 
!    ftt
!    gtttt
! ============================================================================================


! ===================================================================================================
! Macro: Assign the boundary values on Dirichlet boundaries
! ===================================================================================================

! ===================================================================================================
! Macro: Assign the boundary values on "exact" boundaries
! ===================================================================================================



! ===================================================================================================
! Macro: get loop bounds over boundaries with extram points in tangential directions 
! ===================================================================================================


! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 2,4,6,8
! FORCING : noForcing, forcing
! ===================================================================================================

! ===================================================================================================
! Macro: Get the TZ solution in 2d or 3d 
! ===================================================================================================

! ===================================================================================================
! Macro: Evaluate the forcing for the CBCs
! ===================================================================================================

! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 6 
! FORCING : noForcing, forcing
! ===================================================================================================




! ------------------------------------------------------------------------------------
!  Macro: evaluate the RHS to the Neumann BC
! ------------------------------------------------------------------------------------

! ===================================================================================================
! Macro: Assign ghost points on Neumann boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================


! ===================================================================================================
! Macro: Assign ghost points on Neumann boundaries
!          *** COMPATIBILITY BOUNDARY CONDITIONS **** 
! ORDER : 2,4,6,8
! ===================================================================================================
! *** OLD VERSION ****


! ============================================================================================
! Macro: evaluate the forcings for Neumann CBCs
!    Solving
!        u_tt = c^2 * Delta( u ) + f(x,y,z,t)
!        u.n = g
! For TZ at order=2:
!    gg = g
!  order=4:
!    gg,
!    nDotGradF = n.grad( f ), f = ue_tt - c^2*lap(ue)
!    gtt
! ============================================================================================

!==========================================================================
!  Check the coefficients in the ghost points of the residual equations
! using the discrete delta approach
!==========================================================================

! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 2,4,6,8
! FORCING : noForcing, forcing
! ===================================================================================================


! ========================================================================================
!  Apply symmetry conditions in corner ghost for Cartesian grids 
! ========================================================================================





! ===================================================================================
! Utility macro to call different versions of assignDirichletGhostCompatibility
! for a given ORDER
! ===================================================================================

! ===================================================================================
! Utility macro to call different versions of assignNeumannGhostCompatibility
! for a given ORDER
! ===================================================================================


subroutine bcOptWave( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,gridIndexRange, dimRange, isPeriodic, u, mask,rsxy, xy, boundaryCondition, frequencyArray, pdb, ipar, rpar, ierr )
! ===================================================================================
!  Boundary conditions for CgWave
!
!  gridType : 0=rectangular, 1=curvilinear
!
! The forcing for the boundary conditions can be accessed using the statement function:
!         bcf(side,axis,i1,i2,i3,m)
! which is defined below. 
! ===================================================================================

    implicit none

    integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ndb, ierr

    real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
    integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
    real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
    real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
    integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*)
    real frequencyArray(0:*)

  ! *** TEMP ARRAYS FOR WORK SPACE --> **FIX ME **************
    real uTemp(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
    real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)

    double precision pdb  ! pointer to data base

  ! integer addBoundaryForcing(0:1,0:2)
  ! integer interfaceType(0:1,0:2,0:*)
  ! integer dim(0:1,0:2,0:1,0:2)

  ! real bcf0(0:*)
  ! integer*8 bcOffset(0:1,0:2)

  ! real bcData(0:ndb-1,0:1,0:nd-1,0:*)

    integer ipar(0:*)
    real rpar(0:*)

  !     --- local variables ----
    
    integer uc,numberOfComponents,assignTwilightZone,assignKnownSolutionAtBoundaries,freq
    integer grid,gridType,orderOfAccuracy,useWhereMask,gridIsImplicit,useUpwindDissipation
    integer twilightZone,numberOfProcessors,addForcing,assignBCForImplicitForImplicit
    integer debug,myid,ghost

    integer checkCoeff
    real maxDiff

    integer ok,getInt,getReal
    real omega,cfl,c
    real kx,ky,kz,twoPi

    real t,dt,epsx,REAL_MIN 
    real ep
    real a0,a1,an1,an2,an3,aNormi, t1,t2,t3
    real dx(0:2),dr(0:2),gravity(0:2)
    real r1,r2,r3

    real dxn,b0,b1,ue,uex,uey,uez,ff,urv(0:2),ur0,cosPW

    real c2,c4,c6,c8
    real gtt,rFactor,uLap,vLap
    real a11,a12,a21,a22
    real r1a,r2a, r1b,r2b, a11c,a12c,a21c,a22c  
    real u1Save,u2Save  
    real uett,uexx,ueyy,uezz,ueLap
    real ue1,ue2,ue3,ue4,f1,f2,f3,det
    real uettxx,uettyy,uettzz, uexxxx,ueyyyy,uezzzz,uexxyy,uexxzz,ueyyzz
    real uetttt,uettLap,ueLap2,lap3d2Pow2
    real uettx,uetty,uettz
    real uexxx,uexxy,uexxz,uexyy,uexzz,ueyyy,ueyyz,ueyzz,uezzz
    real uexxxxxx,uexxxxyy,uexxxxzz,ueyyyyyy,uexxyyyy,uexxzzzz,ueyyyyzz,ueyyzzzz,uezzzzzz,uexxyyzz
    real fLap,ftt,gtttt
    real gg,nDotGradF,crv(0:3)



    integer side,axis,axisp1,axisp2,i1,i2,i3,is1,is2,is3,j1,j2,j3,js1,js2,js3,k1,k2,k3,ks1,ks2,ks3,is,js
    integer l1,l2,l3

    integer numGhost,numberOfGhostPoints,extraForNeumann,extraForDirichlet,numberOfFrequencies
    integer side1,side2,side3
    integer n1a,n1b,n2a,n2b,n3a,n3b
    integer m1a,m1b,m2a,m2b,m3a,m3b
    integer nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
    integer j1a,j1b,j2a,j2b,ja,j3b
    integer extra1a,extra1b,extra2a,extra2b,extra3a,extra3b,extram

    integer cornerBC(0:2,0:2,0:2), iparc(0:10), orderOfExtrapolationForCorners
    real rparc(0:10)

  ! boundary conditions parameters and interfaceType values
  ! #Include "bcDefineFortran.h"
  ! These should mauch the values in Parameters.h
    integer dirichletBoundaryCondition,neumannBoundaryCondition,dirichletInterface,neumannInterface,mixedBoundaryCondition
    parameter( dirichletBoundaryCondition=12, neumannBoundaryCondition=18, dirichletInterface=21, neumannInterface=22, mixedBoundaryCondition=30 )

    integer rectangular,curvilinear
    parameter(rectangular=0,curvilinear=1)

  ! Boundary conditions: These must mauch the values in CgWave.h
  ! periodic      =-1,
  ! interpolation = 0,
  ! dirichlet     = 1,
  ! neumann       = 2,
  ! evenSymmetry  = 3,
  ! radiation     = 4   
  ! exactBC       = 5 

    integer dirichlet,neumann,evenSymmetry,radiation,exactBC
    parameter( dirichlet=1, neumann=2, evenSymmetry=3, radiation=4, exactBC=5  )

  ! Corner conditions (from op/fortranDeriv/assignCornersOpt.bf)
    integer doNothingCorner,extrapolateCorner,symmetryCorner,taylor2ndOrder
    integer evenSymmetryCorner,oddSymmetryCorner,taylor2ndOrderEvenCorner,taylor4thOrderEvenCorner,vectorSymmetryAxis1Corner,vectorSymmetryAxis2Corner,vectorSymmetryAxis3Corner

    parameter(doNothingCorner=-1,extrapolateCorner=0,symmetryCorner=1,taylor2ndOrder=2, evenSymmetryCorner=3,oddSymmetryCorner=4,taylor2ndOrderEvenCorner=5,taylor4thOrderEvenCorner=6, vectorSymmetryAxis1Corner=7,vectorSymmetryAxis2Corner=8,vectorSymmetryAxis3Corner=9 )      

  ! known solutions
    integer knownSolutionOption
    integer planeWave, gaussianPlaneWave, boxHelmHoltz, polyPeriodic
    parameter( planeWave=1, gaussianPlaneWave=2, boxHelmHoltz=3, polyPeriodic=4 )

  ! parameters for plane wave known solution
    real ampPlaneWave, kxPlaneWave,kyPlaneWave,kzPlaneWave, omegaPlaneWave

  ! parameters for Gaussian plane wave
    real kxGPW,kyGPW,kzGPW, x0GPW,y0GPW,z0GPW, k0GPW, betaGPW
    real xi

  ! parameters for boxHelmholtz known solution
    real kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz,coswt

  ! parameters for polyPeriodic known solution
    real omegaPolyPeriodic,a0PolyPeriodic, a1PolyPeriodic, b1PolyPeriodic, c1PolyPeriodic

  ! --- forcing options ----
  ! These must match the values in CgWave.h: 
  ! enum ForcingOptionEnum
  ! {
  !   noForcing=0,
  !   twilightZoneForcing,
  !   userForcing,
  !   helmholtzForcing
  ! };  
    integer forcingOption
    integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
    parameter( noForcing=0, twilightZoneForcing=1, userForcing=2, helmholtzForcing=2 )

  ! BC APPROACH -- these must match the values in CgWave.h 
  ! enum BoundaryConditionApproachEnum
  ! {
  !   defaultBoundaryConditionApproach,
  !   useOneSidedBoundaryConditions,
  !   useCompatibilityBoundaryConditions,
  !   useLocalCompatibilityBoundaryConditions
  ! };  
    integer bcApproach
    integer defaultBoundaryConditionApproach
    integer useOneSidedBoundaryConditions
    integer useCompatibilityBoundaryConditions
    integer useLocalCompatibilityBoundaryConditions  
    parameter( defaultBoundaryConditionApproach       =0, useOneSidedBoundaryConditions          =1, useCompatibilityBoundaryConditions     =2, useLocalCompatibilityBoundaryConditions=3 )


    real r3v(0:2),a3(0:2,0:2),a3i(0:2,0:2),f3v(0:2)
    real scale1,scale2,scale3
    integer m1,m2,m3
    logical firstTimeForCBC6
    real symSign


  !     --- start statement function ----
    real bcf,mixedRHS,mixedCoeff,mixedNormalCoeff
    integer kd,m,n,component
    real uxOneSided,lap2d2Pow2

  ! real uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 

    real rx,ry,rz,sx,sy,sz,tx,ty,tz

  ! define variables for getDerivatives macros
  ! #Include "../maple/declareGetDerivativesMacrosVariables.h"

      real d12
      real d22
      real h12
      real h22
      real rxr2
      real rxs2
      real rxt2
      real rxrr2
      real rxss2
      real rxrs2
      real ryr2
      real rys2
      real ryt2
      real ryrr2
      real ryss2
      real ryrs2
      real rzr2
      real rzs2
      real rzt2
      real rzrr2
      real rzss2
      real rzrs2
      real sxr2
      real sxs2
      real sxt2
      real sxrr2
      real sxss2
      real sxrs2
      real syr2
      real sys2
      real syt2
      real syrr2
      real syss2
      real syrs2
      real szr2
      real szs2
      real szt2
      real szrr2
      real szss2
      real szrs2
      real txr2
      real txs2
      real txt2
      real txrr2
      real txss2
      real txrs2
      real tyr2
      real tys2
      real tyt2
      real tyrr2
      real tyss2
      real tyrs2
      real tzr2
      real tzs2
      real tzt2
      real tzrr2
      real tzss2
      real tzrs2
      real rxx21
      real rxx22
      real rxy22
      real rxx23
      real rxy23
      real rxz23
      real ryx22
      real ryy22
      real ryx23
      real ryy23
      real ryz23
      real rzx22
      real rzy22
      real rzx23
      real rzy23
      real rzz23
      real sxx22
      real sxy22
      real sxx23
      real sxy23
      real sxz23
      real syx22
      real syy22
      real syx23
      real syy23
      real syz23
      real szx22
      real szy22
      real szx23
      real szy23
      real szz23
      real txx22
      real txy22
      real txx23
      real txy23
      real txz23
      real tyx22
      real tyy22
      real tyx23
      real tyy23
      real tyz23
      real tzx22
      real tzy22
      real tzx23
      real tzy23
      real tzz23
      real ur2
      real us2
      real ut2
      real urr2
      real uss2
      real urs2
      real utt2
      real urt2
      real ust2
      real urrr2
      real usss2
      real uttt2
      real ux21
      real uy21
      real uz21
      real ux22
      real uy22
      real uz22
      real ux23
      real uy23
      real uz23
      real uxx21
      real uyy21
      real uxy21
      real uxz21
      real uyz21
      real uzz21
      real ulaplacian21
      real uxx22
      real uyy22
      real uxy22
      real uxz22
      real uyz22
      real uzz22
      real ulaplacian22
      real uxx23
      real uyy23
      real uzz23
      real uxy23
      real uxz23
      real uyz23
      real ulaplacian23
      real ux23r
      real uy23r
      real uz23r
      real uxx23r
      real uyy23r
      real uxy23r
      real uzz23r
      real uxz23r
      real uyz23r
      real ux21r
      real uy21r
      real uz21r
      real uxx21r
      real uyy21r
      real uzz21r
      real uxy21r
      real uxz21r
      real uyz21r
      real ulaplacian21r
      real ux22r
      real uy22r
      real uz22r
      real uxx22r
      real uyy22r
      real uzz22r
      real uxy22r
      real uxz22r
      real uyz22r
      real ulaplacian22r
      real ulaplacian23r
      real uxxx22r
      real uyyy22r
      real uxxy22r
      real uxyy22r
      real uxxxx22r
      real uyyyy22r
      real uxxyy22r
      real uxxx23r
      real uyyy23r
      real uzzz23r
      real uxxy23r
      real uxxz23r
      real uxyy23r
      real uyyz23r
      real uxzz23r
      real uyzz23r
      real uxxxx23r
      real uyyyy23r
      real uzzzz23r
      real uxxyy23r
      real uxxzz23r
      real uyyzz23r
      real uLapSq22r
      real uLapSq23r
      real d14
      real d24
      real h41
      real h42
      real rxr4
      real rxs4
      real rxt4
      real ryr4
      real rys4
      real ryt4
      real rzr4
      real rzs4
      real rzt4
      real sxr4
      real sxs4
      real sxt4
      real syr4
      real sys4
      real syt4
      real szr4
      real szs4
      real szt4
      real txr4
      real txs4
      real txt4
      real tyr4
      real tys4
      real tyt4
      real tzr4
      real tzs4
      real tzt4
      real rxx41
      real rxx42
      real rxy42
      real rxx43
      real rxy43
      real rxz43
      real ryx42
      real ryy42
      real ryx43
      real ryy43
      real ryz43
      real rzx42
      real rzy42
      real rzx43
      real rzy43
      real rzz43
      real sxx42
      real sxy42
      real sxx43
      real sxy43
      real sxz43
      real syx42
      real syy42
      real syx43
      real syy43
      real syz43
      real szx42
      real szy42
      real szx43
      real szy43
      real szz43
      real txx42
      real txy42
      real txx43
      real txy43
      real txz43
      real tyx42
      real tyy42
      real tyx43
      real tyy43
      real tyz43
      real tzx42
      real tzy42
      real tzx43
      real tzy43
      real tzz43
      real ur4
      real us4
      real ut4
      real urr4
      real uss4
      real utt4
      real urs4
      real urt4
      real ust4
      real ux41
      real uy41
      real uz41
      real ux42
      real uy42
      real uz42
      real ux43
      real uy43
      real uz43
      real uxx41
      real uyy41
      real uxy41
      real uxz41
      real uyz41
      real uzz41
      real ulaplacian41
      real uxx42
      real uyy42
      real uxy42
      real uxz42
      real uyz42
      real uzz42
      real ulaplacian42
      real uxx43
      real uyy43
      real uzz43
      real uxy43
      real uxz43
      real uyz43
      real ulaplacian43
      real ux43r
      real uy43r
      real uz43r
      real uxx43r
      real uyy43r
      real uzz43r
      real uxy43r
      real uxz43r
      real uyz43r
      real ux41r
      real uy41r
      real uz41r
      real uxx41r
      real uyy41r
      real uzz41r
      real uxy41r
      real uxz41r
      real uyz41r
      real ulaplacian41r
      real ux42r
      real uy42r
      real uz42r
      real uxx42r
      real uyy42r
      real uzz42r
      real uxy42r
      real uxz42r
      real uyz42r
      real ulaplacian42r
      real ulaplacian43r
      real vr2
      real vs2
      real vt2
      real vrr2
      real vss2
      real vrs2
      real vtt2
      real vrt2
      real vst2
      real vrrr2
      real vsss2
      real vttt2
      real vx21
      real vy21
      real vz21
      real vx22
      real vy22
      real vz22
      real vx23
      real vy23
      real vz23
      real vxx21
      real vyy21
      real vxy21
      real vxz21
      real vyz21
      real vzz21
      real vlaplacian21
      real vxx22
      real vyy22
      real vxy22
      real vxz22
      real vyz22
      real vzz22
      real vlaplacian22
      real vxx23
      real vyy23
      real vzz23
      real vxy23
      real vxz23
      real vyz23
      real vlaplacian23
      real vx23r
      real vy23r
      real vz23r
      real vxx23r
      real vyy23r
      real vxy23r
      real vzz23r
      real vxz23r
      real vyz23r
      real vx21r
      real vy21r
      real vz21r
      real vxx21r
      real vyy21r
      real vzz21r
      real vxy21r
      real vxz21r
      real vyz21r
      real vlaplacian21r
      real vx22r
      real vy22r
      real vz22r
      real vxx22r
      real vyy22r
      real vzz22r
      real vxy22r
      real vxz22r
      real vyz22r
      real vlaplacian22r
      real vlaplacian23r
      real vxxx22r
      real vyyy22r
      real vxxy22r
      real vxyy22r
      real vxxxx22r
      real vyyyy22r
      real vxxyy22r
      real vxxx23r
      real vyyy23r
      real vzzz23r
      real vxxy23r
      real vxxz23r
      real vxyy23r
      real vyyz23r
      real vxzz23r
      real vyzz23r
      real vxxxx23r
      real vyyyy23r
      real vzzzz23r
      real vxxyy23r
      real vxxzz23r
      real vyyzz23r
      real vLapSq22r
      real vLapSq23r


  !  The next macro call will define the difference approximation statement functions
    d12(kd) = 1./(2.*dr(kd))
    d22(kd) = 1./(dr(kd)**2)
    ur2(i1,i2,i3,kd)=(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))*d12(0)
    us2(i1,i2,i3,kd)=(u(i1,i2+1,i3,kd)-u(i1,i2-1,i3,kd))*d12(1)
    ut2(i1,i2,i3,kd)=(u(i1,i2,i3+1,kd)-u(i1,i2,i3-1,kd))*d12(2)
    urr2(i1,i2,i3,kd)=(-2.*u(i1,i2,i3,kd)+(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd)) )*d22(0)
    uss2(i1,i2,i3,kd)=(-2.*u(i1,i2,i3,kd)+(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd)) )*d22(1)
    urs2(i1,i2,i3,kd)=(ur2(i1,i2+1,i3,kd)-ur2(i1,i2-1,i3,kd))*d12(1)
    utt2(i1,i2,i3,kd)=(-2.*u(i1,i2,i3,kd)+(u(i1,i2,i3+1,kd)+u(i1,i2,i3-1,kd)) )*d22(2)
    urt2(i1,i2,i3,kd)=(ur2(i1,i2,i3+1,kd)-ur2(i1,i2,i3-1,kd))*d12(2)
    ust2(i1,i2,i3,kd)=(us2(i1,i2,i3+1,kd)-us2(i1,i2,i3-1,kd))*d12(2)
    urrr2(i1,i2,i3,kd)=(-2.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))+(u(i1+2,i2,i3,kd)-u(i1-2,i2,i3,kd)) )*d22(0)*d12(0)
    usss2(i1,i2,i3,kd)=(-2.*(u(i1,i2+1,i3,kd)-u(i1,i2-1,i3,kd))+(u(i1,i2+2,i3,kd)-u(i1,i2-2,i3,kd)) )*d22(1)*d12(1)
    uttt2(i1,i2,i3,kd)=(-2.*(u(i1,i2,i3+1,kd)-u(i1,i2,i3-1,kd))+(u(i1,i2,i3+2,kd)-u(i1,i2,i3-2,kd)) )*d22(2)*d12(2)
    rxr2(i1,i2,i3)=(rx(i1+1,i2,i3)-rx(i1-1,i2,i3))*d12(0)
    rxs2(i1,i2,i3)=(rx(i1,i2+1,i3)-rx(i1,i2-1,i3))*d12(1)
    rxt2(i1,i2,i3)=(rx(i1,i2,i3+1)-rx(i1,i2,i3-1))*d12(2)
    rxrr2(i1,i2,i3)=(-2.*rx(i1,i2,i3)+(rx(i1+1,i2,i3)+rx(i1-1,i2,i3)) )*d22(0)
    rxss2(i1,i2,i3)=(-2.*rx(i1,i2,i3)+(rx(i1,i2+1,i3)+rx(i1,i2-1,i3)) )*d22(1)
    rxrs2(i1,i2,i3)=(rxr2(i1,i2+1,i3)-rxr2(i1,i2-1,i3))*d12(1)
    ryr2(i1,i2,i3)=(ry(i1+1,i2,i3)-ry(i1-1,i2,i3))*d12(0)
    rys2(i1,i2,i3)=(ry(i1,i2+1,i3)-ry(i1,i2-1,i3))*d12(1)
    ryt2(i1,i2,i3)=(ry(i1,i2,i3+1)-ry(i1,i2,i3-1))*d12(2)
    ryrr2(i1,i2,i3)=(-2.*ry(i1,i2,i3)+(ry(i1+1,i2,i3)+ry(i1-1,i2,i3)) )*d22(0)
    ryss2(i1,i2,i3)=(-2.*ry(i1,i2,i3)+(ry(i1,i2+1,i3)+ry(i1,i2-1,i3)) )*d22(1)
    ryrs2(i1,i2,i3)=(ryr2(i1,i2+1,i3)-ryr2(i1,i2-1,i3))*d12(1)
    rzr2(i1,i2,i3)=(rz(i1+1,i2,i3)-rz(i1-1,i2,i3))*d12(0)
    rzs2(i1,i2,i3)=(rz(i1,i2+1,i3)-rz(i1,i2-1,i3))*d12(1)
    rzt2(i1,i2,i3)=(rz(i1,i2,i3+1)-rz(i1,i2,i3-1))*d12(2)
    rzrr2(i1,i2,i3)=(-2.*rz(i1,i2,i3)+(rz(i1+1,i2,i3)+rz(i1-1,i2,i3)) )*d22(0)
    rzss2(i1,i2,i3)=(-2.*rz(i1,i2,i3)+(rz(i1,i2+1,i3)+rz(i1,i2-1,i3)) )*d22(1)
    rzrs2(i1,i2,i3)=(rzr2(i1,i2+1,i3)-rzr2(i1,i2-1,i3))*d12(1)
    sxr2(i1,i2,i3)=(sx(i1+1,i2,i3)-sx(i1-1,i2,i3))*d12(0)
    sxs2(i1,i2,i3)=(sx(i1,i2+1,i3)-sx(i1,i2-1,i3))*d12(1)
    sxt2(i1,i2,i3)=(sx(i1,i2,i3+1)-sx(i1,i2,i3-1))*d12(2)
    sxrr2(i1,i2,i3)=(-2.*sx(i1,i2,i3)+(sx(i1+1,i2,i3)+sx(i1-1,i2,i3)) )*d22(0)
    sxss2(i1,i2,i3)=(-2.*sx(i1,i2,i3)+(sx(i1,i2+1,i3)+sx(i1,i2-1,i3)) )*d22(1)
    sxrs2(i1,i2,i3)=(sxr2(i1,i2+1,i3)-sxr2(i1,i2-1,i3))*d12(1)
    syr2(i1,i2,i3)=(sy(i1+1,i2,i3)-sy(i1-1,i2,i3))*d12(0)
    sys2(i1,i2,i3)=(sy(i1,i2+1,i3)-sy(i1,i2-1,i3))*d12(1)
    syt2(i1,i2,i3)=(sy(i1,i2,i3+1)-sy(i1,i2,i3-1))*d12(2)
    syrr2(i1,i2,i3)=(-2.*sy(i1,i2,i3)+(sy(i1+1,i2,i3)+sy(i1-1,i2,i3)) )*d22(0)
    syss2(i1,i2,i3)=(-2.*sy(i1,i2,i3)+(sy(i1,i2+1,i3)+sy(i1,i2-1,i3)) )*d22(1)
    syrs2(i1,i2,i3)=(syr2(i1,i2+1,i3)-syr2(i1,i2-1,i3))*d12(1)
    szr2(i1,i2,i3)=(sz(i1+1,i2,i3)-sz(i1-1,i2,i3))*d12(0)
    szs2(i1,i2,i3)=(sz(i1,i2+1,i3)-sz(i1,i2-1,i3))*d12(1)
    szt2(i1,i2,i3)=(sz(i1,i2,i3+1)-sz(i1,i2,i3-1))*d12(2)
    szrr2(i1,i2,i3)=(-2.*sz(i1,i2,i3)+(sz(i1+1,i2,i3)+sz(i1-1,i2,i3)) )*d22(0)
    szss2(i1,i2,i3)=(-2.*sz(i1,i2,i3)+(sz(i1,i2+1,i3)+sz(i1,i2-1,i3)) )*d22(1)
    szrs2(i1,i2,i3)=(szr2(i1,i2+1,i3)-szr2(i1,i2-1,i3))*d12(1)
    txr2(i1,i2,i3)=(tx(i1+1,i2,i3)-tx(i1-1,i2,i3))*d12(0)
    txs2(i1,i2,i3)=(tx(i1,i2+1,i3)-tx(i1,i2-1,i3))*d12(1)
    txt2(i1,i2,i3)=(tx(i1,i2,i3+1)-tx(i1,i2,i3-1))*d12(2)
    txrr2(i1,i2,i3)=(-2.*tx(i1,i2,i3)+(tx(i1+1,i2,i3)+tx(i1-1,i2,i3)) )*d22(0)
    txss2(i1,i2,i3)=(-2.*tx(i1,i2,i3)+(tx(i1,i2+1,i3)+tx(i1,i2-1,i3)) )*d22(1)
    txrs2(i1,i2,i3)=(txr2(i1,i2+1,i3)-txr2(i1,i2-1,i3))*d12(1)
    tyr2(i1,i2,i3)=(ty(i1+1,i2,i3)-ty(i1-1,i2,i3))*d12(0)
    tys2(i1,i2,i3)=(ty(i1,i2+1,i3)-ty(i1,i2-1,i3))*d12(1)
    tyt2(i1,i2,i3)=(ty(i1,i2,i3+1)-ty(i1,i2,i3-1))*d12(2)
    tyrr2(i1,i2,i3)=(-2.*ty(i1,i2,i3)+(ty(i1+1,i2,i3)+ty(i1-1,i2,i3)) )*d22(0)
    tyss2(i1,i2,i3)=(-2.*ty(i1,i2,i3)+(ty(i1,i2+1,i3)+ty(i1,i2-1,i3)) )*d22(1)
    tyrs2(i1,i2,i3)=(tyr2(i1,i2+1,i3)-tyr2(i1,i2-1,i3))*d12(1)
    tzr2(i1,i2,i3)=(tz(i1+1,i2,i3)-tz(i1-1,i2,i3))*d12(0)
    tzs2(i1,i2,i3)=(tz(i1,i2+1,i3)-tz(i1,i2-1,i3))*d12(1)
    tzt2(i1,i2,i3)=(tz(i1,i2,i3+1)-tz(i1,i2,i3-1))*d12(2)
    tzrr2(i1,i2,i3)=(-2.*tz(i1,i2,i3)+(tz(i1+1,i2,i3)+tz(i1-1,i2,i3)) )*d22(0)
    tzss2(i1,i2,i3)=(-2.*tz(i1,i2,i3)+(tz(i1,i2+1,i3)+tz(i1,i2-1,i3)) )*d22(1)
    tzrs2(i1,i2,i3)=(tzr2(i1,i2+1,i3)-tzr2(i1,i2-1,i3))*d12(1)
    ux21(i1,i2,i3,kd)= rx(i1,i2,i3)*ur2(i1,i2,i3,kd)
    uy21(i1,i2,i3,kd)=0
    uz21(i1,i2,i3,kd)=0
    ux22(i1,i2,i3,kd)= rx(i1,i2,i3)*ur2(i1,i2,i3,kd)+sx(i1,i2,i3)*us2(i1,i2,i3,kd)
    uy22(i1,i2,i3,kd)= ry(i1,i2,i3)*ur2(i1,i2,i3,kd)+sy(i1,i2,i3)*us2(i1,i2,i3,kd)
    uz22(i1,i2,i3,kd)=0
    ux23(i1,i2,i3,kd)=rx(i1,i2,i3)*ur2(i1,i2,i3,kd)+sx(i1,i2,i3)*us2(i1,i2,i3,kd)+tx(i1,i2,i3)*ut2(i1,i2,i3,kd)
    uy23(i1,i2,i3,kd)=ry(i1,i2,i3)*ur2(i1,i2,i3,kd)+sy(i1,i2,i3)*us2(i1,i2,i3,kd)+ty(i1,i2,i3)*ut2(i1,i2,i3,kd)
    uz23(i1,i2,i3,kd)=rz(i1,i2,i3)*ur2(i1,i2,i3,kd)+sz(i1,i2,i3)*us2(i1,i2,i3,kd)+tz(i1,i2,i3)*ut2(i1,i2,i3,kd)
    rxx21(i1,i2,i3)= rx(i1,i2,i3)*rxr2(i1,i2,i3)
    rxx22(i1,i2,i3)= rx(i1,i2,i3)*rxr2(i1,i2,i3)+sx(i1,i2,i3)*rxs2(i1,i2,i3)
    rxy22(i1,i2,i3)= ry(i1,i2,i3)*rxr2(i1,i2,i3)+sy(i1,i2,i3)*rxs2(i1,i2,i3)
    rxx23(i1,i2,i3)=rx(i1,i2,i3)*rxr2(i1,i2,i3)+sx(i1,i2,i3)*rxs2(i1,i2,i3)+tx(i1,i2,i3)*rxt2(i1,i2,i3)
    rxy23(i1,i2,i3)=ry(i1,i2,i3)*rxr2(i1,i2,i3)+sy(i1,i2,i3)*rxs2(i1,i2,i3)+ty(i1,i2,i3)*rxt2(i1,i2,i3)
    rxz23(i1,i2,i3)=rz(i1,i2,i3)*rxr2(i1,i2,i3)+sz(i1,i2,i3)*rxs2(i1,i2,i3)+tz(i1,i2,i3)*rxt2(i1,i2,i3)
    ryx22(i1,i2,i3)= rx(i1,i2,i3)*ryr2(i1,i2,i3)+sx(i1,i2,i3)*rys2(i1,i2,i3)
    ryy22(i1,i2,i3)= ry(i1,i2,i3)*ryr2(i1,i2,i3)+sy(i1,i2,i3)*rys2(i1,i2,i3)
    ryx23(i1,i2,i3)=rx(i1,i2,i3)*ryr2(i1,i2,i3)+sx(i1,i2,i3)*rys2(i1,i2,i3)+tx(i1,i2,i3)*ryt2(i1,i2,i3)
    ryy23(i1,i2,i3)=ry(i1,i2,i3)*ryr2(i1,i2,i3)+sy(i1,i2,i3)*rys2(i1,i2,i3)+ty(i1,i2,i3)*ryt2(i1,i2,i3)
    ryz23(i1,i2,i3)=rz(i1,i2,i3)*ryr2(i1,i2,i3)+sz(i1,i2,i3)*rys2(i1,i2,i3)+tz(i1,i2,i3)*ryt2(i1,i2,i3)
    rzx22(i1,i2,i3)= rx(i1,i2,i3)*rzr2(i1,i2,i3)+sx(i1,i2,i3)*rzs2(i1,i2,i3)
    rzy22(i1,i2,i3)= ry(i1,i2,i3)*rzr2(i1,i2,i3)+sy(i1,i2,i3)*rzs2(i1,i2,i3)
    rzx23(i1,i2,i3)=rx(i1,i2,i3)*rzr2(i1,i2,i3)+sx(i1,i2,i3)*rzs2(i1,i2,i3)+tx(i1,i2,i3)*rzt2(i1,i2,i3)
    rzy23(i1,i2,i3)=ry(i1,i2,i3)*rzr2(i1,i2,i3)+sy(i1,i2,i3)*rzs2(i1,i2,i3)+ty(i1,i2,i3)*rzt2(i1,i2,i3)
    rzz23(i1,i2,i3)=rz(i1,i2,i3)*rzr2(i1,i2,i3)+sz(i1,i2,i3)*rzs2(i1,i2,i3)+tz(i1,i2,i3)*rzt2(i1,i2,i3)
    sxx22(i1,i2,i3)= rx(i1,i2,i3)*sxr2(i1,i2,i3)+sx(i1,i2,i3)*sxs2(i1,i2,i3)
    sxy22(i1,i2,i3)= ry(i1,i2,i3)*sxr2(i1,i2,i3)+sy(i1,i2,i3)*sxs2(i1,i2,i3)
    sxx23(i1,i2,i3)=rx(i1,i2,i3)*sxr2(i1,i2,i3)+sx(i1,i2,i3)*sxs2(i1,i2,i3)+tx(i1,i2,i3)*sxt2(i1,i2,i3)
    sxy23(i1,i2,i3)=ry(i1,i2,i3)*sxr2(i1,i2,i3)+sy(i1,i2,i3)*sxs2(i1,i2,i3)+ty(i1,i2,i3)*sxt2(i1,i2,i3)
    sxz23(i1,i2,i3)=rz(i1,i2,i3)*sxr2(i1,i2,i3)+sz(i1,i2,i3)*sxs2(i1,i2,i3)+tz(i1,i2,i3)*sxt2(i1,i2,i3)
    syx22(i1,i2,i3)= rx(i1,i2,i3)*syr2(i1,i2,i3)+sx(i1,i2,i3)*sys2(i1,i2,i3)
    syy22(i1,i2,i3)= ry(i1,i2,i3)*syr2(i1,i2,i3)+sy(i1,i2,i3)*sys2(i1,i2,i3)
    syx23(i1,i2,i3)=rx(i1,i2,i3)*syr2(i1,i2,i3)+sx(i1,i2,i3)*sys2(i1,i2,i3)+tx(i1,i2,i3)*syt2(i1,i2,i3)
    syy23(i1,i2,i3)=ry(i1,i2,i3)*syr2(i1,i2,i3)+sy(i1,i2,i3)*sys2(i1,i2,i3)+ty(i1,i2,i3)*syt2(i1,i2,i3)
    syz23(i1,i2,i3)=rz(i1,i2,i3)*syr2(i1,i2,i3)+sz(i1,i2,i3)*sys2(i1,i2,i3)+tz(i1,i2,i3)*syt2(i1,i2,i3)
    szx22(i1,i2,i3)= rx(i1,i2,i3)*szr2(i1,i2,i3)+sx(i1,i2,i3)*szs2(i1,i2,i3)
    szy22(i1,i2,i3)= ry(i1,i2,i3)*szr2(i1,i2,i3)+sy(i1,i2,i3)*szs2(i1,i2,i3)
    szx23(i1,i2,i3)=rx(i1,i2,i3)*szr2(i1,i2,i3)+sx(i1,i2,i3)*szs2(i1,i2,i3)+tx(i1,i2,i3)*szt2(i1,i2,i3)
    szy23(i1,i2,i3)=ry(i1,i2,i3)*szr2(i1,i2,i3)+sy(i1,i2,i3)*szs2(i1,i2,i3)+ty(i1,i2,i3)*szt2(i1,i2,i3)
    szz23(i1,i2,i3)=rz(i1,i2,i3)*szr2(i1,i2,i3)+sz(i1,i2,i3)*szs2(i1,i2,i3)+tz(i1,i2,i3)*szt2(i1,i2,i3)
    txx22(i1,i2,i3)= rx(i1,i2,i3)*txr2(i1,i2,i3)+sx(i1,i2,i3)*txs2(i1,i2,i3)
    txy22(i1,i2,i3)= ry(i1,i2,i3)*txr2(i1,i2,i3)+sy(i1,i2,i3)*txs2(i1,i2,i3)
    txx23(i1,i2,i3)=rx(i1,i2,i3)*txr2(i1,i2,i3)+sx(i1,i2,i3)*txs2(i1,i2,i3)+tx(i1,i2,i3)*txt2(i1,i2,i3)
    txy23(i1,i2,i3)=ry(i1,i2,i3)*txr2(i1,i2,i3)+sy(i1,i2,i3)*txs2(i1,i2,i3)+ty(i1,i2,i3)*txt2(i1,i2,i3)
    txz23(i1,i2,i3)=rz(i1,i2,i3)*txr2(i1,i2,i3)+sz(i1,i2,i3)*txs2(i1,i2,i3)+tz(i1,i2,i3)*txt2(i1,i2,i3)
    tyx22(i1,i2,i3)= rx(i1,i2,i3)*tyr2(i1,i2,i3)+sx(i1,i2,i3)*tys2(i1,i2,i3)
    tyy22(i1,i2,i3)= ry(i1,i2,i3)*tyr2(i1,i2,i3)+sy(i1,i2,i3)*tys2(i1,i2,i3)
    tyx23(i1,i2,i3)=rx(i1,i2,i3)*tyr2(i1,i2,i3)+sx(i1,i2,i3)*tys2(i1,i2,i3)+tx(i1,i2,i3)*tyt2(i1,i2,i3)
    tyy23(i1,i2,i3)=ry(i1,i2,i3)*tyr2(i1,i2,i3)+sy(i1,i2,i3)*tys2(i1,i2,i3)+ty(i1,i2,i3)*tyt2(i1,i2,i3)
    tyz23(i1,i2,i3)=rz(i1,i2,i3)*tyr2(i1,i2,i3)+sz(i1,i2,i3)*tys2(i1,i2,i3)+tz(i1,i2,i3)*tyt2(i1,i2,i3)
    tzx22(i1,i2,i3)= rx(i1,i2,i3)*tzr2(i1,i2,i3)+sx(i1,i2,i3)*tzs2(i1,i2,i3)
    tzy22(i1,i2,i3)= ry(i1,i2,i3)*tzr2(i1,i2,i3)+sy(i1,i2,i3)*tzs2(i1,i2,i3)
    tzx23(i1,i2,i3)=rx(i1,i2,i3)*tzr2(i1,i2,i3)+sx(i1,i2,i3)*tzs2(i1,i2,i3)+tx(i1,i2,i3)*tzt2(i1,i2,i3)
    tzy23(i1,i2,i3)=ry(i1,i2,i3)*tzr2(i1,i2,i3)+sy(i1,i2,i3)*tzs2(i1,i2,i3)+ty(i1,i2,i3)*tzt2(i1,i2,i3)
    tzz23(i1,i2,i3)=rz(i1,i2,i3)*tzr2(i1,i2,i3)+sz(i1,i2,i3)*tzs2(i1,i2,i3)+tz(i1,i2,i3)*tzt2(i1,i2,i3)
    uxx21(i1,i2,i3,kd)=(rx(i1,i2,i3)**2)*urr2(i1,i2,i3,kd)+(rxx22(i1,i2,i3))*ur2(i1,i2,i3,kd)
    uyy21(i1,i2,i3,kd)=0
    uxy21(i1,i2,i3,kd)=0
    uxz21(i1,i2,i3,kd)=0
    uyz21(i1,i2,i3,kd)=0
    uzz21(i1,i2,i3,kd)=0
    ulaplacian21(i1,i2,i3,kd)=uxx21(i1,i2,i3,kd)
    uxx22(i1,i2,i3,kd)=(rx(i1,i2,i3)**2)*urr2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3))*urs2(i1,i2,i3,kd)+(sx(i1,i2,i3)**2)*uss2(i1,i2,i3,kd)+(rxx22(i1,i2,i3))*ur2(i1,i2,i3,kd)+(sxx22(i1,i2,i3))*us2(i1,i2,i3,kd)
    uyy22(i1,i2,i3,kd)=(ry(i1,i2,i3)**2)*urr2(i1,i2,i3,kd)+2.*(ry(i1,i2,i3)*sy(i1,i2,i3))*urs2(i1,i2,i3,kd)+(sy(i1,i2,i3)**2)*uss2(i1,i2,i3,kd)+(ryy22(i1,i2,i3))*ur2(i1,i2,i3,kd)+(syy22(i1,i2,i3))*us2(i1,i2,i3,kd)
    uxy22(i1,i2,i3,kd)=rx(i1,i2,i3)*ry(i1,i2,i3)*urr2(i1,i2,i3,kd)+(rx(i1,i2,i3)*sy(i1,i2,i3)+ry(i1,i2,i3)*sx(i1,i2,i3))*urs2(i1,i2,i3,kd)+sx(i1,i2,i3)*sy(i1,i2,i3)*uss2(i1,i2,i3,kd)+rxy22(i1,i2,i3)*ur2(i1,i2,i3,kd)+sxy22(i1,i2,i3)*us2(i1,i2,i3,kd)
    uxz22(i1,i2,i3,kd)=0
    uyz22(i1,i2,i3,kd)=0
    uzz22(i1,i2,i3,kd)=0
    ulaplacian22(i1,i2,i3,kd)=(rx(i1,i2,i3)**2+ry(i1,i2,i3)**2)*urr2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3)+ ry(i1,i2,i3)*sy(i1,i2,i3))*urs2(i1,i2,i3,kd)+(sx(i1,i2,i3)**2+sy(i1,i2,i3)**2)*uss2(i1,i2,i3,kd)+(rxx22(i1,i2,i3)+ryy22(i1,i2,i3))*ur2(i1,i2,i3,kd)+(sxx22(i1,i2,i3)+syy22(i1,i2,i3))*us2(i1,i2,i3,kd)
    uxx23(i1,i2,i3,kd)=rx(i1,i2,i3)**2*urr2(i1,i2,i3,kd)+sx(i1,i2,i3)**2*uss2(i1,i2,i3,kd)+tx(i1,i2,i3)**2*utt2(i1,i2,i3,kd)+2.*rx(i1,i2,i3)*sx(i1,i2,i3)*urs2(i1,i2,i3,kd)+2.*rx(i1,i2,i3)*tx(i1,i2,i3)*urt2(i1,i2,i3,kd)+2.*sx(i1,i2,i3)*tx(i1,i2,i3)*ust2(i1,i2,i3,kd)+rxx23(i1,i2,i3)*ur2(i1,i2,i3,kd)+sxx23(i1,i2,i3)*us2(i1,i2,i3,kd)+txx23(i1,i2,i3)*ut2(i1,i2,i3,kd)
    uyy23(i1,i2,i3,kd)=ry(i1,i2,i3)**2*urr2(i1,i2,i3,kd)+sy(i1,i2,i3)**2*uss2(i1,i2,i3,kd)+ty(i1,i2,i3)**2*utt2(i1,i2,i3,kd)+2.*ry(i1,i2,i3)*sy(i1,i2,i3)*urs2(i1,i2,i3,kd)+2.*ry(i1,i2,i3)*ty(i1,i2,i3)*urt2(i1,i2,i3,kd)+2.*sy(i1,i2,i3)*ty(i1,i2,i3)*ust2(i1,i2,i3,kd)+ryy23(i1,i2,i3)*ur2(i1,i2,i3,kd)+syy23(i1,i2,i3)*us2(i1,i2,i3,kd)+tyy23(i1,i2,i3)*ut2(i1,i2,i3,kd)
    uzz23(i1,i2,i3,kd)=rz(i1,i2,i3)**2*urr2(i1,i2,i3,kd)+sz(i1,i2,i3)**2*uss2(i1,i2,i3,kd)+tz(i1,i2,i3)**2*utt2(i1,i2,i3,kd)+2.*rz(i1,i2,i3)*sz(i1,i2,i3)*urs2(i1,i2,i3,kd)+2.*rz(i1,i2,i3)*tz(i1,i2,i3)*urt2(i1,i2,i3,kd)+2.*sz(i1,i2,i3)*tz(i1,i2,i3)*ust2(i1,i2,i3,kd)+rzz23(i1,i2,i3)*ur2(i1,i2,i3,kd)+szz23(i1,i2,i3)*us2(i1,i2,i3,kd)+tzz23(i1,i2,i3)*ut2(i1,i2,i3,kd)
    uxy23(i1,i2,i3,kd)=rx(i1,i2,i3)*ry(i1,i2,i3)*urr2(i1,i2,i3,kd)+sx(i1,i2,i3)*sy(i1,i2,i3)*uss2(i1,i2,i3,kd)+tx(i1,i2,i3)*ty(i1,i2,i3)*utt2(i1,i2,i3,kd)+(rx(i1,i2,i3)*sy(i1,i2,i3)+ry(i1,i2,i3)*sx(i1,i2,i3))*urs2(i1,i2,i3,kd)+(rx(i1,i2,i3)*ty(i1,i2,i3)+ry(i1,i2,i3)*tx(i1,i2,i3))*urt2(i1,i2,i3,kd)+(sx(i1,i2,i3)*ty(i1,i2,i3)+sy(i1,i2,i3)*tx(i1,i2,i3))*ust2(i1,i2,i3,kd)+rxy23(i1,i2,i3)*ur2(i1,i2,i3,kd)+sxy23(i1,i2,i3)*us2(i1,i2,i3,kd)+txy23(i1,i2,i3)*ut2(i1,i2,i3,kd)
    uxz23(i1,i2,i3,kd)=rx(i1,i2,i3)*rz(i1,i2,i3)*urr2(i1,i2,i3,kd)+sx(i1,i2,i3)*sz(i1,i2,i3)*uss2(i1,i2,i3,kd)+tx(i1,i2,i3)*tz(i1,i2,i3)*utt2(i1,i2,i3,kd)+(rx(i1,i2,i3)*sz(i1,i2,i3)+rz(i1,i2,i3)*sx(i1,i2,i3))*urs2(i1,i2,i3,kd)+(rx(i1,i2,i3)*tz(i1,i2,i3)+rz(i1,i2,i3)*tx(i1,i2,i3))*urt2(i1,i2,i3,kd)+(sx(i1,i2,i3)*tz(i1,i2,i3)+sz(i1,i2,i3)*tx(i1,i2,i3))*ust2(i1,i2,i3,kd)+rxz23(i1,i2,i3)*ur2(i1,i2,i3,kd)+sxz23(i1,i2,i3)*us2(i1,i2,i3,kd)+txz23(i1,i2,i3)*ut2(i1,i2,i3,kd)
    uyz23(i1,i2,i3,kd)=ry(i1,i2,i3)*rz(i1,i2,i3)*urr2(i1,i2,i3,kd)+sy(i1,i2,i3)*sz(i1,i2,i3)*uss2(i1,i2,i3,kd)+ty(i1,i2,i3)*tz(i1,i2,i3)*utt2(i1,i2,i3,kd)+(ry(i1,i2,i3)*sz(i1,i2,i3)+rz(i1,i2,i3)*sy(i1,i2,i3))*urs2(i1,i2,i3,kd)+(ry(i1,i2,i3)*tz(i1,i2,i3)+rz(i1,i2,i3)*ty(i1,i2,i3))*urt2(i1,i2,i3,kd)+(sy(i1,i2,i3)*tz(i1,i2,i3)+sz(i1,i2,i3)*ty(i1,i2,i3))*ust2(i1,i2,i3,kd)+ryz23(i1,i2,i3)*ur2(i1,i2,i3,kd)+syz23(i1,i2,i3)*us2(i1,i2,i3,kd)+tyz23(i1,i2,i3)*ut2(i1,i2,i3,kd)
    ulaplacian23(i1,i2,i3,kd)=(rx(i1,i2,i3)**2+ry(i1,i2,i3)**2+rz(i1,i2,i3)**2)*urr2(i1,i2,i3,kd)+(sx(i1,i2,i3)**2+sy(i1,i2,i3)**2+sz(i1,i2,i3)**2)*uss2(i1,i2,i3,kd)+(tx(i1,i2,i3)**2+ty(i1,i2,i3)**2+tz(i1,i2,i3)**2)*utt2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3)+ ry(i1,i2,i3)*sy(i1,i2,i3)+rz(i1,i2,i3)*sz(i1,i2,i3))*urs2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*tx(i1,i2,i3)+ ry(i1,i2,i3)*ty(i1,i2,i3)+rz(i1,i2,i3)*tz(i1,i2,i3))*urt2(i1,i2,i3,kd)+2.*(sx(i1,i2,i3)*tx(i1,i2,i3)+ sy(i1,i2,i3)*ty(i1,i2,i3)+sz(i1,i2,i3)*tz(i1,i2,i3))*ust2(i1,i2,i3,kd)+(rxx23(i1,i2,i3)+ryy23(i1,i2,i3)+rzz23(i1,i2,i3))*ur2(i1,i2,i3,kd)+(sxx23(i1,i2,i3)+syy23(i1,i2,i3)+szz23(i1,i2,i3))*us2(i1,i2,i3,kd)+(txx23(i1,i2,i3)+tyy23(i1,i2,i3)+tzz23(i1,i2,i3))*ut2(i1,i2,i3,kd)
  !============================================================================================
  ! Define derivatives for a rectangular grid
  !
  !============================================================================================
    h12(kd) = 1./(2.*dx(kd))
    h22(kd) = 1./(dx(kd)**2)
    ux23r(i1,i2,i3,kd)=(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))*h12(0)
    uy23r(i1,i2,i3,kd)=(u(i1,i2+1,i3,kd)-u(i1,i2-1,i3,kd))*h12(1)
    uz23r(i1,i2,i3,kd)=(u(i1,i2,i3+1,kd)-u(i1,i2,i3-1,kd))*h12(2)
    uxx23r(i1,i2,i3,kd)=(-2.*u(i1,i2,i3,kd)+(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd)) )*h22(0)
    uyy23r(i1,i2,i3,kd)=(-2.*u(i1,i2,i3,kd)+(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd)) )*h22(1)
    uxy23r(i1,i2,i3,kd)=(ux23r(i1,i2+1,i3,kd)-ux23r(i1,i2-1,i3,kd))*h12(1)
    uzz23r(i1,i2,i3,kd)=(-2.*u(i1,i2,i3,kd)+(u(i1,i2,i3+1,kd)+u(i1,i2,i3-1,kd)) )*h22(2)
    uxz23r(i1,i2,i3,kd)=(ux23r(i1,i2,i3+1,kd)-ux23r(i1,i2,i3-1,kd))*h12(2)
    uyz23r(i1,i2,i3,kd)=(uy23r(i1,i2,i3+1,kd)-uy23r(i1,i2,i3-1,kd))*h12(2)
    ux21r(i1,i2,i3,kd)= ux23r(i1,i2,i3,kd)
    uy21r(i1,i2,i3,kd)= uy23r(i1,i2,i3,kd)
    uz21r(i1,i2,i3,kd)= uz23r(i1,i2,i3,kd)
    uxx21r(i1,i2,i3,kd)= uxx23r(i1,i2,i3,kd)
    uyy21r(i1,i2,i3,kd)= uyy23r(i1,i2,i3,kd)
    uzz21r(i1,i2,i3,kd)= uzz23r(i1,i2,i3,kd)
    uxy21r(i1,i2,i3,kd)= uxy23r(i1,i2,i3,kd)
    uxz21r(i1,i2,i3,kd)= uxz23r(i1,i2,i3,kd)
    uyz21r(i1,i2,i3,kd)= uyz23r(i1,i2,i3,kd)
    ulaplacian21r(i1,i2,i3,kd)=uxx23r(i1,i2,i3,kd)
    ux22r(i1,i2,i3,kd)= ux23r(i1,i2,i3,kd)
    uy22r(i1,i2,i3,kd)= uy23r(i1,i2,i3,kd)
    uz22r(i1,i2,i3,kd)= uz23r(i1,i2,i3,kd)
    uxx22r(i1,i2,i3,kd)= uxx23r(i1,i2,i3,kd)
    uyy22r(i1,i2,i3,kd)= uyy23r(i1,i2,i3,kd)
    uzz22r(i1,i2,i3,kd)= uzz23r(i1,i2,i3,kd)
    uxy22r(i1,i2,i3,kd)= uxy23r(i1,i2,i3,kd)
    uxz22r(i1,i2,i3,kd)= uxz23r(i1,i2,i3,kd)
    uyz22r(i1,i2,i3,kd)= uyz23r(i1,i2,i3,kd)
    ulaplacian22r(i1,i2,i3,kd)=uxx23r(i1,i2,i3,kd)+uyy23r(i1,i2,i3,kd)
    ulaplacian23r(i1,i2,i3,kd)=uxx23r(i1,i2,i3,kd)+uyy23r(i1,i2,i3,kd)+uzz23r(i1,i2,i3,kd)
    uxxx22r(i1,i2,i3,kd)=(-2.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))+(u(i1+2,i2,i3,kd)-u(i1-2,i2,i3,kd)) )*h22(0)*h12(0)
    uyyy22r(i1,i2,i3,kd)=(-2.*(u(i1,i2+1,i3,kd)-u(i1,i2-1,i3,kd))+(u(i1,i2+2,i3,kd)-u(i1,i2-2,i3,kd)) )*h22(1)*h12(1)
    uxxy22r(i1,i2,i3,kd)=( uxx22r(i1,i2+1,i3,kd)-uxx22r(i1,i2-1,i3,kd))/(2.*dx(1))
    uxyy22r(i1,i2,i3,kd)=( uyy22r(i1+1,i2,i3,kd)-uyy22r(i1-1,i2,i3,kd))/(2.*dx(0))
    uxxxx22r(i1,i2,i3,kd)=(6.*u(i1,i2,i3,kd)-4.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))+(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )/(dx(0)**4)
    uyyyy22r(i1,i2,i3,kd)=(6.*u(i1,i2,i3,kd)-4.*(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))+(u(i1,i2+2,i3,kd)+u(i1,i2-2,i3,kd)) )/(dx(1)**4)
    uxxyy22r(i1,i2,i3,kd)=( 4.*u(i1,i2,i3,kd)     -2.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd)+u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))   +   (u(i1+1,i2+1,i3,kd)+u(i1-1,i2+1,i3,kd)+u(i1+1,i2-1,i3,kd)+u(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)
  ! 2D laplacian squared = u.xxxx + 2 u.xxyy + u.yyyy
    uLapSq22r(i1,i2,i3,kd)= ( 6.*u(i1,i2,i3,kd)   - 4.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))    +(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )/(dx(0)**4) +( 6.*u(i1,i2,i3,kd)    -4.*(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))    +(u(i1,i2+2,i3,kd)+u(i1,i2-2,i3,kd)) )/(dx(1)**4)  +( 8.*u(i1,i2,i3,kd)     -4.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd)+u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))   +2.*(u(i1+1,i2+1,i3,kd)+u(i1-1,i2+1,i3,kd)+u(i1+1,i2-1,i3,kd)+u(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)
    uxxx23r(i1,i2,i3,kd)=(-2.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))+(u(i1+2,i2,i3,kd)-u(i1-2,i2,i3,kd)) )*h22(0)*h12(0)
    uyyy23r(i1,i2,i3,kd)=(-2.*(u(i1,i2+1,i3,kd)-u(i1,i2-1,i3,kd))+(u(i1,i2+2,i3,kd)-u(i1,i2-2,i3,kd)) )*h22(1)*h12(1)
    uzzz23r(i1,i2,i3,kd)=(-2.*(u(i1,i2,i3+1,kd)-u(i1,i2,i3-1,kd))+(u(i1,i2,i3+2,kd)-u(i1,i2,i3-2,kd)) )*h22(1)*h12(2)
    uxxy23r(i1,i2,i3,kd)=( uxx22r(i1,i2+1,i3,kd)-uxx22r(i1,i2-1,i3,kd))/(2.*dx(1))
    uxyy23r(i1,i2,i3,kd)=( uyy22r(i1+1,i2,i3,kd)-uyy22r(i1-1,i2,i3,kd))/(2.*dx(0))
    uxxz23r(i1,i2,i3,kd)=( uxx22r(i1,i2,i3+1,kd)-uxx22r(i1,i2,i3-1,kd))/(2.*dx(2))
    uyyz23r(i1,i2,i3,kd)=( uyy22r(i1,i2,i3+1,kd)-uyy22r(i1,i2,i3-1,kd))/(2.*dx(2))
    uxzz23r(i1,i2,i3,kd)=( uzz22r(i1+1,i2,i3,kd)-uzz22r(i1-1,i2,i3,kd))/(2.*dx(0))
    uyzz23r(i1,i2,i3,kd)=( uzz22r(i1,i2+1,i3,kd)-uzz22r(i1,i2-1,i3,kd))/(2.*dx(1))
    uxxxx23r(i1,i2,i3,kd)=(6.*u(i1,i2,i3,kd)-4.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))+(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )/(dx(0)**4)
    uyyyy23r(i1,i2,i3,kd)=(6.*u(i1,i2,i3,kd)-4.*(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))+(u(i1,i2+2,i3,kd)+u(i1,i2-2,i3,kd)) )/(dx(1)**4)
    uzzzz23r(i1,i2,i3,kd)=(6.*u(i1,i2,i3,kd)-4.*(u(i1,i2,i3+1,kd)+u(i1,i2,i3-1,kd))+(u(i1,i2,i3+2,kd)+u(i1,i2,i3-2,kd)) )/(dx(2)**4)
    uxxyy23r(i1,i2,i3,kd)=( 4.*u(i1,i2,i3,kd)     -2.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd)+u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))   +   (u(i1+1,i2+1,i3,kd)+u(i1-1,i2+1,i3,kd)+u(i1+1,i2-1,i3,kd)+u(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)
    uxxzz23r(i1,i2,i3,kd)=( 4.*u(i1,i2,i3,kd)     -2.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd)+u(i1,i2,i3+1,kd)+u(i1,i2,i3-1,kd))   +   (u(i1+1,i2,i3+1,kd)+u(i1-1,i2,i3+1,kd)+u(i1+1,i2,i3-1,kd)+u(i1-1,i2,i3-1,kd)) )/(dx(0)**2*dx(2)**2)
    uyyzz23r(i1,i2,i3,kd)=( 4.*u(i1,i2,i3,kd)     -2.*(u(i1,i2+1,i3,kd)  +u(i1,i2-1,i3,kd)+  u(i1,i2  ,i3+1,kd)+u(i1,i2  ,i3-1,kd))   +   (u(i1,i2+1,i3+1,kd)+u(i1,i2-1,i3+1,kd)+u(i1,i2+1,i3-1,kd)+u(i1,i2-1,i3-1,kd)) )/(dx(1)**2*dx(2)**2)
  ! 3D laplacian squared = u.xxxx + u.yyyy + u.zzzz + 2 (u.xxyy + u.xxzz + u.yyzz )
    uLapSq23r(i1,i2,i3,kd)= ( 6.*u(i1,i2,i3,kd)   - 4.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))    +(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )/(dx(0)**4) +( 6.*u(i1,i2,i3,kd)    -4.*(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))    +(u(i1,i2+2,i3,kd)+u(i1,i2-2,i3,kd)) )/(dx(1)**4)  +( 6.*u(i1,i2,i3,kd)    -4.*(u(i1,i2,i3+1,kd)+u(i1,i2,i3-1,kd))    +(u(i1,i2,i3+2,kd)+u(i1,i2,i3-2,kd)) )/(dx(2)**4)  +( 8.*u(i1,i2,i3,kd)     -4.*(u(i1+1,i2,i3,kd)  +u(i1-1,i2,i3,kd)  +u(i1  ,i2+1,i3,kd)+u(i1  ,i2-1,i3,kd))   +2.*(u(i1+1,i2+1,i3,kd)+u(i1-1,i2+1,i3,kd)+u(i1+1,i2-1,i3,kd)+u(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)+( 8.*u(i1,i2,i3,kd)     -4.*(u(i1+1,i2,i3,kd)  +u(i1-1,i2,i3,kd)  +u(i1  ,i2,i3+1,kd)+u(i1  ,i2,i3-1,kd))   +2.*(u(i1+1,i2,i3+1,kd)+u(i1-1,i2,i3+1,kd)+u(i1+1,i2,i3-1,kd)+u(i1-1,i2,i3-1,kd)) )/(dx(0)**2*dx(2)**2)+( 8.*u(i1,i2,i3,kd)     -4.*(u(i1,i2+1,i3,kd)  +u(i1,i2-1,i3,kd)  +u(i1,i2  ,i3+1,kd)+u(i1,i2  ,i3-1,kd))   +2.*(u(i1,i2+1,i3+1,kd)+u(i1,i2-1,i3+1,kd)+u(i1,i2+1,i3-1,kd)+u(i1,i2-1,i3-1,kd)) )/(dx(1)**2*dx(2)**2)
    d14(kd) = 1./(12.*dr(kd))
    d24(kd) = 1./(12.*dr(kd)**2)
    ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)
    us4(i1,i2,i3,kd)=(8.*(u(i1,i2+1,i3,kd)-u(i1,i2-1,i3,kd))-(u(i1,i2+2,i3,kd)-u(i1,i2-2,i3,kd)))*d14(1)
    ut4(i1,i2,i3,kd)=(8.*(u(i1,i2,i3+1,kd)-u(i1,i2,i3-1,kd))-(u(i1,i2,i3+2,kd)-u(i1,i2,i3-2,kd)))*d14(2)
    urr4(i1,i2,i3,kd)=(-30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*d24(0)
    uss4(i1,i2,i3,kd)=(-30.*u(i1,i2,i3,kd)+16.*(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))-(u(i1,i2+2,i3,kd)+u(i1,i2-2,i3,kd)) )*d24(1)
    utt4(i1,i2,i3,kd)=(-30.*u(i1,i2,i3,kd)+16.*(u(i1,i2,i3+1,kd)+u(i1,i2,i3-1,kd))-(u(i1,i2,i3+2,kd)+u(i1,i2,i3-2,kd)) )*d24(2)
    urs4(i1,i2,i3,kd)=(8.*(ur4(i1,i2+1,i3,kd)-ur4(i1,i2-1,i3,kd))-(ur4(i1,i2+2,i3,kd)-ur4(i1,i2-2,i3,kd)))*d14(1)
    urt4(i1,i2,i3,kd)=(8.*(ur4(i1,i2,i3+1,kd)-ur4(i1,i2,i3-1,kd))-(ur4(i1,i2,i3+2,kd)-ur4(i1,i2,i3-2,kd)))*d14(2)
    ust4(i1,i2,i3,kd)=(8.*(us4(i1,i2,i3+1,kd)-us4(i1,i2,i3-1,kd))-(us4(i1,i2,i3+2,kd)-us4(i1,i2,i3-2,kd)))*d14(2)
    rxr4(i1,i2,i3)=(8.*(rx(i1+1,i2,i3)-rx(i1-1,i2,i3))-(rx(i1+2,i2,i3)-rx(i1-2,i2,i3)))*d14(0)
    rxs4(i1,i2,i3)=(8.*(rx(i1,i2+1,i3)-rx(i1,i2-1,i3))-(rx(i1,i2+2,i3)-rx(i1,i2-2,i3)))*d14(1)
    rxt4(i1,i2,i3)=(8.*(rx(i1,i2,i3+1)-rx(i1,i2,i3-1))-(rx(i1,i2,i3+2)-rx(i1,i2,i3-2)))*d14(2)
    ryr4(i1,i2,i3)=(8.*(ry(i1+1,i2,i3)-ry(i1-1,i2,i3))-(ry(i1+2,i2,i3)-ry(i1-2,i2,i3)))*d14(0)
    rys4(i1,i2,i3)=(8.*(ry(i1,i2+1,i3)-ry(i1,i2-1,i3))-(ry(i1,i2+2,i3)-ry(i1,i2-2,i3)))*d14(1)
    ryt4(i1,i2,i3)=(8.*(ry(i1,i2,i3+1)-ry(i1,i2,i3-1))-(ry(i1,i2,i3+2)-ry(i1,i2,i3-2)))*d14(2)
    rzr4(i1,i2,i3)=(8.*(rz(i1+1,i2,i3)-rz(i1-1,i2,i3))-(rz(i1+2,i2,i3)-rz(i1-2,i2,i3)))*d14(0)
    rzs4(i1,i2,i3)=(8.*(rz(i1,i2+1,i3)-rz(i1,i2-1,i3))-(rz(i1,i2+2,i3)-rz(i1,i2-2,i3)))*d14(1)
    rzt4(i1,i2,i3)=(8.*(rz(i1,i2,i3+1)-rz(i1,i2,i3-1))-(rz(i1,i2,i3+2)-rz(i1,i2,i3-2)))*d14(2)
    sxr4(i1,i2,i3)=(8.*(sx(i1+1,i2,i3)-sx(i1-1,i2,i3))-(sx(i1+2,i2,i3)-sx(i1-2,i2,i3)))*d14(0)
    sxs4(i1,i2,i3)=(8.*(sx(i1,i2+1,i3)-sx(i1,i2-1,i3))-(sx(i1,i2+2,i3)-sx(i1,i2-2,i3)))*d14(1)
    sxt4(i1,i2,i3)=(8.*(sx(i1,i2,i3+1)-sx(i1,i2,i3-1))-(sx(i1,i2,i3+2)-sx(i1,i2,i3-2)))*d14(2)
    syr4(i1,i2,i3)=(8.*(sy(i1+1,i2,i3)-sy(i1-1,i2,i3))-(sy(i1+2,i2,i3)-sy(i1-2,i2,i3)))*d14(0)
    sys4(i1,i2,i3)=(8.*(sy(i1,i2+1,i3)-sy(i1,i2-1,i3))-(sy(i1,i2+2,i3)-sy(i1,i2-2,i3)))*d14(1)
    syt4(i1,i2,i3)=(8.*(sy(i1,i2,i3+1)-sy(i1,i2,i3-1))-(sy(i1,i2,i3+2)-sy(i1,i2,i3-2)))*d14(2)
    szr4(i1,i2,i3)=(8.*(sz(i1+1,i2,i3)-sz(i1-1,i2,i3))-(sz(i1+2,i2,i3)-sz(i1-2,i2,i3)))*d14(0)
    szs4(i1,i2,i3)=(8.*(sz(i1,i2+1,i3)-sz(i1,i2-1,i3))-(sz(i1,i2+2,i3)-sz(i1,i2-2,i3)))*d14(1)
    szt4(i1,i2,i3)=(8.*(sz(i1,i2,i3+1)-sz(i1,i2,i3-1))-(sz(i1,i2,i3+2)-sz(i1,i2,i3-2)))*d14(2)
    txr4(i1,i2,i3)=(8.*(tx(i1+1,i2,i3)-tx(i1-1,i2,i3))-(tx(i1+2,i2,i3)-tx(i1-2,i2,i3)))*d14(0)
    txs4(i1,i2,i3)=(8.*(tx(i1,i2+1,i3)-tx(i1,i2-1,i3))-(tx(i1,i2+2,i3)-tx(i1,i2-2,i3)))*d14(1)
    txt4(i1,i2,i3)=(8.*(tx(i1,i2,i3+1)-tx(i1,i2,i3-1))-(tx(i1,i2,i3+2)-tx(i1,i2,i3-2)))*d14(2)
    tyr4(i1,i2,i3)=(8.*(ty(i1+1,i2,i3)-ty(i1-1,i2,i3))-(ty(i1+2,i2,i3)-ty(i1-2,i2,i3)))*d14(0)
    tys4(i1,i2,i3)=(8.*(ty(i1,i2+1,i3)-ty(i1,i2-1,i3))-(ty(i1,i2+2,i3)-ty(i1,i2-2,i3)))*d14(1)
    tyt4(i1,i2,i3)=(8.*(ty(i1,i2,i3+1)-ty(i1,i2,i3-1))-(ty(i1,i2,i3+2)-ty(i1,i2,i3-2)))*d14(2)
    tzr4(i1,i2,i3)=(8.*(tz(i1+1,i2,i3)-tz(i1-1,i2,i3))-(tz(i1+2,i2,i3)-tz(i1-2,i2,i3)))*d14(0)
    tzs4(i1,i2,i3)=(8.*(tz(i1,i2+1,i3)-tz(i1,i2-1,i3))-(tz(i1,i2+2,i3)-tz(i1,i2-2,i3)))*d14(1)
    tzt4(i1,i2,i3)=(8.*(tz(i1,i2,i3+1)-tz(i1,i2,i3-1))-(tz(i1,i2,i3+2)-tz(i1,i2,i3-2)))*d14(2)
    ux41(i1,i2,i3,kd)= rx(i1,i2,i3)*ur4(i1,i2,i3,kd)
    uy41(i1,i2,i3,kd)=0
    uz41(i1,i2,i3,kd)=0
    ux42(i1,i2,i3,kd)= rx(i1,i2,i3)*ur4(i1,i2,i3,kd)+sx(i1,i2,i3)*us4(i1,i2,i3,kd)
    uy42(i1,i2,i3,kd)= ry(i1,i2,i3)*ur4(i1,i2,i3,kd)+sy(i1,i2,i3)*us4(i1,i2,i3,kd)
    uz42(i1,i2,i3,kd)=0
    ux43(i1,i2,i3,kd)=rx(i1,i2,i3)*ur4(i1,i2,i3,kd)+sx(i1,i2,i3)*us4(i1,i2,i3,kd)+tx(i1,i2,i3)*ut4(i1,i2,i3,kd)
    uy43(i1,i2,i3,kd)=ry(i1,i2,i3)*ur4(i1,i2,i3,kd)+sy(i1,i2,i3)*us4(i1,i2,i3,kd)+ty(i1,i2,i3)*ut4(i1,i2,i3,kd)
    uz43(i1,i2,i3,kd)=rz(i1,i2,i3)*ur4(i1,i2,i3,kd)+sz(i1,i2,i3)*us4(i1,i2,i3,kd)+tz(i1,i2,i3)*ut4(i1,i2,i3,kd)
    rxx41(i1,i2,i3)= rx(i1,i2,i3)*rxr4(i1,i2,i3)
    rxx42(i1,i2,i3)= rx(i1,i2,i3)*rxr4(i1,i2,i3)+sx(i1,i2,i3)*rxs4(i1,i2,i3)
    rxy42(i1,i2,i3)= ry(i1,i2,i3)*rxr4(i1,i2,i3)+sy(i1,i2,i3)*rxs4(i1,i2,i3)
    rxx43(i1,i2,i3)=rx(i1,i2,i3)*rxr4(i1,i2,i3)+sx(i1,i2,i3)*rxs4(i1,i2,i3)+tx(i1,i2,i3)*rxt4(i1,i2,i3)
    rxy43(i1,i2,i3)=ry(i1,i2,i3)*rxr4(i1,i2,i3)+sy(i1,i2,i3)*rxs4(i1,i2,i3)+ty(i1,i2,i3)*rxt4(i1,i2,i3)
    rxz43(i1,i2,i3)=rz(i1,i2,i3)*rxr4(i1,i2,i3)+sz(i1,i2,i3)*rxs4(i1,i2,i3)+tz(i1,i2,i3)*rxt4(i1,i2,i3)
    ryx42(i1,i2,i3)= rx(i1,i2,i3)*ryr4(i1,i2,i3)+sx(i1,i2,i3)*rys4(i1,i2,i3)
    ryy42(i1,i2,i3)= ry(i1,i2,i3)*ryr4(i1,i2,i3)+sy(i1,i2,i3)*rys4(i1,i2,i3)
    ryx43(i1,i2,i3)=rx(i1,i2,i3)*ryr4(i1,i2,i3)+sx(i1,i2,i3)*rys4(i1,i2,i3)+tx(i1,i2,i3)*ryt4(i1,i2,i3)
    ryy43(i1,i2,i3)=ry(i1,i2,i3)*ryr4(i1,i2,i3)+sy(i1,i2,i3)*rys4(i1,i2,i3)+ty(i1,i2,i3)*ryt4(i1,i2,i3)
    ryz43(i1,i2,i3)=rz(i1,i2,i3)*ryr4(i1,i2,i3)+sz(i1,i2,i3)*rys4(i1,i2,i3)+tz(i1,i2,i3)*ryt4(i1,i2,i3)
    rzx42(i1,i2,i3)= rx(i1,i2,i3)*rzr4(i1,i2,i3)+sx(i1,i2,i3)*rzs4(i1,i2,i3)
    rzy42(i1,i2,i3)= ry(i1,i2,i3)*rzr4(i1,i2,i3)+sy(i1,i2,i3)*rzs4(i1,i2,i3)
    rzx43(i1,i2,i3)=rx(i1,i2,i3)*rzr4(i1,i2,i3)+sx(i1,i2,i3)*rzs4(i1,i2,i3)+tx(i1,i2,i3)*rzt4(i1,i2,i3)
    rzy43(i1,i2,i3)=ry(i1,i2,i3)*rzr4(i1,i2,i3)+sy(i1,i2,i3)*rzs4(i1,i2,i3)+ty(i1,i2,i3)*rzt4(i1,i2,i3)
    rzz43(i1,i2,i3)=rz(i1,i2,i3)*rzr4(i1,i2,i3)+sz(i1,i2,i3)*rzs4(i1,i2,i3)+tz(i1,i2,i3)*rzt4(i1,i2,i3)
    sxx42(i1,i2,i3)= rx(i1,i2,i3)*sxr4(i1,i2,i3)+sx(i1,i2,i3)*sxs4(i1,i2,i3)
    sxy42(i1,i2,i3)= ry(i1,i2,i3)*sxr4(i1,i2,i3)+sy(i1,i2,i3)*sxs4(i1,i2,i3)
    sxx43(i1,i2,i3)=rx(i1,i2,i3)*sxr4(i1,i2,i3)+sx(i1,i2,i3)*sxs4(i1,i2,i3)+tx(i1,i2,i3)*sxt4(i1,i2,i3)
    sxy43(i1,i2,i3)=ry(i1,i2,i3)*sxr4(i1,i2,i3)+sy(i1,i2,i3)*sxs4(i1,i2,i3)+ty(i1,i2,i3)*sxt4(i1,i2,i3)
    sxz43(i1,i2,i3)=rz(i1,i2,i3)*sxr4(i1,i2,i3)+sz(i1,i2,i3)*sxs4(i1,i2,i3)+tz(i1,i2,i3)*sxt4(i1,i2,i3)
    syx42(i1,i2,i3)= rx(i1,i2,i3)*syr4(i1,i2,i3)+sx(i1,i2,i3)*sys4(i1,i2,i3)
    syy42(i1,i2,i3)= ry(i1,i2,i3)*syr4(i1,i2,i3)+sy(i1,i2,i3)*sys4(i1,i2,i3)
    syx43(i1,i2,i3)=rx(i1,i2,i3)*syr4(i1,i2,i3)+sx(i1,i2,i3)*sys4(i1,i2,i3)+tx(i1,i2,i3)*syt4(i1,i2,i3)
    syy43(i1,i2,i3)=ry(i1,i2,i3)*syr4(i1,i2,i3)+sy(i1,i2,i3)*sys4(i1,i2,i3)+ty(i1,i2,i3)*syt4(i1,i2,i3)
    syz43(i1,i2,i3)=rz(i1,i2,i3)*syr4(i1,i2,i3)+sz(i1,i2,i3)*sys4(i1,i2,i3)+tz(i1,i2,i3)*syt4(i1,i2,i3)
    szx42(i1,i2,i3)= rx(i1,i2,i3)*szr4(i1,i2,i3)+sx(i1,i2,i3)*szs4(i1,i2,i3)
    szy42(i1,i2,i3)= ry(i1,i2,i3)*szr4(i1,i2,i3)+sy(i1,i2,i3)*szs4(i1,i2,i3)
    szx43(i1,i2,i3)=rx(i1,i2,i3)*szr4(i1,i2,i3)+sx(i1,i2,i3)*szs4(i1,i2,i3)+tx(i1,i2,i3)*szt4(i1,i2,i3)
    szy43(i1,i2,i3)=ry(i1,i2,i3)*szr4(i1,i2,i3)+sy(i1,i2,i3)*szs4(i1,i2,i3)+ty(i1,i2,i3)*szt4(i1,i2,i3)
    szz43(i1,i2,i3)=rz(i1,i2,i3)*szr4(i1,i2,i3)+sz(i1,i2,i3)*szs4(i1,i2,i3)+tz(i1,i2,i3)*szt4(i1,i2,i3)
    txx42(i1,i2,i3)= rx(i1,i2,i3)*txr4(i1,i2,i3)+sx(i1,i2,i3)*txs4(i1,i2,i3)
    txy42(i1,i2,i3)= ry(i1,i2,i3)*txr4(i1,i2,i3)+sy(i1,i2,i3)*txs4(i1,i2,i3)
    txx43(i1,i2,i3)=rx(i1,i2,i3)*txr4(i1,i2,i3)+sx(i1,i2,i3)*txs4(i1,i2,i3)+tx(i1,i2,i3)*txt4(i1,i2,i3)
    txy43(i1,i2,i3)=ry(i1,i2,i3)*txr4(i1,i2,i3)+sy(i1,i2,i3)*txs4(i1,i2,i3)+ty(i1,i2,i3)*txt4(i1,i2,i3)
    txz43(i1,i2,i3)=rz(i1,i2,i3)*txr4(i1,i2,i3)+sz(i1,i2,i3)*txs4(i1,i2,i3)+tz(i1,i2,i3)*txt4(i1,i2,i3)
    tyx42(i1,i2,i3)= rx(i1,i2,i3)*tyr4(i1,i2,i3)+sx(i1,i2,i3)*tys4(i1,i2,i3)
    tyy42(i1,i2,i3)= ry(i1,i2,i3)*tyr4(i1,i2,i3)+sy(i1,i2,i3)*tys4(i1,i2,i3)
    tyx43(i1,i2,i3)=rx(i1,i2,i3)*tyr4(i1,i2,i3)+sx(i1,i2,i3)*tys4(i1,i2,i3)+tx(i1,i2,i3)*tyt4(i1,i2,i3)
    tyy43(i1,i2,i3)=ry(i1,i2,i3)*tyr4(i1,i2,i3)+sy(i1,i2,i3)*tys4(i1,i2,i3)+ty(i1,i2,i3)*tyt4(i1,i2,i3)
    tyz43(i1,i2,i3)=rz(i1,i2,i3)*tyr4(i1,i2,i3)+sz(i1,i2,i3)*tys4(i1,i2,i3)+tz(i1,i2,i3)*tyt4(i1,i2,i3)
    tzx42(i1,i2,i3)= rx(i1,i2,i3)*tzr4(i1,i2,i3)+sx(i1,i2,i3)*tzs4(i1,i2,i3)
    tzy42(i1,i2,i3)= ry(i1,i2,i3)*tzr4(i1,i2,i3)+sy(i1,i2,i3)*tzs4(i1,i2,i3)
    tzx43(i1,i2,i3)=rx(i1,i2,i3)*tzr4(i1,i2,i3)+sx(i1,i2,i3)*tzs4(i1,i2,i3)+tx(i1,i2,i3)*tzt4(i1,i2,i3)
    tzy43(i1,i2,i3)=ry(i1,i2,i3)*tzr4(i1,i2,i3)+sy(i1,i2,i3)*tzs4(i1,i2,i3)+ty(i1,i2,i3)*tzt4(i1,i2,i3)
    tzz43(i1,i2,i3)=rz(i1,i2,i3)*tzr4(i1,i2,i3)+sz(i1,i2,i3)*tzs4(i1,i2,i3)+tz(i1,i2,i3)*tzt4(i1,i2,i3)
    uxx41(i1,i2,i3,kd)=(rx(i1,i2,i3)**2)*urr4(i1,i2,i3,kd)+(rxx42(i1,i2,i3))*ur4(i1,i2,i3,kd)
    uyy41(i1,i2,i3,kd)=0
    uxy41(i1,i2,i3,kd)=0
    uxz41(i1,i2,i3,kd)=0
    uyz41(i1,i2,i3,kd)=0
    uzz41(i1,i2,i3,kd)=0
    ulaplacian41(i1,i2,i3,kd)=uxx41(i1,i2,i3,kd)
    uxx42(i1,i2,i3,kd)=(rx(i1,i2,i3)**2)*urr4(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3))*urs4(i1,i2,i3,kd)+(sx(i1,i2,i3)**2)*uss4(i1,i2,i3,kd)+(rxx42(i1,i2,i3))*ur4(i1,i2,i3,kd)+(sxx42(i1,i2,i3))*us4(i1,i2,i3,kd)
    uyy42(i1,i2,i3,kd)=(ry(i1,i2,i3)**2)*urr4(i1,i2,i3,kd)+2.*(ry(i1,i2,i3)*sy(i1,i2,i3))*urs4(i1,i2,i3,kd)+(sy(i1,i2,i3)**2)*uss4(i1,i2,i3,kd)+(ryy42(i1,i2,i3))*ur4(i1,i2,i3,kd)+(syy42(i1,i2,i3))*us4(i1,i2,i3,kd)
    uxy42(i1,i2,i3,kd)=rx(i1,i2,i3)*ry(i1,i2,i3)*urr4(i1,i2,i3,kd)+(rx(i1,i2,i3)*sy(i1,i2,i3)+ry(i1,i2,i3)*sx(i1,i2,i3))*urs4(i1,i2,i3,kd)+sx(i1,i2,i3)*sy(i1,i2,i3)*uss4(i1,i2,i3,kd)+rxy42(i1,i2,i3)*ur4(i1,i2,i3,kd)+sxy42(i1,i2,i3)*us4(i1,i2,i3,kd)
    uxz42(i1,i2,i3,kd)=0
    uyz42(i1,i2,i3,kd)=0
    uzz42(i1,i2,i3,kd)=0
    ulaplacian42(i1,i2,i3,kd)=(rx(i1,i2,i3)**2+ry(i1,i2,i3)**2)*urr4(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3)+ ry(i1,i2,i3)*sy(i1,i2,i3))*urs4(i1,i2,i3,kd)+(sx(i1,i2,i3)**2+sy(i1,i2,i3)**2)*uss4(i1,i2,i3,kd)+(rxx42(i1,i2,i3)+ryy42(i1,i2,i3))*ur4(i1,i2,i3,kd)+(sxx42(i1,i2,i3)+syy42(i1,i2,i3))*us4(i1,i2,i3,kd)
    uxx43(i1,i2,i3,kd)=rx(i1,i2,i3)**2*urr4(i1,i2,i3,kd)+sx(i1,i2,i3)**2*uss4(i1,i2,i3,kd)+tx(i1,i2,i3)**2*utt4(i1,i2,i3,kd)+2.*rx(i1,i2,i3)*sx(i1,i2,i3)*urs4(i1,i2,i3,kd)+2.*rx(i1,i2,i3)*tx(i1,i2,i3)*urt4(i1,i2,i3,kd)+2.*sx(i1,i2,i3)*tx(i1,i2,i3)*ust4(i1,i2,i3,kd)+rxx43(i1,i2,i3)*ur4(i1,i2,i3,kd)+sxx43(i1,i2,i3)*us4(i1,i2,i3,kd)+txx43(i1,i2,i3)*ut4(i1,i2,i3,kd)
    uyy43(i1,i2,i3,kd)=ry(i1,i2,i3)**2*urr4(i1,i2,i3,kd)+sy(i1,i2,i3)**2*uss4(i1,i2,i3,kd)+ty(i1,i2,i3)**2*utt4(i1,i2,i3,kd)+2.*ry(i1,i2,i3)*sy(i1,i2,i3)*urs4(i1,i2,i3,kd)+2.*ry(i1,i2,i3)*ty(i1,i2,i3)*urt4(i1,i2,i3,kd)+2.*sy(i1,i2,i3)*ty(i1,i2,i3)*ust4(i1,i2,i3,kd)+ryy43(i1,i2,i3)*ur4(i1,i2,i3,kd)+syy43(i1,i2,i3)*us4(i1,i2,i3,kd)+tyy43(i1,i2,i3)*ut4(i1,i2,i3,kd)
    uzz43(i1,i2,i3,kd)=rz(i1,i2,i3)**2*urr4(i1,i2,i3,kd)+sz(i1,i2,i3)**2*uss4(i1,i2,i3,kd)+tz(i1,i2,i3)**2*utt4(i1,i2,i3,kd)+2.*rz(i1,i2,i3)*sz(i1,i2,i3)*urs4(i1,i2,i3,kd)+2.*rz(i1,i2,i3)*tz(i1,i2,i3)*urt4(i1,i2,i3,kd)+2.*sz(i1,i2,i3)*tz(i1,i2,i3)*ust4(i1,i2,i3,kd)+rzz43(i1,i2,i3)*ur4(i1,i2,i3,kd)+szz43(i1,i2,i3)*us4(i1,i2,i3,kd)+tzz43(i1,i2,i3)*ut4(i1,i2,i3,kd)
    uxy43(i1,i2,i3,kd)=rx(i1,i2,i3)*ry(i1,i2,i3)*urr4(i1,i2,i3,kd)+sx(i1,i2,i3)*sy(i1,i2,i3)*uss4(i1,i2,i3,kd)+tx(i1,i2,i3)*ty(i1,i2,i3)*utt4(i1,i2,i3,kd)+(rx(i1,i2,i3)*sy(i1,i2,i3)+ry(i1,i2,i3)*sx(i1,i2,i3))*urs4(i1,i2,i3,kd)+(rx(i1,i2,i3)*ty(i1,i2,i3)+ry(i1,i2,i3)*tx(i1,i2,i3))*urt4(i1,i2,i3,kd)+(sx(i1,i2,i3)*ty(i1,i2,i3)+sy(i1,i2,i3)*tx(i1,i2,i3))*ust4(i1,i2,i3,kd)+rxy43(i1,i2,i3)*ur4(i1,i2,i3,kd)+sxy43(i1,i2,i3)*us4(i1,i2,i3,kd)+txy43(i1,i2,i3)*ut4(i1,i2,i3,kd)
    uxz43(i1,i2,i3,kd)=rx(i1,i2,i3)*rz(i1,i2,i3)*urr4(i1,i2,i3,kd)+sx(i1,i2,i3)*sz(i1,i2,i3)*uss4(i1,i2,i3,kd)+tx(i1,i2,i3)*tz(i1,i2,i3)*utt4(i1,i2,i3,kd)+(rx(i1,i2,i3)*sz(i1,i2,i3)+rz(i1,i2,i3)*sx(i1,i2,i3))*urs4(i1,i2,i3,kd)+(rx(i1,i2,i3)*tz(i1,i2,i3)+rz(i1,i2,i3)*tx(i1,i2,i3))*urt4(i1,i2,i3,kd)+(sx(i1,i2,i3)*tz(i1,i2,i3)+sz(i1,i2,i3)*tx(i1,i2,i3))*ust4(i1,i2,i3,kd)+rxz43(i1,i2,i3)*ur4(i1,i2,i3,kd)+sxz43(i1,i2,i3)*us4(i1,i2,i3,kd)+txz43(i1,i2,i3)*ut4(i1,i2,i3,kd)
    uyz43(i1,i2,i3,kd)=ry(i1,i2,i3)*rz(i1,i2,i3)*urr4(i1,i2,i3,kd)+sy(i1,i2,i3)*sz(i1,i2,i3)*uss4(i1,i2,i3,kd)+ty(i1,i2,i3)*tz(i1,i2,i3)*utt4(i1,i2,i3,kd)+(ry(i1,i2,i3)*sz(i1,i2,i3)+rz(i1,i2,i3)*sy(i1,i2,i3))*urs4(i1,i2,i3,kd)+(ry(i1,i2,i3)*tz(i1,i2,i3)+rz(i1,i2,i3)*ty(i1,i2,i3))*urt4(i1,i2,i3,kd)+(sy(i1,i2,i3)*tz(i1,i2,i3)+sz(i1,i2,i3)*ty(i1,i2,i3))*ust4(i1,i2,i3,kd)+ryz43(i1,i2,i3)*ur4(i1,i2,i3,kd)+syz43(i1,i2,i3)*us4(i1,i2,i3,kd)+tyz43(i1,i2,i3)*ut4(i1,i2,i3,kd)
    ulaplacian43(i1,i2,i3,kd)=(rx(i1,i2,i3)**2+ry(i1,i2,i3)**2+rz(i1,i2,i3)**2)*urr4(i1,i2,i3,kd)+(sx(i1,i2,i3)**2+sy(i1,i2,i3)**2+sz(i1,i2,i3)**2)*uss4(i1,i2,i3,kd)+(tx(i1,i2,i3)**2+ty(i1,i2,i3)**2+tz(i1,i2,i3)**2)*utt4(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3)+ ry(i1,i2,i3)*sy(i1,i2,i3)+rz(i1,i2,i3)*sz(i1,i2,i3))*urs4(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*tx(i1,i2,i3)+ ry(i1,i2,i3)*ty(i1,i2,i3)+rz(i1,i2,i3)*tz(i1,i2,i3))*urt4(i1,i2,i3,kd)+2.*(sx(i1,i2,i3)*tx(i1,i2,i3)+ sy(i1,i2,i3)*ty(i1,i2,i3)+sz(i1,i2,i3)*tz(i1,i2,i3))*ust4(i1,i2,i3,kd)+(rxx43(i1,i2,i3)+ryy43(i1,i2,i3)+rzz43(i1,i2,i3))*ur4(i1,i2,i3,kd)+(sxx43(i1,i2,i3)+syy43(i1,i2,i3)+szz43(i1,i2,i3))*us4(i1,i2,i3,kd)+(txx43(i1,i2,i3)+tyy43(i1,i2,i3)+tzz43(i1,i2,i3))*ut4(i1,i2,i3,kd)
  !============================================================================================
  ! Define derivatives for a rectangular grid
  !
  !============================================================================================
    h41(kd) = 1./(12.*dx(kd))
    h42(kd) = 1./(12.*dx(kd)**2)
    ux43r(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)-u(i1-2,i2,i3,kd)))*h41(0)
    uy43r(i1,i2,i3,kd)=(8.*(u(i1,i2+1,i3,kd)-u(i1,i2-1,i3,kd))-(u(i1,i2+2,i3,kd)-u(i1,i2-2,i3,kd)))*h41(1)
    uz43r(i1,i2,i3,kd)=(8.*(u(i1,i2,i3+1,kd)-u(i1,i2,i3-1,kd))-(u(i1,i2,i3+2,kd)-u(i1,i2,i3-2,kd)))*h41(2)
    uxx43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*h42(0) 
    uyy43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1,i2+1,i3,kd)+u(i1,i2-1,i3,kd))-(u(i1,i2+2,i3,kd)+u(i1,i2-2,i3,kd)) )*h42(1) 
    uzz43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1,i2,i3+1,kd)+u(i1,i2,i3-1,kd))-(u(i1,i2,i3+2,kd)+u(i1,i2,i3-2,kd)) )*h42(2)
    uxy43r(i1,i2,i3,kd)=( (u(i1+2,i2+2,i3,kd)-u(i1-2,i2+2,i3,kd)- u(i1+2,i2-2,i3,kd)+u(i1-2,i2-2,i3,kd)) +8.*(u(i1-1,i2+2,i3,kd)-u(i1-1,i2-2,i3,kd)-u(i1+1,i2+2,i3,kd)+u(i1+1,i2-2,i3,kd) +u(i1+2,i2-1,i3,kd)-u(i1-2,i2-1,i3,kd)-u(i1+2,i2+1,i3,kd)+u(i1-2,i2+1,i3,kd))+64.*(u(i1+1,i2+1,i3,kd)-u(i1-1,i2+1,i3,kd)- u(i1+1,i2-1,i3,kd)+u(i1-1,i2-1,i3,kd)))*(h41(0)*h41(1))
    uxz43r(i1,i2,i3,kd)=( (u(i1+2,i2,i3+2,kd)-u(i1-2,i2,i3+2,kd)-u(i1+2,i2,i3-2,kd)+u(i1-2,i2,i3-2,kd)) +8.*(u(i1-1,i2,i3+2,kd)-u(i1-1,i2,i3-2,kd)-u(i1+1,i2,i3+2,kd)+u(i1+1,i2,i3-2,kd) +u(i1+2,i2,i3-1,kd)-u(i1-2,i2,i3-1,kd)- u(i1+2,i2,i3+1,kd)+u(i1-2,i2,i3+1,kd)) +64.*(u(i1+1,i2,i3+1,kd)-u(i1-1,i2,i3+1,kd)-u(i1+1,i2,i3-1,kd)+u(i1-1,i2,i3-1,kd)) )*(h41(0)*h41(2))
    uyz43r(i1,i2,i3,kd)=( (u(i1,i2+2,i3+2,kd)-u(i1,i2-2,i3+2,kd)-u(i1,i2+2,i3-2,kd)+u(i1,i2-2,i3-2,kd)) +8.*(u(i1,i2-1,i3+2,kd)-u(i1,i2-1,i3-2,kd)-u(i1,i2+1,i3+2,kd)+u(i1,i2+1,i3-2,kd) +u(i1,i2+2,i3-1,kd)-u(i1,i2-2,i3-1,kd)-u(i1,i2+2,i3+1,kd)+u(i1,i2-2,i3+1,kd)) +64.*(u(i1,i2+1,i3+1,kd)-u(i1,i2-1,i3+1,kd)-u(i1,i2+1,i3-1,kd)+u(i1,i2-1,i3-1,kd)) )*(h41(1)*h41(2))
    ux41r(i1,i2,i3,kd)= ux43r(i1,i2,i3,kd)
    uy41r(i1,i2,i3,kd)= uy43r(i1,i2,i3,kd)
    uz41r(i1,i2,i3,kd)= uz43r(i1,i2,i3,kd)
    uxx41r(i1,i2,i3,kd)= uxx43r(i1,i2,i3,kd)
    uyy41r(i1,i2,i3,kd)= uyy43r(i1,i2,i3,kd)
    uzz41r(i1,i2,i3,kd)= uzz43r(i1,i2,i3,kd)
    uxy41r(i1,i2,i3,kd)= uxy43r(i1,i2,i3,kd)
    uxz41r(i1,i2,i3,kd)= uxz43r(i1,i2,i3,kd)
    uyz41r(i1,i2,i3,kd)= uyz43r(i1,i2,i3,kd)
    ulaplacian41r(i1,i2,i3,kd)=uxx43r(i1,i2,i3,kd)
    ux42r(i1,i2,i3,kd)= ux43r(i1,i2,i3,kd)
    uy42r(i1,i2,i3,kd)= uy43r(i1,i2,i3,kd)
    uz42r(i1,i2,i3,kd)= uz43r(i1,i2,i3,kd)
    uxx42r(i1,i2,i3,kd)= uxx43r(i1,i2,i3,kd)
    uyy42r(i1,i2,i3,kd)= uyy43r(i1,i2,i3,kd)
    uzz42r(i1,i2,i3,kd)= uzz43r(i1,i2,i3,kd)
    uxy42r(i1,i2,i3,kd)= uxy43r(i1,i2,i3,kd)
    uxz42r(i1,i2,i3,kd)= uxz43r(i1,i2,i3,kd)
    uyz42r(i1,i2,i3,kd)= uyz43r(i1,i2,i3,kd)
    ulaplacian42r(i1,i2,i3,kd)=uxx43r(i1,i2,i3,kd)+uyy43r(i1,i2,i3,kd)
    ulaplacian43r(i1,i2,i3,kd)=uxx43r(i1,i2,i3,kd)+uyy43r(i1,i2,i3,kd)+uzz43r(i1,i2,i3,kd)

    vr2(i1,i2,i3,kd)=(v(i1+1,i2,i3,kd)-v(i1-1,i2,i3,kd))*d12(0)
    vs2(i1,i2,i3,kd)=(v(i1,i2+1,i3,kd)-v(i1,i2-1,i3,kd))*d12(1)
    vt2(i1,i2,i3,kd)=(v(i1,i2,i3+1,kd)-v(i1,i2,i3-1,kd))*d12(2)
    vrr2(i1,i2,i3,kd)=(-2.*v(i1,i2,i3,kd)+(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd)) )*d22(0)
    vss2(i1,i2,i3,kd)=(-2.*v(i1,i2,i3,kd)+(v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd)) )*d22(1)
    vrs2(i1,i2,i3,kd)=(vr2(i1,i2+1,i3,kd)-vr2(i1,i2-1,i3,kd))*d12(1)
    vtt2(i1,i2,i3,kd)=(-2.*v(i1,i2,i3,kd)+(v(i1,i2,i3+1,kd)+v(i1,i2,i3-1,kd)) )*d22(2)
    vrt2(i1,i2,i3,kd)=(vr2(i1,i2,i3+1,kd)-vr2(i1,i2,i3-1,kd))*d12(2)
    vst2(i1,i2,i3,kd)=(vs2(i1,i2,i3+1,kd)-vs2(i1,i2,i3-1,kd))*d12(2)
    vrrr2(i1,i2,i3,kd)=(-2.*(v(i1+1,i2,i3,kd)-v(i1-1,i2,i3,kd))+(v(i1+2,i2,i3,kd)-v(i1-2,i2,i3,kd)) )*d22(0)*d12(0)
    vsss2(i1,i2,i3,kd)=(-2.*(v(i1,i2+1,i3,kd)-v(i1,i2-1,i3,kd))+(v(i1,i2+2,i3,kd)-v(i1,i2-2,i3,kd)) )*d22(1)*d12(1)
    vttt2(i1,i2,i3,kd)=(-2.*(v(i1,i2,i3+1,kd)-v(i1,i2,i3-1,kd))+(v(i1,i2,i3+2,kd)-v(i1,i2,i3-2,kd)) )*d22(2)*d12(2)
    vx21(i1,i2,i3,kd)= rx(i1,i2,i3)*vr2(i1,i2,i3,kd)
    vy21(i1,i2,i3,kd)=0
    vz21(i1,i2,i3,kd)=0
    vx22(i1,i2,i3,kd)= rx(i1,i2,i3)*vr2(i1,i2,i3,kd)+sx(i1,i2,i3)*vs2(i1,i2,i3,kd)
    vy22(i1,i2,i3,kd)= ry(i1,i2,i3)*vr2(i1,i2,i3,kd)+sy(i1,i2,i3)*vs2(i1,i2,i3,kd)
    vz22(i1,i2,i3,kd)=0
    vx23(i1,i2,i3,kd)=rx(i1,i2,i3)*vr2(i1,i2,i3,kd)+sx(i1,i2,i3)*vs2(i1,i2,i3,kd)+tx(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vy23(i1,i2,i3,kd)=ry(i1,i2,i3)*vr2(i1,i2,i3,kd)+sy(i1,i2,i3)*vs2(i1,i2,i3,kd)+ty(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vz23(i1,i2,i3,kd)=rz(i1,i2,i3)*vr2(i1,i2,i3,kd)+sz(i1,i2,i3)*vs2(i1,i2,i3,kd)+tz(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vxx21(i1,i2,i3,kd)=(rx(i1,i2,i3)**2)*vrr2(i1,i2,i3,kd)+(rxx22(i1,i2,i3))*vr2(i1,i2,i3,kd)
    vyy21(i1,i2,i3,kd)=0
    vxy21(i1,i2,i3,kd)=0
    vxz21(i1,i2,i3,kd)=0
    vyz21(i1,i2,i3,kd)=0
    vzz21(i1,i2,i3,kd)=0
    vlaplacian21(i1,i2,i3,kd)=vxx21(i1,i2,i3,kd)
    vxx22(i1,i2,i3,kd)=(rx(i1,i2,i3)**2)*vrr2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3))*vrs2(i1,i2,i3,kd)+(sx(i1,i2,i3)**2)*vss2(i1,i2,i3,kd)+(rxx22(i1,i2,i3))*vr2(i1,i2,i3,kd)+(sxx22(i1,i2,i3))*vs2(i1,i2,i3,kd)
    vyy22(i1,i2,i3,kd)=(ry(i1,i2,i3)**2)*vrr2(i1,i2,i3,kd)+2.*(ry(i1,i2,i3)*sy(i1,i2,i3))*vrs2(i1,i2,i3,kd)+(sy(i1,i2,i3)**2)*vss2(i1,i2,i3,kd)+(ryy22(i1,i2,i3))*vr2(i1,i2,i3,kd)+(syy22(i1,i2,i3))*vs2(i1,i2,i3,kd)
    vxy22(i1,i2,i3,kd)=rx(i1,i2,i3)*ry(i1,i2,i3)*vrr2(i1,i2,i3,kd)+(rx(i1,i2,i3)*sy(i1,i2,i3)+ry(i1,i2,i3)*sx(i1,i2,i3))*vrs2(i1,i2,i3,kd)+sx(i1,i2,i3)*sy(i1,i2,i3)*vss2(i1,i2,i3,kd)+rxy22(i1,i2,i3)*vr2(i1,i2,i3,kd)+sxy22(i1,i2,i3)*vs2(i1,i2,i3,kd)
    vxz22(i1,i2,i3,kd)=0
    vyz22(i1,i2,i3,kd)=0
    vzz22(i1,i2,i3,kd)=0
    vlaplacian22(i1,i2,i3,kd)=(rx(i1,i2,i3)**2+ry(i1,i2,i3)**2)*vrr2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3)+ ry(i1,i2,i3)*sy(i1,i2,i3))*vrs2(i1,i2,i3,kd)+(sx(i1,i2,i3)**2+sy(i1,i2,i3)**2)*vss2(i1,i2,i3,kd)+(rxx22(i1,i2,i3)+ryy22(i1,i2,i3))*vr2(i1,i2,i3,kd)+(sxx22(i1,i2,i3)+syy22(i1,i2,i3))*vs2(i1,i2,i3,kd)
    vxx23(i1,i2,i3,kd)=rx(i1,i2,i3)**2*vrr2(i1,i2,i3,kd)+sx(i1,i2,i3)**2*vss2(i1,i2,i3,kd)+tx(i1,i2,i3)**2*vtt2(i1,i2,i3,kd)+2.*rx(i1,i2,i3)*sx(i1,i2,i3)*vrs2(i1,i2,i3,kd)+2.*rx(i1,i2,i3)*tx(i1,i2,i3)*vrt2(i1,i2,i3,kd)+2.*sx(i1,i2,i3)*tx(i1,i2,i3)*vst2(i1,i2,i3,kd)+rxx23(i1,i2,i3)*vr2(i1,i2,i3,kd)+sxx23(i1,i2,i3)*vs2(i1,i2,i3,kd)+txx23(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vyy23(i1,i2,i3,kd)=ry(i1,i2,i3)**2*vrr2(i1,i2,i3,kd)+sy(i1,i2,i3)**2*vss2(i1,i2,i3,kd)+ty(i1,i2,i3)**2*vtt2(i1,i2,i3,kd)+2.*ry(i1,i2,i3)*sy(i1,i2,i3)*vrs2(i1,i2,i3,kd)+2.*ry(i1,i2,i3)*ty(i1,i2,i3)*vrt2(i1,i2,i3,kd)+2.*sy(i1,i2,i3)*ty(i1,i2,i3)*vst2(i1,i2,i3,kd)+ryy23(i1,i2,i3)*vr2(i1,i2,i3,kd)+syy23(i1,i2,i3)*vs2(i1,i2,i3,kd)+tyy23(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vzz23(i1,i2,i3,kd)=rz(i1,i2,i3)**2*vrr2(i1,i2,i3,kd)+sz(i1,i2,i3)**2*vss2(i1,i2,i3,kd)+tz(i1,i2,i3)**2*vtt2(i1,i2,i3,kd)+2.*rz(i1,i2,i3)*sz(i1,i2,i3)*vrs2(i1,i2,i3,kd)+2.*rz(i1,i2,i3)*tz(i1,i2,i3)*vrt2(i1,i2,i3,kd)+2.*sz(i1,i2,i3)*tz(i1,i2,i3)*vst2(i1,i2,i3,kd)+rzz23(i1,i2,i3)*vr2(i1,i2,i3,kd)+szz23(i1,i2,i3)*vs2(i1,i2,i3,kd)+tzz23(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vxy23(i1,i2,i3,kd)=rx(i1,i2,i3)*ry(i1,i2,i3)*vrr2(i1,i2,i3,kd)+sx(i1,i2,i3)*sy(i1,i2,i3)*vss2(i1,i2,i3,kd)+tx(i1,i2,i3)*ty(i1,i2,i3)*vtt2(i1,i2,i3,kd)+(rx(i1,i2,i3)*sy(i1,i2,i3)+ry(i1,i2,i3)*sx(i1,i2,i3))*vrs2(i1,i2,i3,kd)+(rx(i1,i2,i3)*ty(i1,i2,i3)+ry(i1,i2,i3)*tx(i1,i2,i3))*vrt2(i1,i2,i3,kd)+(sx(i1,i2,i3)*ty(i1,i2,i3)+sy(i1,i2,i3)*tx(i1,i2,i3))*vst2(i1,i2,i3,kd)+rxy23(i1,i2,i3)*vr2(i1,i2,i3,kd)+sxy23(i1,i2,i3)*vs2(i1,i2,i3,kd)+txy23(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vxz23(i1,i2,i3,kd)=rx(i1,i2,i3)*rz(i1,i2,i3)*vrr2(i1,i2,i3,kd)+sx(i1,i2,i3)*sz(i1,i2,i3)*vss2(i1,i2,i3,kd)+tx(i1,i2,i3)*tz(i1,i2,i3)*vtt2(i1,i2,i3,kd)+(rx(i1,i2,i3)*sz(i1,i2,i3)+rz(i1,i2,i3)*sx(i1,i2,i3))*vrs2(i1,i2,i3,kd)+(rx(i1,i2,i3)*tz(i1,i2,i3)+rz(i1,i2,i3)*tx(i1,i2,i3))*vrt2(i1,i2,i3,kd)+(sx(i1,i2,i3)*tz(i1,i2,i3)+sz(i1,i2,i3)*tx(i1,i2,i3))*vst2(i1,i2,i3,kd)+rxz23(i1,i2,i3)*vr2(i1,i2,i3,kd)+sxz23(i1,i2,i3)*vs2(i1,i2,i3,kd)+txz23(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vyz23(i1,i2,i3,kd)=ry(i1,i2,i3)*rz(i1,i2,i3)*vrr2(i1,i2,i3,kd)+sy(i1,i2,i3)*sz(i1,i2,i3)*vss2(i1,i2,i3,kd)+ty(i1,i2,i3)*tz(i1,i2,i3)*vtt2(i1,i2,i3,kd)+(ry(i1,i2,i3)*sz(i1,i2,i3)+rz(i1,i2,i3)*sy(i1,i2,i3))*vrs2(i1,i2,i3,kd)+(ry(i1,i2,i3)*tz(i1,i2,i3)+rz(i1,i2,i3)*ty(i1,i2,i3))*vrt2(i1,i2,i3,kd)+(sy(i1,i2,i3)*tz(i1,i2,i3)+sz(i1,i2,i3)*ty(i1,i2,i3))*vst2(i1,i2,i3,kd)+ryz23(i1,i2,i3)*vr2(i1,i2,i3,kd)+syz23(i1,i2,i3)*vs2(i1,i2,i3,kd)+tyz23(i1,i2,i3)*vt2(i1,i2,i3,kd)
    vlaplacian23(i1,i2,i3,kd)=(rx(i1,i2,i3)**2+ry(i1,i2,i3)**2+rz(i1,i2,i3)**2)*vrr2(i1,i2,i3,kd)+(sx(i1,i2,i3)**2+sy(i1,i2,i3)**2+sz(i1,i2,i3)**2)*vss2(i1,i2,i3,kd)+(tx(i1,i2,i3)**2+ty(i1,i2,i3)**2+tz(i1,i2,i3)**2)*vtt2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*sx(i1,i2,i3)+ ry(i1,i2,i3)*sy(i1,i2,i3)+rz(i1,i2,i3)*sz(i1,i2,i3))*vrs2(i1,i2,i3,kd)+2.*(rx(i1,i2,i3)*tx(i1,i2,i3)+ ry(i1,i2,i3)*ty(i1,i2,i3)+rz(i1,i2,i3)*tz(i1,i2,i3))*vrt2(i1,i2,i3,kd)+2.*(sx(i1,i2,i3)*tx(i1,i2,i3)+ sy(i1,i2,i3)*ty(i1,i2,i3)+sz(i1,i2,i3)*tz(i1,i2,i3))*vst2(i1,i2,i3,kd)+(rxx23(i1,i2,i3)+ryy23(i1,i2,i3)+rzz23(i1,i2,i3))*vr2(i1,i2,i3,kd)+(sxx23(i1,i2,i3)+syy23(i1,i2,i3)+szz23(i1,i2,i3))*vs2(i1,i2,i3,kd)+(txx23(i1,i2,i3)+tyy23(i1,i2,i3)+tzz23(i1,i2,i3))*vt2(i1,i2,i3,kd)
  !============================================================================================
  ! Define derivatives for a rectangular grid
  !
  !============================================================================================
    vx23r(i1,i2,i3,kd)=(v(i1+1,i2,i3,kd)-v(i1-1,i2,i3,kd))*h12(0)
    vy23r(i1,i2,i3,kd)=(v(i1,i2+1,i3,kd)-v(i1,i2-1,i3,kd))*h12(1)
    vz23r(i1,i2,i3,kd)=(v(i1,i2,i3+1,kd)-v(i1,i2,i3-1,kd))*h12(2)
    vxx23r(i1,i2,i3,kd)=(-2.*v(i1,i2,i3,kd)+(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd)) )*h22(0)
    vyy23r(i1,i2,i3,kd)=(-2.*v(i1,i2,i3,kd)+(v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd)) )*h22(1)
    vxy23r(i1,i2,i3,kd)=(vx23r(i1,i2+1,i3,kd)-vx23r(i1,i2-1,i3,kd))*h12(1)
    vzz23r(i1,i2,i3,kd)=(-2.*v(i1,i2,i3,kd)+(v(i1,i2,i3+1,kd)+v(i1,i2,i3-1,kd)) )*h22(2)
    vxz23r(i1,i2,i3,kd)=(vx23r(i1,i2,i3+1,kd)-vx23r(i1,i2,i3-1,kd))*h12(2)
    vyz23r(i1,i2,i3,kd)=(vy23r(i1,i2,i3+1,kd)-vy23r(i1,i2,i3-1,kd))*h12(2)
    vx21r(i1,i2,i3,kd)= vx23r(i1,i2,i3,kd)
    vy21r(i1,i2,i3,kd)= vy23r(i1,i2,i3,kd)
    vz21r(i1,i2,i3,kd)= vz23r(i1,i2,i3,kd)
    vxx21r(i1,i2,i3,kd)= vxx23r(i1,i2,i3,kd)
    vyy21r(i1,i2,i3,kd)= vyy23r(i1,i2,i3,kd)
    vzz21r(i1,i2,i3,kd)= vzz23r(i1,i2,i3,kd)
    vxy21r(i1,i2,i3,kd)= vxy23r(i1,i2,i3,kd)
    vxz21r(i1,i2,i3,kd)= vxz23r(i1,i2,i3,kd)
    vyz21r(i1,i2,i3,kd)= vyz23r(i1,i2,i3,kd)
    vlaplacian21r(i1,i2,i3,kd)=vxx23r(i1,i2,i3,kd)
    vx22r(i1,i2,i3,kd)= vx23r(i1,i2,i3,kd)
    vy22r(i1,i2,i3,kd)= vy23r(i1,i2,i3,kd)
    vz22r(i1,i2,i3,kd)= vz23r(i1,i2,i3,kd)
    vxx22r(i1,i2,i3,kd)= vxx23r(i1,i2,i3,kd)
    vyy22r(i1,i2,i3,kd)= vyy23r(i1,i2,i3,kd)
    vzz22r(i1,i2,i3,kd)= vzz23r(i1,i2,i3,kd)
    vxy22r(i1,i2,i3,kd)= vxy23r(i1,i2,i3,kd)
    vxz22r(i1,i2,i3,kd)= vxz23r(i1,i2,i3,kd)
    vyz22r(i1,i2,i3,kd)= vyz23r(i1,i2,i3,kd)
    vlaplacian22r(i1,i2,i3,kd)=vxx23r(i1,i2,i3,kd)+vyy23r(i1,i2,i3,kd)
    vlaplacian23r(i1,i2,i3,kd)=vxx23r(i1,i2,i3,kd)+vyy23r(i1,i2,i3,kd)+vzz23r(i1,i2,i3,kd)
    vxxx22r(i1,i2,i3,kd)=(-2.*(v(i1+1,i2,i3,kd)-v(i1-1,i2,i3,kd))+(v(i1+2,i2,i3,kd)-v(i1-2,i2,i3,kd)) )*h22(0)*h12(0)
    vyyy22r(i1,i2,i3,kd)=(-2.*(v(i1,i2+1,i3,kd)-v(i1,i2-1,i3,kd))+(v(i1,i2+2,i3,kd)-v(i1,i2-2,i3,kd)) )*h22(1)*h12(1)
    vxxy22r(i1,i2,i3,kd)=( vxx22r(i1,i2+1,i3,kd)-vxx22r(i1,i2-1,i3,kd))/(2.*dx(1))
    vxyy22r(i1,i2,i3,kd)=( vyy22r(i1+1,i2,i3,kd)-vyy22r(i1-1,i2,i3,kd))/(2.*dx(0))
    vxxxx22r(i1,i2,i3,kd)=(6.*v(i1,i2,i3,kd)-4.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd))+(v(i1+2,i2,i3,kd)+v(i1-2,i2,i3,kd)) )/(dx(0)**4)
    vyyyy22r(i1,i2,i3,kd)=(6.*v(i1,i2,i3,kd)-4.*(v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd))+(v(i1,i2+2,i3,kd)+v(i1,i2-2,i3,kd)) )/(dx(1)**4)
    vxxyy22r(i1,i2,i3,kd)=( 4.*v(i1,i2,i3,kd)     -2.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd)+v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd))   +   (v(i1+1,i2+1,i3,kd)+v(i1-1,i2+1,i3,kd)+v(i1+1,i2-1,i3,kd)+v(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)
  ! 2D laplacian squared = v.xxxx + 2 v.xxyy + v.yyyy
    vLapSq22r(i1,i2,i3,kd)= ( 6.*v(i1,i2,i3,kd)   - 4.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd))    +(v(i1+2,i2,i3,kd)+v(i1-2,i2,i3,kd)) )/(dx(0)**4) +( 6.*v(i1,i2,i3,kd)    -4.*(v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd))    +(v(i1,i2+2,i3,kd)+v(i1,i2-2,i3,kd)) )/(dx(1)**4)  +( 8.*v(i1,i2,i3,kd)     -4.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd)+v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd))   +2.*(v(i1+1,i2+1,i3,kd)+v(i1-1,i2+1,i3,kd)+v(i1+1,i2-1,i3,kd)+v(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)
    vxxx23r(i1,i2,i3,kd)=(-2.*(v(i1+1,i2,i3,kd)-v(i1-1,i2,i3,kd))+(v(i1+2,i2,i3,kd)-v(i1-2,i2,i3,kd)) )*h22(0)*h12(0)
    vyyy23r(i1,i2,i3,kd)=(-2.*(v(i1,i2+1,i3,kd)-v(i1,i2-1,i3,kd))+(v(i1,i2+2,i3,kd)-v(i1,i2-2,i3,kd)) )*h22(1)*h12(1)
    vzzz23r(i1,i2,i3,kd)=(-2.*(v(i1,i2,i3+1,kd)-v(i1,i2,i3-1,kd))+(v(i1,i2,i3+2,kd)-v(i1,i2,i3-2,kd)) )*h22(1)*h12(2)
    vxxy23r(i1,i2,i3,kd)=( vxx22r(i1,i2+1,i3,kd)-vxx22r(i1,i2-1,i3,kd))/(2.*dx(1))
    vxyy23r(i1,i2,i3,kd)=( vyy22r(i1+1,i2,i3,kd)-vyy22r(i1-1,i2,i3,kd))/(2.*dx(0))
    vxxz23r(i1,i2,i3,kd)=( vxx22r(i1,i2,i3+1,kd)-vxx22r(i1,i2,i3-1,kd))/(2.*dx(2))
    vyyz23r(i1,i2,i3,kd)=( vyy22r(i1,i2,i3+1,kd)-vyy22r(i1,i2,i3-1,kd))/(2.*dx(2))
    vxzz23r(i1,i2,i3,kd)=( vzz22r(i1+1,i2,i3,kd)-vzz22r(i1-1,i2,i3,kd))/(2.*dx(0))
    vyzz23r(i1,i2,i3,kd)=( vzz22r(i1,i2+1,i3,kd)-vzz22r(i1,i2-1,i3,kd))/(2.*dx(1))
    vxxxx23r(i1,i2,i3,kd)=(6.*v(i1,i2,i3,kd)-4.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd))+(v(i1+2,i2,i3,kd)+v(i1-2,i2,i3,kd)) )/(dx(0)**4)
    vyyyy23r(i1,i2,i3,kd)=(6.*v(i1,i2,i3,kd)-4.*(v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd))+(v(i1,i2+2,i3,kd)+v(i1,i2-2,i3,kd)) )/(dx(1)**4)
    vzzzz23r(i1,i2,i3,kd)=(6.*v(i1,i2,i3,kd)-4.*(v(i1,i2,i3+1,kd)+v(i1,i2,i3-1,kd))+(v(i1,i2,i3+2,kd)+v(i1,i2,i3-2,kd)) )/(dx(2)**4)
    vxxyy23r(i1,i2,i3,kd)=( 4.*v(i1,i2,i3,kd)     -2.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd)+v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd))   +   (v(i1+1,i2+1,i3,kd)+v(i1-1,i2+1,i3,kd)+v(i1+1,i2-1,i3,kd)+v(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)
    vxxzz23r(i1,i2,i3,kd)=( 4.*v(i1,i2,i3,kd)     -2.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd)+v(i1,i2,i3+1,kd)+v(i1,i2,i3-1,kd))   +   (v(i1+1,i2,i3+1,kd)+v(i1-1,i2,i3+1,kd)+v(i1+1,i2,i3-1,kd)+v(i1-1,i2,i3-1,kd)) )/(dx(0)**2*dx(2)**2)
    vyyzz23r(i1,i2,i3,kd)=( 4.*v(i1,i2,i3,kd)     -2.*(v(i1,i2+1,i3,kd)  +v(i1,i2-1,i3,kd)+  v(i1,i2  ,i3+1,kd)+v(i1,i2  ,i3-1,kd))   +   (v(i1,i2+1,i3+1,kd)+v(i1,i2-1,i3+1,kd)+v(i1,i2+1,i3-1,kd)+v(i1,i2-1,i3-1,kd)) )/(dx(1)**2*dx(2)**2)
  ! 3D laplacian squared = v.xxxx + v.yyyy + v.zzzz + 2 (v.xxyy + v.xxzz + v.yyzz )
    vLapSq23r(i1,i2,i3,kd)= ( 6.*v(i1,i2,i3,kd)   - 4.*(v(i1+1,i2,i3,kd)+v(i1-1,i2,i3,kd))    +(v(i1+2,i2,i3,kd)+v(i1-2,i2,i3,kd)) )/(dx(0)**4) +( 6.*v(i1,i2,i3,kd)    -4.*(v(i1,i2+1,i3,kd)+v(i1,i2-1,i3,kd))    +(v(i1,i2+2,i3,kd)+v(i1,i2-2,i3,kd)) )/(dx(1)**4)  +( 6.*v(i1,i2,i3,kd)    -4.*(v(i1,i2,i3+1,kd)+v(i1,i2,i3-1,kd))    +(v(i1,i2,i3+2,kd)+v(i1,i2,i3-2,kd)) )/(dx(2)**4)  +( 8.*v(i1,i2,i3,kd)     -4.*(v(i1+1,i2,i3,kd)  +v(i1-1,i2,i3,kd)  +v(i1  ,i2+1,i3,kd)+v(i1  ,i2-1,i3,kd))   +2.*(v(i1+1,i2+1,i3,kd)+v(i1-1,i2+1,i3,kd)+v(i1+1,i2-1,i3,kd)+v(i1-1,i2-1,i3,kd)) )/(dx(0)**2*dx(1)**2)+( 8.*v(i1,i2,i3,kd)     -4.*(v(i1+1,i2,i3,kd)  +v(i1-1,i2,i3,kd)  +v(i1  ,i2,i3+1,kd)+v(i1  ,i2,i3-1,kd))   +2.*(v(i1+1,i2,i3+1,kd)+v(i1-1,i2,i3+1,kd)+v(i1+1,i2,i3-1,kd)+v(i1-1,i2,i3-1,kd)) )/(dx(0)**2*dx(2)**2)+( 8.*v(i1,i2,i3,kd)     -4.*(v(i1,i2+1,i3,kd)  +v(i1,i2-1,i3,kd)  +v(i1,i2  ,i3+1,kd)+v(i1,i2  ,i3-1,kd))   +2.*(v(i1,i2+1,i3+1,kd)+v(i1,i2-1,i3+1,kd)+v(i1,i2+1,i3-1,kd)+v(i1,i2-1,i3-1,kd)) )/(dx(1)**2*dx(2)**2)

! declare variables for getDerivatives macros
! ****** File written by makeGetDerivativesMacros.maple  ******
real ur
real urr
real urrr
real urrrr
real urrrrr
real urrrrrr
real us
real urs
real urrs
real urrrs
real urrrrs
real urrrrrs
real uss
real urss
real urrss
real urrrss
real urrrrss
real usss
real ursss
real urrsss
real urrrsss
real ussss
real urssss
real urrssss
real usssss
real ursssss
real ussssss
real ut
real urt
real urrt
real urrrt
real urrrrt
real urrrrrt
real ust
real urst
real urrst
real urrrst
real urrrrst
real usst
real ursst
real urrsst
real urrrsst
real ussst
real urssst
real urrssst
real usssst
real ursssst
real ussssst
real utt
real urtt
real urrtt
real urrrtt
real urrrrtt
real ustt
real urstt
real urrstt
real urrrstt
real usstt
real ursstt
real urrsstt
real ussstt
real urssstt
real usssstt
real uttt
real urttt
real urrttt
real urrrttt
real usttt
real ursttt
real urrsttt
real ussttt
real urssttt
real usssttt
real utttt
real urtttt
real urrtttt
real ustttt
real urstttt
real usstttt
real uttttt
real urttttt
real usttttt
real utttttt
real rxr
real rxrr
real rxrrr
real rxrrrr
real rxrrrrr
real rxs
real rxrs
real rxrrs
real rxrrrs
real rxrrrrs
real rxss
real rxrss
real rxrrss
real rxrrrss
real rxsss
real rxrsss
real rxrrsss
real rxssss
real rxrssss
real rxsssss
real rxt
real rxrt
real rxrrt
real rxrrrt
real rxrrrrt
real rxst
real rxrst
real rxrrst
real rxrrrst
real rxsst
real rxrsst
real rxrrsst
real rxssst
real rxrssst
real rxsssst
real rxtt
real rxrtt
real rxrrtt
real rxrrrtt
real rxstt
real rxrstt
real rxrrstt
real rxsstt
real rxrsstt
real rxssstt
real rxttt
real rxrttt
real rxrrttt
real rxsttt
real rxrsttt
real rxssttt
real rxtttt
real rxrtttt
real rxstttt
real rxttttt
real ryr
real ryrr
real ryrrr
real ryrrrr
real ryrrrrr
real rys
real ryrs
real ryrrs
real ryrrrs
real ryrrrrs
real ryss
real ryrss
real ryrrss
real ryrrrss
real rysss
real ryrsss
real ryrrsss
real ryssss
real ryrssss
real rysssss
real ryt
real ryrt
real ryrrt
real ryrrrt
real ryrrrrt
real ryst
real ryrst
real ryrrst
real ryrrrst
real rysst
real ryrsst
real ryrrsst
real ryssst
real ryrssst
real rysssst
real rytt
real ryrtt
real ryrrtt
real ryrrrtt
real rystt
real ryrstt
real ryrrstt
real rysstt
real ryrsstt
real ryssstt
real ryttt
real ryrttt
real ryrrttt
real rysttt
real ryrsttt
real ryssttt
real rytttt
real ryrtttt
real rystttt
real ryttttt
real sxr
real sxrr
real sxrrr
real sxrrrr
real sxrrrrr
real sxs
real sxrs
real sxrrs
real sxrrrs
real sxrrrrs
real sxss
real sxrss
real sxrrss
real sxrrrss
real sxsss
real sxrsss
real sxrrsss
real sxssss
real sxrssss
real sxsssss
real sxt
real sxrt
real sxrrt
real sxrrrt
real sxrrrrt
real sxst
real sxrst
real sxrrst
real sxrrrst
real sxsst
real sxrsst
real sxrrsst
real sxssst
real sxrssst
real sxsssst
real sxtt
real sxrtt
real sxrrtt
real sxrrrtt
real sxstt
real sxrstt
real sxrrstt
real sxsstt
real sxrsstt
real sxssstt
real sxttt
real sxrttt
real sxrrttt
real sxsttt
real sxrsttt
real sxssttt
real sxtttt
real sxrtttt
real sxstttt
real sxttttt
real syr
real syrr
real syrrr
real syrrrr
real syrrrrr
real sys
real syrs
real syrrs
real syrrrs
real syrrrrs
real syss
real syrss
real syrrss
real syrrrss
real sysss
real syrsss
real syrrsss
real syssss
real syrssss
real sysssss
real syt
real syrt
real syrrt
real syrrrt
real syrrrrt
real syst
real syrst
real syrrst
real syrrrst
real sysst
real syrsst
real syrrsst
real syssst
real syrssst
real sysssst
real sytt
real syrtt
real syrrtt
real syrrrtt
real systt
real syrstt
real syrrstt
real sysstt
real syrsstt
real syssstt
real syttt
real syrttt
real syrrttt
real systtt
real syrsttt
real syssttt
real sytttt
real syrtttt
real systttt
real syttttt
real rzr
real rzrr
real rzrrr
real rzrrrr
real rzrrrrr
real rzs
real rzrs
real rzrrs
real rzrrrs
real rzrrrrs
real rzss
real rzrss
real rzrrss
real rzrrrss
real rzsss
real rzrsss
real rzrrsss
real rzssss
real rzrssss
real rzsssss
real rzt
real rzrt
real rzrrt
real rzrrrt
real rzrrrrt
real rzst
real rzrst
real rzrrst
real rzrrrst
real rzsst
real rzrsst
real rzrrsst
real rzssst
real rzrssst
real rzsssst
real rztt
real rzrtt
real rzrrtt
real rzrrrtt
real rzstt
real rzrstt
real rzrrstt
real rzsstt
real rzrsstt
real rzssstt
real rzttt
real rzrttt
real rzrrttt
real rzsttt
real rzrsttt
real rzssttt
real rztttt
real rzrtttt
real rzstttt
real rzttttt
real szr
real szrr
real szrrr
real szrrrr
real szrrrrr
real szs
real szrs
real szrrs
real szrrrs
real szrrrrs
real szss
real szrss
real szrrss
real szrrrss
real szsss
real szrsss
real szrrsss
real szssss
real szrssss
real szsssss
real szt
real szrt
real szrrt
real szrrrt
real szrrrrt
real szst
real szrst
real szrrst
real szrrrst
real szsst
real szrsst
real szrrsst
real szssst
real szrssst
real szsssst
real sztt
real szrtt
real szrrtt
real szrrrtt
real szstt
real szrstt
real szrrstt
real szsstt
real szrsstt
real szssstt
real szttt
real szrttt
real szrrttt
real szsttt
real szrsttt
real szssttt
real sztttt
real szrtttt
real szstttt
real szttttt
real txr
real txrr
real txrrr
real txrrrr
real txrrrrr
real txs
real txrs
real txrrs
real txrrrs
real txrrrrs
real txss
real txrss
real txrrss
real txrrrss
real txsss
real txrsss
real txrrsss
real txssss
real txrssss
real txsssss
real txt
real txrt
real txrrt
real txrrrt
real txrrrrt
real txst
real txrst
real txrrst
real txrrrst
real txsst
real txrsst
real txrrsst
real txssst
real txrssst
real txsssst
real txtt
real txrtt
real txrrtt
real txrrrtt
real txstt
real txrstt
real txrrstt
real txsstt
real txrsstt
real txssstt
real txttt
real txrttt
real txrrttt
real txsttt
real txrsttt
real txssttt
real txtttt
real txrtttt
real txstttt
real txttttt
real tyr
real tyrr
real tyrrr
real tyrrrr
real tyrrrrr
real tys
real tyrs
real tyrrs
real tyrrrs
real tyrrrrs
real tyss
real tyrss
real tyrrss
real tyrrrss
real tysss
real tyrsss
real tyrrsss
real tyssss
real tyrssss
real tysssss
real tyt
real tyrt
real tyrrt
real tyrrrt
real tyrrrrt
real tyst
real tyrst
real tyrrst
real tyrrrst
real tysst
real tyrsst
real tyrrsst
real tyssst
real tyrssst
real tysssst
real tytt
real tyrtt
real tyrrtt
real tyrrrtt
real tystt
real tyrstt
real tyrrstt
real tysstt
real tyrsstt
real tyssstt
real tyttt
real tyrttt
real tyrrttt
real tysttt
real tyrsttt
real tyssttt
real tytttt
real tyrtttt
real tystttt
real tyttttt
real tzr
real tzrr
real tzrrr
real tzrrrr
real tzrrrrr
real tzs
real tzrs
real tzrrs
real tzrrrs
real tzrrrrs
real tzss
real tzrss
real tzrrss
real tzrrrss
real tzsss
real tzrsss
real tzrrsss
real tzssss
real tzrssss
real tzsssss
real tzt
real tzrt
real tzrrt
real tzrrrt
real tzrrrrt
real tzst
real tzrst
real tzrrst
real tzrrrst
real tzsst
real tzrsst
real tzrrsst
real tzssst
real tzrssst
real tzsssst
real tztt
real tzrtt
real tzrrtt
real tzrrrtt
real tzstt
real tzrstt
real tzrrstt
real tzsstt
real tzrsstt
real tzssstt
real tzttt
real tzrttt
real tzrrttt
real tzsttt
real tzrsttt
real tzssttt
real tztttt
real tzrtttt
real tzstttt
real tzttttt
real rxi
real ryi
real sxi
real syi
real rzi
real szi
real txi
real tyi
real tzi
real rxx
real rxy
real rxz
real ryy
real ryz
real rzz
real sxx
real sxy
real sxz
real syy
real syz
real szz
real txx
real txy
real txz
real tyy
real tyz
real tzz
real rxxx
real rxxy
real rxyy
real rxxz
real rxyz
real rxzz
real ryyy
real ryyz
real ryzz
real rzzz
real sxxx
real sxxy
real sxyy
real sxxz
real sxyz
real sxzz
real syyy
real syyz
real syzz
real szzz
real txxx
real txxy
real txyy
real txxz
real txyz
real txzz
real tyyy
real tyyz
real tyzz
real tzzz
real rxxxx
real rxxxy
real rxxyy
real rxyyy
real rxxxz
real rxxyz
real rxyyz
real rxxzz
real rxyzz
real rxzzz
real ryyyy
real ryyyz
real ryyzz
real ryzzz
real rzzzz
real sxxxx
real sxxxy
real sxxyy
real sxyyy
real sxxxz
real sxxyz
real sxyyz
real sxxzz
real sxyzz
real sxzzz
real syyyy
real syyyz
real syyzz
real syzzz
real szzzz
real txxxx
real txxxy
real txxyy
real txyyy
real txxxz
real txxyz
real txyyz
real txxzz
real txyzz
real txzzz
real tyyyy
real tyyyz
real tyyzz
real tyzzz
real tzzzz
real rxxxxx
real rxxxxy
real rxxxyy
real rxxyyy
real rxyyyy
real rxxxxz
real rxxxyz
real rxxyyz
real rxyyyz
real rxxxzz
real rxxyzz
real rxyyzz
real rxxzzz
real rxyzzz
real rxzzzz
real ryyyyy
real ryyyyz
real ryyyzz
real ryyzzz
real ryzzzz
real rzzzzz
real sxxxxx
real sxxxxy
real sxxxyy
real sxxyyy
real sxyyyy
real sxxxxz
real sxxxyz
real sxxyyz
real sxyyyz
real sxxxzz
real sxxyzz
real sxyyzz
real sxxzzz
real sxyzzz
real sxzzzz
real syyyyy
real syyyyz
real syyyzz
real syyzzz
real syzzzz
real szzzzz
real txxxxx
real txxxxy
real txxxyy
real txxyyy
real txyyyy
real txxxxz
real txxxyz
real txxyyz
real txyyyz
real txxxzz
real txxyzz
real txyyzz
real txxzzz
real txyzzz
real txzzzz
real tyyyyy
real tyyyyz
real tyyyzz
real tyyzzz
real tyzzzz
real tzzzzz
real rxxxxxx
real rxxxxxy
real rxxxxyy
real rxxxyyy
real rxxyyyy
real rxyyyyy
real rxxxxxz
real rxxxxyz
real rxxxyyz
real rxxyyyz
real rxyyyyz
real rxxxxzz
real rxxxyzz
real rxxyyzz
real rxyyyzz
real rxxxzzz
real rxxyzzz
real rxyyzzz
real rxxzzzz
real rxyzzzz
real rxzzzzz
real ryyyyyy
real ryyyyyz
real ryyyyzz
real ryyyzzz
real ryyzzzz
real ryzzzzz
real rzzzzzz
real sxxxxxx
real sxxxxxy
real sxxxxyy
real sxxxyyy
real sxxyyyy
real sxyyyyy
real sxxxxxz
real sxxxxyz
real sxxxyyz
real sxxyyyz
real sxyyyyz
real sxxxxzz
real sxxxyzz
real sxxyyzz
real sxyyyzz
real sxxxzzz
real sxxyzzz
real sxyyzzz
real sxxzzzz
real sxyzzzz
real sxzzzzz
real syyyyyy
real syyyyyz
real syyyyzz
real syyyzzz
real syyzzzz
real syzzzzz
real szzzzzz
real txxxxxx
real txxxxxy
real txxxxyy
real txxxyyy
real txxyyyy
real txyyyyy
real txxxxxz
real txxxxyz
real txxxyyz
real txxyyyz
real txyyyyz
real txxxxzz
real txxxyzz
real txxyyzz
real txyyyzz
real txxxzzz
real txxyzzz
real txyyzzz
real txxzzzz
real txyzzzz
real txzzzzz
real tyyyyyy
real tyyyyyz
real tyyyyzz
real tyyyzzz
real tyyzzzz
real tyzzzzz
real tzzzzzz
real uxx
real uxxxx
real uxxxxxx
real uyy
real uxxyy
real uxxxxyy
real uyyyy
real uxxyyyy
real uyyyyyy
real uzz
real uxxzz
real uxxxxzz
real uyyzz
real uxxyyzz
real uyyyyzz
real uzzzz
real uxxzzzz
real uyyzzzz
real uzzzzzz

  real uxxx,uxxy,uxyy,uyyy,uxxz,uxzz,uzzz,uyyz,uyzz,uxyz

  ! 4th-order 1 sided derivative  extrap=(1 5 10 10 5 1)
    uxOneSided(i1,i2,i3,m)=-(10./3.)*u(i1,i2,i3,m)+6.*u(i1+is1,i2+is2,i3+is3,m)-2.*u(i1+2*is1,i2+2*is2,i3+2*is3,m)+(1./3.)*u(i1+3*is1,i2+3*is2,i3+3*is3,m)

  ! 2D laplacian squared = u.xxxx + 2 u.xxyy + u.yyyy
    lap2d2Pow2(i1,i2,i3,m)= ( 6.*u(i1,i2,i3,m)   - 4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m))    +(u(i1+2,i2,i3,m)+u(i1-2,i2,i3,m)) )/(dx(0)**4) +( 6.*u(i1,i2,i3,m)    -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))    +(u(i1,i2+2,i3,m)+u(i1,i2-2,i3,m)) )/(dx(1)**4)  +( 8.*u(i1,i2,i3,m)     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))   +2.*(u(i1+1,i2+1,i3,m)+u(i1-1,i2+1,i3,m)+u(i1+1,i2-1,i3,m)+u(i1-1,i2-1,i3,m)) )/( (dx(0)*dx(1))**2 )

  ! 3D laplacian squared = u.xxxx + u.yyyy + u.zzzz + 2 (u.xxyy + u.xxzz + u.yyzz )
    lap3d2Pow2(i1,i2,i3,m)= ( 6.*u(i1,i2,i3,m)   - 4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m))    +(u(i1+2,i2,i3,m)+u(i1-2,i2,i3,m)) )/(dx(0)**4) +(  +6.*u(i1,i2,i3,m)    -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))    +(u(i1,i2+2,i3,m)+u(i1,i2-2,i3,m)) )/(dx(1)**4)+(  +6.*u(i1,i2,i3,m)    -4.*(u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))    +(u(i1,i2,i3+2,m)+u(i1,i2,i3-2,m)) )/(dx(2)**4)+(8.*u(i1,i2,i3,m)     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))   +2.*(u(i1+1,i2+1,i3,m)+u(i1-1,i2+1,i3,m)+u(i1+1,i2-1,i3,m)+u(i1-1,i2-1,i3,m)) )/( (dx(0)*dx(1))**2 ) +(8.*u(i1,i2,i3,m)     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))   +2.*(u(i1+1,i2,i3+1,m)+u(i1-1,i2,i3+1,m)+u(i1+1,i2,i3-1,m)+u(i1-1,i2,i3-1,m)) )/( (dx(0)*dx(2))**2 ) +(8.*u(i1,i2,i3,m)     -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m)+u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))   +2.*(u(i1,i2+1,i3+1,m)+u(i1,i2-1,i3+1,m)+u(i1,i2+1,i3-1,m)+u(i1,i2-1,i3-1,m)) )/( (dx(1)*dx(2))**2 ) 
  

  ! ! Here is the the generic boundary condition forcing array. It uses the bcOffset(side,axis) values as an
  ! ! an offset from the bcf0 array to access the bcf10, bcf01, bcf11, ... arrays
  ! bcf(side,axis,i1,i2,i3,m) = bcf0(bcOffset(side,axis) + !     (i1-dim(0,0,side,axis)+(dim(1,0,side,axis)-dim(0,0,side,axis)+1)* !     (i2-dim(0,1,side,axis)+(dim(1,1,side,axis)-dim(0,1,side,axis)+1)* !     (i3-dim(0,2,side,axis)+(dim(1,2,side,axis)-dim(0,2,side,axis)+1)*(m)))))

  ! mixedRHS(component,side,axis,grid) = bcData(component+numberOfComponents*(0),side,axis,grid)
  ! mixedCoeff(component,side,axis,grid) = bcData(component+numberOfComponents*(1),side,axis,grid)
  ! mixedNormalCoeff(component,side,axis,grid) =  bcData(component+numberOfComponents*(2),side,axis,grid)

  !.......statement functions for jacobian
  rx(i1,i2,i3)=rsxy(i1,i2,i3,0,0)
  ry(i1,i2,i3)=rsxy(i1,i2,i3,0,1)
  rz(i1,i2,i3)=rsxy(i1,i2,i3,0,2)
  sx(i1,i2,i3)=rsxy(i1,i2,i3,1,0)
  sy(i1,i2,i3)=rsxy(i1,i2,i3,1,1)
  sz(i1,i2,i3)=rsxy(i1,i2,i3,1,2)
  tx(i1,i2,i3)=rsxy(i1,i2,i3,2,0)
  ty(i1,i2,i3)=rsxy(i1,i2,i3,2,1)
  tz(i1,i2,i3)=rsxy(i1,i2,i3,2,2)


  !............... end statement functions

    checkCoeff=0 ! set to 1 to check coefficients in CBCs using discrete delta approach

    ierr=0


    uc                              = ipar( 0)
    numberOfComponents              = ipar( 1)
    grid                            = ipar( 2)
    gridType                        = ipar( 3)
    orderOfAccuracy                 = ipar( 4)
    gridIsImplicit                  = ipar( 5)
    twilightZone                    = ipar( 6)
    numberOfProcessors              = ipar( 7)
    debug                           = ipar( 8)
    myid                            = ipar( 9)
    assignKnownSolutionAtBoundaries = ipar(10)
    knownSolutionOption             = ipar(11)
    addForcing                      = ipar(12)
    forcingOption                   = ipar(13)
    useUpwindDissipation            = ipar(14)
    numGhost                        = ipar(15)  
    assignBCForImplicitForImplicit  = ipar(16)
    bcApproach                      = ipar(17)
    numberOfFrequencies             = ipar(18)
  
    t         = rpar( 0)
    dt        = rpar( 1)
    dx(0)     = rpar( 2)
    dx(1)     = rpar( 3)
    dx(2)     = rpar( 4)
    dr(0)     = rpar( 5)
    dr(1)     = rpar( 6)
    dr(2)     = rpar( 7)
    ep        = rpar( 8) ! pointer for exact solution -- new : 110311 
    REAL_MIN  = rpar( 9)
    c         = rpar(10)

    c2 = c**2
    c4 = c**4
    c6 = c**6
    c8 = c**8
    twoPi = atan2(1.,1.)*8.; ! atan2(1,1)=pi/4

  ! numberOfGhostPoints=orderOfAccuracy/2
    numberOfGhostPoints=numGhost ! now passed in 

    if( t.le.dt .and. (.false. .or. debug.gt.1) )then

        write(*,'(" bcOptWave: grid=",i4," gridType=",i2," orderOfAccuracy=",i2," uc=",i3," twilightZone=",i2)') grid,gridType,orderOfAccuracy,uc,twilightZone
        write(*,'("  addForcing=",i4," forcingOption=",i4," assignKnownSolutionAtBoundaries=",i4)') addForcing, forcingOption, assignKnownSolutionAtBoundaries
        write(*,'("  t=",e10.2," dt=",e10.2," knownSolutionOption=",i4," REAL_MIN=",e10.2)') t,dt,knownSolutionOption,REAL_MIN
        write(*,'("  useUpwindDissipation=",i2," numGhost=",i2)') useUpwindDissipation,numGhost
        write(*,'("  assignBCForImplicitForImplicit=",i4," bcApproach=",i4)') assignBCForImplicitForImplicit,bcApproach
        write(*,'("  bc=",6i4)') ((boundaryCondition(side,axis),side=0,1),axis=0,2)
    end if
    
  ! if( bcApproach.eq.useCompatibilityBoundaryConditions )then
  !   write(*,'("bcOptWave: ERROR: useCompatibilityBoundaryConditions not implemented yet.")') 
  !   stop 1010
  ! end if

    if( bcApproach.eq.useLocalCompatibilityBoundaryConditions )then
        write(*,'("bcOptWave: ERROR: useLocalCompatibilityBoundaryConditions not implemented yet.")') 
        stop 2020    
    end if

    if( .true. ) then
        if( knownSolutionOption.eq.planeWave )then

      ! get parameter values from the C++ data-base
              ok=getReal(pdb,'ampPlaneWave',ampPlaneWave) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find ampPlaneWave")') 
                  stop 1133
              end if
              ok=getReal(pdb,'kxPlaneWave',kxPlaneWave) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kxPlaneWave")') 
                  stop 1133
              end if
              ok=getReal(pdb,'kyPlaneWave',kyPlaneWave) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kyPlaneWave")') 
                  stop 1133
              end if
              ok=getReal(pdb,'kzPlaneWave',kzPlaneWave) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kzPlaneWave")') 
                  stop 1133
              end if
              ok=getReal(pdb,'omegaPlaneWave',omegaPlaneWave) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find omegaPlaneWave")') 
                  stop 1133
              end if

            if(  t.le.dt .and. debug.gt.1  )then
                write(*,'(" bcOptWave:  knownSolutionOption=planeWave: ampPlaneWave=",e10.2," kxPlaneWave=",e10.2," kyPlaneWave=",e10.2)') ampPlaneWave,kxPlaneWave,kyPlaneWave
            end if 
                
        else if( knownSolutionOption.eq.gaussianPlaneWave )then

      ! Get the parameters in the Gaussian plane wave (Set in userDefinedKnownSolution)
              ok=getReal(pdb,'kxGPW',kxGPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kxGPW")') 
                  stop 1133
              end if
              ok=getReal(pdb,'kyGPW',kyGPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kyGPW")') 
                  stop 1133
              end if
              ok=getReal(pdb,'kzGPW',kzGPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kzGPW")') 
                  stop 1133
              end if
              ok=getReal(pdb,'x0GPW',x0GPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find x0GPW")') 
                  stop 1133
              end if
              ok=getReal(pdb,'y0GPW',y0GPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find y0GPW")') 
                  stop 1133
              end if
              ok=getReal(pdb,'z0GPW',z0GPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find z0GPW")') 
                  stop 1133
              end if
              ok=getReal(pdb,'k0GPW',k0GPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find k0GPW")') 
                  stop 1133
              end if
              ok=getReal(pdb,'betaGPW',betaGPW) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find betaGPW")') 
                  stop 1133
              end if
            if(  t.le.dt .and. debug.ge.0  )then
                write(*,'(" bcOptWave:  knownSolutionOption=gaussianPlaneWave: kx,ky,kz=",3(1pe10.2)," x0,y0,z0=",3(1pe10.2)," k0,beta=",2(1pe10.2))') kxGPW,kyGPW,kzGPW,x0GPW,y0GPW,z0GPW,k0GPW,betaGPW
            end if           

        else if( knownSolutionOption.eq.boxHelmholtz )then

      ! get parameter values from the C++ data-base
              ok=getReal(pdb,'kxBoxHelmholtz',kxBoxHelmholtz) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kxBoxHelmholtz")') 
                  stop 1133
              end if
              ok=getReal(pdb,'kyBoxHelmholtz',kyBoxHelmholtz) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kyBoxHelmholtz")') 
                  stop 1133
              end if
              ok=getReal(pdb,'kzBoxHelmholtz',kzBoxHelmholtz) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find kzBoxHelmholtz")') 
                  stop 1133
              end if
              ok=getReal(pdb,'omegaBoxHelmholtz',omegaBoxHelmholtz) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find omegaBoxHelmholtz")') 
                  stop 1133
              end if
            coswt = cos(omegaBoxHelmholtz*t)
            assignKnownSolutionAtBoundaries=1  ! for inhomogeneous BCs
            if(  t.le.dt .and. debug.ge.1   )then
                
                write(*,'(" bcOptWave:  assignKnownSolutionAtBoundaries=",i4)') assignKnownSolutionAtBoundaries
                write(*,'(" bcOptWave:  numberOfFrequencies=",i4)') numberOfFrequencies
                write(*,'(" bcOptWave:  frequencyArray=",10(1pe12.4,1x))') (frequencyArray(freq),freq=0,numberOfFrequencies-1)
                write(*,'(" bcOptWave:  knownSolutionOption=boxHelmholtz: kx,ky,kz,omega=",4e10.2)') kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz
            end if

        else if( knownSolutionOption.eq.polyPeriodic )then

      ! get parameter values from the C++ data-base
              ok=getReal(pdb,'omegaPolyPeriodic',omegaPolyPeriodic) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find omegaPolyPeriodic")') 
                  stop 1133
              end if
              ok=getReal(pdb,'a0PolyPeriodic',a0PolyPeriodic) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find a0PolyPeriodic")') 
                  stop 1133
              end if
              ok=getReal(pdb,'a1PolyPeriodic',a1PolyPeriodic) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find a1PolyPeriodic")') 
                  stop 1133
              end if
              ok=getReal(pdb,'b1PolyPeriodic',b1PolyPeriodic) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find b1PolyPeriodic")') 
                  stop 1133
              end if
              ok=getReal(pdb,'c1PolyPeriodic',c1PolyPeriodic) 
              if( ok.eq.0 )then
                  write(*,'("*** bcOptWave:getReal:ERROR: unable to find c1PolyPeriodic")') 
                  stop 1133
              end if

            coswt = cos(omegaPolyPeriodic*t)
            if(  t.le.dt .and. debug.gt.1   )then
                write(*,'(" bcOptWave:  knownSolutionOption=polyPeriodic: a0,a1,b1,c1,omega=",5e10.2)') a0PolyPeriodic,a1PolyPeriodic,b1PolyPeriodic,c1PolyPeriodic,omegaPolyPeriodic
            end if


        else if( knownSolutionOption.ne.0 )then

            write(*,'("bcOptWave:ERROR: unknown knownSolutionOption=",i6)') knownSolutionOption
            stop 1111
        end if 

    end if
            
  ! TEST: 
  ! getRealParameter(omega)
  ! getRealParameter(cfl)
  ! write(*,'(" bcOptWave:  cfl=",e10.2)') cfl

    if( uc.lt.0 .or. uc.ge.numberOfComponents )then
        write(*,'("bcOptWave:ERROR: invalid uc=",i6," but numberOfComponents=",i3)')  uc,numberOfComponents
        stop 1111
    end if
        
    epsx=REAL_MIN*100.  ! for normal

    if( orderOfAccuracy.ne.2 .and. orderOfAccuracy.ne.4 .and. orderOfAccuracy.ne.6 .and. orderOfAccuracy.ne.8 )then
        write(*,'("bcOptWave:ERROR: orderOfAccuracy is not 2, 4 or 6, orderOfAccuracy=",i4)') orderOfAccuracy
        stop 1111
    end if

  ! Now passed in: 
  ! numGhost=orderOfAccuracy/2

    if( assignBCForImplicitForImplicit.eq.1 )then

    ! -------- IMPLICIT BoundaryConditions --------

    ! write(*,'("bcOptWave: fill BCs into RHS for direct Helmholtz solver")')
    ! write(*,'("FINISH ME")')
    ! stop 6789

          extra1a=numGhost
          extra1b=numGhost
          extra2a=numGhost
          extra2b=numGhost
          if( nd.eq.3 )then
              extra3a=numGhost
              extra3b=numGhost
          else
              extra3a=0
              extra3b=0
          end if
          if( boundaryCondition(0,0).lt.0 )then
              extra1a=max(0,extra1a) ! over-ride numGhost=-1 : assign ends in periodic directions (or internal parallel boundaries)
          else if( boundaryCondition(0,0).eq.0 )then
              extra1a=numGhost  ! include interpolation points since we assign ghost points outside these
          end if
     ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
          if( boundaryCondition(1,0).lt.0 )then
              extra1b=max(0,extra1b) ! over-ride numGhost=-1 : assign ends in periodic directions
          else if( boundaryCondition(1,0).eq.0 )then
              extra1b=numGhost
          end if
          if( boundaryCondition(0,1).lt.0 )then
              extra2a=max(0,extra2a) ! over-ride numGhost=-1 : assign ends in periodic directions (or internal parallel boundaries)
          else if( boundaryCondition(0,1).eq.0 )then
              extra2a=numGhost  ! include interpolation points since we assign ghost points outside these
          end if
     ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
          if( boundaryCondition(1,1).lt.0 )then
              extra2b=max(0,extra2b) ! over-ride numGhost=-1 : assign ends in periodic directions
          else if( boundaryCondition(1,1).eq.0 )then
              extra2b=numGhost
          end if
          if(  nd.eq.3 )then
            if( boundaryCondition(0,2).lt.0 )then
                extra3a=max(0,extra3a) ! over-ride numGhost=-1 : assign ends in periodic directions (or internal parallel boundaries)
            else if( boundaryCondition(0,2).eq.0 )then
                extra3a=numGhost  ! include interpolation points since we assign ghost points outside these
            end if
      ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
            if( boundaryCondition(1,2).lt.0 )then
                extra3b=max(0,extra3b) ! over-ride numGhost=-1 : assign ends in periodic directions
            else if( boundaryCondition(1,2).eq.0 )then
                extra3b=numGhost
            end if
          end if
          do axis=0,nd-1
          do side=0,1
              if( boundaryCondition(side,axis).gt.0 )then
         ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,boundaryCondition(side,axis)
                  n1a=gridIndexRange(0,0)
                  n1b=gridIndexRange(1,0)
                  n2a=gridIndexRange(0,1)
                  n2b=gridIndexRange(1,1)
                  n3a=gridIndexRange(0,2)
                  n3b=gridIndexRange(1,2)
                  if( axis.eq.0 )then
                      n1a=gridIndexRange(side,axis)
                      n1b=gridIndexRange(side,axis)
                  else if( axis.eq.1 )then
                      n2a=gridIndexRange(side,axis)
                      n2b=gridIndexRange(side,axis)
                  else
                      n3a=gridIndexRange(side,axis)
                      n3b=gridIndexRange(side,axis)
                  end if
                  nn1a=gridIndexRange(0,0)-extra1a
                  nn1b=gridIndexRange(1,0)+extra1b
                  nn2a=gridIndexRange(0,1)-extra2a
                  nn2b=gridIndexRange(1,1)+extra2b
                  nn3a=gridIndexRange(0,2)-extra3a
                  nn3b=gridIndexRange(1,2)+extra3b
                  if( axis.eq.0 )then
                      nn1a=gridIndexRange(side,axis)
                      nn1b=gridIndexRange(side,axis)
                  else if( axis.eq.1 )then
                      nn2a=gridIndexRange(side,axis)
                      nn2b=gridIndexRange(side,axis)
                  else
                      nn3a=gridIndexRange(side,axis)
                      nn3b=gridIndexRange(side,axis)
                  end if
                  is=1-2*side
                  is1=0
                  is2=0
                  is3=0
                  if( axis.eq.0 )then
                      is1=1-2*side
                  else if( axis.eq.1 )then
                      is2=1-2*side
                  else if( axis.eq.2 )then
                      is3=1-2*side
                  else
                      stop 5
                  end if
                  axisp1=mod(axis+1,nd)
                  axisp2=mod(axis+2,nd)
                  i3=n3a
                  if( debug.gt.7 )then
                      write(*,'(" bcOptWave: grid,side,axis=",3i3,", loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,n1a,n1b,n2a,n2b,n3a,n3b
                  end if
              end if ! if bc>0 
              assignTwilightZone=twilightZone

            if( boundaryCondition(side,axis) == dirichlet )then

                ff=0.
                  do i3=n3a,n3b
                  do i2=n2a,n2b
                  do i1=n1a,n1b
                    if( mask(i1,i2,i3).ne.0 )then

                            if( assignTwilightZone.eq.1 )then
                ! compute RHS from TZ
                                if( nd.eq.2 )then
                                    call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                else
                                    call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                end if
                                ff = ue
                            else if( assignKnownSolutionAtBoundaries.eq.1 )then
                ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                if( knownSolutionOption.eq.planeWave )then
                  ! --- evaluate the plane wave solution ---
                                    if( nd.eq.2 )then
                                        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                    else
                                        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                    end if 
                                else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                  ! Eval the Gaussian plane wave solution
                  !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                  !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                  !  
                                    if( nd.eq.2 )then
                                        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                    else
                                        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                    end if 
                                    ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                else if( knownSolutionOption.eq.boxHelmholtz ) then
                  ! --- evaluate the boxHelmholtz solution ---
                  ! For multi-freq we add up all the component frequencies
                                    ff = 0. 
                                    do freq=0,numberOfFrequencies-1
                    ! kx = kxBoxHelmholtz + twoPi*freq
                    ! ky = kyBoxHelmholtz + twoPi*freq
                    ! kz = kzBoxHelmholtz + twoPi*freq
                    ! coswt = cos( frequencyArray(freq)*t )
                        ! This macro is used in bcOptWave.bf90
                                                omega = frequencyArray(freq);
                                                kx = kxBoxHelmholtz*(freq*.5+1.)
                                                ky = kyBoxHelmholtz*(freq*.5+1.)
                                                kz = kzBoxHelmholtz*(freq*.5+1.)
                        ! kx = kxBoxHelmholtz + twoPi*freq.
                        ! ky = kyBoxHelmholtz + twoPi*freq.
                        ! kz = kzBoxHelmholtz + twoPi*freq.    
                                        coswt = cos( omega*t )
                                        if( nd.eq.2 )then
                                            ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                        else
                                            ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                        end if 
                                    end do
                                else if( knownSolutionOption.eq.polyPeriodic ) then
                  ! --- evaluate the polyPeriodic solution ---
                                    if( nd.eq.2 )then
                                        ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                    else
                                        ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                    end if 
                                else
                                    stop 9876
                                end if 
                            end if
            ! fill in boundary value: 
                        u(i1,i2,i3,uc)=ff

            ! -- Set ghost to zero (RHS to extrapolation conditions) ---
            ! Is this necessary ?
                        do ghost=1,numGhost
                            j1=i1-is1*ghost
                            j2=i2-is2*ghost
                            j3=i3-is3*ghost

                            u(j1,j2,j3,uc) = 0.

                        end do  

                    end if 
                  end do
                  end do
                  end do

            else if( boundaryCondition(side,axis) == exactBC )then

                write(*,*) "bcOpt: implicit BC for exactBc -- finish me"
                stop 4444


            else if( boundaryCondition(side,axis) == neumann )then

                if( gridType.eq.rectangular )then
          ! compute the outward normal (an1,an2,an3)
                    an1 = 0.
                    an2 = 0.
                    an3 = 0.
                    if( axis.eq.0 )then
                      an1=-is
                    else if( axis.eq.1 )then
                      an2=-is
                    else
                      an3=-is
                    end if
                end if        

        ! BC is a0*u + a1*u.n = 
                a0=0.
                a1=1.
                ff=0.
                  do i3=n3a,n3b
                  do i2=n2a,n2b
                  do i1=n1a,n1b
                    if( mask(i1,i2,i3).ne.0 )then

                        if( gridType.eq.curvilinear )then
              ! compute the outward normal (an1,an2,an3)
                                    an1 = rsxy(i1,i2,i3,axis,0)
                                    an2 = rsxy(i1,i2,i3,axis,1)
                                    if( nd.eq.2 )then
                                      aNormi = (-is)/sqrt(an1**2+an2**2)
                                      an1=an1*aNormi
                                      an2=an2*aNormi
                                    else
                                      an3 = rsxy(i1,i2,i3,axis,2)
                                      aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                      an1=an1*aNormi
                                      an2=an2*aNormi
                                      an3=an3*aNormi
                                    end if
                        end if            

                            if( assignTwilightZone.eq.1 )then
                ! compute RHS from TZ
                                if( nd.eq.2 )then
                                    call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                    call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
                                    call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
                                    ff = a0*ue + a1*( an1*uex + an2*uey )
                                else
                                    call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                    call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
                                    call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
                                    call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
                                    ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                end if
                            else if( assignKnownSolutionAtBoundaries.eq.1 )then
                ! -- we set inhomogeneous Neumann values for some known solutions 
                                if( knownSolutionOption.eq.planeWave )then
                  ! --- evaluate RHS for the plane wave solution ---
                                    if( nd.eq.2 )then
                                        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                        uex   = kxPlaneWave*cosPW
                                        uey   = kyPlaneWave*cosPw
                                        ff = a0*ue + a1*( an1*uex + an2*uey )
                                    else
                                        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                        uex   = kxPlaneWave*cosPW
                                        uey   = kyPlaneWave*cosPw
                                        uez   = kzPlaneWave*cosPw
                                        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                    end if 
                                else if( knownSolutionOption.eq.gaussianPlaneWave )then
                  ! Do nothing for Gaussian plane wave solution for now
                                    ff = 0.
                                else if( knownSolutionOption.eq.boxHelmholtz ) then
                  ! --- evaluate RHS the boxHelmholtz solution ---
                                    if( nd.eq.2 )then
                                        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
                                        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
                                        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz
                                        ff = a0*ue + a1*( an1*uex + an2*uey )
                                    else
                                        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
                                        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
                                        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
                                        uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz
                                        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                    end if
                                else if( knownSolutionOption.eq.polyPeriodic ) then
                  ! --- evaluate RHS the polyPeriodic solution ---
                                    if( nd.eq.2 )then
                                        ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) ) *coswt
                                        uex = (      a1PolyPeriodic                                                            ) *coswt
                                        uey = (                          b1PolyPeriodic                                        ) *coswt
                                        ff = a0*ue + a1*( an1*uex + an2*uey )
                                    else
                                        ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                        uex = (      a1PolyPeriodic                                                                                            ) *coswt
                                        uey = (                          b1PolyPeriodic                                                                        ) *coswt
                                        uez = (                                              c1PolyPeriodic                                                    ) *coswt
                                        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                    end if
                                else
                                    stop 9876
                                end if 
                            end if
            ! fill in first ghost:
                        j1=i1-is1
                        j2=i2-is2
                        j3=i3-is3
                        u(j1,j2,j3,uc)=ff

                    end if 
                  end do
                  end do
                  end do

            else if( boundaryCondition(side,axis) > 0 )then

                write(*,'("bcOptWave:fill RHS for direct Helmholtz solver, unexpected boundaryCondition=",i4)') boundaryCondition(side,axis)

                stop 6666
            end if

          end do ! end side
          end do ! end axis
        
    ! ---------------- RETURN ---------------
        return

    end if



  ! ---------------------------------------------------------------
  ! ----------- STAGE I : Assign Dirichlet Conditions -------------
  ! ---------------------------------------------------------------

  ! NOTE: the numGhost args are used in ghost loops
    extraForDirichlet=numGhost
    ff =0. ! default value 
      extra1a=extraForDirichlet
      extra1b=extraForDirichlet
      extra2a=extraForDirichlet
      extra2b=extraForDirichlet
      if( nd.eq.3 )then
          extra3a=extraForDirichlet
          extra3b=extraForDirichlet
      else
          extra3a=0
          extra3b=0
      end if
      if( boundaryCondition(0,0).lt.0 )then
          extra1a=max(0,extra1a) ! over-ride extraForDirichlet=-1 : assign ends in periodic directions (or internal parallel boundaries)
      else if( boundaryCondition(0,0).eq.0 )then
          extra1a=numGhost  ! include interpolation points since we assign ghost points outside these
      end if
   ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
      if( boundaryCondition(1,0).lt.0 )then
          extra1b=max(0,extra1b) ! over-ride extraForDirichlet=-1 : assign ends in periodic directions
      else if( boundaryCondition(1,0).eq.0 )then
          extra1b=numGhost
      end if
      if( boundaryCondition(0,1).lt.0 )then
          extra2a=max(0,extra2a) ! over-ride extraForDirichlet=-1 : assign ends in periodic directions (or internal parallel boundaries)
      else if( boundaryCondition(0,1).eq.0 )then
          extra2a=numGhost  ! include interpolation points since we assign ghost points outside these
      end if
   ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
      if( boundaryCondition(1,1).lt.0 )then
          extra2b=max(0,extra2b) ! over-ride extraForDirichlet=-1 : assign ends in periodic directions
      else if( boundaryCondition(1,1).eq.0 )then
          extra2b=numGhost
      end if
      if(  nd.eq.3 )then
        if( boundaryCondition(0,2).lt.0 )then
            extra3a=max(0,extra3a) ! over-ride extraForDirichlet=-1 : assign ends in periodic directions (or internal parallel boundaries)
        else if( boundaryCondition(0,2).eq.0 )then
            extra3a=numGhost  ! include interpolation points since we assign ghost points outside these
        end if
    ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
        if( boundaryCondition(1,2).lt.0 )then
            extra3b=max(0,extra3b) ! over-ride extraForDirichlet=-1 : assign ends in periodic directions
        else if( boundaryCondition(1,2).eq.0 )then
            extra3b=numGhost
        end if
      end if
      do axis=0,nd-1
      do side=0,1
          if( boundaryCondition(side,axis).gt.0 )then
       ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,boundaryCondition(side,axis)
              n1a=gridIndexRange(0,0)
              n1b=gridIndexRange(1,0)
              n2a=gridIndexRange(0,1)
              n2b=gridIndexRange(1,1)
              n3a=gridIndexRange(0,2)
              n3b=gridIndexRange(1,2)
              if( axis.eq.0 )then
                  n1a=gridIndexRange(side,axis)
                  n1b=gridIndexRange(side,axis)
              else if( axis.eq.1 )then
                  n2a=gridIndexRange(side,axis)
                  n2b=gridIndexRange(side,axis)
              else
                  n3a=gridIndexRange(side,axis)
                  n3b=gridIndexRange(side,axis)
              end if
              nn1a=gridIndexRange(0,0)-extra1a
              nn1b=gridIndexRange(1,0)+extra1b
              nn2a=gridIndexRange(0,1)-extra2a
              nn2b=gridIndexRange(1,1)+extra2b
              nn3a=gridIndexRange(0,2)-extra3a
              nn3b=gridIndexRange(1,2)+extra3b
              if( axis.eq.0 )then
                  nn1a=gridIndexRange(side,axis)
                  nn1b=gridIndexRange(side,axis)
              else if( axis.eq.1 )then
                  nn2a=gridIndexRange(side,axis)
                  nn2b=gridIndexRange(side,axis)
              else
                  nn3a=gridIndexRange(side,axis)
                  nn3b=gridIndexRange(side,axis)
              end if
              is=1-2*side
              is1=0
              is2=0
              is3=0
              if( axis.eq.0 )then
                  is1=1-2*side
              else if( axis.eq.1 )then
                  is2=1-2*side
              else if( axis.eq.2 )then
                  is3=1-2*side
              else
                  stop 5
              end if
              axisp1=mod(axis+1,nd)
              axisp2=mod(axis+2,nd)
              i3=n3a
              if( debug.gt.7 )then
                  write(*,'(" bcOptWave: grid,side,axis=",3i3,", loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,n1a,n1b,n2a,n2b,n3a,n3b
              end if
          end if ! if bc>0 
          assignTwilightZone=twilightZone

        if( boundaryCondition(side,axis).eq.exactBC )then

      ! Set the boundary and ghost with the exact solution
        ! assign extram points in the tangential directions
                extram = numGhost 
                    m1a=gridIndexRange(0,0)-extram
                    m1b=gridIndexRange(1,0)+extram
                    m2a=gridIndexRange(0,1)-extram
                    m2b=gridIndexRange(1,1)+extram
                    if( nd.eq.2 )then
                        m3a=gridIndexRange(0,2)
                        m3b=gridIndexRange(1,2)
                    else
                        m3a=gridIndexRange(0,2)-extram
                        m3b=gridIndexRange(1,2)+extram
                    end if
                    if( axis.eq.0 )then
                      m1a=gridIndexRange(side,axis)
                      m1b=gridIndexRange(side,axis)
                    else if( axis.eq.1 )then
                      m2a=gridIndexRange(side,axis)
                      m2b=gridIndexRange(side,axis)
                    else
                      m3a=gridIndexRange(side,axis)
                      m3b=gridIndexRange(side,axis)
                    end if
                ff=0.
                do i3=m3a,m3b
                do i2=m2a,m2b
                do i1=m1a,m1b
                    if( mask(i1,i2,i3).ne.0 )then
                        do ghost=0,numGhost
                            j1=i1-is1*ghost
                            j2=i2-is2*ghost
                            j3=i3-is3*ghost
                                if( assignTwilightZone.eq.1 )then
                  ! compute RHS from TZ
                                    if( nd.eq.2 )then
                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue )
                                    else
                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),xy(j1,j2,j3,2),t,uc,ue )
                                    end if
                                    ff = ue
                                else if( assignKnownSolutionAtBoundaries.eq.1 )then
                  ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                    if( knownSolutionOption.eq.planeWave )then
                    ! --- evaluate the plane wave solution ---
                                        if( nd.eq.2 )then
                                            ff = ampPlaneWave*sin( kxPlaneWave*xy(j1,j2,j3,0) + kyPlaneWave*xy(j1,j2,j3,1) - omegaPlaneWave*t )
                                        else
                                            ff = ampPlaneWave*sin( kxPlaneWave*xy(j1,j2,j3,0) + kyPlaneWave*xy(j1,j2,j3,1) + kzPlaneWave*xy(j1,j2,j3,2) - omegaPlaneWave*t )
                                        end if 
                                    else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                    ! Eval the Gaussian plane wave solution
                    !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                    !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                    !  
                                        if( nd.eq.2 )then
                                            xi = kxGPW*(xy(j1,j2,j3,0)-x0GPW) + kyGPW*(xy(j1,j2,j3,1)-y0GPW) - c*t
                                        else
                                            xi = kxGPW*(xy(j1,j2,j3,0)-x0GPW) + kyGPW*(xy(j1,j2,j3,1)-y0GPW) + kzGPW*(xy(j1,j2,j3,2)-z0GPW) - c*t
                                        end if 
                                        ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                    else if( knownSolutionOption.eq.boxHelmholtz ) then
                    ! --- evaluate the boxHelmholtz solution ---
                    ! For multi-freq we add up all the component frequencies
                                        ff = 0. 
                                        do freq=0,numberOfFrequencies-1
                      ! kx = kxBoxHelmholtz + twoPi*freq
                      ! ky = kyBoxHelmholtz + twoPi*freq
                      ! kz = kzBoxHelmholtz + twoPi*freq
                      ! coswt = cos( frequencyArray(freq)*t )
                          ! This macro is used in bcOptWave.bf90
                                                    omega = frequencyArray(freq);
                                                    kx = kxBoxHelmholtz*(freq*.5+1.)
                                                    ky = kyBoxHelmholtz*(freq*.5+1.)
                                                    kz = kzBoxHelmholtz*(freq*.5+1.)
                          ! kx = kxBoxHelmholtz + twoPi*freq.
                          ! ky = kyBoxHelmholtz + twoPi*freq.
                          ! kz = kzBoxHelmholtz + twoPi*freq.    
                                            coswt = cos( omega*t )
                                            if( nd.eq.2 )then
                                                ff = ff + sin( kx*xy(j1,j2,j3,0) ) * sin( ky*xy(j1,j2,j3,1) ) *coswt
                                            else
                                                ff = ff + sin( kx*xy(j1,j2,j3,0) ) * sin( ky*xy(j1,j2,j3,1) ) * sin( kz*xy(j1,j2,j3,2) ) *coswt
                                            end if 
                                        end do
                                    else if( knownSolutionOption.eq.polyPeriodic ) then
                    ! --- evaluate the polyPeriodic solution ---
                                        if( nd.eq.2 )then
                                            ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(j1,j2,j3,0) + b1PolyPeriodic*xy(j1,j2,j3,1)                                 ) *coswt
                                        else
                                            ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(j1,j2,j3,0) + b1PolyPeriodic*xy(j1,j2,j3,1) + c1PolyPeriodic*xy(j1,j2,j3,2) ) *coswt
                                        end if 
                                    else
                                        stop 9876
                                    end if 
                                end if
                            u(j1,j2,j3,uc) = ff
                        end do
                    end if ! mask .ne. 0
                  end do
                  end do
                  end do

        else if( boundaryCondition(side,axis).eq.dirichlet )then

            if( bcApproach.eq.useCompatibilityBoundaryConditions )then
        ! --- Assign values on the boundary for CBCs ---
                if( orderOfAccuracy.eq.2 )then

                    if( gridType.eq.rectangular )then
                            ff=0.
                              do i3=n3a,n3b
                              do i2=n2a,n2b
                              do i1=n1a,n1b
                                if( mask(i1,i2,i3).ne.0 )then
                  ! --- get the RHS to the Dirichlet BC ---
                                        if( assignTwilightZone.eq.1 )then
                      ! compute RHS from TZ
                                            if( nd.eq.2 )then
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            else
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            end if
                                            ff = ue
                                        else if( assignKnownSolutionAtBoundaries.eq.1 )then
                      ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                            if( knownSolutionOption.eq.planeWave )then
                        ! --- evaluate the plane wave solution ---
                                                if( nd.eq.2 )then
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                else
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                end if 
                                            else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                        ! Eval the Gaussian plane wave solution
                        !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                        !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                        !  
                                                if( nd.eq.2 )then
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                                else
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                                end if 
                                                ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                            else if( knownSolutionOption.eq.boxHelmholtz ) then
                        ! --- evaluate the boxHelmholtz solution ---
                        ! For multi-freq we add up all the component frequencies
                                                ff = 0. 
                                                do freq=0,numberOfFrequencies-1
                          ! kx = kxBoxHelmholtz + twoPi*freq
                          ! ky = kyBoxHelmholtz + twoPi*freq
                          ! kz = kzBoxHelmholtz + twoPi*freq
                          ! coswt = cos( frequencyArray(freq)*t )
                              ! This macro is used in bcOptWave.bf90
                                                            omega = frequencyArray(freq);
                                                            kx = kxBoxHelmholtz*(freq*.5+1.)
                                                            ky = kyBoxHelmholtz*(freq*.5+1.)
                                                            kz = kzBoxHelmholtz*(freq*.5+1.)
                              ! kx = kxBoxHelmholtz + twoPi*freq.
                              ! ky = kyBoxHelmholtz + twoPi*freq.
                              ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                    coswt = cos( omega*t )
                                                    if( nd.eq.2 )then
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                    else
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                    end if 
                                                end do
                                            else if( knownSolutionOption.eq.polyPeriodic ) then
                        ! --- evaluate the polyPeriodic solution ---
                                                if( nd.eq.2 )then
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                                else
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            else
                                                stop 9876
                                            end if 
                                        end if
                  ! --- Dirichlet BC ---
                                    u(i1,i2,i3,uc)=ff
                                end if ! mask .ne. 0
                              end do
                              end do
                              end do
                    else
                            ff=0.
                              do i3=n3a,n3b
                              do i2=n2a,n2b
                              do i1=n1a,n1b
                                if( mask(i1,i2,i3).ne.0 )then
                  ! --- get the RHS to the Dirichlet BC ---
                                        if( assignTwilightZone.eq.1 )then
                      ! compute RHS from TZ
                                            if( nd.eq.2 )then
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            else
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            end if
                                            ff = ue
                                        else if( assignKnownSolutionAtBoundaries.eq.1 )then
                      ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                            if( knownSolutionOption.eq.planeWave )then
                        ! --- evaluate the plane wave solution ---
                                                if( nd.eq.2 )then
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                else
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                end if 
                                            else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                        ! Eval the Gaussian plane wave solution
                        !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                        !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                        !  
                                                if( nd.eq.2 )then
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                                else
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                                end if 
                                                ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                            else if( knownSolutionOption.eq.boxHelmholtz ) then
                        ! --- evaluate the boxHelmholtz solution ---
                        ! For multi-freq we add up all the component frequencies
                                                ff = 0. 
                                                do freq=0,numberOfFrequencies-1
                          ! kx = kxBoxHelmholtz + twoPi*freq
                          ! ky = kyBoxHelmholtz + twoPi*freq
                          ! kz = kzBoxHelmholtz + twoPi*freq
                          ! coswt = cos( frequencyArray(freq)*t )
                              ! This macro is used in bcOptWave.bf90
                                                            omega = frequencyArray(freq);
                                                            kx = kxBoxHelmholtz*(freq*.5+1.)
                                                            ky = kyBoxHelmholtz*(freq*.5+1.)
                                                            kz = kzBoxHelmholtz*(freq*.5+1.)
                              ! kx = kxBoxHelmholtz + twoPi*freq.
                              ! ky = kyBoxHelmholtz + twoPi*freq.
                              ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                    coswt = cos( omega*t )
                                                    if( nd.eq.2 )then
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                    else
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                    end if 
                                                end do
                                            else if( knownSolutionOption.eq.polyPeriodic ) then
                        ! --- evaluate the polyPeriodic solution ---
                                                if( nd.eq.2 )then
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                                else
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            else
                                                stop 9876
                                            end if 
                                        end if
                  ! --- Dirichlet BC ---
                                    u(i1,i2,i3,uc)=ff
                                end if ! mask .ne. 0
                              end do
                              end do
                              end do
                    end if          

                else if( orderOfAccuracy.eq.4 )then

                    if( gridType.eq.rectangular )then
                            ff=0.
                              do i3=n3a,n3b
                              do i2=n2a,n2b
                              do i1=n1a,n1b
                                if( mask(i1,i2,i3).ne.0 )then
                  ! --- get the RHS to the Dirichlet BC ---
                                        if( assignTwilightZone.eq.1 )then
                      ! compute RHS from TZ
                                            if( nd.eq.2 )then
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            else
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            end if
                                            ff = ue
                                        else if( assignKnownSolutionAtBoundaries.eq.1 )then
                      ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                            if( knownSolutionOption.eq.planeWave )then
                        ! --- evaluate the plane wave solution ---
                                                if( nd.eq.2 )then
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                else
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                end if 
                                            else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                        ! Eval the Gaussian plane wave solution
                        !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                        !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                        !  
                                                if( nd.eq.2 )then
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                                else
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                                end if 
                                                ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                            else if( knownSolutionOption.eq.boxHelmholtz ) then
                        ! --- evaluate the boxHelmholtz solution ---
                        ! For multi-freq we add up all the component frequencies
                                                ff = 0. 
                                                do freq=0,numberOfFrequencies-1
                          ! kx = kxBoxHelmholtz + twoPi*freq
                          ! ky = kyBoxHelmholtz + twoPi*freq
                          ! kz = kzBoxHelmholtz + twoPi*freq
                          ! coswt = cos( frequencyArray(freq)*t )
                              ! This macro is used in bcOptWave.bf90
                                                            omega = frequencyArray(freq);
                                                            kx = kxBoxHelmholtz*(freq*.5+1.)
                                                            ky = kyBoxHelmholtz*(freq*.5+1.)
                                                            kz = kzBoxHelmholtz*(freq*.5+1.)
                              ! kx = kxBoxHelmholtz + twoPi*freq.
                              ! ky = kyBoxHelmholtz + twoPi*freq.
                              ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                    coswt = cos( omega*t )
                                                    if( nd.eq.2 )then
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                    else
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                    end if 
                                                end do
                                            else if( knownSolutionOption.eq.polyPeriodic ) then
                        ! --- evaluate the polyPeriodic solution ---
                                                if( nd.eq.2 )then
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                                else
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            else
                                                stop 9876
                                            end if 
                                        end if
                  ! --- Dirichlet BC ---
                                    u(i1,i2,i3,uc)=ff
                                end if ! mask .ne. 0
                              end do
                              end do
                              end do
                    else
                            ff=0.
                              do i3=n3a,n3b
                              do i2=n2a,n2b
                              do i1=n1a,n1b
                                if( mask(i1,i2,i3).ne.0 )then
                  ! --- get the RHS to the Dirichlet BC ---
                                        if( assignTwilightZone.eq.1 )then
                      ! compute RHS from TZ
                                            if( nd.eq.2 )then
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            else
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            end if
                                            ff = ue
                                        else if( assignKnownSolutionAtBoundaries.eq.1 )then
                      ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                            if( knownSolutionOption.eq.planeWave )then
                        ! --- evaluate the plane wave solution ---
                                                if( nd.eq.2 )then
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                else
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                end if 
                                            else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                        ! Eval the Gaussian plane wave solution
                        !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                        !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                        !  
                                                if( nd.eq.2 )then
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                                else
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                                end if 
                                                ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                            else if( knownSolutionOption.eq.boxHelmholtz ) then
                        ! --- evaluate the boxHelmholtz solution ---
                        ! For multi-freq we add up all the component frequencies
                                                ff = 0. 
                                                do freq=0,numberOfFrequencies-1
                          ! kx = kxBoxHelmholtz + twoPi*freq
                          ! ky = kyBoxHelmholtz + twoPi*freq
                          ! kz = kzBoxHelmholtz + twoPi*freq
                          ! coswt = cos( frequencyArray(freq)*t )
                              ! This macro is used in bcOptWave.bf90
                                                            omega = frequencyArray(freq);
                                                            kx = kxBoxHelmholtz*(freq*.5+1.)
                                                            ky = kyBoxHelmholtz*(freq*.5+1.)
                                                            kz = kzBoxHelmholtz*(freq*.5+1.)
                              ! kx = kxBoxHelmholtz + twoPi*freq.
                              ! ky = kyBoxHelmholtz + twoPi*freq.
                              ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                    coswt = cos( omega*t )
                                                    if( nd.eq.2 )then
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                    else
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                    end if 
                                                end do
                                            else if( knownSolutionOption.eq.polyPeriodic ) then
                        ! --- evaluate the polyPeriodic solution ---
                                                if( nd.eq.2 )then
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                                else
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            else
                                                stop 9876
                                            end if 
                                        end if
                  ! --- Dirichlet BC ---
                                    u(i1,i2,i3,uc)=ff
                                end if ! mask .ne. 0
                              end do
                              end do
                              end do
                    end if          

                else if( orderOfAccuracy.eq.6 )then 

                    if( gridType.eq.rectangular )then
                            ff=0.
                              do i3=n3a,n3b
                              do i2=n2a,n2b
                              do i1=n1a,n1b
                                if( mask(i1,i2,i3).ne.0 )then
                  ! --- get the RHS to the Dirichlet BC ---
                                        if( assignTwilightZone.eq.1 )then
                      ! compute RHS from TZ
                                            if( nd.eq.2 )then
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            else
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            end if
                                            ff = ue
                                        else if( assignKnownSolutionAtBoundaries.eq.1 )then
                      ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                            if( knownSolutionOption.eq.planeWave )then
                        ! --- evaluate the plane wave solution ---
                                                if( nd.eq.2 )then
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                else
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                end if 
                                            else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                        ! Eval the Gaussian plane wave solution
                        !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                        !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                        !  
                                                if( nd.eq.2 )then
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                                else
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                                end if 
                                                ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                            else if( knownSolutionOption.eq.boxHelmholtz ) then
                        ! --- evaluate the boxHelmholtz solution ---
                        ! For multi-freq we add up all the component frequencies
                                                ff = 0. 
                                                do freq=0,numberOfFrequencies-1
                          ! kx = kxBoxHelmholtz + twoPi*freq
                          ! ky = kyBoxHelmholtz + twoPi*freq
                          ! kz = kzBoxHelmholtz + twoPi*freq
                          ! coswt = cos( frequencyArray(freq)*t )
                              ! This macro is used in bcOptWave.bf90
                                                            omega = frequencyArray(freq);
                                                            kx = kxBoxHelmholtz*(freq*.5+1.)
                                                            ky = kyBoxHelmholtz*(freq*.5+1.)
                                                            kz = kzBoxHelmholtz*(freq*.5+1.)
                              ! kx = kxBoxHelmholtz + twoPi*freq.
                              ! ky = kyBoxHelmholtz + twoPi*freq.
                              ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                    coswt = cos( omega*t )
                                                    if( nd.eq.2 )then
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                    else
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                    end if 
                                                end do
                                            else if( knownSolutionOption.eq.polyPeriodic ) then
                        ! --- evaluate the polyPeriodic solution ---
                                                if( nd.eq.2 )then
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                                else
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            else
                                                stop 9876
                                            end if 
                                        end if
                  ! --- Dirichlet BC ---
                                    u(i1,i2,i3,uc)=ff
                                end if ! mask .ne. 0
                              end do
                              end do
                              end do
                    else
                            ff=0.
                              do i3=n3a,n3b
                              do i2=n2a,n2b
                              do i1=n1a,n1b
                                if( mask(i1,i2,i3).ne.0 )then
                  ! --- get the RHS to the Dirichlet BC ---
                                        if( assignTwilightZone.eq.1 )then
                      ! compute RHS from TZ
                                            if( nd.eq.2 )then
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            else
                                                call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            end if
                                            ff = ue
                                        else if( assignKnownSolutionAtBoundaries.eq.1 )then
                      ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                            if( knownSolutionOption.eq.planeWave )then
                        ! --- evaluate the plane wave solution ---
                                                if( nd.eq.2 )then
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                else
                                                    ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                end if 
                                            else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                        ! Eval the Gaussian plane wave solution
                        !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                        !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                        !  
                                                if( nd.eq.2 )then
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                                else
                                                    xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                                end if 
                                                ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                            else if( knownSolutionOption.eq.boxHelmholtz ) then
                        ! --- evaluate the boxHelmholtz solution ---
                        ! For multi-freq we add up all the component frequencies
                                                ff = 0. 
                                                do freq=0,numberOfFrequencies-1
                          ! kx = kxBoxHelmholtz + twoPi*freq
                          ! ky = kyBoxHelmholtz + twoPi*freq
                          ! kz = kzBoxHelmholtz + twoPi*freq
                          ! coswt = cos( frequencyArray(freq)*t )
                              ! This macro is used in bcOptWave.bf90
                                                            omega = frequencyArray(freq);
                                                            kx = kxBoxHelmholtz*(freq*.5+1.)
                                                            ky = kyBoxHelmholtz*(freq*.5+1.)
                                                            kz = kzBoxHelmholtz*(freq*.5+1.)
                              ! kx = kxBoxHelmholtz + twoPi*freq.
                              ! ky = kyBoxHelmholtz + twoPi*freq.
                              ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                    coswt = cos( omega*t )
                                                    if( nd.eq.2 )then
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                    else
                                                        ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                    end if 
                                                end do
                                            else if( knownSolutionOption.eq.polyPeriodic ) then
                        ! --- evaluate the polyPeriodic solution ---
                                                if( nd.eq.2 )then
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                                else
                                                    ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            else
                                                stop 9876
                                            end if 
                                        end if
                  ! --- Dirichlet BC ---
                                    u(i1,i2,i3,uc)=ff
                                end if ! mask .ne. 0
                              end do
                              end do
                              end do
                    end if      

                else if( orderOfAccuracy.eq.8 )then   
                    stop 888
                else
                    write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
                    stop 8888
                end if

            else 
        ! ----- assign boundary and then ghost by extrapolation ----
        ! This was a temporary method until other approaches were implemented
                if( orderOfAccuracy.eq.2 )then
                        ff=0.
                          do i3=n3a,n3b
                          do i2=n2a,n2b
                          do i1=n1a,n1b
                            if( mask(i1,i2,i3).ne.0 )then
                ! --- get the RHS to the Dirichlet BC ---
                                    if( assignTwilightZone.eq.1 )then
                    ! compute RHS from TZ
                                        if( nd.eq.2 )then
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                        else
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                        end if
                                        ff = ue
                                    else if( assignKnownSolutionAtBoundaries.eq.1 )then
                    ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                        if( knownSolutionOption.eq.planeWave )then
                      ! --- evaluate the plane wave solution ---
                                            if( nd.eq.2 )then
                                                ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                            else
                                                ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                            end if 
                                        else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                      ! Eval the Gaussian plane wave solution
                      !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                      !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                      !  
                                            if( nd.eq.2 )then
                                                xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                            else
                                                xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                            end if 
                                            ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                        else if( knownSolutionOption.eq.boxHelmholtz ) then
                      ! --- evaluate the boxHelmholtz solution ---
                      ! For multi-freq we add up all the component frequencies
                                            ff = 0. 
                                            do freq=0,numberOfFrequencies-1
                        ! kx = kxBoxHelmholtz + twoPi*freq
                        ! ky = kyBoxHelmholtz + twoPi*freq
                        ! kz = kzBoxHelmholtz + twoPi*freq
                        ! coswt = cos( frequencyArray(freq)*t )
                            ! This macro is used in bcOptWave.bf90
                                                        omega = frequencyArray(freq);
                                                        kx = kxBoxHelmholtz*(freq*.5+1.)
                                                        ky = kyBoxHelmholtz*(freq*.5+1.)
                                                        kz = kzBoxHelmholtz*(freq*.5+1.)
                            ! kx = kxBoxHelmholtz + twoPi*freq.
                            ! ky = kyBoxHelmholtz + twoPi*freq.
                            ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                coswt = cos( omega*t )
                                                if( nd.eq.2 )then
                                                    ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                else
                                                    ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            end do
                                        else if( knownSolutionOption.eq.polyPeriodic ) then
                      ! --- evaluate the polyPeriodic solution ---
                                            if( nd.eq.2 )then
                                                ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                            else
                                                ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                            end if 
                                        else
                                            stop 9876
                                        end if 
                                    end if
                ! --- Dirichlet BC ---
                                u(i1,i2,i3,uc)=ff
                ! -- extrapolate ghost ---
                                do ghost=1,numGhost
                                    j1=i1-is1*ghost
                                    j2=i2-is2*ghost
                                    j3=i3-is3*ghost
                                    u(j1,j2,j3,uc) = (3.*u(j1+is1,j2+is2,j3+is3,uc)-3.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)) 
                                end do
                            end if ! mask .ne. 0
                          end do
                          end do
                          end do

                else if( orderOfAccuracy.eq.4 )then
                        ff=0.
                          do i3=n3a,n3b
                          do i2=n2a,n2b
                          do i1=n1a,n1b
                            if( mask(i1,i2,i3).ne.0 )then
                ! --- get the RHS to the Dirichlet BC ---
                                    if( assignTwilightZone.eq.1 )then
                    ! compute RHS from TZ
                                        if( nd.eq.2 )then
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                        else
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                        end if
                                        ff = ue
                                    else if( assignKnownSolutionAtBoundaries.eq.1 )then
                    ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                        if( knownSolutionOption.eq.planeWave )then
                      ! --- evaluate the plane wave solution ---
                                            if( nd.eq.2 )then
                                                ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                            else
                                                ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                            end if 
                                        else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                      ! Eval the Gaussian plane wave solution
                      !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                      !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                      !  
                                            if( nd.eq.2 )then
                                                xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                            else
                                                xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                            end if 
                                            ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                        else if( knownSolutionOption.eq.boxHelmholtz ) then
                      ! --- evaluate the boxHelmholtz solution ---
                      ! For multi-freq we add up all the component frequencies
                                            ff = 0. 
                                            do freq=0,numberOfFrequencies-1
                        ! kx = kxBoxHelmholtz + twoPi*freq
                        ! ky = kyBoxHelmholtz + twoPi*freq
                        ! kz = kzBoxHelmholtz + twoPi*freq
                        ! coswt = cos( frequencyArray(freq)*t )
                            ! This macro is used in bcOptWave.bf90
                                                        omega = frequencyArray(freq);
                                                        kx = kxBoxHelmholtz*(freq*.5+1.)
                                                        ky = kyBoxHelmholtz*(freq*.5+1.)
                                                        kz = kzBoxHelmholtz*(freq*.5+1.)
                            ! kx = kxBoxHelmholtz + twoPi*freq.
                            ! ky = kyBoxHelmholtz + twoPi*freq.
                            ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                coswt = cos( omega*t )
                                                if( nd.eq.2 )then
                                                    ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                else
                                                    ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            end do
                                        else if( knownSolutionOption.eq.polyPeriodic ) then
                      ! --- evaluate the polyPeriodic solution ---
                                            if( nd.eq.2 )then
                                                ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                            else
                                                ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                            end if 
                                        else
                                            stop 9876
                                        end if 
                                    end if
                ! --- Dirichlet BC ---
                                u(i1,i2,i3,uc)=ff
                ! -- extrapolate ghost ---
                                do ghost=1,numGhost
                                    j1=i1-is1*ghost
                                    j2=i2-is2*ghost
                                    j3=i3-is3*ghost
                                    u(j1,j2,j3,uc) = (5.*u(j1+is1,j2+is2,j3+is3,uc)-10.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+10.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-5.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)) 
                                end do
                            end if ! mask .ne. 0
                          end do
                          end do
                          end do

                else if( orderOfAccuracy.eq.6 )then   

              ! #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap6(u,i1,i2,i3,n,is1,is2,is3)
                        ff=0.
                          do i3=n3a,n3b
                          do i2=n2a,n2b
                          do i1=n1a,n1b
                            if( mask(i1,i2,i3).ne.0 )then
                ! --- get the RHS to the Dirichlet BC ---
                                    if( assignTwilightZone.eq.1 )then
                    ! compute RHS from TZ
                                        if( nd.eq.2 )then
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                        else
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                        end if
                                        ff = ue
                                    else if( assignKnownSolutionAtBoundaries.eq.1 )then
                    ! -- we set inhomogeneous Dirichlet values for some known solutions 
                                        if( knownSolutionOption.eq.planeWave )then
                      ! --- evaluate the plane wave solution ---
                                            if( nd.eq.2 )then
                                                ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                            else
                                                ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                            end if 
                                        else if( knownSolutionOption.eq.gaussianPlaneWave ) then
                      ! Eval the Gaussian plane wave solution
                      !    u = exp( -beta*(xi^2) )*cos( k0*xi )
                      !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
                      !  
                                            if( nd.eq.2 )then
                                                xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
                                            else
                                                xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
                                            end if 
                                            ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      
                                        else if( knownSolutionOption.eq.boxHelmholtz ) then
                      ! --- evaluate the boxHelmholtz solution ---
                      ! For multi-freq we add up all the component frequencies
                                            ff = 0. 
                                            do freq=0,numberOfFrequencies-1
                        ! kx = kxBoxHelmholtz + twoPi*freq
                        ! ky = kyBoxHelmholtz + twoPi*freq
                        ! kz = kzBoxHelmholtz + twoPi*freq
                        ! coswt = cos( frequencyArray(freq)*t )
                            ! This macro is used in bcOptWave.bf90
                                                        omega = frequencyArray(freq);
                                                        kx = kxBoxHelmholtz*(freq*.5+1.)
                                                        ky = kyBoxHelmholtz*(freq*.5+1.)
                                                        kz = kzBoxHelmholtz*(freq*.5+1.)
                            ! kx = kxBoxHelmholtz + twoPi*freq.
                            ! ky = kyBoxHelmholtz + twoPi*freq.
                            ! kz = kzBoxHelmholtz + twoPi*freq.    
                                                coswt = cos( omega*t )
                                                if( nd.eq.2 )then
                                                    ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
                                                else
                                                    ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
                                                end if 
                                            end do
                                        else if( knownSolutionOption.eq.polyPeriodic ) then
                      ! --- evaluate the polyPeriodic solution ---
                                            if( nd.eq.2 )then
                                                ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
                                            else
                                                ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                            end if 
                                        else
                                            stop 9876
                                        end if 
                                    end if
                ! --- Dirichlet BC ---
                                u(i1,i2,i3,uc)=ff
                ! -- extrapolate ghost ---
                                do ghost=1,numGhost
                                    j1=i1-is1*ghost
                                    j2=i2-is2*ghost
                                    j3=i3-is3*ghost
                                    u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc)) 
                                end do
                            end if ! mask .ne. 0
                          end do
                          end do
                          end do

                else if( orderOfAccuracy.eq.8 )then   
                    stop 888
                else
                    write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
                    stop 8888
                end if
            end if

        end if ! end if dirichlet 

      end do ! end side
      end do ! end axis

  ! --  Extrap values on remaining sides to give initial values 
  !     --> maybe we only need to do this along extended boundaries on
  !         curvilinear grids so we have values for the Neumann BC
      extra1a=numGhost
      extra1b=numGhost
      extra2a=numGhost
      extra2b=numGhost
      if( nd.eq.3 )then
          extra3a=numGhost
          extra3b=numGhost
      else
          extra3a=0
          extra3b=0
      end if
      if( boundaryCondition(0,0).lt.0 )then
          extra1a=max(0,extra1a) ! over-ride numGhost=-1 : assign ends in periodic directions (or internal parallel boundaries)
      else if( boundaryCondition(0,0).eq.0 )then
          extra1a=numGhost  ! include interpolation points since we assign ghost points outside these
      end if
   ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
      if( boundaryCondition(1,0).lt.0 )then
          extra1b=max(0,extra1b) ! over-ride numGhost=-1 : assign ends in periodic directions
      else if( boundaryCondition(1,0).eq.0 )then
          extra1b=numGhost
      end if
      if( boundaryCondition(0,1).lt.0 )then
          extra2a=max(0,extra2a) ! over-ride numGhost=-1 : assign ends in periodic directions (or internal parallel boundaries)
      else if( boundaryCondition(0,1).eq.0 )then
          extra2a=numGhost  ! include interpolation points since we assign ghost points outside these
      end if
   ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
      if( boundaryCondition(1,1).lt.0 )then
          extra2b=max(0,extra2b) ! over-ride numGhost=-1 : assign ends in periodic directions
      else if( boundaryCondition(1,1).eq.0 )then
          extra2b=numGhost
      end if
      if(  nd.eq.3 )then
        if( boundaryCondition(0,2).lt.0 )then
            extra3a=max(0,extra3a) ! over-ride numGhost=-1 : assign ends in periodic directions (or internal parallel boundaries)
        else if( boundaryCondition(0,2).eq.0 )then
            extra3a=numGhost  ! include interpolation points since we assign ghost points outside these
        end if
    ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
        if( boundaryCondition(1,2).lt.0 )then
            extra3b=max(0,extra3b) ! over-ride numGhost=-1 : assign ends in periodic directions
        else if( boundaryCondition(1,2).eq.0 )then
            extra3b=numGhost
        end if
      end if
      do axis=0,nd-1
      do side=0,1
          if( boundaryCondition(side,axis).gt.0 )then
       ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,boundaryCondition(side,axis)
              n1a=gridIndexRange(0,0)
              n1b=gridIndexRange(1,0)
              n2a=gridIndexRange(0,1)
              n2b=gridIndexRange(1,1)
              n3a=gridIndexRange(0,2)
              n3b=gridIndexRange(1,2)
              if( axis.eq.0 )then
                  n1a=gridIndexRange(side,axis)
                  n1b=gridIndexRange(side,axis)
              else if( axis.eq.1 )then
                  n2a=gridIndexRange(side,axis)
                  n2b=gridIndexRange(side,axis)
              else
                  n3a=gridIndexRange(side,axis)
                  n3b=gridIndexRange(side,axis)
              end if
              nn1a=gridIndexRange(0,0)-extra1a
              nn1b=gridIndexRange(1,0)+extra1b
              nn2a=gridIndexRange(0,1)-extra2a
              nn2b=gridIndexRange(1,1)+extra2b
              nn3a=gridIndexRange(0,2)-extra3a
              nn3b=gridIndexRange(1,2)+extra3b
              if( axis.eq.0 )then
                  nn1a=gridIndexRange(side,axis)
                  nn1b=gridIndexRange(side,axis)
              else if( axis.eq.1 )then
                  nn2a=gridIndexRange(side,axis)
                  nn2b=gridIndexRange(side,axis)
              else
                  nn3a=gridIndexRange(side,axis)
                  nn3b=gridIndexRange(side,axis)
              end if
              is=1-2*side
              is1=0
              is2=0
              is3=0
              if( axis.eq.0 )then
                  is1=1-2*side
              else if( axis.eq.1 )then
                  is2=1-2*side
              else if( axis.eq.2 )then
                  is3=1-2*side
              else
                  stop 5
              end if
              axisp1=mod(axis+1,nd)
              axisp2=mod(axis+2,nd)
              i3=n3a
              if( debug.gt.7 )then
                  write(*,'(" bcOptWave: grid,side,axis=",3i3,", loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,n1a,n1b,n2a,n2b,n3a,n3b
              end if
          end if ! if bc>0 
          assignTwilightZone=twilightZone

        if( ( (boundaryCondition(side,axis).ne.dirichlet .and. boundaryCondition(side,axis).ne.exactBC ) .or. bcApproach.eq.useCompatibilityBoundaryConditions ) .and. boundaryCondition(side,axis).gt.0 )then

            if( orderOfAccuracy.eq.2 )then

          ! ghost-loops will assign extra points in tangential directions
                      do i3=nn3a,nn3b
                      do i2=nn2a,nn2b
                      do i1=nn1a,nn1b
                        if( mask(i1,i2,i3).ne.0 )then
              ! -- extrapolate ghost ---
                            do ghost=1,numGhost
                                j1=i1-is1*ghost
                                j2=i2-is2*ghost
                                j3=i3-is3*ghost
                                u(j1,j2,j3,uc) = (3.*u(j1+is1,j2+is2,j3+is3,uc)-3.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)) 
                            end do
                        end if ! mask .ne. 0
                      end do
                      end do
                      end do

            else if( orderOfAccuracy.eq.4 )then

          ! ghost-loops will assign extra points in tangential directions
                      do i3=nn3a,nn3b
                      do i2=nn2a,nn2b
                      do i1=nn1a,nn1b
                        if( mask(i1,i2,i3).ne.0 )then
              ! -- extrapolate ghost ---
                            do ghost=1,numGhost
                                j1=i1-is1*ghost
                                j2=i2-is2*ghost
                                j3=i3-is3*ghost
                                u(j1,j2,j3,uc) = (5.*u(j1+is1,j2+is2,j3+is3,uc)-10.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+10.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-5.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)) 
                            end do
                        end if ! mask .ne. 0
                      end do
                      end do
                      end do

            else if( orderOfAccuracy.eq.6 )then   

            ! #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap6(u,i1,i2,i3,n,is1,is2,is3)
          ! ghost-loops will assign extra points in tangential directions
                      do i3=nn3a,nn3b
                      do i2=nn2a,nn2b
                      do i1=nn1a,nn1b
                        if( mask(i1,i2,i3).ne.0 )then
              ! -- extrapolate ghost ---
                            do ghost=1,numGhost
                                j1=i1-is1*ghost
                                j2=i2-is2*ghost
                                j3=i3-is3*ghost
                                u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc)) 
                            end do
                        end if ! mask .ne. 0
                      end do
                      end do
                      end do

            else if( orderOfAccuracy.eq.8 )then   

          ! ghost-loops will assign extra points in tangential directions
                      do i3=nn3a,nn3b
                      do i2=nn2a,nn2b
                      do i1=nn1a,nn1b
                        if( mask(i1,i2,i3).ne.0 )then
              ! -- extrapolate ghost ---
                            do ghost=1,numGhost
                                j1=i1-is1*ghost
                                j2=i2-is2*ghost
                                j3=i3-is3*ghost
                                u(j1,j2,j3,uc) = (9.*u(j1+is1,j2+is2,j3+is3,uc)-36.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+84.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-126.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+126.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-84.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+36.*u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc)-9.*u(j1+is1+7*is1,j2+is2+7*is2,j3+is3+7*is3,uc)+u(j1+is1+8*is1,j2+is2+8*is2,j3+is3+8*is3,uc)) 
                            end do
                        end if ! mask .ne. 0
                      end do
                      end do
                      end do

            else

                write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
                stop 8888

            end if

        end if

      end do ! end side
      end do ! end axis

  !  --- Assign ghost points outside corners ---
  ! assignCornerGhostsMacro()

  ! Try this for order==6
  ! if( .false. .and. orderOfAccuracy.eq.6 .and. nd.eq.2 .and. gridType.eq.rectangular )then
  !   if( forcingOption.eq.noForcing )then
  !     assignSymmetryCornerGhost(noForcing)
  !   else
  !     assignSymmetryCornerGhost(forcing)
  !   end if
  ! end if

  ! ---------------------------------------------------------------------
  ! ----------- STAGE II : Neumann-like Boundary Conditions -------------
  ! -----------            Ghost values for CBCs            -------------
  ! ---------------------------------------------------------------------

  ! CHECK ME --> numGhost here ??
    extraForNeumann=0 ! only assign Neumann conditions to the boundary
      extra1a=extraForNeumann
      extra1b=extraForNeumann
      extra2a=extraForNeumann
      extra2b=extraForNeumann
      if( nd.eq.3 )then
          extra3a=extraForNeumann
          extra3b=extraForNeumann
      else
          extra3a=0
          extra3b=0
      end if
      if( boundaryCondition(0,0).lt.0 )then
          extra1a=max(0,extra1a) ! over-ride extraForNeumann=-1 : assign ends in periodic directions (or internal parallel boundaries)
      else if( boundaryCondition(0,0).eq.0 )then
          extra1a=numGhost  ! include interpolation points since we assign ghost points outside these
      end if
   ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
      if( boundaryCondition(1,0).lt.0 )then
          extra1b=max(0,extra1b) ! over-ride extraForNeumann=-1 : assign ends in periodic directions
      else if( boundaryCondition(1,0).eq.0 )then
          extra1b=numGhost
      end if
      if( boundaryCondition(0,1).lt.0 )then
          extra2a=max(0,extra2a) ! over-ride extraForNeumann=-1 : assign ends in periodic directions (or internal parallel boundaries)
      else if( boundaryCondition(0,1).eq.0 )then
          extra2a=numGhost  ! include interpolation points since we assign ghost points outside these
      end if
   ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
      if( boundaryCondition(1,1).lt.0 )then
          extra2b=max(0,extra2b) ! over-ride extraForNeumann=-1 : assign ends in periodic directions
      else if( boundaryCondition(1,1).eq.0 )then
          extra2b=numGhost
      end if
      if(  nd.eq.3 )then
        if( boundaryCondition(0,2).lt.0 )then
            extra3a=max(0,extra3a) ! over-ride extraForNeumann=-1 : assign ends in periodic directions (or internal parallel boundaries)
        else if( boundaryCondition(0,2).eq.0 )then
            extra3a=numGhost  ! include interpolation points since we assign ghost points outside these
        end if
    ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
        if( boundaryCondition(1,2).lt.0 )then
            extra3b=max(0,extra3b) ! over-ride extraForNeumann=-1 : assign ends in periodic directions
        else if( boundaryCondition(1,2).eq.0 )then
            extra3b=numGhost
        end if
      end if
      do axis=0,nd-1
      do side=0,1
          if( boundaryCondition(side,axis).gt.0 )then
       ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,boundaryCondition(side,axis)
              n1a=gridIndexRange(0,0)
              n1b=gridIndexRange(1,0)
              n2a=gridIndexRange(0,1)
              n2b=gridIndexRange(1,1)
              n3a=gridIndexRange(0,2)
              n3b=gridIndexRange(1,2)
              if( axis.eq.0 )then
                  n1a=gridIndexRange(side,axis)
                  n1b=gridIndexRange(side,axis)
              else if( axis.eq.1 )then
                  n2a=gridIndexRange(side,axis)
                  n2b=gridIndexRange(side,axis)
              else
                  n3a=gridIndexRange(side,axis)
                  n3b=gridIndexRange(side,axis)
              end if
              nn1a=gridIndexRange(0,0)-extra1a
              nn1b=gridIndexRange(1,0)+extra1b
              nn2a=gridIndexRange(0,1)-extra2a
              nn2b=gridIndexRange(1,1)+extra2b
              nn3a=gridIndexRange(0,2)-extra3a
              nn3b=gridIndexRange(1,2)+extra3b
              if( axis.eq.0 )then
                  nn1a=gridIndexRange(side,axis)
                  nn1b=gridIndexRange(side,axis)
              else if( axis.eq.1 )then
                  nn2a=gridIndexRange(side,axis)
                  nn2b=gridIndexRange(side,axis)
              else
                  nn3a=gridIndexRange(side,axis)
                  nn3b=gridIndexRange(side,axis)
              end if
              is=1-2*side
              is1=0
              is2=0
              is3=0
              if( axis.eq.0 )then
                  is1=1-2*side
              else if( axis.eq.1 )then
                  is2=1-2*side
              else if( axis.eq.2 )then
                  is3=1-2*side
              else
                  stop 5
              end if
              axisp1=mod(axis+1,nd)
              axisp2=mod(axis+2,nd)
              i3=n3a
              if( debug.gt.7 )then
                  write(*,'(" bcOptWave: grid,side,axis=",3i3,", loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,n1a,n1b,n2a,n2b,n3a,n3b
              end if
          end if ! if bc>0 
          assignTwilightZone=twilightZone

        if( boundaryCondition(side,axis).eq.dirichlet .and. bcApproach.eq.useCompatibilityBoundaryConditions )then
      ! -- fill ghost using CBCs ----

            if( orderOfAccuracy.eq.2 )then

                        if( forcingOption.eq.noForcing )then
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian22r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian23r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                end if
                            else
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian22(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian23(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                end if
                            end if 
                        else
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                ueLap = uexx + ueyy
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian22r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                ! 3D 
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                ueLap = uexx + ueyy + uezz
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian23r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                end if
                            else
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                ueLap = uexx + ueyy
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian22(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                ! 3D 
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                ueLap = uexx + ueyy + uezz
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian23(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                                end if
                            end if     
                        end if

            else if( orderOfAccuracy.eq.4 )then

                        if( forcingOption.eq.noForcing )then
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian22r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                              ! No forcing, do nothing 
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! uxx43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*dx42(0) 
                                                        uLap = ulaplacian42r(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                        a11 = c2*16./(12.*dx(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 =    -c2/(12.*dx(axis)**2)                           ! coeff of u(-2) in r1
                            ! uxxxx = 1 -4 6 -4 1
                            ! vLap = Lap^2( u )
                                                        vLap = lap2d2Pow2(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                                                        a21 =  -c4*4./(dx(axis)**4)                              ! coeff of u(-1) in r2
                                                        a22 =   c4*1./(dx(axis)**4)
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian23r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                              ! No forcing, do nothing 
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! uxx43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*dx42(0) 
                                                        uLap = ulaplacian43r(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                        a11 = c2*16./(12.*dx(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 =    -c2/(12.*dx(axis)**2)                           ! coeff of u(-2) in r1
                            ! uxxxx = 1 -4 6 -4 1
                            ! vLap = Lap^2( u )
                                                        vLap = lap3d2Pow2(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                                                        a21 =  -c4*4./(dx(axis)**4)                              ! coeff of u(-1) in r2
                                                        a22 =   c4*1./(dx(axis)**4)
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                end if
                            else
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian22(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                        ! Compute and save v = Lap(u) at some points near the boundary
                        !  for use below to compute Lap^2 (u)
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !         r=0 
                                                do i3=m3a,m3b
                                                do i2=m2a,m2b
                                                do i1=m1a,m1b
                          ! eval Lap(u) on ghost, boundary and first line in:
                                                    if( mask(i1,i2,i3).ne.0 )then 
                                                        v(i1-is1,i2-is2,i3-is3,0) = ulaplacian22(i1-is1,i2-is2,i3-is3,0)
                                                        v(i1    ,i2    ,i3    ,0) = ulaplacian22(i1    ,i2    ,i3    ,0)
                                                        v(i1+is1,i2+is2,i3+is3,0) = ulaplacian22(i1+is1,i2+is2,i3+is3,0)
                                                    end if
                                                end do
                                                end do
                                                end do
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                              ! No forcing, do nothing 
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! curvilinear 
                            ! uxx42(i1,i2,i3,kd)=(rsxy(i1,i2,i3,0,0)**2)*urr4(i1,i2,i3,kd)+2.*(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,0))*urs4(i1,i2,i3,kd)+(rsxy(i1,i2,i3,1,0)**2)*uss4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,0,0))*ur4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,1,0))*us4(i1,i2,i3,kd)
                                                        uLap = ulaplacian42(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
                                                        a11 =  c2*rFactor*16./(12.*dr(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 = -c2*rFactor    /(12.*dr(axis)**2)                           ! coeff of u(-2) in r1
                            ! vLap = Lap^2( u) to second-order
                            ! vLap = vlaplacian22 or vlaplacian23 
                                                        vLap = vlaplacian22(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                            ! Here is the leading order term in a21, a22   ** this may not be good enough for stability but should remain accurate ***
                                                        a21 =  -c4*( rFactor**2*4./(dr(axis)**4) )                             ! coeff of u(-1) in r2
                                                        a22 =   c4*( rFactor**2   /(dr(axis)**4) )         
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian23(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                        ! Compute and save v = Lap(u) at some points near the boundary
                        !  for use below to compute Lap^2 (u)
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !         r=0 
                                                do i3=m3a,m3b
                                                do i2=m2a,m2b
                                                do i1=m1a,m1b
                          ! eval Lap(u) on ghost, boundary and first line in:
                                                    if( mask(i1,i2,i3).ne.0 )then 
                                                        v(i1-is1,i2-is2,i3-is3,0) = ulaplacian23(i1-is1,i2-is2,i3-is3,0)
                                                        v(i1    ,i2    ,i3    ,0) = ulaplacian23(i1    ,i2    ,i3    ,0)
                                                        v(i1+is1,i2+is2,i3+is3,0) = ulaplacian23(i1+is1,i2+is2,i3+is3,0)
                                                    end if
                                                end do
                                                end do
                                                end do
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                              ! No forcing, do nothing 
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! curvilinear 
                            ! uxx42(i1,i2,i3,kd)=(rsxy(i1,i2,i3,0,0)**2)*urr4(i1,i2,i3,kd)+2.*(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,0))*urs4(i1,i2,i3,kd)+(rsxy(i1,i2,i3,1,0)**2)*uss4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,0,0))*ur4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,1,0))*us4(i1,i2,i3,kd)
                                                        uLap = ulaplacian43(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2
                                                        a11 =  c2*rFactor*16./(12.*dr(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 = -c2*rFactor    /(12.*dr(axis)**2)                           ! coeff of u(-2) in r1
                            ! vLap = Lap^2( u) to second-order
                            ! vLap = vlaplacian22 or vlaplacian23 
                                                        vLap = vlaplacian23(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                            ! Here is the leading order term in a21, a22   ** this may not be good enough for stability but should remain accurate ***
                                                        a21 =  -c4*( rFactor**2*4./(dr(axis)**4) )                             ! coeff of u(-1) in r2
                                                        a22 =   c4*( rFactor**2   /(dr(axis)**4) )         
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                end if
                            end if 
                        else
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                ueLap = uexx + ueyy
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian22r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                    ueLap = uexx + ueyy
                                                                    call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
                                                                        call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettxx )
                                                                        call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettyy )
                                                                        uettLap = uettxx + uettyy
                                                                        call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx )
                                                                        call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
                                                                        call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )
                                                                        ueLap2 = uexxxx + 2.*uexxyy + ueyyyy ! Lap^2( u )
                                                                        call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )
                                                                ff = uett - c2*ueLap
                                                                gtt = uett
                                                                    fLap = uettLap - c2*ueLap2 
                                                                    ftt  = uetttt - c2*uettLap
                                                                    gtttt = uetttt
                                                            else
                                                                ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                            end if
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! uxx43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*dx42(0) 
                                                        uLap = ulaplacian42r(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                        a11 = c2*16./(12.*dx(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 =    -c2/(12.*dx(axis)**2)                           ! coeff of u(-2) in r1
                            ! uxxxx = 1 -4 6 -4 1
                            ! vLap = Lap^2( u )
                                                        vLap = lap2d2Pow2(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                                                        a21 =  -c4*4./(dx(axis)**4)                              ! coeff of u(-1) in r2
                                                        a22 =   c4*1./(dx(axis)**4)
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                ! 3D 
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                ueLap = uexx + ueyy + uezz
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22r or ulaplacian23r 
                                                    uLap = ulaplacian23r(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
                                                    a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                  ! 3D 
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                    call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                    ueLap = uexx + ueyy + uezz
                                                                    call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
                                                                        call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettxx )
                                                                        call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettyy )
                                                                        call ogDeriv(ep,2,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettzz )
                                                                        uettLap = uettxx + uettyy + uettzz
                                                                        call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxx )
                                                                        call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyy )
                                                                        call ogDeriv(ep,0,0,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzz )
                                                                        call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyy )
                                                                        call ogDeriv(ep,0,2,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzz )
                                                                        call ogDeriv(ep,0,0,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzz )
                                                                        ueLap2 = uexxxx + 2.*( uexxyy + uexxzz + ueyyzz)  + ueyyyy + uezzzz ! Lap^2( u )
                                                                        call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )
                                                                ff = uett - c2*ueLap
                                                                gtt = uett
                                                                    fLap = uettLap - c2*ueLap2 
                                                                    ftt  = uetttt - c2*uettLap
                                                                    gtttt = uetttt
                                                            else
                                                                ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                            end if
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! uxx43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*dx42(0) 
                                                        uLap = ulaplacian43r(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                        a11 = c2*16./(12.*dx(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 =    -c2/(12.*dx(axis)**2)                           ! coeff of u(-2) in r1
                            ! uxxxx = 1 -4 6 -4 1
                            ! vLap = Lap^2( u )
                                                        vLap = lap3d2Pow2(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                                                        a21 =  -c4*4./(dx(axis)**4)                              ! coeff of u(-1) in r2
                                                        a22 =   c4*1./(dx(axis)**4)
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                end if
                            else
                                if( nd.eq.2 )then
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                ueLap = uexx + ueyy
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian22(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                        ! Compute and save v = Lap(u) at some points near the boundary
                        !  for use below to compute Lap^2 (u)
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !         r=0 
                                                do i3=m3a,m3b
                                                do i2=m2a,m2b
                                                do i1=m1a,m1b
                          ! eval Lap(u) on ghost, boundary and first line in:
                                                    if( mask(i1,i2,i3).ne.0 )then 
                                                        v(i1-is1,i2-is2,i3-is3,0) = ulaplacian22(i1-is1,i2-is2,i3-is3,0)
                                                        v(i1    ,i2    ,i3    ,0) = ulaplacian22(i1    ,i2    ,i3    ,0)
                                                        v(i1+is1,i2+is2,i3+is3,0) = ulaplacian22(i1+is1,i2+is2,i3+is3,0)
                                                    end if
                                                end do
                                                end do
                                                end do
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                    ueLap = uexx + ueyy
                                                                    call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
                                                                        call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettxx )
                                                                        call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettyy )
                                                                        uettLap = uettxx + uettyy
                                                                        call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx )
                                                                        call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
                                                                        call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )
                                                                        ueLap2 = uexxxx + 2.*uexxyy + ueyyyy ! Lap^2( u )
                                                                        call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )
                                                                ff = uett - c2*ueLap
                                                                gtt = uett
                                                                    fLap = uettLap - c2*ueLap2 
                                                                    ftt  = uetttt - c2*uettLap
                                                                    gtttt = uetttt
                                                            else
                                                                ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                            end if
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! curvilinear 
                            ! uxx42(i1,i2,i3,kd)=(rsxy(i1,i2,i3,0,0)**2)*urr4(i1,i2,i3,kd)+2.*(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,0))*urs4(i1,i2,i3,kd)+(rsxy(i1,i2,i3,1,0)**2)*uss4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,0,0))*ur4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,1,0))*us4(i1,i2,i3,kd)
                                                        uLap = ulaplacian42(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
                                                        a11 =  c2*rFactor*16./(12.*dr(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 = -c2*rFactor    /(12.*dr(axis)**2)                           ! coeff of u(-2) in r1
                            ! vLap = Lap^2( u) to second-order
                            ! vLap = vlaplacian22 or vlaplacian23 
                                                        vLap = vlaplacian22(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                            ! Here is the leading order term in a21, a22   ** this may not be good enough for stability but should remain accurate ***
                                                        a21 =  -c4*( rFactor**2*4./(dr(axis)**4) )                             ! coeff of u(-1) in r2
                                                        a22 =   c4*( rFactor**2   /(dr(axis)**4) )         
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                else
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                                            if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
                        ! --- get the compatibility forcings for order=2 ---
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                ! 3D 
                                                                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                ueLap = uexx + ueyy + uezz
                                                                call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
                                                            ff = uett - c2*ueLap
                                                            gtt = uett
                                                        else
                                                            ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                          ! uLap = ulaplacian22 or ulaplacian23 
                                                    uLap = ulaplacian23(i1,i2,i3,0)
                                                    r1 = uLap + (ff - gtt)/c2
                                                        a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
                                                if( .false. )then
                          ! check the error
                                                    call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                    write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
                                                end if
                                            else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
                        ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                ghost = 1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                            end if ! mask 
                                        end do
                                        end do
                                        end do
                      !----------------------------------------------------------------
                      ! --- STAGE II fill in first ghost by 4th-order compatibility ---
                      !----------------------------------------------------------------
                        ! Compute and save v = Lap(u) at some points near the boundary
                        !  for use below to compute Lap^2 (u)
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !        +-X-+
                        !          |
                        !         r=0 
                                                do i3=m3a,m3b
                                                do i2=m2a,m2b
                                                do i1=m1a,m1b
                          ! eval Lap(u) on ghost, boundary and first line in:
                                                    if( mask(i1,i2,i3).ne.0 )then 
                                                        v(i1-is1,i2-is2,i3-is3,0) = ulaplacian23(i1-is1,i2-is2,i3-is3,0)
                                                        v(i1    ,i2    ,i3    ,0) = ulaplacian23(i1    ,i2    ,i3    ,0)
                                                        v(i1+is1,i2+is2,i3+is3,0) = ulaplacian23(i1+is1,i2+is2,i3+is3,0)
                                                    end if
                                                end do
                                                end do
                                                end do
                      ! --- fill in two ghost using 4th- order compatibility ---
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                          ! --- get the compatibility forcings at order=4 ---
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                  ! 3D 
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                    call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                    ueLap = uexx + ueyy + uezz
                                                                    call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
                                                                        call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettxx )
                                                                        call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettyy )
                                                                        call ogDeriv(ep,2,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettzz )
                                                                        uettLap = uettxx + uettyy + uettzz
                                                                        call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxx )
                                                                        call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyy )
                                                                        call ogDeriv(ep,0,0,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzz )
                                                                        call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyy )
                                                                        call ogDeriv(ep,0,2,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzz )
                                                                        call ogDeriv(ep,0,0,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzz )
                                                                        ueLap2 = uexxxx + 2.*( uexxyy + uexxzz + ueyyzz)  + ueyyyy + uezzzz ! Lap^2( u )
                                                                        call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )
                                                                ff = uett - c2*ueLap
                                                                gtt = uett
                                                                    fLap = uettLap - c2*ueLap2 
                                                                    ftt  = uetttt - c2*uettLap
                                                                    gtttt = uetttt
                                                            else
                                                                ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
                                                            end if
                          ! u_tt = c^2*Lap(u) + f 
                          ! u_tttt = c^2*Lap(u_tt) + f_tt 
                          !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                          !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                            ! curvilinear 
                            ! uxx42(i1,i2,i3,kd)=(rsxy(i1,i2,i3,0,0)**2)*urr4(i1,i2,i3,kd)+2.*(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,0))*urs4(i1,i2,i3,kd)+(rsxy(i1,i2,i3,1,0)**2)*uss4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,0,0))*ur4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,1,0))*us4(i1,i2,i3,kd)
                                                        uLap = ulaplacian43(i1,i2,i3,0)
                                                        r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
                                                            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2
                                                        a11 =  c2*rFactor*16./(12.*dr(axis)**2)                           ! coeff of u(-1) in r1 
                                                        a12 = -c2*rFactor    /(12.*dr(axis)**2)                           ! coeff of u(-2) in r1
                            ! vLap = Lap^2( u) to second-order
                            ! vLap = vlaplacian22 or vlaplacian23 
                                                        vLap = vlaplacian23(i1,i2,i3,0)
                                                        r2 =  c4*vLap + c2*fLap + ftt - gtttt
                            ! Here is the leading order term in a21, a22   ** this may not be good enough for stability but should remain accurate ***
                                                        a21 =  -c4*( rFactor**2*4./(dr(axis)**4) )                             ! coeff of u(-1) in r2
                                                        a22 =   c4*( rFactor**2   /(dr(axis)**4) )         
                                                if( .false. )then
                                                    write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
                                                end if
                                                    ghost =1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost =2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost        
                          ! Solve
                          !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
                          !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det
                                                    if( .false. )then
                            ! check the error
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                                        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
                                                    end if
                                                end if ! mask .gt. 0
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                end if
                            end if     
                        end if

            else if( orderOfAccuracy.eq.6 )then  

            ! Special macro for order 6 
                        if( forcingOption.eq.noForcing )then
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                            ! ---------- RECTANGULAR  ---------
                            ! This assumes dr(0:2) = dx(0:2)
                                                        uxx      = (2.*u(i1-3,i2,i3,0)-27.*u(i1-2,i2,i3,0)+270.*u(i1-1,i2,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1+1,i2,i3,0)-27.*u(i1+2,i2,i3,0)+2.*u(i1+3,i2,i3,0))/(180.*dr(0)**2)
                                                        uxxxx    = (-u(i1-3,i2,i3,0)+12.*u(i1-2,i2,i3,0)-39.*u(i1-1,i2,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1+1,i2,i3,0)+12.*u(i1+2,i2,i3,0)-u(i1+3,i2,i3,0))/(6.*dr(0)**4)
                                                        uxxxxxx  = (u(i1-3,i2,i3,0)-6.*u(i1-2,i2,i3,0)+15.*u(i1-1,i2,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1+1,i2,i3,0)-6.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(dr(0)**6)
                                                        uyy      = (2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)
                                                        uxxyy    = (2.*(2.*u(i1-3,i2-3,i3,0)-27.*u(i1-3,i2-2,i3,0)+270.*u(i1-3,i2-1,i3,0)-490.*u(i1-3,i2,i3,0)+270.*u(i1-3,i2+1,i3,0)-27.*u(i1-3,i2+2,i3,0)+2.*u(i1-3,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1-2,i2-3,i3,0)-27.*u(i1-2,i2-2,i3,0)+270.*u(i1-2,i2-1,i3,0)-490.*u(i1-2,i2,i3,0)+270.*u(i1-2,i2+1,i3,0)-27.*u(i1-2,i2+2,i3,0)+2.*u(i1-2,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1-1,i2-3,i3,0)-27.*u(i1-1,i2-2,i3,0)+270.*u(i1-1,i2-1,i3,0)-490.*u(i1-1,i2,i3,0)+270.*u(i1-1,i2+1,i3,0)-27.*u(i1-1,i2+2,i3,0)+2.*u(i1-1,i2+3,i3,0))/(180.*dr(1)**2)-490.*(2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1+1,i2-3,i3,0)-27.*u(i1+1,i2-2,i3,0)+270.*u(i1+1,i2-1,i3,0)-490.*u(i1+1,i2,i3,0)+270.*u(i1+1,i2+1,i3,0)-27.*u(i1+1,i2+2,i3,0)+2.*u(i1+1,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1+2,i2-3,i3,0)-27.*u(i1+2,i2-2,i3,0)+270.*u(i1+2,i2-1,i3,0)-490.*u(i1+2,i2,i3,0)+270.*u(i1+2,i2+1,i3,0)-27.*u(i1+2,i2+2,i3,0)+2.*u(i1+2,i2+3,i3,0))/(180.*dr(1)**2)+2.*(2.*u(i1+3,i2-3,i3,0)-27.*u(i1+3,i2-2,i3,0)+270.*u(i1+3,i2-1,i3,0)-490.*u(i1+3,i2,i3,0)+270.*u(i1+3,i2+1,i3,0)-27.*u(i1+3,i2+2,i3,0)+2.*u(i1+3,i2+3,i3,0))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        uxxxxyy  = (-(-u(i1-3,i2-2,i3,0)+16.*u(i1-3,i2-1,i3,0)-30.*u(i1-3,i2,i3,0)+16.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1-2,i2-2,i3,0)+16.*u(i1-2,i2-1,i3,0)-30.*u(i1-2,i2,i3,0)+16.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1-1,i2-2,i3,0)+16.*u(i1-1,i2-1,i3,0)-30.*u(i1-1,i2,i3,0)+16.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1)**2)+56.*(-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1+1,i2-2,i3,0)+16.*u(i1+1,i2-1,i3,0)-30.*u(i1+1,i2,i3,0)+16.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1+2,i2-2,i3,0)+16.*u(i1+2,i2-1,i3,0)-30.*u(i1+2,i2,i3,0)+16.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)**2)-(-u(i1+3,i2-2,i3,0)+16.*u(i1+3,i2-1,i3,0)-30.*u(i1+3,i2,i3,0)+16.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)**2))/(6.*dr(0)**4)
                                                        uyyyy    = (-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)
                                                        uxxyyyy  = (-(-u(i1-2,i2-3,i3,0)+12.*u(i1-2,i2-2,i3,0)-39.*u(i1-2,i2-1,i3,0)+56.*u(i1-2,i2,i3,0)-39.*u(i1-2,i2+1,i3,0)+12.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1-1,i2-3,i3,0)+12.*u(i1-1,i2-2,i3,0)-39.*u(i1-1,i2-1,i3,0)+56.*u(i1-1,i2,i3,0)-39.*u(i1-1,i2+1,i3,0)+12.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(6.*dr(1)**4)-30.*(-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1+1,i2-3,i3,0)+12.*u(i1+1,i2-2,i3,0)-39.*u(i1+1,i2-1,i3,0)+56.*u(i1+1,i2,i3,0)-39.*u(i1+1,i2+1,i3,0)+12.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(6.*dr(1)**4)-(-u(i1+2,i2-3,i3,0)+12.*u(i1+2,i2-2,i3,0)-39.*u(i1+2,i2-1,i3,0)+56.*u(i1+2,i2,i3,0)-39.*u(i1+2,i2+1,i3,0)+12.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(6.*dr(1)**4))/(12.*dr(0)**2)
                                                        uyyyyyy  = (u(i1,i2-3,i3,0)-6.*u(i1,i2-2,i3,0)+15.*u(i1,i2-1,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1,i2+1,i3,0)-6.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(dr(1)**6)
                            ! scale equations for better conditioning
                                                        scale1 = dx(axis)**2/c2; 
                                                        scale2 = dx(axis)**4/c4;
                                                        scale3 = dx(axis)**6/c6; 
                            ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
                                                        r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
                                                        r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
                                                        r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3
                            ! write(*,'("(i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
                                                        if( firstTimeForCBC6 )then
                              ! first time trhu, create the matrix of coefficients
                                                              firstTimeForCBC6 = .false. 
                              ! Order=6: (see MakeGetDerivativesMacro.maple output)
                              ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
                                                            a3(0,0) = c2*( (  3./2.)/(dx(axis)**2) )*scale1   ! coeff of u(-1) in c2*( uxx + uyy )*scale
                                                            a3(0,1) = c2*( (-3./20.)/(dx(axis)**2) )*scale1   ! coeff of u(-2) 
                                                            a3(0,2) = c2*( ( 1./90.)/(dx(axis)**2) )*scale1   ! coeff of u(-3)
                              ! Order=4:
                              ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
                                                            a3(1,0) = c4*( (-13./2.)/(dx(axis)**4) )*scale2
                                                            a3(1,1) = c4*( (     2.)/(dx(axis)**4) )*scale2
                                                            a3(1,2) = c4*( ( -1./6.)/(dx(axis)**4) )*scale2
                              ! Order=2
                              ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
                                                            a3(2,0) = c6*( (    15.)/(dx(axis)**6) )*scale3
                                                            a3(2,1) = c6*( (    -6.)/(dx(axis)**6) )*scale3
                                                            a3(2,2) = c6*( (     1.)/(dx(axis)**6) )*scale3
                              ! Find the inverse -- could be done once for rectangular and saved
                                                            det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
                                                            det=1./det;
                                                            a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
                                                            a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
                                                            a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
                                                            a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
                                                            a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
                                                            a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
                                                            a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
                                                            a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
                                                            a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 
                            !   ! check inverse
                            !   if( .true. )then
                            !     do m1=0,2
                            !       do m2=0,2
                            !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
                            !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
                            !       end do
                            !     end do
                            !   end if
                                                        end if ! end if firstTime
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                else
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                          ! -- 3D ---
                          ! This next seems broken: 
                          ! getSixthDerivatives3d(6,rectangular,OPTION,i1,i2,i3)
                                                    stop 6363
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                end if
                            else
                                if( nd.eq.2 )then
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                            ! ----- curvilinear ----
                            ! ---------- START CURVILINEAR  ---------
                            ! ---------- Parametric derivatives ---------
                                                        ur       = (-u(i1-3,i2,i3,0)+9.*u(i1-2,i2,i3,0)-45.*u(i1-1,i2,i3,0)+45.*u(i1+1,i2,i3,0)-9.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(60.*dr(0))
                                                        urr      = (2.*u(i1-3,i2,i3,0)-27.*u(i1-2,i2,i3,0)+270.*u(i1-1,i2,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1+1,i2,i3,0)-27.*u(i1+2,i2,i3,0)+2.*u(i1+3,i2,i3,0))/(180.*dr(0)**2)
                                                        urrr     = (u(i1-3,i2,i3,0)-8.*u(i1-2,i2,i3,0)+13.*u(i1-1,i2,i3,0)-13.*u(i1+1,i2,i3,0)+8.*u(i1+2,i2,i3,0)-u(i1+3,i2,i3,0))/(8.*dr(0)**3)
                                                        urrrr    = (-u(i1-3,i2,i3,0)+12.*u(i1-2,i2,i3,0)-39.*u(i1-1,i2,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1+1,i2,i3,0)+12.*u(i1+2,i2,i3,0)-u(i1+3,i2,i3,0))/(6.*dr(0)**4)
                                                        urrrrr   = (-u(i1-3,i2,i3,0)+4.*u(i1-2,i2,i3,0)-5.*u(i1-1,i2,i3,0)+5.*u(i1+1,i2,i3,0)-4.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(2.*dr(0)**5)
                                                        urrrrrr  = (u(i1-3,i2,i3,0)-6.*u(i1-2,i2,i3,0)+15.*u(i1-1,i2,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1+1,i2,i3,0)-6.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(dr(0)**6)
                                                        us       = (-u(i1,i2-3,i3,0)+9.*u(i1,i2-2,i3,0)-45.*u(i1,i2-1,i3,0)+45.*u(i1,i2+1,i3,0)-9.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(60.*dr(1))
                                                        urs      = (-(-u(i1-3,i2-3,i3,0)+9.*u(i1-3,i2-2,i3,0)-45.*u(i1-3,i2-1,i3,0)+45.*u(i1-3,i2+1,i3,0)-9.*u(i1-3,i2+2,i3,0)+u(i1-3,i2+3,i3,0))/(60.*dr(1))+9.*(-u(i1-2,i2-3,i3,0)+9.*u(i1-2,i2-2,i3,0)-45.*u(i1-2,i2-1,i3,0)+45.*u(i1-2,i2+1,i3,0)-9.*u(i1-2,i2+2,i3,0)+u(i1-2,i2+3,i3,0))/(60.*dr(1))-45.*(-u(i1-1,i2-3,i3,0)+9.*u(i1-1,i2-2,i3,0)-45.*u(i1-1,i2-1,i3,0)+45.*u(i1-1,i2+1,i3,0)-9.*u(i1-1,i2+2,i3,0)+u(i1-1,i2+3,i3,0))/(60.*dr(1))+45.*(-u(i1+1,i2-3,i3,0)+9.*u(i1+1,i2-2,i3,0)-45.*u(i1+1,i2-1,i3,0)+45.*u(i1+1,i2+1,i3,0)-9.*u(i1+1,i2+2,i3,0)+u(i1+1,i2+3,i3,0))/(60.*dr(1))-9.*(-u(i1+2,i2-3,i3,0)+9.*u(i1+2,i2-2,i3,0)-45.*u(i1+2,i2-1,i3,0)+45.*u(i1+2,i2+1,i3,0)-9.*u(i1+2,i2+2,i3,0)+u(i1+2,i2+3,i3,0))/(60.*dr(1))+(-u(i1+3,i2-3,i3,0)+9.*u(i1+3,i2-2,i3,0)-45.*u(i1+3,i2-1,i3,0)+45.*u(i1+3,i2+1,i3,0)-9.*u(i1+3,i2+2,i3,0)+u(i1+3,i2+3,i3,0))/(60.*dr(1)))/(60.*dr(0))
                                                        urrs     = (2.*(-u(i1-3,i2-3,i3,0)+9.*u(i1-3,i2-2,i3,0)-45.*u(i1-3,i2-1,i3,0)+45.*u(i1-3,i2+1,i3,0)-9.*u(i1-3,i2+2,i3,0)+u(i1-3,i2+3,i3,0))/(60.*dr(1))-27.*(-u(i1-2,i2-3,i3,0)+9.*u(i1-2,i2-2,i3,0)-45.*u(i1-2,i2-1,i3,0)+45.*u(i1-2,i2+1,i3,0)-9.*u(i1-2,i2+2,i3,0)+u(i1-2,i2+3,i3,0))/(60.*dr(1))+270.*(-u(i1-1,i2-3,i3,0)+9.*u(i1-1,i2-2,i3,0)-45.*u(i1-1,i2-1,i3,0)+45.*u(i1-1,i2+1,i3,0)-9.*u(i1-1,i2+2,i3,0)+u(i1-1,i2+3,i3,0))/(60.*dr(1))-490.*(-u(i1,i2-3,i3,0)+9.*u(i1,i2-2,i3,0)-45.*u(i1,i2-1,i3,0)+45.*u(i1,i2+1,i3,0)-9.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(60.*dr(1))+270.*(-u(i1+1,i2-3,i3,0)+9.*u(i1+1,i2-2,i3,0)-45.*u(i1+1,i2-1,i3,0)+45.*u(i1+1,i2+1,i3,0)-9.*u(i1+1,i2+2,i3,0)+u(i1+1,i2+3,i3,0))/(60.*dr(1))-27.*(-u(i1+2,i2-3,i3,0)+9.*u(i1+2,i2-2,i3,0)-45.*u(i1+2,i2-1,i3,0)+45.*u(i1+2,i2+1,i3,0)-9.*u(i1+2,i2+2,i3,0)+u(i1+2,i2+3,i3,0))/(60.*dr(1))+2.*(-u(i1+3,i2-3,i3,0)+9.*u(i1+3,i2-2,i3,0)-45.*u(i1+3,i2-1,i3,0)+45.*u(i1+3,i2+1,i3,0)-9.*u(i1+3,i2+2,i3,0)+u(i1+3,i2+3,i3,0))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        urrrs    = ((u(i1-3,i2-2,i3,0)-8.*u(i1-3,i2-1,i3,0)+8.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))+13.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))-13.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1))-(u(i1+3,i2-2,i3,0)-8.*u(i1+3,i2-1,i3,0)+8.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        urrrrs   = (-(u(i1-3,i2-2,i3,0)-8.*u(i1-3,i2-1,i3,0)+8.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1))+12.*(u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-39.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+56.*(u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))-39.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))+12.*(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1))-(u(i1+3,i2-2,i3,0)-8.*u(i1+3,i2-1,i3,0)+8.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        urrrrrs  = (-(-u(i1-3,i2-1,i3,0)+u(i1-3,i2+1,i3,0))/(2.*dr(1))+4.*(-u(i1-2,i2-1,i3,0)+u(i1-2,i2+1,i3,0))/(2.*dr(1))-5.*(-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))+5.*(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1))-4.*(-u(i1+2,i2-1,i3,0)+u(i1+2,i2+1,i3,0))/(2.*dr(1))+(-u(i1+3,i2-1,i3,0)+u(i1+3,i2+1,i3,0))/(2.*dr(1)))/(2.*dr(0)**5)
                                                        uss      = (2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)
                                                        urss     = (-(2.*u(i1-3,i2-3,i3,0)-27.*u(i1-3,i2-2,i3,0)+270.*u(i1-3,i2-1,i3,0)-490.*u(i1-3,i2,i3,0)+270.*u(i1-3,i2+1,i3,0)-27.*u(i1-3,i2+2,i3,0)+2.*u(i1-3,i2+3,i3,0))/(180.*dr(1)**2)+9.*(2.*u(i1-2,i2-3,i3,0)-27.*u(i1-2,i2-2,i3,0)+270.*u(i1-2,i2-1,i3,0)-490.*u(i1-2,i2,i3,0)+270.*u(i1-2,i2+1,i3,0)-27.*u(i1-2,i2+2,i3,0)+2.*u(i1-2,i2+3,i3,0))/(180.*dr(1)**2)-45.*(2.*u(i1-1,i2-3,i3,0)-27.*u(i1-1,i2-2,i3,0)+270.*u(i1-1,i2-1,i3,0)-490.*u(i1-1,i2,i3,0)+270.*u(i1-1,i2+1,i3,0)-27.*u(i1-1,i2+2,i3,0)+2.*u(i1-1,i2+3,i3,0))/(180.*dr(1)**2)+45.*(2.*u(i1+1,i2-3,i3,0)-27.*u(i1+1,i2-2,i3,0)+270.*u(i1+1,i2-1,i3,0)-490.*u(i1+1,i2,i3,0)+270.*u(i1+1,i2+1,i3,0)-27.*u(i1+1,i2+2,i3,0)+2.*u(i1+1,i2+3,i3,0))/(180.*dr(1)**2)-9.*(2.*u(i1+2,i2-3,i3,0)-27.*u(i1+2,i2-2,i3,0)+270.*u(i1+2,i2-1,i3,0)-490.*u(i1+2,i2,i3,0)+270.*u(i1+2,i2+1,i3,0)-27.*u(i1+2,i2+2,i3,0)+2.*u(i1+2,i2+3,i3,0))/(180.*dr(1)**2)+(2.*u(i1+3,i2-3,i3,0)-27.*u(i1+3,i2-2,i3,0)+270.*u(i1+3,i2-1,i3,0)-490.*u(i1+3,i2,i3,0)+270.*u(i1+3,i2+1,i3,0)-27.*u(i1+3,i2+2,i3,0)+2.*u(i1+3,i2+3,i3,0))/(180.*dr(1)**2))/(60.*dr(0))
                                                        urrss    = (2.*(2.*u(i1-3,i2-3,i3,0)-27.*u(i1-3,i2-2,i3,0)+270.*u(i1-3,i2-1,i3,0)-490.*u(i1-3,i2,i3,0)+270.*u(i1-3,i2+1,i3,0)-27.*u(i1-3,i2+2,i3,0)+2.*u(i1-3,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1-2,i2-3,i3,0)-27.*u(i1-2,i2-2,i3,0)+270.*u(i1-2,i2-1,i3,0)-490.*u(i1-2,i2,i3,0)+270.*u(i1-2,i2+1,i3,0)-27.*u(i1-2,i2+2,i3,0)+2.*u(i1-2,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1-1,i2-3,i3,0)-27.*u(i1-1,i2-2,i3,0)+270.*u(i1-1,i2-1,i3,0)-490.*u(i1-1,i2,i3,0)+270.*u(i1-1,i2+1,i3,0)-27.*u(i1-1,i2+2,i3,0)+2.*u(i1-1,i2+3,i3,0))/(180.*dr(1)**2)-490.*(2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1+1,i2-3,i3,0)-27.*u(i1+1,i2-2,i3,0)+270.*u(i1+1,i2-1,i3,0)-490.*u(i1+1,i2,i3,0)+270.*u(i1+1,i2+1,i3,0)-27.*u(i1+1,i2+2,i3,0)+2.*u(i1+1,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1+2,i2-3,i3,0)-27.*u(i1+2,i2-2,i3,0)+270.*u(i1+2,i2-1,i3,0)-490.*u(i1+2,i2,i3,0)+270.*u(i1+2,i2+1,i3,0)-27.*u(i1+2,i2+2,i3,0)+2.*u(i1+2,i2+3,i3,0))/(180.*dr(1)**2)+2.*(2.*u(i1+3,i2-3,i3,0)-27.*u(i1+3,i2-2,i3,0)+270.*u(i1+3,i2-1,i3,0)-490.*u(i1+3,i2,i3,0)+270.*u(i1+3,i2+1,i3,0)-27.*u(i1+3,i2+2,i3,0)+2.*u(i1+3,i2+3,i3,0))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        urrrss   = ((-u(i1-3,i2-2,i3,0)+16.*u(i1-3,i2-1,i3,0)-30.*u(i1-3,i2,i3,0)+16.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1)**2)-8.*(-u(i1-2,i2-2,i3,0)+16.*u(i1-2,i2-1,i3,0)-30.*u(i1-2,i2,i3,0)+16.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1)**2)+13.*(-u(i1-1,i2-2,i3,0)+16.*u(i1-1,i2-1,i3,0)-30.*u(i1-1,i2,i3,0)+16.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1)**2)-13.*(-u(i1+1,i2-2,i3,0)+16.*u(i1+1,i2-1,i3,0)-30.*u(i1+1,i2,i3,0)+16.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1)**2)+8.*(-u(i1+2,i2-2,i3,0)+16.*u(i1+2,i2-1,i3,0)-30.*u(i1+2,i2,i3,0)+16.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)**2)-(-u(i1+3,i2-2,i3,0)+16.*u(i1+3,i2-1,i3,0)-30.*u(i1+3,i2,i3,0)+16.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        urrrrss  = (-(-u(i1-3,i2-2,i3,0)+16.*u(i1-3,i2-1,i3,0)-30.*u(i1-3,i2,i3,0)+16.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1-2,i2-2,i3,0)+16.*u(i1-2,i2-1,i3,0)-30.*u(i1-2,i2,i3,0)+16.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1-1,i2-2,i3,0)+16.*u(i1-1,i2-1,i3,0)-30.*u(i1-1,i2,i3,0)+16.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1)**2)+56.*(-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1+1,i2-2,i3,0)+16.*u(i1+1,i2-1,i3,0)-30.*u(i1+1,i2,i3,0)+16.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1+2,i2-2,i3,0)+16.*u(i1+2,i2-1,i3,0)-30.*u(i1+2,i2,i3,0)+16.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)**2)-(-u(i1+3,i2-2,i3,0)+16.*u(i1+3,i2-1,i3,0)-30.*u(i1+3,i2,i3,0)+16.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)**2))/(6.*dr(0)**4)
                                                        usss     = (u(i1,i2-3,i3,0)-8.*u(i1,i2-2,i3,0)+13.*u(i1,i2-1,i3,0)-13.*u(i1,i2+1,i3,0)+8.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(8.*dr(1)**3)
                                                        ursss    = ((u(i1-2,i2-3,i3,0)-8.*u(i1-2,i2-2,i3,0)+13.*u(i1-2,i2-1,i3,0)-13.*u(i1-2,i2+1,i3,0)+8.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(8.*dr(1)**3)-8.*(u(i1-1,i2-3,i3,0)-8.*u(i1-1,i2-2,i3,0)+13.*u(i1-1,i2-1,i3,0)-13.*u(i1-1,i2+1,i3,0)+8.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(8.*dr(1)**3)+8.*(u(i1+1,i2-3,i3,0)-8.*u(i1+1,i2-2,i3,0)+13.*u(i1+1,i2-1,i3,0)-13.*u(i1+1,i2+1,i3,0)+8.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(8.*dr(1)**3)-(u(i1+2,i2-3,i3,0)-8.*u(i1+2,i2-2,i3,0)+13.*u(i1+2,i2-1,i3,0)-13.*u(i1+2,i2+1,i3,0)+8.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(8.*dr(1)**3))/(12.*dr(0))
                                                        urrsss   = (-(u(i1-2,i2-3,i3,0)-8.*u(i1-2,i2-2,i3,0)+13.*u(i1-2,i2-1,i3,0)-13.*u(i1-2,i2+1,i3,0)+8.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(8.*dr(1)**3)+16.*(u(i1-1,i2-3,i3,0)-8.*u(i1-1,i2-2,i3,0)+13.*u(i1-1,i2-1,i3,0)-13.*u(i1-1,i2+1,i3,0)+8.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(8.*dr(1)**3)-30.*(u(i1,i2-3,i3,0)-8.*u(i1,i2-2,i3,0)+13.*u(i1,i2-1,i3,0)-13.*u(i1,i2+1,i3,0)+8.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(8.*dr(1)**3)+16.*(u(i1+1,i2-3,i3,0)-8.*u(i1+1,i2-2,i3,0)+13.*u(i1+1,i2-1,i3,0)-13.*u(i1+1,i2+1,i3,0)+8.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(8.*dr(1)**3)-(u(i1+2,i2-3,i3,0)-8.*u(i1+2,i2-2,i3,0)+13.*u(i1+2,i2-1,i3,0)-13.*u(i1+2,i2+1,i3,0)+8.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        urrrsss  = ((u(i1-3,i2-3,i3,0)-8.*u(i1-3,i2-2,i3,0)+13.*u(i1-3,i2-1,i3,0)-13.*u(i1-3,i2+1,i3,0)+8.*u(i1-3,i2+2,i3,0)-u(i1-3,i2+3,i3,0))/(8.*dr(1)**3)-8.*(u(i1-2,i2-3,i3,0)-8.*u(i1-2,i2-2,i3,0)+13.*u(i1-2,i2-1,i3,0)-13.*u(i1-2,i2+1,i3,0)+8.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(8.*dr(1)**3)+13.*(u(i1-1,i2-3,i3,0)-8.*u(i1-1,i2-2,i3,0)+13.*u(i1-1,i2-1,i3,0)-13.*u(i1-1,i2+1,i3,0)+8.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(8.*dr(1)**3)-13.*(u(i1+1,i2-3,i3,0)-8.*u(i1+1,i2-2,i3,0)+13.*u(i1+1,i2-1,i3,0)-13.*u(i1+1,i2+1,i3,0)+8.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(8.*dr(1)**3)+8.*(u(i1+2,i2-3,i3,0)-8.*u(i1+2,i2-2,i3,0)+13.*u(i1+2,i2-1,i3,0)-13.*u(i1+2,i2+1,i3,0)+8.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(8.*dr(1)**3)-(u(i1+3,i2-3,i3,0)-8.*u(i1+3,i2-2,i3,0)+13.*u(i1+3,i2-1,i3,0)-13.*u(i1+3,i2+1,i3,0)+8.*u(i1+3,i2+2,i3,0)-u(i1+3,i2+3,i3,0))/(8.*dr(1)**3))/(8.*dr(0)**3)
                                                        ussss    = (-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)
                                                        urssss   = ((-u(i1-2,i2-3,i3,0)+12.*u(i1-2,i2-2,i3,0)-39.*u(i1-2,i2-1,i3,0)+56.*u(i1-2,i2,i3,0)-39.*u(i1-2,i2+1,i3,0)+12.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(6.*dr(1)**4)-8.*(-u(i1-1,i2-3,i3,0)+12.*u(i1-1,i2-2,i3,0)-39.*u(i1-1,i2-1,i3,0)+56.*u(i1-1,i2,i3,0)-39.*u(i1-1,i2+1,i3,0)+12.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(6.*dr(1)**4)+8.*(-u(i1+1,i2-3,i3,0)+12.*u(i1+1,i2-2,i3,0)-39.*u(i1+1,i2-1,i3,0)+56.*u(i1+1,i2,i3,0)-39.*u(i1+1,i2+1,i3,0)+12.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(6.*dr(1)**4)-(-u(i1+2,i2-3,i3,0)+12.*u(i1+2,i2-2,i3,0)-39.*u(i1+2,i2-1,i3,0)+56.*u(i1+2,i2,i3,0)-39.*u(i1+2,i2+1,i3,0)+12.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(6.*dr(1)**4))/(12.*dr(0))
                                                        urrssss  = (-(-u(i1-2,i2-3,i3,0)+12.*u(i1-2,i2-2,i3,0)-39.*u(i1-2,i2-1,i3,0)+56.*u(i1-2,i2,i3,0)-39.*u(i1-2,i2+1,i3,0)+12.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1-1,i2-3,i3,0)+12.*u(i1-1,i2-2,i3,0)-39.*u(i1-1,i2-1,i3,0)+56.*u(i1-1,i2,i3,0)-39.*u(i1-1,i2+1,i3,0)+12.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(6.*dr(1)**4)-30.*(-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1+1,i2-3,i3,0)+12.*u(i1+1,i2-2,i3,0)-39.*u(i1+1,i2-1,i3,0)+56.*u(i1+1,i2,i3,0)-39.*u(i1+1,i2+1,i3,0)+12.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(6.*dr(1)**4)-(-u(i1+2,i2-3,i3,0)+12.*u(i1+2,i2-2,i3,0)-39.*u(i1+2,i2-1,i3,0)+56.*u(i1+2,i2,i3,0)-39.*u(i1+2,i2+1,i3,0)+12.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(6.*dr(1)**4))/(12.*dr(0)**2)
                                                        usssss   = (-u(i1,i2-3,i3,0)+4.*u(i1,i2-2,i3,0)-5.*u(i1,i2-1,i3,0)+5.*u(i1,i2+1,i3,0)-4.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(2.*dr(1)**5)
                                                        ursssss  = (-(-u(i1-1,i2-3,i3,0)+4.*u(i1-1,i2-2,i3,0)-5.*u(i1-1,i2-1,i3,0)+5.*u(i1-1,i2+1,i3,0)-4.*u(i1-1,i2+2,i3,0)+u(i1-1,i2+3,i3,0))/(2.*dr(1)**5)+(-u(i1+1,i2-3,i3,0)+4.*u(i1+1,i2-2,i3,0)-5.*u(i1+1,i2-1,i3,0)+5.*u(i1+1,i2+1,i3,0)-4.*u(i1+1,i2+2,i3,0)+u(i1+1,i2+3,i3,0))/(2.*dr(1)**5))/(2.*dr(0))
                                                        ussssss  = (u(i1,i2-3,i3,0)-6.*u(i1,i2-2,i3,0)+15.*u(i1,i2-1,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1,i2+1,i3,0)-6.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(dr(1)**6)
                                                        rxr      = (-rx(i1-3,i2,i3)+9.*rx(i1-2,i2,i3)-45.*rx(i1-1,i2,i3)+45.*rx(i1+1,i2,i3)-9.*rx(i1+2,i2,i3)+rx(i1+3,i2,i3))/(60.*dr(0))
                                                        rxrr     = (2.*rx(i1-3,i2,i3)-27.*rx(i1-2,i2,i3)+270.*rx(i1-1,i2,i3)-490.*rx(i1,i2,i3)+270.*rx(i1+1,i2,i3)-27.*rx(i1+2,i2,i3)+2.*rx(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        rxrrr    = (rx(i1-3,i2,i3)-8.*rx(i1-2,i2,i3)+13.*rx(i1-1,i2,i3)-13.*rx(i1+1,i2,i3)+8.*rx(i1+2,i2,i3)-rx(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        rxrrrr   = (-rx(i1-3,i2,i3)+12.*rx(i1-2,i2,i3)-39.*rx(i1-1,i2,i3)+56.*rx(i1,i2,i3)-39.*rx(i1+1,i2,i3)+12.*rx(i1+2,i2,i3)-rx(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        rxrrrrr  = (-rx(i1-3,i2,i3)+4.*rx(i1-2,i2,i3)-5.*rx(i1-1,i2,i3)+5.*rx(i1+1,i2,i3)-4.*rx(i1+2,i2,i3)+rx(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        rxs      = (-rx(i1,i2-3,i3)+9.*rx(i1,i2-2,i3)-45.*rx(i1,i2-1,i3)+45.*rx(i1,i2+1,i3)-9.*rx(i1,i2+2,i3)+rx(i1,i2+3,i3))/(60.*dr(1))
                                                        rxrs     = (-(-rx(i1-3,i2-3,i3)+9.*rx(i1-3,i2-2,i3)-45.*rx(i1-3,i2-1,i3)+45.*rx(i1-3,i2+1,i3)-9.*rx(i1-3,i2+2,i3)+rx(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-rx(i1-2,i2-3,i3)+9.*rx(i1-2,i2-2,i3)-45.*rx(i1-2,i2-1,i3)+45.*rx(i1-2,i2+1,i3)-9.*rx(i1-2,i2+2,i3)+rx(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-rx(i1-1,i2-3,i3)+9.*rx(i1-1,i2-2,i3)-45.*rx(i1-1,i2-1,i3)+45.*rx(i1-1,i2+1,i3)-9.*rx(i1-1,i2+2,i3)+rx(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-rx(i1+1,i2-3,i3)+9.*rx(i1+1,i2-2,i3)-45.*rx(i1+1,i2-1,i3)+45.*rx(i1+1,i2+1,i3)-9.*rx(i1+1,i2+2,i3)+rx(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-rx(i1+2,i2-3,i3)+9.*rx(i1+2,i2-2,i3)-45.*rx(i1+2,i2-1,i3)+45.*rx(i1+2,i2+1,i3)-9.*rx(i1+2,i2+2,i3)+rx(i1+2,i2+3,i3))/(60.*dr(1))+(-rx(i1+3,i2-3,i3)+9.*rx(i1+3,i2-2,i3)-45.*rx(i1+3,i2-1,i3)+45.*rx(i1+3,i2+1,i3)-9.*rx(i1+3,i2+2,i3)+rx(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        rxrrs    = (2.*(-rx(i1-3,i2-3,i3)+9.*rx(i1-3,i2-2,i3)-45.*rx(i1-3,i2-1,i3)+45.*rx(i1-3,i2+1,i3)-9.*rx(i1-3,i2+2,i3)+rx(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-rx(i1-2,i2-3,i3)+9.*rx(i1-2,i2-2,i3)-45.*rx(i1-2,i2-1,i3)+45.*rx(i1-2,i2+1,i3)-9.*rx(i1-2,i2+2,i3)+rx(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-rx(i1-1,i2-3,i3)+9.*rx(i1-1,i2-2,i3)-45.*rx(i1-1,i2-1,i3)+45.*rx(i1-1,i2+1,i3)-9.*rx(i1-1,i2+2,i3)+rx(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-rx(i1,i2-3,i3)+9.*rx(i1,i2-2,i3)-45.*rx(i1,i2-1,i3)+45.*rx(i1,i2+1,i3)-9.*rx(i1,i2+2,i3)+rx(i1,i2+3,i3))/(60.*dr(1))+270.*(-rx(i1+1,i2-3,i3)+9.*rx(i1+1,i2-2,i3)-45.*rx(i1+1,i2-1,i3)+45.*rx(i1+1,i2+1,i3)-9.*rx(i1+1,i2+2,i3)+rx(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-rx(i1+2,i2-3,i3)+9.*rx(i1+2,i2-2,i3)-45.*rx(i1+2,i2-1,i3)+45.*rx(i1+2,i2+1,i3)-9.*rx(i1+2,i2+2,i3)+rx(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-rx(i1+3,i2-3,i3)+9.*rx(i1+3,i2-2,i3)-45.*rx(i1+3,i2-1,i3)+45.*rx(i1+3,i2+1,i3)-9.*rx(i1+3,i2+2,i3)+rx(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        rxrrrs   = ((rx(i1-3,i2-2,i3)-8.*rx(i1-3,i2-1,i3)+8.*rx(i1-3,i2+1,i3)-rx(i1-3,i2+2,i3))/(12.*dr(1))-8.*(rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))+13.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))-13.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))+8.*(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1))-(rx(i1+3,i2-2,i3)-8.*rx(i1+3,i2-1,i3)+8.*rx(i1+3,i2+1,i3)-rx(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        rxrrrrs  = (-(rx(i1-3,i2-2,i3)-8.*rx(i1-3,i2-1,i3)+8.*rx(i1-3,i2+1,i3)-rx(i1-3,i2+2,i3))/(12.*dr(1))+12.*(rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))-39.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))+56.*(rx(i1,i2-2,i3)-8.*rx(i1,i2-1,i3)+8.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1))-39.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))+12.*(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1))-(rx(i1+3,i2-2,i3)-8.*rx(i1+3,i2-1,i3)+8.*rx(i1+3,i2+1,i3)-rx(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        rxss     = (2.*rx(i1,i2-3,i3)-27.*rx(i1,i2-2,i3)+270.*rx(i1,i2-1,i3)-490.*rx(i1,i2,i3)+270.*rx(i1,i2+1,i3)-27.*rx(i1,i2+2,i3)+2.*rx(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        rxrss    = (-(2.*rx(i1-3,i2-3,i3)-27.*rx(i1-3,i2-2,i3)+270.*rx(i1-3,i2-1,i3)-490.*rx(i1-3,i2,i3)+270.*rx(i1-3,i2+1,i3)-27.*rx(i1-3,i2+2,i3)+2.*rx(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*rx(i1-2,i2-3,i3)-27.*rx(i1-2,i2-2,i3)+270.*rx(i1-2,i2-1,i3)-490.*rx(i1-2,i2,i3)+270.*rx(i1-2,i2+1,i3)-27.*rx(i1-2,i2+2,i3)+2.*rx(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*rx(i1-1,i2-3,i3)-27.*rx(i1-1,i2-2,i3)+270.*rx(i1-1,i2-1,i3)-490.*rx(i1-1,i2,i3)+270.*rx(i1-1,i2+1,i3)-27.*rx(i1-1,i2+2,i3)+2.*rx(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*rx(i1+1,i2-3,i3)-27.*rx(i1+1,i2-2,i3)+270.*rx(i1+1,i2-1,i3)-490.*rx(i1+1,i2,i3)+270.*rx(i1+1,i2+1,i3)-27.*rx(i1+1,i2+2,i3)+2.*rx(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*rx(i1+2,i2-3,i3)-27.*rx(i1+2,i2-2,i3)+270.*rx(i1+2,i2-1,i3)-490.*rx(i1+2,i2,i3)+270.*rx(i1+2,i2+1,i3)-27.*rx(i1+2,i2+2,i3)+2.*rx(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*rx(i1+3,i2-3,i3)-27.*rx(i1+3,i2-2,i3)+270.*rx(i1+3,i2-1,i3)-490.*rx(i1+3,i2,i3)+270.*rx(i1+3,i2+1,i3)-27.*rx(i1+3,i2+2,i3)+2.*rx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        rxrrss   = (2.*(2.*rx(i1-3,i2-3,i3)-27.*rx(i1-3,i2-2,i3)+270.*rx(i1-3,i2-1,i3)-490.*rx(i1-3,i2,i3)+270.*rx(i1-3,i2+1,i3)-27.*rx(i1-3,i2+2,i3)+2.*rx(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*rx(i1-2,i2-3,i3)-27.*rx(i1-2,i2-2,i3)+270.*rx(i1-2,i2-1,i3)-490.*rx(i1-2,i2,i3)+270.*rx(i1-2,i2+1,i3)-27.*rx(i1-2,i2+2,i3)+2.*rx(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*rx(i1-1,i2-3,i3)-27.*rx(i1-1,i2-2,i3)+270.*rx(i1-1,i2-1,i3)-490.*rx(i1-1,i2,i3)+270.*rx(i1-1,i2+1,i3)-27.*rx(i1-1,i2+2,i3)+2.*rx(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*rx(i1,i2-3,i3)-27.*rx(i1,i2-2,i3)+270.*rx(i1,i2-1,i3)-490.*rx(i1,i2,i3)+270.*rx(i1,i2+1,i3)-27.*rx(i1,i2+2,i3)+2.*rx(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*rx(i1+1,i2-3,i3)-27.*rx(i1+1,i2-2,i3)+270.*rx(i1+1,i2-1,i3)-490.*rx(i1+1,i2,i3)+270.*rx(i1+1,i2+1,i3)-27.*rx(i1+1,i2+2,i3)+2.*rx(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*rx(i1+2,i2-3,i3)-27.*rx(i1+2,i2-2,i3)+270.*rx(i1+2,i2-1,i3)-490.*rx(i1+2,i2,i3)+270.*rx(i1+2,i2+1,i3)-27.*rx(i1+2,i2+2,i3)+2.*rx(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*rx(i1+3,i2-3,i3)-27.*rx(i1+3,i2-2,i3)+270.*rx(i1+3,i2-1,i3)-490.*rx(i1+3,i2,i3)+270.*rx(i1+3,i2+1,i3)-27.*rx(i1+3,i2+2,i3)+2.*rx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        rxrrrss  = ((-rx(i1-3,i2-2,i3)+16.*rx(i1-3,i2-1,i3)-30.*rx(i1-3,i2,i3)+16.*rx(i1-3,i2+1,i3)-rx(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-rx(i1-2,i2-2,i3)+16.*rx(i1-2,i2-1,i3)-30.*rx(i1-2,i2,i3)+16.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-rx(i1-1,i2-2,i3)+16.*rx(i1-1,i2-1,i3)-30.*rx(i1-1,i2,i3)+16.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-rx(i1+1,i2-2,i3)+16.*rx(i1+1,i2-1,i3)-30.*rx(i1+1,i2,i3)+16.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-rx(i1+2,i2-2,i3)+16.*rx(i1+2,i2-1,i3)-30.*rx(i1+2,i2,i3)+16.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-rx(i1+3,i2-2,i3)+16.*rx(i1+3,i2-1,i3)-30.*rx(i1+3,i2,i3)+16.*rx(i1+3,i2+1,i3)-rx(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        rxsss    = (rx(i1,i2-3,i3)-8.*rx(i1,i2-2,i3)+13.*rx(i1,i2-1,i3)-13.*rx(i1,i2+1,i3)+8.*rx(i1,i2+2,i3)-rx(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        rxrsss   = ((rx(i1-2,i2-3,i3)-8.*rx(i1-2,i2-2,i3)+13.*rx(i1-2,i2-1,i3)-13.*rx(i1-2,i2+1,i3)+8.*rx(i1-2,i2+2,i3)-rx(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(rx(i1-1,i2-3,i3)-8.*rx(i1-1,i2-2,i3)+13.*rx(i1-1,i2-1,i3)-13.*rx(i1-1,i2+1,i3)+8.*rx(i1-1,i2+2,i3)-rx(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(rx(i1+1,i2-3,i3)-8.*rx(i1+1,i2-2,i3)+13.*rx(i1+1,i2-1,i3)-13.*rx(i1+1,i2+1,i3)+8.*rx(i1+1,i2+2,i3)-rx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(rx(i1+2,i2-3,i3)-8.*rx(i1+2,i2-2,i3)+13.*rx(i1+2,i2-1,i3)-13.*rx(i1+2,i2+1,i3)+8.*rx(i1+2,i2+2,i3)-rx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        rxrrsss  = (-(rx(i1-2,i2-3,i3)-8.*rx(i1-2,i2-2,i3)+13.*rx(i1-2,i2-1,i3)-13.*rx(i1-2,i2+1,i3)+8.*rx(i1-2,i2+2,i3)-rx(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(rx(i1-1,i2-3,i3)-8.*rx(i1-1,i2-2,i3)+13.*rx(i1-1,i2-1,i3)-13.*rx(i1-1,i2+1,i3)+8.*rx(i1-1,i2+2,i3)-rx(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(rx(i1,i2-3,i3)-8.*rx(i1,i2-2,i3)+13.*rx(i1,i2-1,i3)-13.*rx(i1,i2+1,i3)+8.*rx(i1,i2+2,i3)-rx(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(rx(i1+1,i2-3,i3)-8.*rx(i1+1,i2-2,i3)+13.*rx(i1+1,i2-1,i3)-13.*rx(i1+1,i2+1,i3)+8.*rx(i1+1,i2+2,i3)-rx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(rx(i1+2,i2-3,i3)-8.*rx(i1+2,i2-2,i3)+13.*rx(i1+2,i2-1,i3)-13.*rx(i1+2,i2+1,i3)+8.*rx(i1+2,i2+2,i3)-rx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        rxssss   = (-rx(i1,i2-3,i3)+12.*rx(i1,i2-2,i3)-39.*rx(i1,i2-1,i3)+56.*rx(i1,i2,i3)-39.*rx(i1,i2+1,i3)+12.*rx(i1,i2+2,i3)-rx(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        rxrssss  = ((-rx(i1-2,i2-3,i3)+12.*rx(i1-2,i2-2,i3)-39.*rx(i1-2,i2-1,i3)+56.*rx(i1-2,i2,i3)-39.*rx(i1-2,i2+1,i3)+12.*rx(i1-2,i2+2,i3)-rx(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-rx(i1-1,i2-3,i3)+12.*rx(i1-1,i2-2,i3)-39.*rx(i1-1,i2-1,i3)+56.*rx(i1-1,i2,i3)-39.*rx(i1-1,i2+1,i3)+12.*rx(i1-1,i2+2,i3)-rx(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-rx(i1+1,i2-3,i3)+12.*rx(i1+1,i2-2,i3)-39.*rx(i1+1,i2-1,i3)+56.*rx(i1+1,i2,i3)-39.*rx(i1+1,i2+1,i3)+12.*rx(i1+1,i2+2,i3)-rx(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-rx(i1+2,i2-3,i3)+12.*rx(i1+2,i2-2,i3)-39.*rx(i1+2,i2-1,i3)+56.*rx(i1+2,i2,i3)-39.*rx(i1+2,i2+1,i3)+12.*rx(i1+2,i2+2,i3)-rx(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        rxsssss  = (-rx(i1,i2-3,i3)+4.*rx(i1,i2-2,i3)-5.*rx(i1,i2-1,i3)+5.*rx(i1,i2+1,i3)-4.*rx(i1,i2+2,i3)+rx(i1,i2+3,i3))/(2.*dr(1)**5)
                                                        ryr      = (-ry(i1-3,i2,i3)+9.*ry(i1-2,i2,i3)-45.*ry(i1-1,i2,i3)+45.*ry(i1+1,i2,i3)-9.*ry(i1+2,i2,i3)+ry(i1+3,i2,i3))/(60.*dr(0))
                                                        ryrr     = (2.*ry(i1-3,i2,i3)-27.*ry(i1-2,i2,i3)+270.*ry(i1-1,i2,i3)-490.*ry(i1,i2,i3)+270.*ry(i1+1,i2,i3)-27.*ry(i1+2,i2,i3)+2.*ry(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        ryrrr    = (ry(i1-3,i2,i3)-8.*ry(i1-2,i2,i3)+13.*ry(i1-1,i2,i3)-13.*ry(i1+1,i2,i3)+8.*ry(i1+2,i2,i3)-ry(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        ryrrrr   = (-ry(i1-3,i2,i3)+12.*ry(i1-2,i2,i3)-39.*ry(i1-1,i2,i3)+56.*ry(i1,i2,i3)-39.*ry(i1+1,i2,i3)+12.*ry(i1+2,i2,i3)-ry(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        ryrrrrr  = (-ry(i1-3,i2,i3)+4.*ry(i1-2,i2,i3)-5.*ry(i1-1,i2,i3)+5.*ry(i1+1,i2,i3)-4.*ry(i1+2,i2,i3)+ry(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        rys      = (-ry(i1,i2-3,i3)+9.*ry(i1,i2-2,i3)-45.*ry(i1,i2-1,i3)+45.*ry(i1,i2+1,i3)-9.*ry(i1,i2+2,i3)+ry(i1,i2+3,i3))/(60.*dr(1))
                                                        ryrs     = (-(-ry(i1-3,i2-3,i3)+9.*ry(i1-3,i2-2,i3)-45.*ry(i1-3,i2-1,i3)+45.*ry(i1-3,i2+1,i3)-9.*ry(i1-3,i2+2,i3)+ry(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-ry(i1-2,i2-3,i3)+9.*ry(i1-2,i2-2,i3)-45.*ry(i1-2,i2-1,i3)+45.*ry(i1-2,i2+1,i3)-9.*ry(i1-2,i2+2,i3)+ry(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-ry(i1-1,i2-3,i3)+9.*ry(i1-1,i2-2,i3)-45.*ry(i1-1,i2-1,i3)+45.*ry(i1-1,i2+1,i3)-9.*ry(i1-1,i2+2,i3)+ry(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-ry(i1+1,i2-3,i3)+9.*ry(i1+1,i2-2,i3)-45.*ry(i1+1,i2-1,i3)+45.*ry(i1+1,i2+1,i3)-9.*ry(i1+1,i2+2,i3)+ry(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-ry(i1+2,i2-3,i3)+9.*ry(i1+2,i2-2,i3)-45.*ry(i1+2,i2-1,i3)+45.*ry(i1+2,i2+1,i3)-9.*ry(i1+2,i2+2,i3)+ry(i1+2,i2+3,i3))/(60.*dr(1))+(-ry(i1+3,i2-3,i3)+9.*ry(i1+3,i2-2,i3)-45.*ry(i1+3,i2-1,i3)+45.*ry(i1+3,i2+1,i3)-9.*ry(i1+3,i2+2,i3)+ry(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        ryrrs    = (2.*(-ry(i1-3,i2-3,i3)+9.*ry(i1-3,i2-2,i3)-45.*ry(i1-3,i2-1,i3)+45.*ry(i1-3,i2+1,i3)-9.*ry(i1-3,i2+2,i3)+ry(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-ry(i1-2,i2-3,i3)+9.*ry(i1-2,i2-2,i3)-45.*ry(i1-2,i2-1,i3)+45.*ry(i1-2,i2+1,i3)-9.*ry(i1-2,i2+2,i3)+ry(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-ry(i1-1,i2-3,i3)+9.*ry(i1-1,i2-2,i3)-45.*ry(i1-1,i2-1,i3)+45.*ry(i1-1,i2+1,i3)-9.*ry(i1-1,i2+2,i3)+ry(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-ry(i1,i2-3,i3)+9.*ry(i1,i2-2,i3)-45.*ry(i1,i2-1,i3)+45.*ry(i1,i2+1,i3)-9.*ry(i1,i2+2,i3)+ry(i1,i2+3,i3))/(60.*dr(1))+270.*(-ry(i1+1,i2-3,i3)+9.*ry(i1+1,i2-2,i3)-45.*ry(i1+1,i2-1,i3)+45.*ry(i1+1,i2+1,i3)-9.*ry(i1+1,i2+2,i3)+ry(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-ry(i1+2,i2-3,i3)+9.*ry(i1+2,i2-2,i3)-45.*ry(i1+2,i2-1,i3)+45.*ry(i1+2,i2+1,i3)-9.*ry(i1+2,i2+2,i3)+ry(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-ry(i1+3,i2-3,i3)+9.*ry(i1+3,i2-2,i3)-45.*ry(i1+3,i2-1,i3)+45.*ry(i1+3,i2+1,i3)-9.*ry(i1+3,i2+2,i3)+ry(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        ryrrrs   = ((ry(i1-3,i2-2,i3)-8.*ry(i1-3,i2-1,i3)+8.*ry(i1-3,i2+1,i3)-ry(i1-3,i2+2,i3))/(12.*dr(1))-8.*(ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))+13.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))-13.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))+8.*(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1))-(ry(i1+3,i2-2,i3)-8.*ry(i1+3,i2-1,i3)+8.*ry(i1+3,i2+1,i3)-ry(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        ryrrrrs  = (-(ry(i1-3,i2-2,i3)-8.*ry(i1-3,i2-1,i3)+8.*ry(i1-3,i2+1,i3)-ry(i1-3,i2+2,i3))/(12.*dr(1))+12.*(ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))-39.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))+56.*(ry(i1,i2-2,i3)-8.*ry(i1,i2-1,i3)+8.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1))-39.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))+12.*(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1))-(ry(i1+3,i2-2,i3)-8.*ry(i1+3,i2-1,i3)+8.*ry(i1+3,i2+1,i3)-ry(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        ryss     = (2.*ry(i1,i2-3,i3)-27.*ry(i1,i2-2,i3)+270.*ry(i1,i2-1,i3)-490.*ry(i1,i2,i3)+270.*ry(i1,i2+1,i3)-27.*ry(i1,i2+2,i3)+2.*ry(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        ryrss    = (-(2.*ry(i1-3,i2-3,i3)-27.*ry(i1-3,i2-2,i3)+270.*ry(i1-3,i2-1,i3)-490.*ry(i1-3,i2,i3)+270.*ry(i1-3,i2+1,i3)-27.*ry(i1-3,i2+2,i3)+2.*ry(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*ry(i1-2,i2-3,i3)-27.*ry(i1-2,i2-2,i3)+270.*ry(i1-2,i2-1,i3)-490.*ry(i1-2,i2,i3)+270.*ry(i1-2,i2+1,i3)-27.*ry(i1-2,i2+2,i3)+2.*ry(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*ry(i1-1,i2-3,i3)-27.*ry(i1-1,i2-2,i3)+270.*ry(i1-1,i2-1,i3)-490.*ry(i1-1,i2,i3)+270.*ry(i1-1,i2+1,i3)-27.*ry(i1-1,i2+2,i3)+2.*ry(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*ry(i1+1,i2-3,i3)-27.*ry(i1+1,i2-2,i3)+270.*ry(i1+1,i2-1,i3)-490.*ry(i1+1,i2,i3)+270.*ry(i1+1,i2+1,i3)-27.*ry(i1+1,i2+2,i3)+2.*ry(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*ry(i1+2,i2-3,i3)-27.*ry(i1+2,i2-2,i3)+270.*ry(i1+2,i2-1,i3)-490.*ry(i1+2,i2,i3)+270.*ry(i1+2,i2+1,i3)-27.*ry(i1+2,i2+2,i3)+2.*ry(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*ry(i1+3,i2-3,i3)-27.*ry(i1+3,i2-2,i3)+270.*ry(i1+3,i2-1,i3)-490.*ry(i1+3,i2,i3)+270.*ry(i1+3,i2+1,i3)-27.*ry(i1+3,i2+2,i3)+2.*ry(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        ryrrss   = (2.*(2.*ry(i1-3,i2-3,i3)-27.*ry(i1-3,i2-2,i3)+270.*ry(i1-3,i2-1,i3)-490.*ry(i1-3,i2,i3)+270.*ry(i1-3,i2+1,i3)-27.*ry(i1-3,i2+2,i3)+2.*ry(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*ry(i1-2,i2-3,i3)-27.*ry(i1-2,i2-2,i3)+270.*ry(i1-2,i2-1,i3)-490.*ry(i1-2,i2,i3)+270.*ry(i1-2,i2+1,i3)-27.*ry(i1-2,i2+2,i3)+2.*ry(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*ry(i1-1,i2-3,i3)-27.*ry(i1-1,i2-2,i3)+270.*ry(i1-1,i2-1,i3)-490.*ry(i1-1,i2,i3)+270.*ry(i1-1,i2+1,i3)-27.*ry(i1-1,i2+2,i3)+2.*ry(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*ry(i1,i2-3,i3)-27.*ry(i1,i2-2,i3)+270.*ry(i1,i2-1,i3)-490.*ry(i1,i2,i3)+270.*ry(i1,i2+1,i3)-27.*ry(i1,i2+2,i3)+2.*ry(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*ry(i1+1,i2-3,i3)-27.*ry(i1+1,i2-2,i3)+270.*ry(i1+1,i2-1,i3)-490.*ry(i1+1,i2,i3)+270.*ry(i1+1,i2+1,i3)-27.*ry(i1+1,i2+2,i3)+2.*ry(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*ry(i1+2,i2-3,i3)-27.*ry(i1+2,i2-2,i3)+270.*ry(i1+2,i2-1,i3)-490.*ry(i1+2,i2,i3)+270.*ry(i1+2,i2+1,i3)-27.*ry(i1+2,i2+2,i3)+2.*ry(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*ry(i1+3,i2-3,i3)-27.*ry(i1+3,i2-2,i3)+270.*ry(i1+3,i2-1,i3)-490.*ry(i1+3,i2,i3)+270.*ry(i1+3,i2+1,i3)-27.*ry(i1+3,i2+2,i3)+2.*ry(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        ryrrrss  = ((-ry(i1-3,i2-2,i3)+16.*ry(i1-3,i2-1,i3)-30.*ry(i1-3,i2,i3)+16.*ry(i1-3,i2+1,i3)-ry(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-ry(i1-2,i2-2,i3)+16.*ry(i1-2,i2-1,i3)-30.*ry(i1-2,i2,i3)+16.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-ry(i1-1,i2-2,i3)+16.*ry(i1-1,i2-1,i3)-30.*ry(i1-1,i2,i3)+16.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-ry(i1+1,i2-2,i3)+16.*ry(i1+1,i2-1,i3)-30.*ry(i1+1,i2,i3)+16.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-ry(i1+2,i2-2,i3)+16.*ry(i1+2,i2-1,i3)-30.*ry(i1+2,i2,i3)+16.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-ry(i1+3,i2-2,i3)+16.*ry(i1+3,i2-1,i3)-30.*ry(i1+3,i2,i3)+16.*ry(i1+3,i2+1,i3)-ry(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        rysss    = (ry(i1,i2-3,i3)-8.*ry(i1,i2-2,i3)+13.*ry(i1,i2-1,i3)-13.*ry(i1,i2+1,i3)+8.*ry(i1,i2+2,i3)-ry(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        ryrsss   = ((ry(i1-2,i2-3,i3)-8.*ry(i1-2,i2-2,i3)+13.*ry(i1-2,i2-1,i3)-13.*ry(i1-2,i2+1,i3)+8.*ry(i1-2,i2+2,i3)-ry(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(ry(i1-1,i2-3,i3)-8.*ry(i1-1,i2-2,i3)+13.*ry(i1-1,i2-1,i3)-13.*ry(i1-1,i2+1,i3)+8.*ry(i1-1,i2+2,i3)-ry(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(ry(i1+1,i2-3,i3)-8.*ry(i1+1,i2-2,i3)+13.*ry(i1+1,i2-1,i3)-13.*ry(i1+1,i2+1,i3)+8.*ry(i1+1,i2+2,i3)-ry(i1+1,i2+3,i3))/(8.*dr(1)**3)-(ry(i1+2,i2-3,i3)-8.*ry(i1+2,i2-2,i3)+13.*ry(i1+2,i2-1,i3)-13.*ry(i1+2,i2+1,i3)+8.*ry(i1+2,i2+2,i3)-ry(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        ryrrsss  = (-(ry(i1-2,i2-3,i3)-8.*ry(i1-2,i2-2,i3)+13.*ry(i1-2,i2-1,i3)-13.*ry(i1-2,i2+1,i3)+8.*ry(i1-2,i2+2,i3)-ry(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(ry(i1-1,i2-3,i3)-8.*ry(i1-1,i2-2,i3)+13.*ry(i1-1,i2-1,i3)-13.*ry(i1-1,i2+1,i3)+8.*ry(i1-1,i2+2,i3)-ry(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(ry(i1,i2-3,i3)-8.*ry(i1,i2-2,i3)+13.*ry(i1,i2-1,i3)-13.*ry(i1,i2+1,i3)+8.*ry(i1,i2+2,i3)-ry(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(ry(i1+1,i2-3,i3)-8.*ry(i1+1,i2-2,i3)+13.*ry(i1+1,i2-1,i3)-13.*ry(i1+1,i2+1,i3)+8.*ry(i1+1,i2+2,i3)-ry(i1+1,i2+3,i3))/(8.*dr(1)**3)-(ry(i1+2,i2-3,i3)-8.*ry(i1+2,i2-2,i3)+13.*ry(i1+2,i2-1,i3)-13.*ry(i1+2,i2+1,i3)+8.*ry(i1+2,i2+2,i3)-ry(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        ryssss   = (-ry(i1,i2-3,i3)+12.*ry(i1,i2-2,i3)-39.*ry(i1,i2-1,i3)+56.*ry(i1,i2,i3)-39.*ry(i1,i2+1,i3)+12.*ry(i1,i2+2,i3)-ry(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        ryrssss  = ((-ry(i1-2,i2-3,i3)+12.*ry(i1-2,i2-2,i3)-39.*ry(i1-2,i2-1,i3)+56.*ry(i1-2,i2,i3)-39.*ry(i1-2,i2+1,i3)+12.*ry(i1-2,i2+2,i3)-ry(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-ry(i1-1,i2-3,i3)+12.*ry(i1-1,i2-2,i3)-39.*ry(i1-1,i2-1,i3)+56.*ry(i1-1,i2,i3)-39.*ry(i1-1,i2+1,i3)+12.*ry(i1-1,i2+2,i3)-ry(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-ry(i1+1,i2-3,i3)+12.*ry(i1+1,i2-2,i3)-39.*ry(i1+1,i2-1,i3)+56.*ry(i1+1,i2,i3)-39.*ry(i1+1,i2+1,i3)+12.*ry(i1+1,i2+2,i3)-ry(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-ry(i1+2,i2-3,i3)+12.*ry(i1+2,i2-2,i3)-39.*ry(i1+2,i2-1,i3)+56.*ry(i1+2,i2,i3)-39.*ry(i1+2,i2+1,i3)+12.*ry(i1+2,i2+2,i3)-ry(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        rysssss  = (-ry(i1,i2-3,i3)+4.*ry(i1,i2-2,i3)-5.*ry(i1,i2-1,i3)+5.*ry(i1,i2+1,i3)-4.*ry(i1,i2+2,i3)+ry(i1,i2+3,i3))/(2.*dr(1)**5)
                                                        sxr      = (-sx(i1-3,i2,i3)+9.*sx(i1-2,i2,i3)-45.*sx(i1-1,i2,i3)+45.*sx(i1+1,i2,i3)-9.*sx(i1+2,i2,i3)+sx(i1+3,i2,i3))/(60.*dr(0))
                                                        sxrr     = (2.*sx(i1-3,i2,i3)-27.*sx(i1-2,i2,i3)+270.*sx(i1-1,i2,i3)-490.*sx(i1,i2,i3)+270.*sx(i1+1,i2,i3)-27.*sx(i1+2,i2,i3)+2.*sx(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        sxrrr    = (sx(i1-3,i2,i3)-8.*sx(i1-2,i2,i3)+13.*sx(i1-1,i2,i3)-13.*sx(i1+1,i2,i3)+8.*sx(i1+2,i2,i3)-sx(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        sxrrrr   = (-sx(i1-3,i2,i3)+12.*sx(i1-2,i2,i3)-39.*sx(i1-1,i2,i3)+56.*sx(i1,i2,i3)-39.*sx(i1+1,i2,i3)+12.*sx(i1+2,i2,i3)-sx(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        sxrrrrr  = (-sx(i1-3,i2,i3)+4.*sx(i1-2,i2,i3)-5.*sx(i1-1,i2,i3)+5.*sx(i1+1,i2,i3)-4.*sx(i1+2,i2,i3)+sx(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        sxs      = (-sx(i1,i2-3,i3)+9.*sx(i1,i2-2,i3)-45.*sx(i1,i2-1,i3)+45.*sx(i1,i2+1,i3)-9.*sx(i1,i2+2,i3)+sx(i1,i2+3,i3))/(60.*dr(1))
                                                        sxrs     = (-(-sx(i1-3,i2-3,i3)+9.*sx(i1-3,i2-2,i3)-45.*sx(i1-3,i2-1,i3)+45.*sx(i1-3,i2+1,i3)-9.*sx(i1-3,i2+2,i3)+sx(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-sx(i1-2,i2-3,i3)+9.*sx(i1-2,i2-2,i3)-45.*sx(i1-2,i2-1,i3)+45.*sx(i1-2,i2+1,i3)-9.*sx(i1-2,i2+2,i3)+sx(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-sx(i1-1,i2-3,i3)+9.*sx(i1-1,i2-2,i3)-45.*sx(i1-1,i2-1,i3)+45.*sx(i1-1,i2+1,i3)-9.*sx(i1-1,i2+2,i3)+sx(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-sx(i1+1,i2-3,i3)+9.*sx(i1+1,i2-2,i3)-45.*sx(i1+1,i2-1,i3)+45.*sx(i1+1,i2+1,i3)-9.*sx(i1+1,i2+2,i3)+sx(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-sx(i1+2,i2-3,i3)+9.*sx(i1+2,i2-2,i3)-45.*sx(i1+2,i2-1,i3)+45.*sx(i1+2,i2+1,i3)-9.*sx(i1+2,i2+2,i3)+sx(i1+2,i2+3,i3))/(60.*dr(1))+(-sx(i1+3,i2-3,i3)+9.*sx(i1+3,i2-2,i3)-45.*sx(i1+3,i2-1,i3)+45.*sx(i1+3,i2+1,i3)-9.*sx(i1+3,i2+2,i3)+sx(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        sxrrs    = (2.*(-sx(i1-3,i2-3,i3)+9.*sx(i1-3,i2-2,i3)-45.*sx(i1-3,i2-1,i3)+45.*sx(i1-3,i2+1,i3)-9.*sx(i1-3,i2+2,i3)+sx(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-sx(i1-2,i2-3,i3)+9.*sx(i1-2,i2-2,i3)-45.*sx(i1-2,i2-1,i3)+45.*sx(i1-2,i2+1,i3)-9.*sx(i1-2,i2+2,i3)+sx(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-sx(i1-1,i2-3,i3)+9.*sx(i1-1,i2-2,i3)-45.*sx(i1-1,i2-1,i3)+45.*sx(i1-1,i2+1,i3)-9.*sx(i1-1,i2+2,i3)+sx(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-sx(i1,i2-3,i3)+9.*sx(i1,i2-2,i3)-45.*sx(i1,i2-1,i3)+45.*sx(i1,i2+1,i3)-9.*sx(i1,i2+2,i3)+sx(i1,i2+3,i3))/(60.*dr(1))+270.*(-sx(i1+1,i2-3,i3)+9.*sx(i1+1,i2-2,i3)-45.*sx(i1+1,i2-1,i3)+45.*sx(i1+1,i2+1,i3)-9.*sx(i1+1,i2+2,i3)+sx(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-sx(i1+2,i2-3,i3)+9.*sx(i1+2,i2-2,i3)-45.*sx(i1+2,i2-1,i3)+45.*sx(i1+2,i2+1,i3)-9.*sx(i1+2,i2+2,i3)+sx(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-sx(i1+3,i2-3,i3)+9.*sx(i1+3,i2-2,i3)-45.*sx(i1+3,i2-1,i3)+45.*sx(i1+3,i2+1,i3)-9.*sx(i1+3,i2+2,i3)+sx(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        sxrrrs   = ((sx(i1-3,i2-2,i3)-8.*sx(i1-3,i2-1,i3)+8.*sx(i1-3,i2+1,i3)-sx(i1-3,i2+2,i3))/(12.*dr(1))-8.*(sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))+13.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))-13.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))+8.*(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1))-(sx(i1+3,i2-2,i3)-8.*sx(i1+3,i2-1,i3)+8.*sx(i1+3,i2+1,i3)-sx(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        sxrrrrs  = (-(sx(i1-3,i2-2,i3)-8.*sx(i1-3,i2-1,i3)+8.*sx(i1-3,i2+1,i3)-sx(i1-3,i2+2,i3))/(12.*dr(1))+12.*(sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))-39.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))+56.*(sx(i1,i2-2,i3)-8.*sx(i1,i2-1,i3)+8.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1))-39.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))+12.*(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1))-(sx(i1+3,i2-2,i3)-8.*sx(i1+3,i2-1,i3)+8.*sx(i1+3,i2+1,i3)-sx(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        sxss     = (2.*sx(i1,i2-3,i3)-27.*sx(i1,i2-2,i3)+270.*sx(i1,i2-1,i3)-490.*sx(i1,i2,i3)+270.*sx(i1,i2+1,i3)-27.*sx(i1,i2+2,i3)+2.*sx(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        sxrss    = (-(2.*sx(i1-3,i2-3,i3)-27.*sx(i1-3,i2-2,i3)+270.*sx(i1-3,i2-1,i3)-490.*sx(i1-3,i2,i3)+270.*sx(i1-3,i2+1,i3)-27.*sx(i1-3,i2+2,i3)+2.*sx(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*sx(i1-2,i2-3,i3)-27.*sx(i1-2,i2-2,i3)+270.*sx(i1-2,i2-1,i3)-490.*sx(i1-2,i2,i3)+270.*sx(i1-2,i2+1,i3)-27.*sx(i1-2,i2+2,i3)+2.*sx(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*sx(i1-1,i2-3,i3)-27.*sx(i1-1,i2-2,i3)+270.*sx(i1-1,i2-1,i3)-490.*sx(i1-1,i2,i3)+270.*sx(i1-1,i2+1,i3)-27.*sx(i1-1,i2+2,i3)+2.*sx(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*sx(i1+1,i2-3,i3)-27.*sx(i1+1,i2-2,i3)+270.*sx(i1+1,i2-1,i3)-490.*sx(i1+1,i2,i3)+270.*sx(i1+1,i2+1,i3)-27.*sx(i1+1,i2+2,i3)+2.*sx(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*sx(i1+2,i2-3,i3)-27.*sx(i1+2,i2-2,i3)+270.*sx(i1+2,i2-1,i3)-490.*sx(i1+2,i2,i3)+270.*sx(i1+2,i2+1,i3)-27.*sx(i1+2,i2+2,i3)+2.*sx(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*sx(i1+3,i2-3,i3)-27.*sx(i1+3,i2-2,i3)+270.*sx(i1+3,i2-1,i3)-490.*sx(i1+3,i2,i3)+270.*sx(i1+3,i2+1,i3)-27.*sx(i1+3,i2+2,i3)+2.*sx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        sxrrss   = (2.*(2.*sx(i1-3,i2-3,i3)-27.*sx(i1-3,i2-2,i3)+270.*sx(i1-3,i2-1,i3)-490.*sx(i1-3,i2,i3)+270.*sx(i1-3,i2+1,i3)-27.*sx(i1-3,i2+2,i3)+2.*sx(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sx(i1-2,i2-3,i3)-27.*sx(i1-2,i2-2,i3)+270.*sx(i1-2,i2-1,i3)-490.*sx(i1-2,i2,i3)+270.*sx(i1-2,i2+1,i3)-27.*sx(i1-2,i2+2,i3)+2.*sx(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sx(i1-1,i2-3,i3)-27.*sx(i1-1,i2-2,i3)+270.*sx(i1-1,i2-1,i3)-490.*sx(i1-1,i2,i3)+270.*sx(i1-1,i2+1,i3)-27.*sx(i1-1,i2+2,i3)+2.*sx(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*sx(i1,i2-3,i3)-27.*sx(i1,i2-2,i3)+270.*sx(i1,i2-1,i3)-490.*sx(i1,i2,i3)+270.*sx(i1,i2+1,i3)-27.*sx(i1,i2+2,i3)+2.*sx(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sx(i1+1,i2-3,i3)-27.*sx(i1+1,i2-2,i3)+270.*sx(i1+1,i2-1,i3)-490.*sx(i1+1,i2,i3)+270.*sx(i1+1,i2+1,i3)-27.*sx(i1+1,i2+2,i3)+2.*sx(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sx(i1+2,i2-3,i3)-27.*sx(i1+2,i2-2,i3)+270.*sx(i1+2,i2-1,i3)-490.*sx(i1+2,i2,i3)+270.*sx(i1+2,i2+1,i3)-27.*sx(i1+2,i2+2,i3)+2.*sx(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*sx(i1+3,i2-3,i3)-27.*sx(i1+3,i2-2,i3)+270.*sx(i1+3,i2-1,i3)-490.*sx(i1+3,i2,i3)+270.*sx(i1+3,i2+1,i3)-27.*sx(i1+3,i2+2,i3)+2.*sx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        sxrrrss  = ((-sx(i1-3,i2-2,i3)+16.*sx(i1-3,i2-1,i3)-30.*sx(i1-3,i2,i3)+16.*sx(i1-3,i2+1,i3)-sx(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-sx(i1-2,i2-2,i3)+16.*sx(i1-2,i2-1,i3)-30.*sx(i1-2,i2,i3)+16.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-sx(i1-1,i2-2,i3)+16.*sx(i1-1,i2-1,i3)-30.*sx(i1-1,i2,i3)+16.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-sx(i1+1,i2-2,i3)+16.*sx(i1+1,i2-1,i3)-30.*sx(i1+1,i2,i3)+16.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-sx(i1+2,i2-2,i3)+16.*sx(i1+2,i2-1,i3)-30.*sx(i1+2,i2,i3)+16.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-sx(i1+3,i2-2,i3)+16.*sx(i1+3,i2-1,i3)-30.*sx(i1+3,i2,i3)+16.*sx(i1+3,i2+1,i3)-sx(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        sxsss    = (sx(i1,i2-3,i3)-8.*sx(i1,i2-2,i3)+13.*sx(i1,i2-1,i3)-13.*sx(i1,i2+1,i3)+8.*sx(i1,i2+2,i3)-sx(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        sxrsss   = ((sx(i1-2,i2-3,i3)-8.*sx(i1-2,i2-2,i3)+13.*sx(i1-2,i2-1,i3)-13.*sx(i1-2,i2+1,i3)+8.*sx(i1-2,i2+2,i3)-sx(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(sx(i1-1,i2-3,i3)-8.*sx(i1-1,i2-2,i3)+13.*sx(i1-1,i2-1,i3)-13.*sx(i1-1,i2+1,i3)+8.*sx(i1-1,i2+2,i3)-sx(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(sx(i1+1,i2-3,i3)-8.*sx(i1+1,i2-2,i3)+13.*sx(i1+1,i2-1,i3)-13.*sx(i1+1,i2+1,i3)+8.*sx(i1+1,i2+2,i3)-sx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sx(i1+2,i2-3,i3)-8.*sx(i1+2,i2-2,i3)+13.*sx(i1+2,i2-1,i3)-13.*sx(i1+2,i2+1,i3)+8.*sx(i1+2,i2+2,i3)-sx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        sxrrsss  = (-(sx(i1-2,i2-3,i3)-8.*sx(i1-2,i2-2,i3)+13.*sx(i1-2,i2-1,i3)-13.*sx(i1-2,i2+1,i3)+8.*sx(i1-2,i2+2,i3)-sx(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(sx(i1-1,i2-3,i3)-8.*sx(i1-1,i2-2,i3)+13.*sx(i1-1,i2-1,i3)-13.*sx(i1-1,i2+1,i3)+8.*sx(i1-1,i2+2,i3)-sx(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(sx(i1,i2-3,i3)-8.*sx(i1,i2-2,i3)+13.*sx(i1,i2-1,i3)-13.*sx(i1,i2+1,i3)+8.*sx(i1,i2+2,i3)-sx(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(sx(i1+1,i2-3,i3)-8.*sx(i1+1,i2-2,i3)+13.*sx(i1+1,i2-1,i3)-13.*sx(i1+1,i2+1,i3)+8.*sx(i1+1,i2+2,i3)-sx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sx(i1+2,i2-3,i3)-8.*sx(i1+2,i2-2,i3)+13.*sx(i1+2,i2-1,i3)-13.*sx(i1+2,i2+1,i3)+8.*sx(i1+2,i2+2,i3)-sx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        sxssss   = (-sx(i1,i2-3,i3)+12.*sx(i1,i2-2,i3)-39.*sx(i1,i2-1,i3)+56.*sx(i1,i2,i3)-39.*sx(i1,i2+1,i3)+12.*sx(i1,i2+2,i3)-sx(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        sxrssss  = ((-sx(i1-2,i2-3,i3)+12.*sx(i1-2,i2-2,i3)-39.*sx(i1-2,i2-1,i3)+56.*sx(i1-2,i2,i3)-39.*sx(i1-2,i2+1,i3)+12.*sx(i1-2,i2+2,i3)-sx(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-sx(i1-1,i2-3,i3)+12.*sx(i1-1,i2-2,i3)-39.*sx(i1-1,i2-1,i3)+56.*sx(i1-1,i2,i3)-39.*sx(i1-1,i2+1,i3)+12.*sx(i1-1,i2+2,i3)-sx(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-sx(i1+1,i2-3,i3)+12.*sx(i1+1,i2-2,i3)-39.*sx(i1+1,i2-1,i3)+56.*sx(i1+1,i2,i3)-39.*sx(i1+1,i2+1,i3)+12.*sx(i1+1,i2+2,i3)-sx(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-sx(i1+2,i2-3,i3)+12.*sx(i1+2,i2-2,i3)-39.*sx(i1+2,i2-1,i3)+56.*sx(i1+2,i2,i3)-39.*sx(i1+2,i2+1,i3)+12.*sx(i1+2,i2+2,i3)-sx(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        sxsssss  = (-sx(i1,i2-3,i3)+4.*sx(i1,i2-2,i3)-5.*sx(i1,i2-1,i3)+5.*sx(i1,i2+1,i3)-4.*sx(i1,i2+2,i3)+sx(i1,i2+3,i3))/(2.*dr(1)**5)
                                                        syr      = (-sy(i1-3,i2,i3)+9.*sy(i1-2,i2,i3)-45.*sy(i1-1,i2,i3)+45.*sy(i1+1,i2,i3)-9.*sy(i1+2,i2,i3)+sy(i1+3,i2,i3))/(60.*dr(0))
                                                        syrr     = (2.*sy(i1-3,i2,i3)-27.*sy(i1-2,i2,i3)+270.*sy(i1-1,i2,i3)-490.*sy(i1,i2,i3)+270.*sy(i1+1,i2,i3)-27.*sy(i1+2,i2,i3)+2.*sy(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        syrrr    = (sy(i1-3,i2,i3)-8.*sy(i1-2,i2,i3)+13.*sy(i1-1,i2,i3)-13.*sy(i1+1,i2,i3)+8.*sy(i1+2,i2,i3)-sy(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        syrrrr   = (-sy(i1-3,i2,i3)+12.*sy(i1-2,i2,i3)-39.*sy(i1-1,i2,i3)+56.*sy(i1,i2,i3)-39.*sy(i1+1,i2,i3)+12.*sy(i1+2,i2,i3)-sy(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        syrrrrr  = (-sy(i1-3,i2,i3)+4.*sy(i1-2,i2,i3)-5.*sy(i1-1,i2,i3)+5.*sy(i1+1,i2,i3)-4.*sy(i1+2,i2,i3)+sy(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        sys      = (-sy(i1,i2-3,i3)+9.*sy(i1,i2-2,i3)-45.*sy(i1,i2-1,i3)+45.*sy(i1,i2+1,i3)-9.*sy(i1,i2+2,i3)+sy(i1,i2+3,i3))/(60.*dr(1))
                                                        syrs     = (-(-sy(i1-3,i2-3,i3)+9.*sy(i1-3,i2-2,i3)-45.*sy(i1-3,i2-1,i3)+45.*sy(i1-3,i2+1,i3)-9.*sy(i1-3,i2+2,i3)+sy(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-sy(i1-2,i2-3,i3)+9.*sy(i1-2,i2-2,i3)-45.*sy(i1-2,i2-1,i3)+45.*sy(i1-2,i2+1,i3)-9.*sy(i1-2,i2+2,i3)+sy(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-sy(i1-1,i2-3,i3)+9.*sy(i1-1,i2-2,i3)-45.*sy(i1-1,i2-1,i3)+45.*sy(i1-1,i2+1,i3)-9.*sy(i1-1,i2+2,i3)+sy(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-sy(i1+1,i2-3,i3)+9.*sy(i1+1,i2-2,i3)-45.*sy(i1+1,i2-1,i3)+45.*sy(i1+1,i2+1,i3)-9.*sy(i1+1,i2+2,i3)+sy(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-sy(i1+2,i2-3,i3)+9.*sy(i1+2,i2-2,i3)-45.*sy(i1+2,i2-1,i3)+45.*sy(i1+2,i2+1,i3)-9.*sy(i1+2,i2+2,i3)+sy(i1+2,i2+3,i3))/(60.*dr(1))+(-sy(i1+3,i2-3,i3)+9.*sy(i1+3,i2-2,i3)-45.*sy(i1+3,i2-1,i3)+45.*sy(i1+3,i2+1,i3)-9.*sy(i1+3,i2+2,i3)+sy(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        syrrs    = (2.*(-sy(i1-3,i2-3,i3)+9.*sy(i1-3,i2-2,i3)-45.*sy(i1-3,i2-1,i3)+45.*sy(i1-3,i2+1,i3)-9.*sy(i1-3,i2+2,i3)+sy(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-sy(i1-2,i2-3,i3)+9.*sy(i1-2,i2-2,i3)-45.*sy(i1-2,i2-1,i3)+45.*sy(i1-2,i2+1,i3)-9.*sy(i1-2,i2+2,i3)+sy(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-sy(i1-1,i2-3,i3)+9.*sy(i1-1,i2-2,i3)-45.*sy(i1-1,i2-1,i3)+45.*sy(i1-1,i2+1,i3)-9.*sy(i1-1,i2+2,i3)+sy(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-sy(i1,i2-3,i3)+9.*sy(i1,i2-2,i3)-45.*sy(i1,i2-1,i3)+45.*sy(i1,i2+1,i3)-9.*sy(i1,i2+2,i3)+sy(i1,i2+3,i3))/(60.*dr(1))+270.*(-sy(i1+1,i2-3,i3)+9.*sy(i1+1,i2-2,i3)-45.*sy(i1+1,i2-1,i3)+45.*sy(i1+1,i2+1,i3)-9.*sy(i1+1,i2+2,i3)+sy(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-sy(i1+2,i2-3,i3)+9.*sy(i1+2,i2-2,i3)-45.*sy(i1+2,i2-1,i3)+45.*sy(i1+2,i2+1,i3)-9.*sy(i1+2,i2+2,i3)+sy(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-sy(i1+3,i2-3,i3)+9.*sy(i1+3,i2-2,i3)-45.*sy(i1+3,i2-1,i3)+45.*sy(i1+3,i2+1,i3)-9.*sy(i1+3,i2+2,i3)+sy(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        syrrrs   = ((sy(i1-3,i2-2,i3)-8.*sy(i1-3,i2-1,i3)+8.*sy(i1-3,i2+1,i3)-sy(i1-3,i2+2,i3))/(12.*dr(1))-8.*(sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))+13.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))-13.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))+8.*(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1))-(sy(i1+3,i2-2,i3)-8.*sy(i1+3,i2-1,i3)+8.*sy(i1+3,i2+1,i3)-sy(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        syrrrrs  = (-(sy(i1-3,i2-2,i3)-8.*sy(i1-3,i2-1,i3)+8.*sy(i1-3,i2+1,i3)-sy(i1-3,i2+2,i3))/(12.*dr(1))+12.*(sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))-39.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))+56.*(sy(i1,i2-2,i3)-8.*sy(i1,i2-1,i3)+8.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1))-39.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))+12.*(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1))-(sy(i1+3,i2-2,i3)-8.*sy(i1+3,i2-1,i3)+8.*sy(i1+3,i2+1,i3)-sy(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        syss     = (2.*sy(i1,i2-3,i3)-27.*sy(i1,i2-2,i3)+270.*sy(i1,i2-1,i3)-490.*sy(i1,i2,i3)+270.*sy(i1,i2+1,i3)-27.*sy(i1,i2+2,i3)+2.*sy(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        syrss    = (-(2.*sy(i1-3,i2-3,i3)-27.*sy(i1-3,i2-2,i3)+270.*sy(i1-3,i2-1,i3)-490.*sy(i1-3,i2,i3)+270.*sy(i1-3,i2+1,i3)-27.*sy(i1-3,i2+2,i3)+2.*sy(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*sy(i1-2,i2-3,i3)-27.*sy(i1-2,i2-2,i3)+270.*sy(i1-2,i2-1,i3)-490.*sy(i1-2,i2,i3)+270.*sy(i1-2,i2+1,i3)-27.*sy(i1-2,i2+2,i3)+2.*sy(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*sy(i1-1,i2-3,i3)-27.*sy(i1-1,i2-2,i3)+270.*sy(i1-1,i2-1,i3)-490.*sy(i1-1,i2,i3)+270.*sy(i1-1,i2+1,i3)-27.*sy(i1-1,i2+2,i3)+2.*sy(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*sy(i1+1,i2-3,i3)-27.*sy(i1+1,i2-2,i3)+270.*sy(i1+1,i2-1,i3)-490.*sy(i1+1,i2,i3)+270.*sy(i1+1,i2+1,i3)-27.*sy(i1+1,i2+2,i3)+2.*sy(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*sy(i1+2,i2-3,i3)-27.*sy(i1+2,i2-2,i3)+270.*sy(i1+2,i2-1,i3)-490.*sy(i1+2,i2,i3)+270.*sy(i1+2,i2+1,i3)-27.*sy(i1+2,i2+2,i3)+2.*sy(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*sy(i1+3,i2-3,i3)-27.*sy(i1+3,i2-2,i3)+270.*sy(i1+3,i2-1,i3)-490.*sy(i1+3,i2,i3)+270.*sy(i1+3,i2+1,i3)-27.*sy(i1+3,i2+2,i3)+2.*sy(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        syrrss   = (2.*(2.*sy(i1-3,i2-3,i3)-27.*sy(i1-3,i2-2,i3)+270.*sy(i1-3,i2-1,i3)-490.*sy(i1-3,i2,i3)+270.*sy(i1-3,i2+1,i3)-27.*sy(i1-3,i2+2,i3)+2.*sy(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sy(i1-2,i2-3,i3)-27.*sy(i1-2,i2-2,i3)+270.*sy(i1-2,i2-1,i3)-490.*sy(i1-2,i2,i3)+270.*sy(i1-2,i2+1,i3)-27.*sy(i1-2,i2+2,i3)+2.*sy(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sy(i1-1,i2-3,i3)-27.*sy(i1-1,i2-2,i3)+270.*sy(i1-1,i2-1,i3)-490.*sy(i1-1,i2,i3)+270.*sy(i1-1,i2+1,i3)-27.*sy(i1-1,i2+2,i3)+2.*sy(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*sy(i1,i2-3,i3)-27.*sy(i1,i2-2,i3)+270.*sy(i1,i2-1,i3)-490.*sy(i1,i2,i3)+270.*sy(i1,i2+1,i3)-27.*sy(i1,i2+2,i3)+2.*sy(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sy(i1+1,i2-3,i3)-27.*sy(i1+1,i2-2,i3)+270.*sy(i1+1,i2-1,i3)-490.*sy(i1+1,i2,i3)+270.*sy(i1+1,i2+1,i3)-27.*sy(i1+1,i2+2,i3)+2.*sy(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sy(i1+2,i2-3,i3)-27.*sy(i1+2,i2-2,i3)+270.*sy(i1+2,i2-1,i3)-490.*sy(i1+2,i2,i3)+270.*sy(i1+2,i2+1,i3)-27.*sy(i1+2,i2+2,i3)+2.*sy(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*sy(i1+3,i2-3,i3)-27.*sy(i1+3,i2-2,i3)+270.*sy(i1+3,i2-1,i3)-490.*sy(i1+3,i2,i3)+270.*sy(i1+3,i2+1,i3)-27.*sy(i1+3,i2+2,i3)+2.*sy(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        syrrrss  = ((-sy(i1-3,i2-2,i3)+16.*sy(i1-3,i2-1,i3)-30.*sy(i1-3,i2,i3)+16.*sy(i1-3,i2+1,i3)-sy(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-sy(i1-2,i2-2,i3)+16.*sy(i1-2,i2-1,i3)-30.*sy(i1-2,i2,i3)+16.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-sy(i1-1,i2-2,i3)+16.*sy(i1-1,i2-1,i3)-30.*sy(i1-1,i2,i3)+16.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-sy(i1+1,i2-2,i3)+16.*sy(i1+1,i2-1,i3)-30.*sy(i1+1,i2,i3)+16.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-sy(i1+2,i2-2,i3)+16.*sy(i1+2,i2-1,i3)-30.*sy(i1+2,i2,i3)+16.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-sy(i1+3,i2-2,i3)+16.*sy(i1+3,i2-1,i3)-30.*sy(i1+3,i2,i3)+16.*sy(i1+3,i2+1,i3)-sy(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        sysss    = (sy(i1,i2-3,i3)-8.*sy(i1,i2-2,i3)+13.*sy(i1,i2-1,i3)-13.*sy(i1,i2+1,i3)+8.*sy(i1,i2+2,i3)-sy(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        syrsss   = ((sy(i1-2,i2-3,i3)-8.*sy(i1-2,i2-2,i3)+13.*sy(i1-2,i2-1,i3)-13.*sy(i1-2,i2+1,i3)+8.*sy(i1-2,i2+2,i3)-sy(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(sy(i1-1,i2-3,i3)-8.*sy(i1-1,i2-2,i3)+13.*sy(i1-1,i2-1,i3)-13.*sy(i1-1,i2+1,i3)+8.*sy(i1-1,i2+2,i3)-sy(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(sy(i1+1,i2-3,i3)-8.*sy(i1+1,i2-2,i3)+13.*sy(i1+1,i2-1,i3)-13.*sy(i1+1,i2+1,i3)+8.*sy(i1+1,i2+2,i3)-sy(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sy(i1+2,i2-3,i3)-8.*sy(i1+2,i2-2,i3)+13.*sy(i1+2,i2-1,i3)-13.*sy(i1+2,i2+1,i3)+8.*sy(i1+2,i2+2,i3)-sy(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        syrrsss  = (-(sy(i1-2,i2-3,i3)-8.*sy(i1-2,i2-2,i3)+13.*sy(i1-2,i2-1,i3)-13.*sy(i1-2,i2+1,i3)+8.*sy(i1-2,i2+2,i3)-sy(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(sy(i1-1,i2-3,i3)-8.*sy(i1-1,i2-2,i3)+13.*sy(i1-1,i2-1,i3)-13.*sy(i1-1,i2+1,i3)+8.*sy(i1-1,i2+2,i3)-sy(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(sy(i1,i2-3,i3)-8.*sy(i1,i2-2,i3)+13.*sy(i1,i2-1,i3)-13.*sy(i1,i2+1,i3)+8.*sy(i1,i2+2,i3)-sy(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(sy(i1+1,i2-3,i3)-8.*sy(i1+1,i2-2,i3)+13.*sy(i1+1,i2-1,i3)-13.*sy(i1+1,i2+1,i3)+8.*sy(i1+1,i2+2,i3)-sy(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sy(i1+2,i2-3,i3)-8.*sy(i1+2,i2-2,i3)+13.*sy(i1+2,i2-1,i3)-13.*sy(i1+2,i2+1,i3)+8.*sy(i1+2,i2+2,i3)-sy(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        syssss   = (-sy(i1,i2-3,i3)+12.*sy(i1,i2-2,i3)-39.*sy(i1,i2-1,i3)+56.*sy(i1,i2,i3)-39.*sy(i1,i2+1,i3)+12.*sy(i1,i2+2,i3)-sy(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        syrssss  = ((-sy(i1-2,i2-3,i3)+12.*sy(i1-2,i2-2,i3)-39.*sy(i1-2,i2-1,i3)+56.*sy(i1-2,i2,i3)-39.*sy(i1-2,i2+1,i3)+12.*sy(i1-2,i2+2,i3)-sy(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-sy(i1-1,i2-3,i3)+12.*sy(i1-1,i2-2,i3)-39.*sy(i1-1,i2-1,i3)+56.*sy(i1-1,i2,i3)-39.*sy(i1-1,i2+1,i3)+12.*sy(i1-1,i2+2,i3)-sy(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-sy(i1+1,i2-3,i3)+12.*sy(i1+1,i2-2,i3)-39.*sy(i1+1,i2-1,i3)+56.*sy(i1+1,i2,i3)-39.*sy(i1+1,i2+1,i3)+12.*sy(i1+1,i2+2,i3)-sy(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-sy(i1+2,i2-3,i3)+12.*sy(i1+2,i2-2,i3)-39.*sy(i1+2,i2-1,i3)+56.*sy(i1+2,i2,i3)-39.*sy(i1+2,i2+1,i3)+12.*sy(i1+2,i2+2,i3)-sy(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        sysssss  = (-sy(i1,i2-3,i3)+4.*sy(i1,i2-2,i3)-5.*sy(i1,i2-1,i3)+5.*sy(i1,i2+1,i3)-4.*sy(i1,i2+2,i3)+sy(i1,i2+3,i3))/(2.*dr(1)**5)
                            ! ---------- Spatial derivatives of metrics rx, sx, ry, ... ---------
                                                        rxi = rx(i1,i2,i3)
                                                        ryi = ry(i1,i2,i3)
                                                        sxi = sx(i1,i2,i3)
                                                        syi = sy(i1,i2,i3)
                                                        rxx      = rxi*rxr+sxi*rxs
                                                        rxy      = ryi*rxr+syi*rxs
                                                        ryy      = ryi*ryr+syi*rys
                                                        sxx      = rxi*sxr+sxi*sxs
                                                        sxy      = ryi*sxr+syi*sxs
                                                        syy      = ryi*syr+syi*sys
                                                        rxxx     = rxi**2*rxrr+2.*rxi*sxi*rxrs+sxi**2*rxss+rxx*rxr+sxx*rxs
                                                        rxxy     = rxi*ryi*rxrr+(rxi*syi+ryi*sxi)*rxrs+sxi*syi*rxss+rxy*rxr+sxy*rxs
                                                        rxyy     = ryi**2*rxrr+2.*ryi*syi*rxrs+syi**2*rxss+ryy*rxr+syy*rxs
                                                        ryyy     = ryi**2*ryrr+2.*ryi*syi*ryrs+syi**2*ryss+ryy*ryr+syy*rys
                                                        sxxx     = rxi**2*sxrr+2.*rxi*sxi*sxrs+sxi**2*sxss+rxx*sxr+sxx*sxs
                                                        sxxy     = rxi*ryi*sxrr+(rxi*syi+ryi*sxi)*sxrs+sxi*syi*sxss+rxy*sxr+sxy*sxs
                                                        sxyy     = ryi**2*sxrr+2.*ryi*syi*sxrs+syi**2*sxss+ryy*sxr+syy*sxs
                                                        syyy     = ryi**2*syrr+2.*ryi*syi*syrs+syi**2*syss+ryy*syr+syy*sys
                                                        rxxxx    = rxi**3*rxrrr+3.*rxi**2*sxi*rxrrs+3.*rxi*sxi**2*rxrss+sxi**3*rxsss+3.*rxi*rxx*rxrr+(3.*rxi*sxx+3.*rxx*sxi)*rxrs+3.*sxi*sxx*rxss+rxxx*rxr+sxxx*rxs
                                                        rxxxy    = rxi**2*ryi*rxrrr+(rxi**2*syi+2.*rxi*ryi*sxi)*rxrrs+(2.*rxi*sxi*syi+ryi*sxi**2)*rxrss+sxi**2*syi*rxsss+(2.*rxi*rxy+rxx*ryi)*rxrr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*rxrs+(2.*sxi*sxy+sxx*syi)*rxss+rxxy*rxr+sxxy*rxs
                                                        rxxyy    = rxi*ryi**2*rxrrr+(2.*rxi*ryi*syi+ryi**2*sxi)*rxrrs+(rxi*syi**2+2.*ryi*sxi*syi)*rxrss+sxi*syi**2*rxsss+(rxi*ryy+2.*rxy*ryi)*rxrr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*rxrs+(sxi*syy+2.*sxy*syi)*rxss+rxyy*rxr+sxyy*rxs
                                                        rxyyy    = ryi**3*rxrrr+3.*ryi**2*syi*rxrrs+3.*ryi*syi**2*rxrss+syi**3*rxsss+3.*ryi*ryy*rxrr+(3.*ryi*syy+3.*ryy*syi)*rxrs+3.*syi*syy*rxss+ryyy*rxr+syyy*rxs
                                                        ryyyy    = ryi**3*ryrrr+3.*ryi**2*syi*ryrrs+3.*ryi*syi**2*ryrss+syi**3*rysss+3.*ryi*ryy*ryrr+(3.*ryi*syy+3.*ryy*syi)*ryrs+3.*syi*syy*ryss+ryyy*ryr+syyy*rys
                                                        sxxxx    = rxi**3*sxrrr+3.*rxi**2*sxi*sxrrs+3.*rxi*sxi**2*sxrss+sxi**3*sxsss+3.*rxi*rxx*sxrr+(3.*rxi*sxx+3.*rxx*sxi)*sxrs+3.*sxi*sxx*sxss+rxxx*sxr+sxxx*sxs
                                                        sxxxy    = rxi**2*ryi*sxrrr+(rxi**2*syi+2.*rxi*ryi*sxi)*sxrrs+(2.*rxi*sxi*syi+ryi*sxi**2)*sxrss+sxi**2*syi*sxsss+(2.*rxi*rxy+rxx*ryi)*sxrr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*sxrs+(2.*sxi*sxy+sxx*syi)*sxss+rxxy*sxr+sxxy*sxs
                                                        sxxyy    = rxi*ryi**2*sxrrr+(2.*rxi*ryi*syi+ryi**2*sxi)*sxrrs+(rxi*syi**2+2.*ryi*sxi*syi)*sxrss+sxi*syi**2*sxsss+(rxi*ryy+2.*rxy*ryi)*sxrr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*sxrs+(sxi*syy+2.*sxy*syi)*sxss+rxyy*sxr+sxyy*sxs
                                                        sxyyy    = ryi**3*sxrrr+3.*ryi**2*syi*sxrrs+3.*ryi*syi**2*sxrss+syi**3*sxsss+3.*ryi*ryy*sxrr+(3.*ryi*syy+3.*ryy*syi)*sxrs+3.*syi*syy*sxss+ryyy*sxr+syyy*sxs
                                                        syyyy    = ryi**3*syrrr+3.*ryi**2*syi*syrrs+3.*ryi*syi**2*syrss+syi**3*sysss+3.*ryi*ryy*syrr+(3.*ryi*syy+3.*ryy*syi)*syrs+3.*syi*syy*syss+ryyy*syr+syyy*sys
                                                        rxxxxx   = rxi**4*rxrrrr+4.*rxi**3*sxi*rxrrrs+6.*rxi**2*sxi**2*rxrrss+4.*rxi*sxi**3*rxrsss+sxi**4*rxssss+6.*rxi**2*rxx*rxrrr+(6.*rxi**2*sxx+12.*rxi*rxx*sxi)*rxrrs+(12.*rxi*sxi*sxx+6.*rxx*sxi**2)*rxrss+6.*sxi**2*sxx*rxsss+(4.*rxi*rxxx+3.*rxx**2)*rxrr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*rxrs+(4.*sxi*sxxx+3.*sxx**2)*rxss+rxxxx*rxr+sxxxx*rxs
                                                        rxxxxy   = rxi**3*ryi*rxrrrr+(rxi**3*syi+3.*rxi**2*ryi*sxi)*rxrrrs+(3.*rxi**2*sxi*syi+3.*rxi*ryi*sxi**2)*rxrrss+(3.*rxi*sxi**2*syi+ryi*sxi**3)*rxrsss+sxi**3*syi*rxssss+(3.*rxi**2*rxy+3.*rxi*rxx*ryi)*rxrrr+(3.*rxi**2*sxy+(3.*rxx*syi+6.*rxy*sxi+3.*ryi*sxx)*rxi+3.*rxx*ryi*sxi)*rxrrs+((6.*sxi*sxy+3.*sxx*syi)*rxi+3.*rxy*sxi**2+(3.*rxx*syi+3.*ryi*sxx)*sxi)*rxrss+(3.*sxi**2*sxy+3.*sxi*sxx*syi)*rxsss+(3.*rxi*rxxy+3.*rxx*rxy+rxxx*ryi)*rxrr+(3.*rxi*sxxy+3.*rxx*sxy+rxxx*syi+3.*rxxy*sxi+3.*rxy*sxx+ryi*sxxx)*rxrs+(3.*sxi*sxxy+3.*sxx*sxy+sxxx*syi)*rxss+rxxxy*rxr+sxxxy*rxs
                                                        rxxxyy   = rxi**2*ryi**2*rxrrrr+(2.*rxi**2*ryi*syi+2.*rxi*ryi**2*sxi)*rxrrrs+(rxi**2*syi**2+4.*rxi*ryi*sxi*syi+ryi**2*sxi**2)*rxrrss+(2.*rxi*sxi*syi**2+2.*ryi*sxi**2*syi)*rxrsss+sxi**2*syi**2*rxssss+(rxi**2*ryy+4.*rxi*rxy*ryi+rxx*ryi**2)*rxrrr+(rxi**2*syy+(4.*rxy*syi+4.*ryi*sxy+2.*ryy*sxi)*rxi+ryi**2*sxx+(2.*rxx*syi+4.*rxy*sxi)*ryi)*rxrrs+((2.*sxi*syy+4.*sxy*syi)*rxi+(4.*sxi*sxy+2.*sxx*syi)*ryi+ryy*sxi**2+4.*rxy*syi*sxi+rxx*syi**2)*rxrss+(sxi**2*syy+4.*sxi*sxy*syi+sxx*syi**2)*rxsss+(2.*rxi*rxyy+rxx*ryy+2.*rxxy*ryi+2.*rxy**2)*rxrr+(2.*rxi*sxyy+rxx*syy+2.*rxxy*syi+4.*rxy*sxy+2.*rxyy*sxi+2.*ryi*sxxy+ryy*sxx)*rxrs+(2.*sxi*sxyy+sxx*syy+2.*sxxy*syi+2.*sxy**2)*rxss+rxxyy*rxr+sxxyy*rxs
                                                        rxxyyy   = rxi*ryi**3*rxrrrr+(3.*rxi*ryi**2*syi+ryi**3*sxi)*rxrrrs+(3.*rxi*ryi*syi**2+3.*ryi**2*sxi*syi)*rxrrss+(rxi*syi**3+3.*ryi*sxi*syi**2)*rxrsss+sxi*syi**3*rxssss+(3.*rxi*ryi*ryy+3.*rxy*ryi**2)*rxrrr+(3.*ryi**2*sxy+(3.*rxi*syy+6.*rxy*syi+3.*ryy*sxi)*ryi+3.*ryy*rxi*syi)*rxrrs+((3.*sxi*syy+6.*sxy*syi)*ryi+3.*rxy*syi**2+(3.*rxi*syy+3.*ryy*sxi)*syi)*rxrss+(3.*sxi*syi*syy+3.*sxy*syi**2)*rxsss+(rxi*ryyy+3.*rxy*ryy+3.*rxyy*ryi)*rxrr+(rxi*syyy+3.*rxy*syy+3.*rxyy*syi+3.*ryi*sxyy+3.*ryy*sxy+ryyy*sxi)*rxrs+(sxi*syyy+3.*sxy*syy+3.*sxyy*syi)*rxss+rxyyy*rxr+sxyyy*rxs
                                                        rxyyyy   = ryi**4*rxrrrr+4.*ryi**3*syi*rxrrrs+6.*ryi**2*syi**2*rxrrss+4.*ryi*syi**3*rxrsss+syi**4*rxssss+6.*ryi**2*ryy*rxrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*rxrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*rxrss+6.*syi**2*syy*rxsss+(4.*ryi*ryyy+3.*ryy**2)*rxrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*rxrs+(4.*syi*syyy+3.*syy**2)*rxss+ryyyy*rxr+syyyy*rxs
                                                        ryyyyy   = ryi**4*ryrrrr+4.*ryi**3*syi*ryrrrs+6.*ryi**2*syi**2*ryrrss+4.*ryi*syi**3*ryrsss+syi**4*ryssss+6.*ryi**2*ryy*ryrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*ryrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*ryrss+6.*syi**2*syy*rysss+(4.*ryi*ryyy+3.*ryy**2)*ryrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*ryrs+(4.*syi*syyy+3.*syy**2)*ryss+ryyyy*ryr+syyyy*rys
                                                        sxxxxx   = rxi**4*sxrrrr+4.*rxi**3*sxi*sxrrrs+6.*rxi**2*sxi**2*sxrrss+4.*rxi*sxi**3*sxrsss+sxi**4*sxssss+6.*rxi**2*rxx*sxrrr+(6.*rxi**2*sxx+12.*rxi*rxx*sxi)*sxrrs+(12.*rxi*sxi*sxx+6.*rxx*sxi**2)*sxrss+6.*sxi**2*sxx*sxsss+(4.*rxi*rxxx+3.*rxx**2)*sxrr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*sxrs+(4.*sxi*sxxx+3.*sxx**2)*sxss+rxxxx*sxr+sxxxx*sxs
                                                        sxxxxy   = rxi**3*ryi*sxrrrr+(rxi**3*syi+3.*rxi**2*ryi*sxi)*sxrrrs+(3.*rxi**2*sxi*syi+3.*rxi*ryi*sxi**2)*sxrrss+(3.*rxi*sxi**2*syi+ryi*sxi**3)*sxrsss+sxi**3*syi*sxssss+(3.*rxi**2*rxy+3.*rxi*rxx*ryi)*sxrrr+(3.*rxi**2*sxy+(3.*rxx*syi+6.*rxy*sxi+3.*ryi*sxx)*rxi+3.*rxx*ryi*sxi)*sxrrs+((6.*sxi*sxy+3.*sxx*syi)*rxi+3.*rxy*sxi**2+(3.*rxx*syi+3.*ryi*sxx)*sxi)*sxrss+(3.*sxi**2*sxy+3.*sxi*sxx*syi)*sxsss+(3.*rxi*rxxy+3.*rxx*rxy+rxxx*ryi)*sxrr+(3.*rxi*sxxy+3.*rxx*sxy+rxxx*syi+3.*rxxy*sxi+3.*rxy*sxx+ryi*sxxx)*sxrs+(3.*sxi*sxxy+3.*sxx*sxy+sxxx*syi)*sxss+rxxxy*sxr+sxxxy*sxs
                                                        sxxxyy   = rxi**2*ryi**2*sxrrrr+(2.*rxi**2*ryi*syi+2.*rxi*ryi**2*sxi)*sxrrrs+(rxi**2*syi**2+4.*rxi*ryi*sxi*syi+ryi**2*sxi**2)*sxrrss+(2.*rxi*sxi*syi**2+2.*ryi*sxi**2*syi)*sxrsss+sxi**2*syi**2*sxssss+(rxi**2*ryy+4.*rxi*rxy*ryi+rxx*ryi**2)*sxrrr+(rxi**2*syy+(4.*rxy*syi+4.*ryi*sxy+2.*ryy*sxi)*rxi+ryi**2*sxx+(2.*rxx*syi+4.*rxy*sxi)*ryi)*sxrrs+((2.*sxi*syy+4.*sxy*syi)*rxi+(4.*sxi*sxy+2.*sxx*syi)*ryi+ryy*sxi**2+4.*rxy*syi*sxi+rxx*syi**2)*sxrss+(sxi**2*syy+4.*sxi*sxy*syi+sxx*syi**2)*sxsss+(2.*rxi*rxyy+rxx*ryy+2.*rxxy*ryi+2.*rxy**2)*sxrr+(2.*rxi*sxyy+rxx*syy+2.*rxxy*syi+4.*rxy*sxy+2.*rxyy*sxi+2.*ryi*sxxy+ryy*sxx)*sxrs+(2.*sxi*sxyy+sxx*syy+2.*sxxy*syi+2.*sxy**2)*sxss+rxxyy*sxr+sxxyy*sxs
                                                        sxxyyy   = rxi*ryi**3*sxrrrr+(3.*rxi*ryi**2*syi+ryi**3*sxi)*sxrrrs+(3.*rxi*ryi*syi**2+3.*ryi**2*sxi*syi)*sxrrss+(rxi*syi**3+3.*ryi*sxi*syi**2)*sxrsss+sxi*syi**3*sxssss+(3.*rxi*ryi*ryy+3.*rxy*ryi**2)*sxrrr+(3.*ryi**2*sxy+(3.*rxi*syy+6.*rxy*syi+3.*ryy*sxi)*ryi+3.*ryy*rxi*syi)*sxrrs+((3.*sxi*syy+6.*sxy*syi)*ryi+3.*rxy*syi**2+(3.*rxi*syy+3.*ryy*sxi)*syi)*sxrss+(3.*sxi*syi*syy+3.*sxy*syi**2)*sxsss+(rxi*ryyy+3.*rxy*ryy+3.*rxyy*ryi)*sxrr+(rxi*syyy+3.*rxy*syy+3.*rxyy*syi+3.*ryi*sxyy+3.*ryy*sxy+ryyy*sxi)*sxrs+(sxi*syyy+3.*sxy*syy+3.*sxyy*syi)*sxss+rxyyy*sxr+sxyyy*sxs
                                                        sxyyyy   = ryi**4*sxrrrr+4.*ryi**3*syi*sxrrrs+6.*ryi**2*syi**2*sxrrss+4.*ryi*syi**3*sxrsss+syi**4*sxssss+6.*ryi**2*ryy*sxrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*sxrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*sxrss+6.*syi**2*syy*sxsss+(4.*ryi*ryyy+3.*ryy**2)*sxrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*sxrs+(4.*syi*syyy+3.*syy**2)*sxss+ryyyy*sxr+syyyy*sxs
                                                        syyyyy   = ryi**4*syrrrr+4.*ryi**3*syi*syrrrs+6.*ryi**2*syi**2*syrrss+4.*ryi*syi**3*syrsss+syi**4*syssss+6.*ryi**2*ryy*syrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*syrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*syrss+6.*syi**2*syy*sysss+(4.*ryi*ryyy+3.*ryy**2)*syrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*syrs+(4.*syi*syyy+3.*syy**2)*syss+ryyyy*syr+syyyy*sys
                                                        rxxxxxx  = rxi**5*rxrrrrr+5.*sxi*rxi**4*rxrrrrs+10.*rxi**3*sxi**2*rxrrrss+10.*rxi**2*sxi**3*rxrrsss+5.*rxi*sxi**4*rxrssss+sxi**5*rxsssss+10.*rxi**3*rxx*rxrrrr+(10.*rxi**3*sxx+30.*rxi**2*rxx*sxi)*rxrrrs+(30.*rxi**2*sxi*sxx+30.*rxi*rxx*sxi**2)*rxrrss+(30.*rxi*sxi**2*sxx+10.*rxx*sxi**3)*rxrsss+10.*sxi**3*sxx*rxssss+(10.*rxi**2*rxxx+15.*rxi*rxx**2)*rxrrr+(10.*rxi**2*sxxx+(30.*rxx*sxx+20.*rxxx*sxi)*rxi+15.*rxx**2*sxi)*rxrrs+((20.*sxi*sxxx+15.*sxx**2)*rxi+10.*rxxx*sxi**2+30.*rxx*sxx*sxi)*rxrss+(10.*sxi**2*sxxx+15.*sxi*sxx**2)*rxsss+(5.*rxi*rxxxx+10.*rxx*rxxx)*rxrr+(5.*rxi*sxxxx+10.*rxx*sxxx+10.*rxxx*sxx+5.*rxxxx*sxi)*rxrs+(5.*sxi*sxxxx+10.*sxx*sxxx)*rxss+rxxxxx*rxr+sxxxxx*rxs
                                                        rxxxxxy  = ryi*rxi**4*rxrrrrr+(rxi**4*syi+4.*rxi**3*ryi*sxi)*rxrrrrs+(4.*rxi**3*sxi*syi+6.*rxi**2*ryi*sxi**2)*rxrrrss+(6.*rxi**2*sxi**2*syi+4.*rxi*ryi*sxi**3)*rxrrsss+(4.*rxi*sxi**3*syi+ryi*sxi**4)*rxrssss+syi*sxi**4*rxsssss+(4.*rxi**3*rxy+6.*rxi**2*rxx*ryi)*rxrrrr+(4.*rxi**3*sxy+(6.*rxx*syi+12.*rxy*sxi+6.*ryi*sxx)*rxi**2+12.*rxx*ryi*sxi*rxi)*rxrrrs+((12.*sxi*sxy+6.*sxx*syi)*rxi**2+(12.*rxy*sxi**2+(12.*rxx*syi+12.*ryi*sxx)*sxi)*rxi+6.*rxx*ryi*sxi**2)*rxrrss+((12.*sxi**2*sxy+12.*sxi*sxx*syi)*rxi+4.*rxy*sxi**3+(6.*rxx*syi+6.*ryi*sxx)*sxi**2)*rxrsss+(4.*sxi**3*sxy+6.*sxi**2*sxx*syi)*rxssss+(6.*rxxy*rxi**2+(12.*rxx*rxy+4.*rxxx*ryi)*rxi+3.*rxx**2*ryi)*rxrrr+(6.*rxi**2*sxxy+(12.*rxx*sxy+4.*rxxx*syi+12.*rxxy*sxi+12.*rxy*sxx+4.*ryi*sxxx)*rxi+(12.*rxx*rxy+4.*rxxx*ryi)*sxi+6.*rxx*sxx*ryi+3.*rxx**2*syi)*rxrrs+((12.*sxi*sxxy+12.*sxx*sxy+4.*sxxx*syi)*rxi+6.*rxxy*sxi**2+(12.*rxx*sxy+4.*rxxx*syi+12.*rxy*sxx+4.*ryi*sxxx)*sxi+3.*sxx**2*ryi+6.*rxx*sxx*syi)*rxrss+(6.*sxi**2*sxxy+(12.*sxx*sxy+4.*sxxx*syi)*sxi+3.*sxx**2*syi)*rxsss+(4.*rxi*rxxxy+6.*rxx*rxxy+4.*rxxx*rxy+rxxxx*ryi)*rxrr+(4.*rxi*sxxxy+6.*rxx*sxxy+4.*rxxx*sxy+rxxxx*syi+4.*rxxxy*sxi+6.*rxxy*sxx+4.*rxy*sxxx+ryi*sxxxx)*rxrs+(4.*sxi*sxxxy+6.*sxx*sxxy+4.*sxxx*sxy+sxxxx*syi)*rxss+rxxxxy*rxr+sxxxxy*rxs
                                                        rxxxxyy  = rxi**3*ryi**2*rxrrrrr+(2.*rxi**3*ryi*syi+3.*rxi**2*ryi**2*sxi)*rxrrrrs+(rxi**3*syi**2+6.*rxi**2*ryi*sxi*syi+3.*rxi*ryi**2*sxi**2)*rxrrrss+(3.*rxi**2*sxi*syi**2+6.*rxi*ryi*sxi**2*syi+ryi**2*sxi**3)*rxrrsss+(3.*rxi*sxi**2*syi**2+2.*ryi*sxi**3*syi)*rxrssss+sxi**3*syi**2*rxsssss+(rxi**3*ryy+6.*rxi**2*rxy*ryi+3.*rxi*rxx*ryi**2)*rxrrrr+(rxi**3*syy+(6.*rxy*syi+6.*ryi*sxy+3.*ryy*sxi)*rxi**2+(6.*rxx*ryi*syi+12.*rxy*ryi*sxi+3.*ryi**2*sxx)*rxi+3.*rxx*ryi**2*sxi)*rxrrrs+((3.*sxi*syy+6.*sxy*syi)*rxi**2+(3.*ryy*sxi**2+(12.*rxy*syi+12.*ryi*sxy)*sxi+6.*sxx*syi*ryi+3.*rxx*syi**2)*rxi+6.*rxy*ryi*sxi**2+(6.*rxx*ryi*syi+3.*ryi**2*sxx)*sxi)*rxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*rxi+ryy*sxi**3+(6.*rxy*syi+6.*ryi*sxy)*sxi**2+(3.*rxx*syi**2+6.*ryi*sxx*syi)*sxi)*rxrsss+(sxi**3*syy+6.*sxi**2*sxy*syi+3.*sxi*sxx*syi**2)*rxssss+(3.*rxyy*rxi**2+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*rxi+rxxx*ryi**2+6.*rxy*rxx*ryi)*rxrrr+(3.*rxi**2*sxyy+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+6.*ryi*sxxy+3.*ryy*sxx)*rxi+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*sxi+ryi**2*sxxx+(6.*rxx*sxy+2.*rxxx*syi+6.*rxy*sxx)*ryi+6.*rxy*rxx*syi)*rxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*rxi+3.*rxyy*sxi**2+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*ryi*sxxy+3.*ryy*sxx)*sxi+(6.*sxx*sxy+2.*sxxx*syi)*ryi+rxxx*syi**2+(6.*rxx*sxy+6.*rxy*sxx)*syi)*rxrss+(3.*sxi**2*sxyy+(3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*sxi+sxxx*syi**2+6.*sxx*sxy*syi)*rxsss+(3.*rxi*rxxyy+3.*rxx*rxyy+rxxx*ryy+2.*rxxxy*ryi+6.*rxxy*rxy)*rxrr+(3.*rxi*sxxyy+3.*rxx*sxyy+rxxx*syy+2.*rxxxy*syi+6.*rxxy*sxy+3.*rxxyy*sxi+6.*rxy*sxxy+3.*rxyy*sxx+2.*ryi*sxxxy+ryy*sxxx)*rxrs+(3.*sxi*sxxyy+3.*sxx*sxyy+sxxx*syy+2.*sxxxy*syi+6.*sxxy*sxy)*rxss+rxxxyy*rxr+sxxxyy*rxs
                                                        rxxxyyy  = rxi**2*ryi**3*rxrrrrr+(3.*rxi**2*ryi**2*syi+2.*rxi*ryi**3*sxi)*rxrrrrs+(3.*rxi**2*ryi*syi**2+6.*rxi*ryi**2*sxi*syi+ryi**3*sxi**2)*rxrrrss+(rxi**2*syi**3+6.*rxi*ryi*sxi*syi**2+3.*ryi**2*sxi**2*syi)*rxrrsss+(2.*rxi*sxi*syi**3+3.*ryi*sxi**2*syi**2)*rxrssss+sxi**2*syi**3*rxsssss+(3.*rxi**2*ryi*ryy+6.*rxi*rxy*ryi**2+rxx*ryi**3)*rxrrrr+(ryi**3*sxx+(6.*rxi*sxy+3.*rxx*syi+6.*rxy*sxi)*ryi**2+(3.*rxi**2*syy+12.*rxi*rxy*syi+6.*rxi*ryy*sxi)*ryi+3.*ryy*rxi**2*syi)*rxrrrs+((6.*sxi*sxy+3.*sxx*syi)*ryi**2+(3.*rxx*syi**2+(12.*rxi*sxy+12.*rxy*sxi)*syi+6.*sxi*syy*rxi+3.*ryy*sxi**2)*ryi+6.*rxy*rxi*syi**2+(3.*rxi**2*syy+6.*rxi*ryy*sxi)*syi)*rxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*ryi+rxx*syi**3+(6.*rxi*sxy+6.*rxy*sxi)*syi**2+(6.*rxi*sxi*syy+3.*ryy*sxi**2)*syi)*rxrsss+(3.*sxi**2*syi*syy+6.*sxi*sxy*syi**2+sxx*syi**3)*rxssss+(3.*rxxy*ryi**2+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*ryi+ryyy*rxi**2+6.*rxy*ryy*rxi)*rxrrr+(3.*ryi**2*sxxy+(6.*rxi*sxyy+3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*ryi+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*syi+rxi**2*syyy+(6.*rxy*syy+6.*ryy*sxy+2.*ryyy*sxi)*rxi+6.*rxy*ryy*sxi)*rxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*ryi+3.*rxxy*syi**2+(6.*rxi*sxyy+3.*rxx*syy+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*syi+(2.*sxi*syyy+6.*sxy*syy)*rxi+ryyy*sxi**2+(6.*rxy*syy+6.*ryy*sxy)*sxi)*rxrss+(3.*sxxy*syi**2+(6.*sxi*sxyy+3.*sxx*syy+6.*sxy**2)*syi+sxi**2*syyy+6.*sxy*syy*sxi)*rxsss+(2.*rxi*rxyyy+rxx*ryyy+3.*rxxy*ryy+3.*rxxyy*ryi+6.*rxy*rxyy)*rxrr+(2.*rxi*sxyyy+rxx*syyy+3.*rxxy*syy+3.*rxxyy*syi+6.*rxy*sxyy+6.*rxyy*sxy+2.*rxyyy*sxi+3.*ryi*sxxyy+3.*ryy*sxxy+ryyy*sxx)*rxrs+(2.*sxi*sxyyy+sxx*syyy+3.*sxxy*syy+3.*sxxyy*syi+6.*sxy*sxyy)*rxss+rxxyyy*rxr+sxxyyy*rxs
                                                        rxxyyyy  = rxi*ryi**4*rxrrrrr+(4.*rxi*ryi**3*syi+ryi**4*sxi)*rxrrrrs+(6.*rxi*ryi**2*syi**2+4.*ryi**3*sxi*syi)*rxrrrss+(4.*rxi*ryi*syi**3+6.*ryi**2*sxi*syi**2)*rxrrsss+(rxi*syi**4+4.*ryi*sxi*syi**3)*rxrssss+sxi*syi**4*rxsssss+(6.*rxi*ryi**2*ryy+4.*rxy*ryi**3)*rxrrrr+(4.*ryi**3*sxy+(6.*rxi*syy+12.*rxy*syi+6.*ryy*sxi)*ryi**2+12.*ryy*rxi*syi*ryi)*rxrrrs+((6.*sxi*syy+12.*sxy*syi)*ryi**2+(12.*rxy*syi**2+(12.*rxi*syy+12.*ryy*sxi)*syi)*ryi+6.*ryy*rxi*syi**2)*rxrrss+((12.*sxi*syi*syy+12.*sxy*syi**2)*ryi+4.*rxy*syi**3+(6.*rxi*syy+6.*ryy*sxi)*syi**2)*rxrsss+(6.*sxi*syi**2*syy+4.*sxy*syi**3)*rxssss+(6.*rxyy*ryi**2+(4.*rxi*ryyy+12.*rxy*ryy)*ryi+3.*ryy**2*rxi)*rxrrr+(6.*ryi**2*sxyy+(4.*rxi*syyy+12.*rxy*syy+12.*rxyy*syi+12.*ryy*sxy+4.*ryyy*sxi)*ryi+(4.*rxi*ryyy+12.*rxy*ryy)*syi+6.*ryy*syy*rxi+3.*ryy**2*sxi)*rxrrs+((4.*sxi*syyy+12.*sxy*syy+12.*sxyy*syi)*ryi+6.*rxyy*syi**2+(4.*rxi*syyy+12.*rxy*syy+12.*ryy*sxy+4.*ryyy*sxi)*syi+3.*syy**2*rxi+6.*ryy*syy*sxi)*rxrss+(6.*sxyy*syi**2+(4.*sxi*syyy+12.*sxy*syy)*syi+3.*syy**2*sxi)*rxsss+(rxi*ryyyy+4.*rxy*ryyy+6.*rxyy*ryy+4.*rxyyy*ryi)*rxrr+(rxi*syyyy+4.*rxy*syyy+6.*rxyy*syy+4.*rxyyy*syi+4.*ryi*sxyyy+6.*ryy*sxyy+4.*ryyy*sxy+ryyyy*sxi)*rxrs+(sxi*syyyy+4.*sxy*syyy+6.*sxyy*syy+4.*sxyyy*syi)*rxss+rxyyyy*rxr+sxyyyy*rxs
                                                        rxyyyyy  = ryi**5*rxrrrrr+5.*syi*ryi**4*rxrrrrs+10.*ryi**3*syi**2*rxrrrss+10.*ryi**2*syi**3*rxrrsss+5.*ryi*syi**4*rxrssss+syi**5*rxsssss+10.*ryi**3*ryy*rxrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*rxrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*rxrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*rxrsss+10.*syi**3*syy*rxssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*rxrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*rxrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*rxrss+(10.*syi**2*syyy+15.*syi*syy**2)*rxsss+(5.*ryi*ryyyy+10.*ryy*ryyy)*rxrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*rxrs+(5.*syi*syyyy+10.*syy*syyy)*rxss+ryyyyy*rxr+syyyyy*rxs
                                                        ryyyyyy  = ryi**5*ryrrrrr+5.*syi*ryi**4*ryrrrrs+10.*ryi**3*syi**2*ryrrrss+10.*ryi**2*syi**3*ryrrsss+5.*ryi*syi**4*ryrssss+syi**5*rysssss+10.*ryi**3*ryy*ryrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*ryrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*ryrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*ryrsss+10.*syi**3*syy*ryssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*ryrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*ryrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*ryrss+(10.*syi**2*syyy+15.*syi*syy**2)*rysss+(5.*ryi*ryyyy+10.*ryy*ryyy)*ryrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*ryrs+(5.*syi*syyyy+10.*syy*syyy)*ryss+ryyyyy*ryr+syyyyy*rys
                                                        sxxxxxx  = rxi**5*sxrrrrr+5.*sxi*rxi**4*sxrrrrs+10.*rxi**3*sxi**2*sxrrrss+10.*rxi**2*sxi**3*sxrrsss+5.*rxi*sxi**4*sxrssss+sxi**5*sxsssss+10.*rxi**3*rxx*sxrrrr+(10.*rxi**3*sxx+30.*rxi**2*rxx*sxi)*sxrrrs+(30.*rxi**2*sxi*sxx+30.*rxi*rxx*sxi**2)*sxrrss+(30.*rxi*sxi**2*sxx+10.*rxx*sxi**3)*sxrsss+10.*sxi**3*sxx*sxssss+(10.*rxi**2*rxxx+15.*rxi*rxx**2)*sxrrr+(10.*rxi**2*sxxx+(30.*rxx*sxx+20.*rxxx*sxi)*rxi+15.*rxx**2*sxi)*sxrrs+((20.*sxi*sxxx+15.*sxx**2)*rxi+10.*rxxx*sxi**2+30.*rxx*sxx*sxi)*sxrss+(10.*sxi**2*sxxx+15.*sxi*sxx**2)*sxsss+(5.*rxi*rxxxx+10.*rxx*rxxx)*sxrr+(5.*rxi*sxxxx+10.*rxx*sxxx+10.*rxxx*sxx+5.*rxxxx*sxi)*sxrs+(5.*sxi*sxxxx+10.*sxx*sxxx)*sxss+rxxxxx*sxr+sxxxxx*sxs
                                                        sxxxxxy  = ryi*rxi**4*sxrrrrr+(rxi**4*syi+4.*rxi**3*ryi*sxi)*sxrrrrs+(4.*rxi**3*sxi*syi+6.*rxi**2*ryi*sxi**2)*sxrrrss+(6.*rxi**2*sxi**2*syi+4.*rxi*ryi*sxi**3)*sxrrsss+(4.*rxi*sxi**3*syi+ryi*sxi**4)*sxrssss+syi*sxi**4*sxsssss+(4.*rxi**3*rxy+6.*rxi**2*rxx*ryi)*sxrrrr+(4.*rxi**3*sxy+(6.*rxx*syi+12.*rxy*sxi+6.*ryi*sxx)*rxi**2+12.*rxx*ryi*sxi*rxi)*sxrrrs+((12.*sxi*sxy+6.*sxx*syi)*rxi**2+(12.*rxy*sxi**2+(12.*rxx*syi+12.*ryi*sxx)*sxi)*rxi+6.*rxx*ryi*sxi**2)*sxrrss+((12.*sxi**2*sxy+12.*sxi*sxx*syi)*rxi+4.*rxy*sxi**3+(6.*rxx*syi+6.*ryi*sxx)*sxi**2)*sxrsss+(4.*sxi**3*sxy+6.*sxi**2*sxx*syi)*sxssss+(6.*rxxy*rxi**2+(12.*rxx*rxy+4.*rxxx*ryi)*rxi+3.*rxx**2*ryi)*sxrrr+(6.*rxi**2*sxxy+(12.*rxx*sxy+4.*rxxx*syi+12.*rxxy*sxi+12.*rxy*sxx+4.*ryi*sxxx)*rxi+(12.*rxx*rxy+4.*rxxx*ryi)*sxi+6.*rxx*sxx*ryi+3.*rxx**2*syi)*sxrrs+((12.*sxi*sxxy+12.*sxx*sxy+4.*sxxx*syi)*rxi+6.*rxxy*sxi**2+(12.*rxx*sxy+4.*rxxx*syi+12.*rxy*sxx+4.*ryi*sxxx)*sxi+3.*sxx**2*ryi+6.*rxx*sxx*syi)*sxrss+(6.*sxi**2*sxxy+(12.*sxx*sxy+4.*sxxx*syi)*sxi+3.*sxx**2*syi)*sxsss+(4.*rxi*rxxxy+6.*rxx*rxxy+4.*rxxx*rxy+rxxxx*ryi)*sxrr+(4.*rxi*sxxxy+6.*rxx*sxxy+4.*rxxx*sxy+rxxxx*syi+4.*rxxxy*sxi+6.*rxxy*sxx+4.*rxy*sxxx+ryi*sxxxx)*sxrs+(4.*sxi*sxxxy+6.*sxx*sxxy+4.*sxxx*sxy+sxxxx*syi)*sxss+rxxxxy*sxr+sxxxxy*sxs
                                                        sxxxxyy  = rxi**3*ryi**2*sxrrrrr+(2.*rxi**3*ryi*syi+3.*rxi**2*ryi**2*sxi)*sxrrrrs+(rxi**3*syi**2+6.*rxi**2*ryi*sxi*syi+3.*rxi*ryi**2*sxi**2)*sxrrrss+(3.*rxi**2*sxi*syi**2+6.*rxi*ryi*sxi**2*syi+ryi**2*sxi**3)*sxrrsss+(3.*rxi*sxi**2*syi**2+2.*ryi*sxi**3*syi)*sxrssss+sxi**3*syi**2*sxsssss+(rxi**3*ryy+6.*rxi**2*rxy*ryi+3.*rxi*rxx*ryi**2)*sxrrrr+(rxi**3*syy+(6.*rxy*syi+6.*ryi*sxy+3.*ryy*sxi)*rxi**2+(6.*rxx*ryi*syi+12.*rxy*ryi*sxi+3.*ryi**2*sxx)*rxi+3.*rxx*ryi**2*sxi)*sxrrrs+((3.*sxi*syy+6.*sxy*syi)*rxi**2+(3.*ryy*sxi**2+(12.*rxy*syi+12.*ryi*sxy)*sxi+6.*sxx*syi*ryi+3.*rxx*syi**2)*rxi+6.*rxy*ryi*sxi**2+(6.*rxx*ryi*syi+3.*ryi**2*sxx)*sxi)*sxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*rxi+ryy*sxi**3+(6.*rxy*syi+6.*ryi*sxy)*sxi**2+(3.*rxx*syi**2+6.*ryi*sxx*syi)*sxi)*sxrsss+(sxi**3*syy+6.*sxi**2*sxy*syi+3.*sxi*sxx*syi**2)*sxssss+(3.*rxyy*rxi**2+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*rxi+rxxx*ryi**2+6.*rxy*rxx*ryi)*sxrrr+(3.*rxi**2*sxyy+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+6.*ryi*sxxy+3.*ryy*sxx)*rxi+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*sxi+ryi**2*sxxx+(6.*rxx*sxy+2.*rxxx*syi+6.*rxy*sxx)*ryi+6.*rxy*rxx*syi)*sxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*rxi+3.*rxyy*sxi**2+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*ryi*sxxy+3.*ryy*sxx)*sxi+(6.*sxx*sxy+2.*sxxx*syi)*ryi+rxxx*syi**2+(6.*rxx*sxy+6.*rxy*sxx)*syi)*sxrss+(3.*sxi**2*sxyy+(3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*sxi+sxxx*syi**2+6.*sxx*sxy*syi)*sxsss+(3.*rxi*rxxyy+3.*rxx*rxyy+rxxx*ryy+2.*rxxxy*ryi+6.*rxxy*rxy)*sxrr+(3.*rxi*sxxyy+3.*rxx*sxyy+rxxx*syy+2.*rxxxy*syi+6.*rxxy*sxy+3.*rxxyy*sxi+6.*rxy*sxxy+3.*rxyy*sxx+2.*ryi*sxxxy+ryy*sxxx)*sxrs+(3.*sxi*sxxyy+3.*sxx*sxyy+sxxx*syy+2.*sxxxy*syi+6.*sxxy*sxy)*sxss+rxxxyy*sxr+sxxxyy*sxs
                                                        sxxxyyy  = rxi**2*ryi**3*sxrrrrr+(3.*rxi**2*ryi**2*syi+2.*rxi*ryi**3*sxi)*sxrrrrs+(3.*rxi**2*ryi*syi**2+6.*rxi*ryi**2*sxi*syi+ryi**3*sxi**2)*sxrrrss+(rxi**2*syi**3+6.*rxi*ryi*sxi*syi**2+3.*ryi**2*sxi**2*syi)*sxrrsss+(2.*rxi*sxi*syi**3+3.*ryi*sxi**2*syi**2)*sxrssss+sxi**2*syi**3*sxsssss+(3.*rxi**2*ryi*ryy+6.*rxi*rxy*ryi**2+rxx*ryi**3)*sxrrrr+(ryi**3*sxx+(6.*rxi*sxy+3.*rxx*syi+6.*rxy*sxi)*ryi**2+(3.*rxi**2*syy+12.*rxi*rxy*syi+6.*rxi*ryy*sxi)*ryi+3.*ryy*rxi**2*syi)*sxrrrs+((6.*sxi*sxy+3.*sxx*syi)*ryi**2+(3.*rxx*syi**2+(12.*rxi*sxy+12.*rxy*sxi)*syi+6.*sxi*syy*rxi+3.*ryy*sxi**2)*ryi+6.*rxy*rxi*syi**2+(3.*rxi**2*syy+6.*rxi*ryy*sxi)*syi)*sxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*ryi+rxx*syi**3+(6.*rxi*sxy+6.*rxy*sxi)*syi**2+(6.*rxi*sxi*syy+3.*ryy*sxi**2)*syi)*sxrsss+(3.*sxi**2*syi*syy+6.*sxi*sxy*syi**2+sxx*syi**3)*sxssss+(3.*rxxy*ryi**2+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*ryi+ryyy*rxi**2+6.*rxy*ryy*rxi)*sxrrr+(3.*ryi**2*sxxy+(6.*rxi*sxyy+3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*ryi+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*syi+rxi**2*syyy+(6.*rxy*syy+6.*ryy*sxy+2.*ryyy*sxi)*rxi+6.*rxy*ryy*sxi)*sxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*ryi+3.*rxxy*syi**2+(6.*rxi*sxyy+3.*rxx*syy+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*syi+(2.*sxi*syyy+6.*sxy*syy)*rxi+ryyy*sxi**2+(6.*rxy*syy+6.*ryy*sxy)*sxi)*sxrss+(3.*sxxy*syi**2+(6.*sxi*sxyy+3.*sxx*syy+6.*sxy**2)*syi+sxi**2*syyy+6.*sxy*syy*sxi)*sxsss+(2.*rxi*rxyyy+rxx*ryyy+3.*rxxy*ryy+3.*rxxyy*ryi+6.*rxy*rxyy)*sxrr+(2.*rxi*sxyyy+rxx*syyy+3.*rxxy*syy+3.*rxxyy*syi+6.*rxy*sxyy+6.*rxyy*sxy+2.*rxyyy*sxi+3.*ryi*sxxyy+3.*ryy*sxxy+ryyy*sxx)*sxrs+(2.*sxi*sxyyy+sxx*syyy+3.*sxxy*syy+3.*sxxyy*syi+6.*sxy*sxyy)*sxss+rxxyyy*sxr+sxxyyy*sxs
                                                        sxxyyyy  = rxi*ryi**4*sxrrrrr+(4.*rxi*ryi**3*syi+ryi**4*sxi)*sxrrrrs+(6.*rxi*ryi**2*syi**2+4.*ryi**3*sxi*syi)*sxrrrss+(4.*rxi*ryi*syi**3+6.*ryi**2*sxi*syi**2)*sxrrsss+(rxi*syi**4+4.*ryi*sxi*syi**3)*sxrssss+sxi*syi**4*sxsssss+(6.*rxi*ryi**2*ryy+4.*rxy*ryi**3)*sxrrrr+(4.*ryi**3*sxy+(6.*rxi*syy+12.*rxy*syi+6.*ryy*sxi)*ryi**2+12.*ryy*rxi*syi*ryi)*sxrrrs+((6.*sxi*syy+12.*sxy*syi)*ryi**2+(12.*rxy*syi**2+(12.*rxi*syy+12.*ryy*sxi)*syi)*ryi+6.*ryy*rxi*syi**2)*sxrrss+((12.*sxi*syi*syy+12.*sxy*syi**2)*ryi+4.*rxy*syi**3+(6.*rxi*syy+6.*ryy*sxi)*syi**2)*sxrsss+(6.*sxi*syi**2*syy+4.*sxy*syi**3)*sxssss+(6.*rxyy*ryi**2+(4.*rxi*ryyy+12.*rxy*ryy)*ryi+3.*ryy**2*rxi)*sxrrr+(6.*ryi**2*sxyy+(4.*rxi*syyy+12.*rxy*syy+12.*rxyy*syi+12.*ryy*sxy+4.*ryyy*sxi)*ryi+(4.*rxi*ryyy+12.*rxy*ryy)*syi+6.*ryy*syy*rxi+3.*ryy**2*sxi)*sxrrs+((4.*sxi*syyy+12.*sxy*syy+12.*sxyy*syi)*ryi+6.*rxyy*syi**2+(4.*rxi*syyy+12.*rxy*syy+12.*ryy*sxy+4.*ryyy*sxi)*syi+3.*syy**2*rxi+6.*ryy*syy*sxi)*sxrss+(6.*sxyy*syi**2+(4.*sxi*syyy+12.*sxy*syy)*syi+3.*syy**2*sxi)*sxsss+(rxi*ryyyy+4.*rxy*ryyy+6.*rxyy*ryy+4.*rxyyy*ryi)*sxrr+(rxi*syyyy+4.*rxy*syyy+6.*rxyy*syy+4.*rxyyy*syi+4.*ryi*sxyyy+6.*ryy*sxyy+4.*ryyy*sxy+ryyyy*sxi)*sxrs+(sxi*syyyy+4.*sxy*syyy+6.*sxyy*syy+4.*sxyyy*syi)*sxss+rxyyyy*sxr+sxyyyy*sxs
                                                        sxyyyyy  = ryi**5*sxrrrrr+5.*syi*ryi**4*sxrrrrs+10.*ryi**3*syi**2*sxrrrss+10.*ryi**2*syi**3*sxrrsss+5.*ryi*syi**4*sxrssss+syi**5*sxsssss+10.*ryi**3*ryy*sxrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*sxrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*sxrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*sxrsss+10.*syi**3*syy*sxssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*sxrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*sxrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*sxrss+(10.*syi**2*syyy+15.*syi*syy**2)*sxsss+(5.*ryi*ryyyy+10.*ryy*ryyy)*sxrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*sxrs+(5.*syi*syyyy+10.*syy*syyy)*sxss+ryyyyy*sxr+syyyyy*sxs
                                                        syyyyyy  = ryi**5*syrrrrr+5.*syi*ryi**4*syrrrrs+10.*ryi**3*syi**2*syrrrss+10.*ryi**2*syi**3*syrrsss+5.*ryi*syi**4*syrssss+syi**5*sysssss+10.*ryi**3*ryy*syrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*syrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*syrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*syrsss+10.*syi**3*syy*syssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*syrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*syrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*syrss+(10.*syi**2*syyy+15.*syi*syy**2)*sysss+(5.*ryi*ryyyy+10.*ryy*ryyy)*syrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*syrs+(5.*syi*syyyy+10.*syy*syyy)*syss+ryyyyy*syr+syyyyy*sys
                            ! ---- end evalMetrics eq evalMetrics ---
                            ! ---------- Sixth spatial derivatives of u ---------
                                                        uxx      = rxi**2*urr+2.*rxi*sxi*urs+sxi**2*uss+rxx*ur+sxx*us
                                                        uxxxx    = rxi**4*urrrr+4.*rxi**3*sxi*urrrs+6.*rxi**2*sxi**2*urrss+4.*rxi*sxi**3*ursss+sxi**4*ussss+6.*rxi**2*rxx*urrr+(6.*rxi**2*sxx+12.*rxi*rxx*sxi)*urrs+(12.*rxi*sxi*sxx+6.*rxx*sxi**2)*urss+6.*sxi**2*sxx*usss+(4.*rxi*rxxx+3.*rxx**2)*urr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*urs+(4.*sxi*sxxx+3.*sxx**2)*uss+rxxxx*ur+sxxxx*us
                                                        uxxxxxx  = rxi**6*urrrrrr+sxi**6*ussssss+(15.*rxi**4*sxx+60.*rxi**3*rxx*sxi)*urrrrs+(60.*rxi**3*sxi*sxx+90.*rxi**2*rxx*sxi**2)*urrrss+(90.*rxi**2*sxi**2*sxx+60.*rxi*rxx*sxi**3)*urrsss+(60.*rxi*sxi**3*sxx+15.*rxx*sxi**4)*urssss+(20.*rxi**3*rxxx+45.*rxi**2*rxx**2)*urrrr+(20.*rxi**3*sxxx+(90.*rxx*sxx+60.*rxxx*sxi)*rxi**2+90.*rxx**2*sxi*rxi)*urrrs+((60.*sxi*sxxx+45.*sxx**2)*rxi**2+(180.*rxx*sxi*sxx+60.*rxxx*sxi**2)*rxi+45.*rxx**2*sxi**2)*urrss+((60.*sxi**2*sxxx+90.*sxi*sxx**2)*rxi+20.*rxxx*sxi**3+90.*rxx*sxx*sxi**2)*ursss+(20.*sxi**3*sxxx+45.*sxi**2*sxx**2)*ussss+(15.*rxi**2*rxxxx+60.*rxi*rxx*rxxx+15.*rxx**3)*urrr+(15.*rxi**2*sxxxx+(60.*rxx*sxxx+60.*rxxx*sxx+30.*rxxxx*sxi)*rxi+60.*rxxx*rxx*sxi+45.*sxx*rxx**2)*urrs+((30.*sxi*sxxxx+60.*sxx*sxxx)*rxi+15.*rxxxx*sxi**2+(60.*rxx*sxxx+60.*rxxx*sxx)*sxi+45.*sxx**2*rxx)*urss+(15.*sxi**2*sxxxx+60.*sxi*sxx*sxxx+15.*sxx**3)*usss+(6.*rxi*rxxxxx+15.*rxx*rxxxx+10.*rxxx**2)*urr+(6.*rxi*sxxxxx+15.*rxx*sxxxx+20.*rxxx*sxxx+15.*rxxxx*sxx+6.*rxxxxx*sxi)*urs+(6.*sxi*sxxxxx+15.*sxx*sxxxx+10.*sxxx**2)*uss+rxxxxxx*ur+sxxxxxx*us+6.*rxi**5*sxi*urrrrrs+15.*rxi**4*sxi**2*urrrrss+20.*rxi**3*sxi**3*urrrsss+15.*rxi**2*sxi**4*urrssss+6.*rxi*sxi**5*ursssss+15.*rxi**4*rxx*urrrrr+15.*sxi**4*sxx*usssss
                                                        uyy      = ryi**2*urr+2.*ryi*syi*urs+syi**2*uss+ryy*ur+syy*us
                                                        uxxyy    = rxi**2*ryi**2*urrrr+(2.*rxi**2*ryi*syi+2.*rxi*ryi**2*sxi)*urrrs+(rxi**2*syi**2+4.*rxi*ryi*sxi*syi+ryi**2*sxi**2)*urrss+(2.*rxi*sxi*syi**2+2.*ryi*sxi**2*syi)*ursss+sxi**2*syi**2*ussss+(rxi**2*ryy+4.*rxi*rxy*ryi+rxx*ryi**2)*urrr+(rxi**2*syy+(4.*rxy*syi+4.*ryi*sxy+2.*ryy*sxi)*rxi+ryi**2*sxx+(2.*rxx*syi+4.*rxy*sxi)*ryi)*urrs+((2.*sxi*syy+4.*sxy*syi)*rxi+(4.*sxi*sxy+2.*sxx*syi)*ryi+ryy*sxi**2+4.*rxy*syi*sxi+rxx*syi**2)*urss+(sxi**2*syy+4.*sxi*sxy*syi+sxx*syi**2)*usss+(2.*rxi*rxyy+rxx*ryy+2.*rxxy*ryi+2.*rxy**2)*urr+(2.*rxi*sxyy+rxx*syy+2.*rxxy*syi+4.*rxy*sxy+2.*rxyy*sxi+2.*ryi*sxxy+ryy*sxx)*urs+(2.*sxi*sxyy+sxx*syy+2.*sxxy*syi+2.*sxy**2)*uss+rxxyy*ur+sxxyy*us
                                                        uxxxxyy  = syi**2*sxi**4*ussssss+ryi**2*rxi**4*urrrrrr+(12.*rxy**2*rxx+3.*ryy*rxx**2+(12.*rxx*rxxy+8.*rxxx*rxy)*ryi+rxxxx*ryi**2+6.*rxxyy*rxi**2+(12.*rxx*rxyy+4.*rxxx*ryy+8.*rxxxy*ryi+24.*rxxy*rxy)*rxi)*urrr+((12.*rxx*rxyy+4.*rxxx*ryy+8.*rxxxy*ryi+24.*rxxy*rxy)*sxi+12.*rxy**2*sxx+(24.*rxy*sxy+6.*ryy*sxx)*rxx+(12.*rxx*rxxy+8.*rxxx*rxy)*syi+3.*syy*rxx**2+(12.*rxx*sxxy+8.*rxxx*sxy+2.*rxxxx*syi+12.*rxxy*sxx+8.*rxy*sxxx)*ryi+ryi**2*sxxxx+6.*rxi**2*sxxyy+(12.*rxx*sxyy+4.*rxxx*syy+8.*rxxxy*syi+24.*rxxy*sxy+12.*rxxyy*sxi+24.*rxy*sxxy+12.*rxyy*sxx+8.*ryi*sxxxy+4.*ryy*sxxx)*rxi)*urrs+((12.*rxx*sxyy+4.*rxxx*syy+8.*rxxxy*syi+24.*rxxy*sxy+24.*rxy*sxxy+12.*rxyy*sxx+8.*ryi*sxxxy+4.*ryy*sxxx)*sxi+24.*rxy*sxy*sxx+3.*ryy*sxx**2+(6.*sxx*syy+12.*sxy**2)*rxx+(12.*rxx*sxxy+8.*rxxx*sxy+12.*rxxy*sxx+8.*rxy*sxxx)*syi+rxxxx*syi**2+(12.*sxx*sxxy+8.*sxxx*sxy+2.*sxxxx*syi)*ryi+(12.*sxi*sxxyy+12.*sxx*sxyy+4.*sxxx*syy+8.*sxxxy*syi+24.*sxxy*sxy)*rxi+6.*rxxyy*sxi**2)*urss+((12.*sxx*sxyy+4.*sxxx*syy+8.*sxxxy*syi+24.*sxxy*sxy)*sxi+12.*sxy**2*sxx+3.*syy*sxx**2+(12.*sxx*sxxy+8.*sxxx*sxy)*syi+sxxxx*syi**2+6.*sxi**2*sxxyy)*usss+(4.*rxi*rxxxyy+6.*rxx*rxxyy+4.*rxxx*rxyy+rxxxx*ryy+2.*rxxxxy*ryi+8.*rxxxy*rxy+6.*rxxy**2)*urr+(4.*rxi*sxxxyy+6.*rxx*sxxyy+4.*rxxx*sxyy+rxxxx*syy+2.*rxxxxy*syi+8.*rxxxy*sxy+4.*rxxxyy*sxi+12.*rxxy*sxxy+6.*rxxyy*sxx+8.*rxy*sxxxy+4.*rxyy*sxxx+2.*ryi*sxxxxy+ryy*sxxxx)*urs+(4.*sxi*sxxxyy+6.*sxx*sxxyy+4.*sxxx*sxyy+sxxxx*syy+2.*sxxxxy*syi+8.*sxxxy*sxy+6.*sxxy**2)*uss+rxxxxyy*ur+sxxxxyy*us+(2.*rxi**4*ryi*syi+4.*rxi**3*ryi**2*sxi)*urrrrrs+(4.*rxi**3*sxi*syi**2+12.*rxi**2*ryi*sxi**2*syi+4.*rxi*ryi**2*sxi**3)*urrrsss+(rxi**4*syi**2+8.*rxi**3*ryi*sxi*syi+6.*rxi**2*ryi**2*sxi**2)*urrrrss+(6.*rxi**2*sxi**2*syi**2+8.*rxi*ryi*sxi**3*syi+ryi**2*sxi**4)*urrssss+(4.*rxi*sxi**3*syi**2+2.*ryi*sxi**4*syi)*ursssss+(rxi**4*ryy+8.*rxi**3*rxy*ryi+6.*rxi**2*rxx*ryi**2)*urrrrr+(12.*rxx*ryi**2*sxi*rxi+(8.*rxy*syi+8.*ryi*sxy+4.*ryy*sxi)*rxi**3+(12.*rxx*ryi*syi+24.*rxy*ryi*sxi+6.*ryi**2*sxx)*rxi**2+syy*rxi**4)*urrrrs+(6.*rxx*ryi**2*sxi**2+(24.*rxy*ryi*sxi**2+(24.*rxx*ryi*syi+12.*ryi**2*sxx)*sxi)*rxi+(4.*sxi*syy+8.*sxy*syi)*rxi**3+(6.*ryy*sxi**2+(24.*rxy*syi+24.*ryi*sxy)*sxi+12.*sxx*syi*ryi+6.*rxx*syi**2)*rxi**2)*urrrss+(8.*rxy*ryi*sxi**3+(12.*rxx*ryi*syi+6.*ryi**2*sxx)*sxi**2+(4.*ryy*sxi**3+(24.*rxy*syi+24.*ryi*sxy)*sxi**2+(12.*rxx*syi**2+24.*ryi*sxx*syi)*sxi)*rxi+(6.*sxi**2*syy+24.*sxi*sxy*syi+6.*sxx*syi**2)*rxi**2)*urrsss+((4.*sxi**3*syy+24.*sxi**2*sxy*syi+12.*sxi*sxx*syi**2)*rxi+(8.*rxy*syi+8.*ryi*sxy)*sxi**3+(6.*rxx*syi**2+12.*ryi*sxx*syi)*sxi**2+ryy*sxi**4)*urssss+(sxi**4*syy+8.*sxi**3*sxy*syi+6.*sxi**2*sxx*syi**2)*usssss+(3.*rxx**2*ryi**2+(6.*rxx*ryy+12.*rxxy*ryi+12.*rxy**2)*rxi**2+(24.*rxx*rxy*ryi+4.*rxxx*ryi**2)*rxi+4.*rxyy*rxi**3)*urrrr+((24.*rxx*rxy*ryi+4.*rxxx*ryi**2)*sxi+6.*rxx**2*syi*ryi+6.*rxx*sxx*ryi**2+(6.*rxx*syy+12.*rxxy*syi+24.*rxy*sxy+12.*rxyy*sxi+12.*ryi*sxxy+6.*ryy*sxx)*rxi**2+((12.*rxx*ryy+24.*rxxy*ryi+24.*rxy**2)*sxi+4.*ryi**2*sxxx+(24.*rxx*sxy+8.*rxxx*syi+24.*rxy*sxx)*ryi+24.*rxy*rxx*syi)*rxi+4.*rxi**3*sxyy)*urrrs+((4.*ryi**2*sxxx+(24.*rxx*sxy+8.*rxxx*syi+24.*rxy*sxx)*ryi+24.*rxy*rxx*syi)*sxi+3.*rxx**2*syi**2+12.*rxx*sxx*syi*ryi+3.*sxx**2*ryi**2+(12.*sxi*sxyy+6.*sxx*syy+12.*sxxy*syi+12.*sxy**2)*rxi**2+(12.*rxyy*sxi**2+(12.*rxx*syy+24.*rxxy*syi+48.*rxy*sxy+24.*ryi*sxxy+12.*ryy*sxx)*sxi+(24.*sxx*sxy+8.*sxxx*syi)*ryi+4.*rxxx*syi**2+(24.*rxx*sxy+24.*rxy*sxx)*syi)*rxi+(6.*rxx*ryy+12.*rxxy*ryi+12.*rxy**2)*sxi**2)*urrss+(((24.*sxx*sxy+8.*sxxx*syi)*ryi+4.*rxxx*syi**2+(24.*rxx*sxy+24.*rxy*sxx)*syi)*sxi+6.*rxx*sxx*syi**2+6.*sxx**2*syi*ryi+(12.*sxi**2*sxyy+(12.*sxx*syy+24.*sxxy*syi+24.*sxy**2)*sxi+4.*sxxx*syi**2+24.*sxx*sxy*syi)*rxi+4.*rxyy*sxi**3+(6.*rxx*syy+12.*rxxy*syi+24.*rxy*sxy+12.*ryi*sxxy+6.*ryy*sxx)*sxi**2)*ursss+((24.*sxx*sxy*syi+4.*sxxx*syi**2)*sxi+3.*sxx**2*syi**2+4.*sxi**3*sxyy+(6.*sxx*syy+12.*sxxy*syi+12.*sxy**2)*sxi**2)*ussss
                                                        uyyyy    = ryi**4*urrrr+4.*ryi**3*syi*urrrs+6.*ryi**2*syi**2*urrss+4.*ryi*syi**3*ursss+syi**4*ussss+6.*ryi**2*ryy*urrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*urrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*urss+6.*syi**2*syy*usss+(4.*ryi*ryyy+3.*ryy**2)*urr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*urs+(4.*syi*syyy+3.*syy**2)*uss+ryyyy*ur+syyyy*us
                                                        uxxyyyy  = ((12.*rxi*rxyy+6.*rxx*ryy+12.*rxy**2)*syi**2+(12.*sxi*sxyy+6.*sxx*syy+12.*sxxy*syi+12.*sxy**2)*ryi**2+(12.*rxxy*syi**2+(24.*rxi*sxyy+12.*rxx*syy+48.*rxy*sxy+24.*rxyy*sxi+12.*ryy*sxx)*syi+(8.*sxi*syyy+24.*sxy*syy)*rxi+4.*ryyy*sxi**2+(24.*rxy*syy+24.*ryy*sxy)*sxi)*ryi+3.*syy**2*rxi**2+3.*ryy**2*sxi**2+12.*ryy*syy*sxi*rxi+(4.*rxi**2*syyy+(24.*rxy*syy+24.*ryy*sxy+8.*ryyy*sxi)*rxi+24.*rxy*ryy*sxi)*syi)*urrss+((12.*rxi*sxyy+6.*rxx*syy+24.*rxy*sxy+12.*rxyy*sxi+6.*ryy*sxx)*syi**2+4.*rxxy*syi**3+(12.*sxxy*syi**2+(24.*sxi*sxyy+12.*sxx*syy+24.*sxy**2)*syi+4.*sxi**2*syyy+24.*sxy*syy*sxi)*ryi+6.*ryy*syy*sxi**2+6.*syy**2*sxi*rxi+((8.*sxi*syyy+24.*sxy*syy)*rxi+4.*ryyy*sxi**2+(24.*rxy*syy+24.*ryy*sxy)*sxi)*syi)*ursss+((12.*sxi*sxyy+6.*sxx*syy+12.*sxy**2)*syi**2+4.*sxxy*syi**3+3.*syy**2*sxi**2+(4.*sxi**2*syyy+24.*sxi*sxy*syy)*syi)*ussss+(6.*rxxyy*ryi**2+(8.*rxi*rxyyy+4.*rxx*ryyy+12.*rxxy*ryy+24.*rxy*rxyy)*ryi+ryyyy*rxi**2+12.*rxy**2*ryy+3.*rxx*ryy**2+(8.*rxy*ryyy+12.*rxyy*ryy)*rxi)*urrr+(6.*ryi**2*sxxyy+(8.*rxi*sxyyy+4.*rxx*syyy+12.*rxxy*syy+12.*rxxyy*syi+24.*rxy*sxyy+24.*rxyy*sxy+8.*rxyyy*sxi+12.*ryy*sxxy+4.*ryyy*sxx)*ryi+rxi**2*syyyy+12.*rxy**2*syy+(6.*rxx*syy+24.*rxy*sxy)*ryy+(8.*rxy*ryyy+12.*rxyy*ryy)*sxi+3.*ryy**2*sxx+(8.*rxy*syyy+12.*rxyy*syy+12.*ryy*sxyy+8.*ryyy*sxy+2.*ryyyy*sxi)*rxi+(8.*rxi*rxyyy+4.*rxx*ryyy+12.*rxxy*ryy+24.*rxy*rxyy)*syi)*urrs+(6.*rxxyy*syi**2+(8.*sxi*sxyyy+4.*sxx*syyy+12.*sxxy*syy+12.*sxxyy*syi+24.*sxy*sxyy)*ryi+24.*rxy*sxy*syy+(6.*sxx*syy+12.*sxy**2)*ryy+3.*rxx*syy**2+(8.*rxy*syyy+12.*rxyy*syy+12.*ryy*sxyy+8.*ryyy*sxy)*sxi+ryyyy*sxi**2+(2.*sxi*syyyy+8.*sxy*syyy+12.*sxyy*syy)*rxi+(8.*rxi*sxyyy+4.*rxx*syyy+12.*rxxy*syy+24.*rxy*sxyy+24.*rxyy*sxy+8.*rxyyy*sxi+12.*ryy*sxxy+4.*ryyy*sxx)*syi)*urss+(6.*sxxyy*syi**2+12.*sxy**2*syy+3.*sxx*syy**2+(8.*sxy*syyy+12.*sxyy*syy)*sxi+sxi**2*syyyy+(8.*sxi*sxyyy+4.*sxx*syyy+12.*sxxy*syy+24.*sxy*sxyy)*syi)*usss+(2.*rxi*rxyyyy+rxx*ryyyy+4.*rxxy*ryyy+6.*rxxyy*ryy+4.*rxxyyy*ryi+8.*rxy*rxyyy+6.*rxyy**2)*urr+(2.*rxi*sxyyyy+rxx*syyyy+4.*rxxy*syyy+6.*rxxyy*syy+4.*rxxyyy*syi+8.*rxy*sxyyy+12.*rxyy*sxyy+8.*rxyyy*sxy+2.*rxyyyy*sxi+4.*ryi*sxxyyy+6.*ryy*sxxyy+4.*ryyy*sxxy+ryyyy*sxx)*urs+(2.*sxi*sxyyyy+sxx*syyyy+4.*sxxy*syyy+6.*sxxyy*syy+4.*sxxyyy*syi+8.*sxy*sxyyy+6.*sxyy**2)*uss+rxxyyyy*ur+sxxyyyy*us+(4.*rxi**2*ryi**3*syi+2.*rxi*ryi**4*sxi)*urrrrrs+(4.*rxi**2*ryi*syi**3+12.*rxi*ryi**2*sxi*syi**2+4.*ryi**3*sxi**2*syi)*urrrsss+(6.*rxi**2*ryi**2*syi**2+8.*rxi*ryi**3*sxi*syi+ryi**4*sxi**2)*urrrrss+(rxi**2*syi**4+8.*rxi*ryi*sxi*syi**3+6.*ryi**2*sxi**2*syi**2)*urrssss+(2.*rxi*sxi*syi**4+4.*ryi*sxi**2*syi**3)*ursssss+(6.*rxi**2*ryi**2*ryy+8.*rxi*rxy*ryi**3+rxx*ryi**4)*urrrrr+(ryi**4*sxx+12.*ryy*rxi**2*syi*ryi+(8.*rxi*sxy+4.*rxx*syi+8.*rxy*sxi)*ryi**3+(6.*rxi**2*syy+24.*rxi*rxy*syi+12.*rxi*ryy*sxi)*ryi**2)*urrrrs+((24.*rxy*rxi*syi**2+(12.*rxi**2*syy+24.*rxi*ryy*sxi)*syi)*ryi+(8.*sxi*sxy+4.*sxx*syi)*ryi**3+(6.*rxx*syi**2+(24.*rxi*sxy+24.*rxy*sxi)*syi+12.*sxi*syy*rxi+6.*ryy*sxi**2)*ryi**2+6.*ryy*rxi**2*syi**2)*urrrss+((4.*rxx*syi**3+(24.*rxi*sxy+24.*rxy*sxi)*syi**2+(24.*rxi*sxi*syy+12.*ryy*sxi**2)*syi)*ryi+(6.*sxi**2*syy+24.*sxi*sxy*syi+6.*sxx*syi**2)*ryi**2+(6.*rxi**2*syy+12.*rxi*ryy*sxi)*syi**2+8.*rxy*rxi*syi**3)*urrsss+((12.*sxi**2*syi*syy+24.*sxi*sxy*syi**2+4.*sxx*syi**3)*ryi+(12.*rxi*sxi*syy+6.*ryy*sxi**2)*syi**2+(8.*rxi*sxy+8.*rxy*sxi)*syi**3+rxx*syi**4)*urssss+(6.*sxi**2*syi**2*syy+8.*sxi*sxy*syi**3+sxx*syi**4)*usssss+((12.*rxi*rxyy+6.*rxx*ryy+12.*rxy**2)*ryi**2+(4.*rxi**2*ryyy+24.*rxi*rxy*ryy)*ryi+4.*rxxy*ryi**3+3.*ryy**2*rxi**2)*urrrr+(4.*ryi**3*sxxy+(12.*rxi*sxyy+6.*rxx*syy+12.*rxxy*syi+24.*rxy*sxy+12.*rxyy*sxi+6.*ryy*sxx)*ryi**2+((24.*rxi*rxyy+12.*rxx*ryy+24.*rxy**2)*syi+4.*rxi**2*syyy+(24.*rxy*syy+24.*ryy*sxy+8.*ryyy*sxi)*rxi+24.*rxy*ryy*sxi)*ryi+6.*ryy*syy*rxi**2+6.*ryy**2*sxi*rxi+(4.*rxi**2*ryyy+24.*rxi*rxy*ryy)*syi)*urrrs+rxi**2*ryi**4*urrrrrr+sxi**2*syi**4*ussssss
                                                        uyyyyyy  = ryi**6*urrrrrr+syi**6*ussssss+(15.*ryi**4*syy+60.*ryi**3*ryy*syi)*urrrrs+(60.*ryi**3*syi*syy+90.*ryi**2*ryy*syi**2)*urrrss+(90.*ryi**2*syi**2*syy+60.*ryi*ryy*syi**3)*urrsss+(60.*ryi*syi**3*syy+15.*ryy*syi**4)*urssss+(20.*ryi**3*ryyy+45.*ryi**2*ryy**2)*urrrr+(20.*ryi**3*syyy+(90.*ryy*syy+60.*ryyy*syi)*ryi**2+90.*ryy**2*syi*ryi)*urrrs+((60.*syi*syyy+45.*syy**2)*ryi**2+(180.*ryy*syi*syy+60.*ryyy*syi**2)*ryi+45.*ryy**2*syi**2)*urrss+((60.*syi**2*syyy+90.*syi*syy**2)*ryi+20.*ryyy*syi**3+90.*ryy*syy*syi**2)*ursss+(20.*syi**3*syyy+45.*syi**2*syy**2)*ussss+(15.*ryi**2*ryyyy+60.*ryi*ryy*ryyy+15.*ryy**3)*urrr+(15.*ryi**2*syyyy+(60.*ryy*syyy+60.*ryyy*syy+30.*ryyyy*syi)*ryi+60.*ryyy*ryy*syi+45.*syy*ryy**2)*urrs+((30.*syi*syyyy+60.*syy*syyy)*ryi+15.*ryyyy*syi**2+(60.*ryy*syyy+60.*ryyy*syy)*syi+45.*syy**2*ryy)*urss+(15.*syi**2*syyyy+60.*syi*syy*syyy+15.*syy**3)*usss+(6.*ryi*ryyyyy+15.*ryy*ryyyy+10.*ryyy**2)*urr+(6.*ryi*syyyyy+15.*ryy*syyyy+20.*ryyy*syyy+15.*ryyyy*syy+6.*ryyyyy*syi)*urs+(6.*syi*syyyyy+15.*syy*syyyy+10.*syyy**2)*uss+ryyyyyy*ur+syyyyyy*us+6.*syi*ryi**5*urrrrrs+15.*ryi**4*syi**2*urrrrss+20.*ryi**3*syi**3*urrrsss+15.*ryi**2*syi**4*urrssss+6.*ryi*syi**5*ursssss+15.*ryi**4*ryy*urrrrr+15.*syi**4*syy*usssss
                            ! ---------- END CURVILINEAR  ---------
                                                            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
                            ! Scaling for equations so leading terms are undivided differences
                                                        scale1 = (dr(axis)**2/rFactor)**1/c2; 
                                                        scale2 = (dr(axis)**2/rFactor)**2/c4;
                                                        scale3 = (dr(axis)**2/rFactor)**3/c6; 
                            ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
                                                        r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
                                                        r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
                                                        r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3
                            ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: uxx,uxxxx,uxxxxxx=",3(1pe9.2,1x))') i1,i2,uxx,uxxxx,uxxxxxx
                            ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
                            ! Order=6: (see MakeGetDerivativesMacro.maple output)
                            ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
                                                        a3(0,0) = ( (  3./2.) )   ! coeff of u(-1) in c2*( uxx + uyy )*scale1
                                                        a3(0,1) = ( (-3./20.) )   ! coeff of u(-2) 
                                                        a3(0,2) = ( ( 1./90.) )   ! coeff of u(-3)
                            ! Order=4:
                            ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
                                                        a3(1,0) = ( (-13./2.) )
                                                        a3(1,1) = ( (     2.) )
                                                        a3(1,2) = ( ( -1./6.) )
                            ! Order=2
                            ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
                                                        a3(2,0) = ( (    15.) )
                                                        a3(2,1) = ( (    -6.) )
                                                        a3(2,2) = ( (     1.) )
                            ! Find the inverse -- We could save these inverses
                                                        det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
                                                        det=1./det;
                                                        a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
                                                        a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
                                                        a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
                                                        a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
                                                        a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
                                                        a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
                                                        a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
                                                        a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
                                                        a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 
                          !   ! check inverse
                          !   if( .true. )then
                          !     do m1=0,2
                          !       do m2=0,2
                          !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
                          !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
                          !       end do
                          !     end do
                          !   end if
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                else
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                            ! No forcing, do nothing 
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                          ! -- 3D ---
                          ! This next seems broken: 
                          ! getSixthDerivatives3d(6,curvilinear,OPTION,i1,i2,i3)
                                                    stop 6363
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                end if
                            end if 
                        else
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                    call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx )
                                                                    call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
                                                                    call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )
                                                                    call ogDeriv(ep,0,6,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxx )
                                                                    call ogDeriv(ep,0,4,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxyy )
                                                                    call ogDeriv(ep,0,2,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyyy )
                                                                    call ogDeriv(ep,0,0,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyyy )
                                                                f1 = -c2*( uexx + ueyy )
                                                                f2 = -c4*( uexxxx + ueyyyy + 2.*uexxyy )
                                                                f3 = -c6*( uexxxxxx + ueyyyyyy + 3.*( uexxxxyy + uexxyyyy ) )
                                                        else
                              ! Fix me for standard forcings 
                                                            f1=0.; f2=0.; f3=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                            ! ---------- RECTANGULAR  ---------
                            ! This assumes dr(0:2) = dx(0:2)
                                                        uxx      = (2.*u(i1-3,i2,i3,0)-27.*u(i1-2,i2,i3,0)+270.*u(i1-1,i2,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1+1,i2,i3,0)-27.*u(i1+2,i2,i3,0)+2.*u(i1+3,i2,i3,0))/(180.*dr(0)**2)
                                                        uxxxx    = (-u(i1-3,i2,i3,0)+12.*u(i1-2,i2,i3,0)-39.*u(i1-1,i2,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1+1,i2,i3,0)+12.*u(i1+2,i2,i3,0)-u(i1+3,i2,i3,0))/(6.*dr(0)**4)
                                                        uxxxxxx  = (u(i1-3,i2,i3,0)-6.*u(i1-2,i2,i3,0)+15.*u(i1-1,i2,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1+1,i2,i3,0)-6.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(dr(0)**6)
                                                        uyy      = (2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)
                                                        uxxyy    = (2.*(2.*u(i1-3,i2-3,i3,0)-27.*u(i1-3,i2-2,i3,0)+270.*u(i1-3,i2-1,i3,0)-490.*u(i1-3,i2,i3,0)+270.*u(i1-3,i2+1,i3,0)-27.*u(i1-3,i2+2,i3,0)+2.*u(i1-3,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1-2,i2-3,i3,0)-27.*u(i1-2,i2-2,i3,0)+270.*u(i1-2,i2-1,i3,0)-490.*u(i1-2,i2,i3,0)+270.*u(i1-2,i2+1,i3,0)-27.*u(i1-2,i2+2,i3,0)+2.*u(i1-2,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1-1,i2-3,i3,0)-27.*u(i1-1,i2-2,i3,0)+270.*u(i1-1,i2-1,i3,0)-490.*u(i1-1,i2,i3,0)+270.*u(i1-1,i2+1,i3,0)-27.*u(i1-1,i2+2,i3,0)+2.*u(i1-1,i2+3,i3,0))/(180.*dr(1)**2)-490.*(2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1+1,i2-3,i3,0)-27.*u(i1+1,i2-2,i3,0)+270.*u(i1+1,i2-1,i3,0)-490.*u(i1+1,i2,i3,0)+270.*u(i1+1,i2+1,i3,0)-27.*u(i1+1,i2+2,i3,0)+2.*u(i1+1,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1+2,i2-3,i3,0)-27.*u(i1+2,i2-2,i3,0)+270.*u(i1+2,i2-1,i3,0)-490.*u(i1+2,i2,i3,0)+270.*u(i1+2,i2+1,i3,0)-27.*u(i1+2,i2+2,i3,0)+2.*u(i1+2,i2+3,i3,0))/(180.*dr(1)**2)+2.*(2.*u(i1+3,i2-3,i3,0)-27.*u(i1+3,i2-2,i3,0)+270.*u(i1+3,i2-1,i3,0)-490.*u(i1+3,i2,i3,0)+270.*u(i1+3,i2+1,i3,0)-27.*u(i1+3,i2+2,i3,0)+2.*u(i1+3,i2+3,i3,0))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        uxxxxyy  = (-(-u(i1-3,i2-2,i3,0)+16.*u(i1-3,i2-1,i3,0)-30.*u(i1-3,i2,i3,0)+16.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1-2,i2-2,i3,0)+16.*u(i1-2,i2-1,i3,0)-30.*u(i1-2,i2,i3,0)+16.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1-1,i2-2,i3,0)+16.*u(i1-1,i2-1,i3,0)-30.*u(i1-1,i2,i3,0)+16.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1)**2)+56.*(-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1+1,i2-2,i3,0)+16.*u(i1+1,i2-1,i3,0)-30.*u(i1+1,i2,i3,0)+16.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1+2,i2-2,i3,0)+16.*u(i1+2,i2-1,i3,0)-30.*u(i1+2,i2,i3,0)+16.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)**2)-(-u(i1+3,i2-2,i3,0)+16.*u(i1+3,i2-1,i3,0)-30.*u(i1+3,i2,i3,0)+16.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)**2))/(6.*dr(0)**4)
                                                        uyyyy    = (-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)
                                                        uxxyyyy  = (-(-u(i1-2,i2-3,i3,0)+12.*u(i1-2,i2-2,i3,0)-39.*u(i1-2,i2-1,i3,0)+56.*u(i1-2,i2,i3,0)-39.*u(i1-2,i2+1,i3,0)+12.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1-1,i2-3,i3,0)+12.*u(i1-1,i2-2,i3,0)-39.*u(i1-1,i2-1,i3,0)+56.*u(i1-1,i2,i3,0)-39.*u(i1-1,i2+1,i3,0)+12.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(6.*dr(1)**4)-30.*(-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1+1,i2-3,i3,0)+12.*u(i1+1,i2-2,i3,0)-39.*u(i1+1,i2-1,i3,0)+56.*u(i1+1,i2,i3,0)-39.*u(i1+1,i2+1,i3,0)+12.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(6.*dr(1)**4)-(-u(i1+2,i2-3,i3,0)+12.*u(i1+2,i2-2,i3,0)-39.*u(i1+2,i2-1,i3,0)+56.*u(i1+2,i2,i3,0)-39.*u(i1+2,i2+1,i3,0)+12.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(6.*dr(1)**4))/(12.*dr(0)**2)
                                                        uyyyyyy  = (u(i1,i2-3,i3,0)-6.*u(i1,i2-2,i3,0)+15.*u(i1,i2-1,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1,i2+1,i3,0)-6.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(dr(1)**6)
                            ! scale equations for better conditioning
                                                        scale1 = dx(axis)**2/c2; 
                                                        scale2 = dx(axis)**4/c4;
                                                        scale3 = dx(axis)**6/c6; 
                            ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
                                                        r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
                                                        r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
                                                        r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3
                            ! write(*,'("(i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
                                                        if( firstTimeForCBC6 )then
                              ! first time trhu, create the matrix of coefficients
                                                              firstTimeForCBC6 = .false. 
                              ! Order=6: (see MakeGetDerivativesMacro.maple output)
                              ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
                                                            a3(0,0) = c2*( (  3./2.)/(dx(axis)**2) )*scale1   ! coeff of u(-1) in c2*( uxx + uyy )*scale
                                                            a3(0,1) = c2*( (-3./20.)/(dx(axis)**2) )*scale1   ! coeff of u(-2) 
                                                            a3(0,2) = c2*( ( 1./90.)/(dx(axis)**2) )*scale1   ! coeff of u(-3)
                              ! Order=4:
                              ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
                                                            a3(1,0) = c4*( (-13./2.)/(dx(axis)**4) )*scale2
                                                            a3(1,1) = c4*( (     2.)/(dx(axis)**4) )*scale2
                                                            a3(1,2) = c4*( ( -1./6.)/(dx(axis)**4) )*scale2
                              ! Order=2
                              ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
                                                            a3(2,0) = c6*( (    15.)/(dx(axis)**6) )*scale3
                                                            a3(2,1) = c6*( (    -6.)/(dx(axis)**6) )*scale3
                                                            a3(2,2) = c6*( (     1.)/(dx(axis)**6) )*scale3
                              ! Find the inverse -- could be done once for rectangular and saved
                                                            det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
                                                            det=1./det;
                                                            a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
                                                            a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
                                                            a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
                                                            a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
                                                            a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
                                                            a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
                                                            a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
                                                            a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
                                                            a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 
                            !   ! check inverse
                            !   if( .true. )then
                            !     do m1=0,2
                            !       do m2=0,2
                            !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
                            !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
                            !       end do
                            !     end do
                            !   end if
                                                        end if ! end if firstTime
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                else
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                    call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxx )
                                                                    call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyy )
                                                                    call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyy )
                                                                    call ogDeriv(ep,0,6,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxxxx )
                                                                    call ogDeriv(ep,0,4,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxxyy )
                                                                    call ogDeriv(ep,0,2,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyyyy )
                                                                    call ogDeriv(ep,0,0,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyyyy )
                                                                        call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                        call ogDeriv(ep,0,2,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzz )
                                                                        call ogDeriv(ep,0,0,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzz )
                                                                        call ogDeriv(ep,0,0,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzz )
                                                                        call ogDeriv(ep,0,4,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxxzz )
                                                                        call ogDeriv(ep,0,2,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzzzz )
                                                                        call ogDeriv(ep,0,0,4,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyyzz )
                                                                        call ogDeriv(ep,0,0,2,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzzzz )
                                                                        call ogDeriv(ep,0,0,0,6,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzzzz )
                                                                        call ogDeriv(ep,0,2,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyyzz )
                                                                f1 = -c2*( uexx + ueyy + uezz )
                                                                f2 = -c4*( uexxxx + ueyyyy + uezzzz + 2.*(uexxyy + uexxzz + ueyyzz) )
                                                                f3 = -c6*(       uexxxxxx + ueyyyyyy + uezzzzzz + 3.*( uexxxxyy + uexxyyyy + uexxxxzz + uexxzzzz + ueyyyyzz + ueyyzzzz) + 6.*( uexxyyzz ) )
                                                        else
                              ! Fix me for standard forcings 
                                                            f1=0.; f2=0.; f3=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                          ! -- 3D ---
                          ! This next seems broken: 
                          ! getSixthDerivatives3d(6,rectangular,OPTION,i1,i2,i3)
                                                    stop 6363
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                end if
                            else
                                if( nd.eq.2 )then
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                                                                    call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx )
                                                                    call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
                                                                    call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )
                                                                    call ogDeriv(ep,0,6,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxx )
                                                                    call ogDeriv(ep,0,4,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxyy )
                                                                    call ogDeriv(ep,0,2,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyyy )
                                                                    call ogDeriv(ep,0,0,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyyy )
                                                                f1 = -c2*( uexx + ueyy )
                                                                f2 = -c4*( uexxxx + ueyyyy + 2.*uexxyy )
                                                                f3 = -c6*( uexxxxxx + ueyyyyyy + 3.*( uexxxxyy + uexxyyyy ) )
                                                        else
                              ! Fix me for standard forcings 
                                                            f1=0.; f2=0.; f3=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                            ! ----- curvilinear ----
                            ! ---------- START CURVILINEAR  ---------
                            ! ---------- Parametric derivatives ---------
                                                        ur       = (-u(i1-3,i2,i3,0)+9.*u(i1-2,i2,i3,0)-45.*u(i1-1,i2,i3,0)+45.*u(i1+1,i2,i3,0)-9.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(60.*dr(0))
                                                        urr      = (2.*u(i1-3,i2,i3,0)-27.*u(i1-2,i2,i3,0)+270.*u(i1-1,i2,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1+1,i2,i3,0)-27.*u(i1+2,i2,i3,0)+2.*u(i1+3,i2,i3,0))/(180.*dr(0)**2)
                                                        urrr     = (u(i1-3,i2,i3,0)-8.*u(i1-2,i2,i3,0)+13.*u(i1-1,i2,i3,0)-13.*u(i1+1,i2,i3,0)+8.*u(i1+2,i2,i3,0)-u(i1+3,i2,i3,0))/(8.*dr(0)**3)
                                                        urrrr    = (-u(i1-3,i2,i3,0)+12.*u(i1-2,i2,i3,0)-39.*u(i1-1,i2,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1+1,i2,i3,0)+12.*u(i1+2,i2,i3,0)-u(i1+3,i2,i3,0))/(6.*dr(0)**4)
                                                        urrrrr   = (-u(i1-3,i2,i3,0)+4.*u(i1-2,i2,i3,0)-5.*u(i1-1,i2,i3,0)+5.*u(i1+1,i2,i3,0)-4.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(2.*dr(0)**5)
                                                        urrrrrr  = (u(i1-3,i2,i3,0)-6.*u(i1-2,i2,i3,0)+15.*u(i1-1,i2,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1+1,i2,i3,0)-6.*u(i1+2,i2,i3,0)+u(i1+3,i2,i3,0))/(dr(0)**6)
                                                        us       = (-u(i1,i2-3,i3,0)+9.*u(i1,i2-2,i3,0)-45.*u(i1,i2-1,i3,0)+45.*u(i1,i2+1,i3,0)-9.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(60.*dr(1))
                                                        urs      = (-(-u(i1-3,i2-3,i3,0)+9.*u(i1-3,i2-2,i3,0)-45.*u(i1-3,i2-1,i3,0)+45.*u(i1-3,i2+1,i3,0)-9.*u(i1-3,i2+2,i3,0)+u(i1-3,i2+3,i3,0))/(60.*dr(1))+9.*(-u(i1-2,i2-3,i3,0)+9.*u(i1-2,i2-2,i3,0)-45.*u(i1-2,i2-1,i3,0)+45.*u(i1-2,i2+1,i3,0)-9.*u(i1-2,i2+2,i3,0)+u(i1-2,i2+3,i3,0))/(60.*dr(1))-45.*(-u(i1-1,i2-3,i3,0)+9.*u(i1-1,i2-2,i3,0)-45.*u(i1-1,i2-1,i3,0)+45.*u(i1-1,i2+1,i3,0)-9.*u(i1-1,i2+2,i3,0)+u(i1-1,i2+3,i3,0))/(60.*dr(1))+45.*(-u(i1+1,i2-3,i3,0)+9.*u(i1+1,i2-2,i3,0)-45.*u(i1+1,i2-1,i3,0)+45.*u(i1+1,i2+1,i3,0)-9.*u(i1+1,i2+2,i3,0)+u(i1+1,i2+3,i3,0))/(60.*dr(1))-9.*(-u(i1+2,i2-3,i3,0)+9.*u(i1+2,i2-2,i3,0)-45.*u(i1+2,i2-1,i3,0)+45.*u(i1+2,i2+1,i3,0)-9.*u(i1+2,i2+2,i3,0)+u(i1+2,i2+3,i3,0))/(60.*dr(1))+(-u(i1+3,i2-3,i3,0)+9.*u(i1+3,i2-2,i3,0)-45.*u(i1+3,i2-1,i3,0)+45.*u(i1+3,i2+1,i3,0)-9.*u(i1+3,i2+2,i3,0)+u(i1+3,i2+3,i3,0))/(60.*dr(1)))/(60.*dr(0))
                                                        urrs     = (2.*(-u(i1-3,i2-3,i3,0)+9.*u(i1-3,i2-2,i3,0)-45.*u(i1-3,i2-1,i3,0)+45.*u(i1-3,i2+1,i3,0)-9.*u(i1-3,i2+2,i3,0)+u(i1-3,i2+3,i3,0))/(60.*dr(1))-27.*(-u(i1-2,i2-3,i3,0)+9.*u(i1-2,i2-2,i3,0)-45.*u(i1-2,i2-1,i3,0)+45.*u(i1-2,i2+1,i3,0)-9.*u(i1-2,i2+2,i3,0)+u(i1-2,i2+3,i3,0))/(60.*dr(1))+270.*(-u(i1-1,i2-3,i3,0)+9.*u(i1-1,i2-2,i3,0)-45.*u(i1-1,i2-1,i3,0)+45.*u(i1-1,i2+1,i3,0)-9.*u(i1-1,i2+2,i3,0)+u(i1-1,i2+3,i3,0))/(60.*dr(1))-490.*(-u(i1,i2-3,i3,0)+9.*u(i1,i2-2,i3,0)-45.*u(i1,i2-1,i3,0)+45.*u(i1,i2+1,i3,0)-9.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(60.*dr(1))+270.*(-u(i1+1,i2-3,i3,0)+9.*u(i1+1,i2-2,i3,0)-45.*u(i1+1,i2-1,i3,0)+45.*u(i1+1,i2+1,i3,0)-9.*u(i1+1,i2+2,i3,0)+u(i1+1,i2+3,i3,0))/(60.*dr(1))-27.*(-u(i1+2,i2-3,i3,0)+9.*u(i1+2,i2-2,i3,0)-45.*u(i1+2,i2-1,i3,0)+45.*u(i1+2,i2+1,i3,0)-9.*u(i1+2,i2+2,i3,0)+u(i1+2,i2+3,i3,0))/(60.*dr(1))+2.*(-u(i1+3,i2-3,i3,0)+9.*u(i1+3,i2-2,i3,0)-45.*u(i1+3,i2-1,i3,0)+45.*u(i1+3,i2+1,i3,0)-9.*u(i1+3,i2+2,i3,0)+u(i1+3,i2+3,i3,0))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        urrrs    = ((u(i1-3,i2-2,i3,0)-8.*u(i1-3,i2-1,i3,0)+8.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))+13.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))-13.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1))-(u(i1+3,i2-2,i3,0)-8.*u(i1+3,i2-1,i3,0)+8.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        urrrrs   = (-(u(i1-3,i2-2,i3,0)-8.*u(i1-3,i2-1,i3,0)+8.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1))+12.*(u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-39.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+56.*(u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))-39.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))+12.*(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1))-(u(i1+3,i2-2,i3,0)-8.*u(i1+3,i2-1,i3,0)+8.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        urrrrrs  = (-(-u(i1-3,i2-1,i3,0)+u(i1-3,i2+1,i3,0))/(2.*dr(1))+4.*(-u(i1-2,i2-1,i3,0)+u(i1-2,i2+1,i3,0))/(2.*dr(1))-5.*(-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))+5.*(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1))-4.*(-u(i1+2,i2-1,i3,0)+u(i1+2,i2+1,i3,0))/(2.*dr(1))+(-u(i1+3,i2-1,i3,0)+u(i1+3,i2+1,i3,0))/(2.*dr(1)))/(2.*dr(0)**5)
                                                        uss      = (2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)
                                                        urss     = (-(2.*u(i1-3,i2-3,i3,0)-27.*u(i1-3,i2-2,i3,0)+270.*u(i1-3,i2-1,i3,0)-490.*u(i1-3,i2,i3,0)+270.*u(i1-3,i2+1,i3,0)-27.*u(i1-3,i2+2,i3,0)+2.*u(i1-3,i2+3,i3,0))/(180.*dr(1)**2)+9.*(2.*u(i1-2,i2-3,i3,0)-27.*u(i1-2,i2-2,i3,0)+270.*u(i1-2,i2-1,i3,0)-490.*u(i1-2,i2,i3,0)+270.*u(i1-2,i2+1,i3,0)-27.*u(i1-2,i2+2,i3,0)+2.*u(i1-2,i2+3,i3,0))/(180.*dr(1)**2)-45.*(2.*u(i1-1,i2-3,i3,0)-27.*u(i1-1,i2-2,i3,0)+270.*u(i1-1,i2-1,i3,0)-490.*u(i1-1,i2,i3,0)+270.*u(i1-1,i2+1,i3,0)-27.*u(i1-1,i2+2,i3,0)+2.*u(i1-1,i2+3,i3,0))/(180.*dr(1)**2)+45.*(2.*u(i1+1,i2-3,i3,0)-27.*u(i1+1,i2-2,i3,0)+270.*u(i1+1,i2-1,i3,0)-490.*u(i1+1,i2,i3,0)+270.*u(i1+1,i2+1,i3,0)-27.*u(i1+1,i2+2,i3,0)+2.*u(i1+1,i2+3,i3,0))/(180.*dr(1)**2)-9.*(2.*u(i1+2,i2-3,i3,0)-27.*u(i1+2,i2-2,i3,0)+270.*u(i1+2,i2-1,i3,0)-490.*u(i1+2,i2,i3,0)+270.*u(i1+2,i2+1,i3,0)-27.*u(i1+2,i2+2,i3,0)+2.*u(i1+2,i2+3,i3,0))/(180.*dr(1)**2)+(2.*u(i1+3,i2-3,i3,0)-27.*u(i1+3,i2-2,i3,0)+270.*u(i1+3,i2-1,i3,0)-490.*u(i1+3,i2,i3,0)+270.*u(i1+3,i2+1,i3,0)-27.*u(i1+3,i2+2,i3,0)+2.*u(i1+3,i2+3,i3,0))/(180.*dr(1)**2))/(60.*dr(0))
                                                        urrss    = (2.*(2.*u(i1-3,i2-3,i3,0)-27.*u(i1-3,i2-2,i3,0)+270.*u(i1-3,i2-1,i3,0)-490.*u(i1-3,i2,i3,0)+270.*u(i1-3,i2+1,i3,0)-27.*u(i1-3,i2+2,i3,0)+2.*u(i1-3,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1-2,i2-3,i3,0)-27.*u(i1-2,i2-2,i3,0)+270.*u(i1-2,i2-1,i3,0)-490.*u(i1-2,i2,i3,0)+270.*u(i1-2,i2+1,i3,0)-27.*u(i1-2,i2+2,i3,0)+2.*u(i1-2,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1-1,i2-3,i3,0)-27.*u(i1-1,i2-2,i3,0)+270.*u(i1-1,i2-1,i3,0)-490.*u(i1-1,i2,i3,0)+270.*u(i1-1,i2+1,i3,0)-27.*u(i1-1,i2+2,i3,0)+2.*u(i1-1,i2+3,i3,0))/(180.*dr(1)**2)-490.*(2.*u(i1,i2-3,i3,0)-27.*u(i1,i2-2,i3,0)+270.*u(i1,i2-1,i3,0)-490.*u(i1,i2,i3,0)+270.*u(i1,i2+1,i3,0)-27.*u(i1,i2+2,i3,0)+2.*u(i1,i2+3,i3,0))/(180.*dr(1)**2)+270.*(2.*u(i1+1,i2-3,i3,0)-27.*u(i1+1,i2-2,i3,0)+270.*u(i1+1,i2-1,i3,0)-490.*u(i1+1,i2,i3,0)+270.*u(i1+1,i2+1,i3,0)-27.*u(i1+1,i2+2,i3,0)+2.*u(i1+1,i2+3,i3,0))/(180.*dr(1)**2)-27.*(2.*u(i1+2,i2-3,i3,0)-27.*u(i1+2,i2-2,i3,0)+270.*u(i1+2,i2-1,i3,0)-490.*u(i1+2,i2,i3,0)+270.*u(i1+2,i2+1,i3,0)-27.*u(i1+2,i2+2,i3,0)+2.*u(i1+2,i2+3,i3,0))/(180.*dr(1)**2)+2.*(2.*u(i1+3,i2-3,i3,0)-27.*u(i1+3,i2-2,i3,0)+270.*u(i1+3,i2-1,i3,0)-490.*u(i1+3,i2,i3,0)+270.*u(i1+3,i2+1,i3,0)-27.*u(i1+3,i2+2,i3,0)+2.*u(i1+3,i2+3,i3,0))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        urrrss   = ((-u(i1-3,i2-2,i3,0)+16.*u(i1-3,i2-1,i3,0)-30.*u(i1-3,i2,i3,0)+16.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1)**2)-8.*(-u(i1-2,i2-2,i3,0)+16.*u(i1-2,i2-1,i3,0)-30.*u(i1-2,i2,i3,0)+16.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1)**2)+13.*(-u(i1-1,i2-2,i3,0)+16.*u(i1-1,i2-1,i3,0)-30.*u(i1-1,i2,i3,0)+16.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1)**2)-13.*(-u(i1+1,i2-2,i3,0)+16.*u(i1+1,i2-1,i3,0)-30.*u(i1+1,i2,i3,0)+16.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1)**2)+8.*(-u(i1+2,i2-2,i3,0)+16.*u(i1+2,i2-1,i3,0)-30.*u(i1+2,i2,i3,0)+16.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)**2)-(-u(i1+3,i2-2,i3,0)+16.*u(i1+3,i2-1,i3,0)-30.*u(i1+3,i2,i3,0)+16.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        urrrrss  = (-(-u(i1-3,i2-2,i3,0)+16.*u(i1-3,i2-1,i3,0)-30.*u(i1-3,i2,i3,0)+16.*u(i1-3,i2+1,i3,0)-u(i1-3,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1-2,i2-2,i3,0)+16.*u(i1-2,i2-1,i3,0)-30.*u(i1-2,i2,i3,0)+16.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1-1,i2-2,i3,0)+16.*u(i1-1,i2-1,i3,0)-30.*u(i1-1,i2,i3,0)+16.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1)**2)+56.*(-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)-39.*(-u(i1+1,i2-2,i3,0)+16.*u(i1+1,i2-1,i3,0)-30.*u(i1+1,i2,i3,0)+16.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1)**2)+12.*(-u(i1+2,i2-2,i3,0)+16.*u(i1+2,i2-1,i3,0)-30.*u(i1+2,i2,i3,0)+16.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)**2)-(-u(i1+3,i2-2,i3,0)+16.*u(i1+3,i2-1,i3,0)-30.*u(i1+3,i2,i3,0)+16.*u(i1+3,i2+1,i3,0)-u(i1+3,i2+2,i3,0))/(12.*dr(1)**2))/(6.*dr(0)**4)
                                                        usss     = (u(i1,i2-3,i3,0)-8.*u(i1,i2-2,i3,0)+13.*u(i1,i2-1,i3,0)-13.*u(i1,i2+1,i3,0)+8.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(8.*dr(1)**3)
                                                        ursss    = ((u(i1-2,i2-3,i3,0)-8.*u(i1-2,i2-2,i3,0)+13.*u(i1-2,i2-1,i3,0)-13.*u(i1-2,i2+1,i3,0)+8.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(8.*dr(1)**3)-8.*(u(i1-1,i2-3,i3,0)-8.*u(i1-1,i2-2,i3,0)+13.*u(i1-1,i2-1,i3,0)-13.*u(i1-1,i2+1,i3,0)+8.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(8.*dr(1)**3)+8.*(u(i1+1,i2-3,i3,0)-8.*u(i1+1,i2-2,i3,0)+13.*u(i1+1,i2-1,i3,0)-13.*u(i1+1,i2+1,i3,0)+8.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(8.*dr(1)**3)-(u(i1+2,i2-3,i3,0)-8.*u(i1+2,i2-2,i3,0)+13.*u(i1+2,i2-1,i3,0)-13.*u(i1+2,i2+1,i3,0)+8.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(8.*dr(1)**3))/(12.*dr(0))
                                                        urrsss   = (-(u(i1-2,i2-3,i3,0)-8.*u(i1-2,i2-2,i3,0)+13.*u(i1-2,i2-1,i3,0)-13.*u(i1-2,i2+1,i3,0)+8.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(8.*dr(1)**3)+16.*(u(i1-1,i2-3,i3,0)-8.*u(i1-1,i2-2,i3,0)+13.*u(i1-1,i2-1,i3,0)-13.*u(i1-1,i2+1,i3,0)+8.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(8.*dr(1)**3)-30.*(u(i1,i2-3,i3,0)-8.*u(i1,i2-2,i3,0)+13.*u(i1,i2-1,i3,0)-13.*u(i1,i2+1,i3,0)+8.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(8.*dr(1)**3)+16.*(u(i1+1,i2-3,i3,0)-8.*u(i1+1,i2-2,i3,0)+13.*u(i1+1,i2-1,i3,0)-13.*u(i1+1,i2+1,i3,0)+8.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(8.*dr(1)**3)-(u(i1+2,i2-3,i3,0)-8.*u(i1+2,i2-2,i3,0)+13.*u(i1+2,i2-1,i3,0)-13.*u(i1+2,i2+1,i3,0)+8.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        urrrsss  = ((u(i1-3,i2-3,i3,0)-8.*u(i1-3,i2-2,i3,0)+13.*u(i1-3,i2-1,i3,0)-13.*u(i1-3,i2+1,i3,0)+8.*u(i1-3,i2+2,i3,0)-u(i1-3,i2+3,i3,0))/(8.*dr(1)**3)-8.*(u(i1-2,i2-3,i3,0)-8.*u(i1-2,i2-2,i3,0)+13.*u(i1-2,i2-1,i3,0)-13.*u(i1-2,i2+1,i3,0)+8.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(8.*dr(1)**3)+13.*(u(i1-1,i2-3,i3,0)-8.*u(i1-1,i2-2,i3,0)+13.*u(i1-1,i2-1,i3,0)-13.*u(i1-1,i2+1,i3,0)+8.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(8.*dr(1)**3)-13.*(u(i1+1,i2-3,i3,0)-8.*u(i1+1,i2-2,i3,0)+13.*u(i1+1,i2-1,i3,0)-13.*u(i1+1,i2+1,i3,0)+8.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(8.*dr(1)**3)+8.*(u(i1+2,i2-3,i3,0)-8.*u(i1+2,i2-2,i3,0)+13.*u(i1+2,i2-1,i3,0)-13.*u(i1+2,i2+1,i3,0)+8.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(8.*dr(1)**3)-(u(i1+3,i2-3,i3,0)-8.*u(i1+3,i2-2,i3,0)+13.*u(i1+3,i2-1,i3,0)-13.*u(i1+3,i2+1,i3,0)+8.*u(i1+3,i2+2,i3,0)-u(i1+3,i2+3,i3,0))/(8.*dr(1)**3))/(8.*dr(0)**3)
                                                        ussss    = (-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)
                                                        urssss   = ((-u(i1-2,i2-3,i3,0)+12.*u(i1-2,i2-2,i3,0)-39.*u(i1-2,i2-1,i3,0)+56.*u(i1-2,i2,i3,0)-39.*u(i1-2,i2+1,i3,0)+12.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(6.*dr(1)**4)-8.*(-u(i1-1,i2-3,i3,0)+12.*u(i1-1,i2-2,i3,0)-39.*u(i1-1,i2-1,i3,0)+56.*u(i1-1,i2,i3,0)-39.*u(i1-1,i2+1,i3,0)+12.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(6.*dr(1)**4)+8.*(-u(i1+1,i2-3,i3,0)+12.*u(i1+1,i2-2,i3,0)-39.*u(i1+1,i2-1,i3,0)+56.*u(i1+1,i2,i3,0)-39.*u(i1+1,i2+1,i3,0)+12.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(6.*dr(1)**4)-(-u(i1+2,i2-3,i3,0)+12.*u(i1+2,i2-2,i3,0)-39.*u(i1+2,i2-1,i3,0)+56.*u(i1+2,i2,i3,0)-39.*u(i1+2,i2+1,i3,0)+12.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(6.*dr(1)**4))/(12.*dr(0))
                                                        urrssss  = (-(-u(i1-2,i2-3,i3,0)+12.*u(i1-2,i2-2,i3,0)-39.*u(i1-2,i2-1,i3,0)+56.*u(i1-2,i2,i3,0)-39.*u(i1-2,i2+1,i3,0)+12.*u(i1-2,i2+2,i3,0)-u(i1-2,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1-1,i2-3,i3,0)+12.*u(i1-1,i2-2,i3,0)-39.*u(i1-1,i2-1,i3,0)+56.*u(i1-1,i2,i3,0)-39.*u(i1-1,i2+1,i3,0)+12.*u(i1-1,i2+2,i3,0)-u(i1-1,i2+3,i3,0))/(6.*dr(1)**4)-30.*(-u(i1,i2-3,i3,0)+12.*u(i1,i2-2,i3,0)-39.*u(i1,i2-1,i3,0)+56.*u(i1,i2,i3,0)-39.*u(i1,i2+1,i3,0)+12.*u(i1,i2+2,i3,0)-u(i1,i2+3,i3,0))/(6.*dr(1)**4)+16.*(-u(i1+1,i2-3,i3,0)+12.*u(i1+1,i2-2,i3,0)-39.*u(i1+1,i2-1,i3,0)+56.*u(i1+1,i2,i3,0)-39.*u(i1+1,i2+1,i3,0)+12.*u(i1+1,i2+2,i3,0)-u(i1+1,i2+3,i3,0))/(6.*dr(1)**4)-(-u(i1+2,i2-3,i3,0)+12.*u(i1+2,i2-2,i3,0)-39.*u(i1+2,i2-1,i3,0)+56.*u(i1+2,i2,i3,0)-39.*u(i1+2,i2+1,i3,0)+12.*u(i1+2,i2+2,i3,0)-u(i1+2,i2+3,i3,0))/(6.*dr(1)**4))/(12.*dr(0)**2)
                                                        usssss   = (-u(i1,i2-3,i3,0)+4.*u(i1,i2-2,i3,0)-5.*u(i1,i2-1,i3,0)+5.*u(i1,i2+1,i3,0)-4.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(2.*dr(1)**5)
                                                        ursssss  = (-(-u(i1-1,i2-3,i3,0)+4.*u(i1-1,i2-2,i3,0)-5.*u(i1-1,i2-1,i3,0)+5.*u(i1-1,i2+1,i3,0)-4.*u(i1-1,i2+2,i3,0)+u(i1-1,i2+3,i3,0))/(2.*dr(1)**5)+(-u(i1+1,i2-3,i3,0)+4.*u(i1+1,i2-2,i3,0)-5.*u(i1+1,i2-1,i3,0)+5.*u(i1+1,i2+1,i3,0)-4.*u(i1+1,i2+2,i3,0)+u(i1+1,i2+3,i3,0))/(2.*dr(1)**5))/(2.*dr(0))
                                                        ussssss  = (u(i1,i2-3,i3,0)-6.*u(i1,i2-2,i3,0)+15.*u(i1,i2-1,i3,0)-20.*u(i1,i2,i3,0)+15.*u(i1,i2+1,i3,0)-6.*u(i1,i2+2,i3,0)+u(i1,i2+3,i3,0))/(dr(1)**6)
                                                        rxr      = (-rx(i1-3,i2,i3)+9.*rx(i1-2,i2,i3)-45.*rx(i1-1,i2,i3)+45.*rx(i1+1,i2,i3)-9.*rx(i1+2,i2,i3)+rx(i1+3,i2,i3))/(60.*dr(0))
                                                        rxrr     = (2.*rx(i1-3,i2,i3)-27.*rx(i1-2,i2,i3)+270.*rx(i1-1,i2,i3)-490.*rx(i1,i2,i3)+270.*rx(i1+1,i2,i3)-27.*rx(i1+2,i2,i3)+2.*rx(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        rxrrr    = (rx(i1-3,i2,i3)-8.*rx(i1-2,i2,i3)+13.*rx(i1-1,i2,i3)-13.*rx(i1+1,i2,i3)+8.*rx(i1+2,i2,i3)-rx(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        rxrrrr   = (-rx(i1-3,i2,i3)+12.*rx(i1-2,i2,i3)-39.*rx(i1-1,i2,i3)+56.*rx(i1,i2,i3)-39.*rx(i1+1,i2,i3)+12.*rx(i1+2,i2,i3)-rx(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        rxrrrrr  = (-rx(i1-3,i2,i3)+4.*rx(i1-2,i2,i3)-5.*rx(i1-1,i2,i3)+5.*rx(i1+1,i2,i3)-4.*rx(i1+2,i2,i3)+rx(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        rxs      = (-rx(i1,i2-3,i3)+9.*rx(i1,i2-2,i3)-45.*rx(i1,i2-1,i3)+45.*rx(i1,i2+1,i3)-9.*rx(i1,i2+2,i3)+rx(i1,i2+3,i3))/(60.*dr(1))
                                                        rxrs     = (-(-rx(i1-3,i2-3,i3)+9.*rx(i1-3,i2-2,i3)-45.*rx(i1-3,i2-1,i3)+45.*rx(i1-3,i2+1,i3)-9.*rx(i1-3,i2+2,i3)+rx(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-rx(i1-2,i2-3,i3)+9.*rx(i1-2,i2-2,i3)-45.*rx(i1-2,i2-1,i3)+45.*rx(i1-2,i2+1,i3)-9.*rx(i1-2,i2+2,i3)+rx(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-rx(i1-1,i2-3,i3)+9.*rx(i1-1,i2-2,i3)-45.*rx(i1-1,i2-1,i3)+45.*rx(i1-1,i2+1,i3)-9.*rx(i1-1,i2+2,i3)+rx(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-rx(i1+1,i2-3,i3)+9.*rx(i1+1,i2-2,i3)-45.*rx(i1+1,i2-1,i3)+45.*rx(i1+1,i2+1,i3)-9.*rx(i1+1,i2+2,i3)+rx(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-rx(i1+2,i2-3,i3)+9.*rx(i1+2,i2-2,i3)-45.*rx(i1+2,i2-1,i3)+45.*rx(i1+2,i2+1,i3)-9.*rx(i1+2,i2+2,i3)+rx(i1+2,i2+3,i3))/(60.*dr(1))+(-rx(i1+3,i2-3,i3)+9.*rx(i1+3,i2-2,i3)-45.*rx(i1+3,i2-1,i3)+45.*rx(i1+3,i2+1,i3)-9.*rx(i1+3,i2+2,i3)+rx(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        rxrrs    = (2.*(-rx(i1-3,i2-3,i3)+9.*rx(i1-3,i2-2,i3)-45.*rx(i1-3,i2-1,i3)+45.*rx(i1-3,i2+1,i3)-9.*rx(i1-3,i2+2,i3)+rx(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-rx(i1-2,i2-3,i3)+9.*rx(i1-2,i2-2,i3)-45.*rx(i1-2,i2-1,i3)+45.*rx(i1-2,i2+1,i3)-9.*rx(i1-2,i2+2,i3)+rx(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-rx(i1-1,i2-3,i3)+9.*rx(i1-1,i2-2,i3)-45.*rx(i1-1,i2-1,i3)+45.*rx(i1-1,i2+1,i3)-9.*rx(i1-1,i2+2,i3)+rx(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-rx(i1,i2-3,i3)+9.*rx(i1,i2-2,i3)-45.*rx(i1,i2-1,i3)+45.*rx(i1,i2+1,i3)-9.*rx(i1,i2+2,i3)+rx(i1,i2+3,i3))/(60.*dr(1))+270.*(-rx(i1+1,i2-3,i3)+9.*rx(i1+1,i2-2,i3)-45.*rx(i1+1,i2-1,i3)+45.*rx(i1+1,i2+1,i3)-9.*rx(i1+1,i2+2,i3)+rx(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-rx(i1+2,i2-3,i3)+9.*rx(i1+2,i2-2,i3)-45.*rx(i1+2,i2-1,i3)+45.*rx(i1+2,i2+1,i3)-9.*rx(i1+2,i2+2,i3)+rx(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-rx(i1+3,i2-3,i3)+9.*rx(i1+3,i2-2,i3)-45.*rx(i1+3,i2-1,i3)+45.*rx(i1+3,i2+1,i3)-9.*rx(i1+3,i2+2,i3)+rx(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        rxrrrs   = ((rx(i1-3,i2-2,i3)-8.*rx(i1-3,i2-1,i3)+8.*rx(i1-3,i2+1,i3)-rx(i1-3,i2+2,i3))/(12.*dr(1))-8.*(rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))+13.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))-13.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))+8.*(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1))-(rx(i1+3,i2-2,i3)-8.*rx(i1+3,i2-1,i3)+8.*rx(i1+3,i2+1,i3)-rx(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        rxrrrrs  = (-(rx(i1-3,i2-2,i3)-8.*rx(i1-3,i2-1,i3)+8.*rx(i1-3,i2+1,i3)-rx(i1-3,i2+2,i3))/(12.*dr(1))+12.*(rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))-39.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))+56.*(rx(i1,i2-2,i3)-8.*rx(i1,i2-1,i3)+8.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1))-39.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))+12.*(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1))-(rx(i1+3,i2-2,i3)-8.*rx(i1+3,i2-1,i3)+8.*rx(i1+3,i2+1,i3)-rx(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        rxss     = (2.*rx(i1,i2-3,i3)-27.*rx(i1,i2-2,i3)+270.*rx(i1,i2-1,i3)-490.*rx(i1,i2,i3)+270.*rx(i1,i2+1,i3)-27.*rx(i1,i2+2,i3)+2.*rx(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        rxrss    = (-(2.*rx(i1-3,i2-3,i3)-27.*rx(i1-3,i2-2,i3)+270.*rx(i1-3,i2-1,i3)-490.*rx(i1-3,i2,i3)+270.*rx(i1-3,i2+1,i3)-27.*rx(i1-3,i2+2,i3)+2.*rx(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*rx(i1-2,i2-3,i3)-27.*rx(i1-2,i2-2,i3)+270.*rx(i1-2,i2-1,i3)-490.*rx(i1-2,i2,i3)+270.*rx(i1-2,i2+1,i3)-27.*rx(i1-2,i2+2,i3)+2.*rx(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*rx(i1-1,i2-3,i3)-27.*rx(i1-1,i2-2,i3)+270.*rx(i1-1,i2-1,i3)-490.*rx(i1-1,i2,i3)+270.*rx(i1-1,i2+1,i3)-27.*rx(i1-1,i2+2,i3)+2.*rx(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*rx(i1+1,i2-3,i3)-27.*rx(i1+1,i2-2,i3)+270.*rx(i1+1,i2-1,i3)-490.*rx(i1+1,i2,i3)+270.*rx(i1+1,i2+1,i3)-27.*rx(i1+1,i2+2,i3)+2.*rx(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*rx(i1+2,i2-3,i3)-27.*rx(i1+2,i2-2,i3)+270.*rx(i1+2,i2-1,i3)-490.*rx(i1+2,i2,i3)+270.*rx(i1+2,i2+1,i3)-27.*rx(i1+2,i2+2,i3)+2.*rx(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*rx(i1+3,i2-3,i3)-27.*rx(i1+3,i2-2,i3)+270.*rx(i1+3,i2-1,i3)-490.*rx(i1+3,i2,i3)+270.*rx(i1+3,i2+1,i3)-27.*rx(i1+3,i2+2,i3)+2.*rx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        rxrrss   = (2.*(2.*rx(i1-3,i2-3,i3)-27.*rx(i1-3,i2-2,i3)+270.*rx(i1-3,i2-1,i3)-490.*rx(i1-3,i2,i3)+270.*rx(i1-3,i2+1,i3)-27.*rx(i1-3,i2+2,i3)+2.*rx(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*rx(i1-2,i2-3,i3)-27.*rx(i1-2,i2-2,i3)+270.*rx(i1-2,i2-1,i3)-490.*rx(i1-2,i2,i3)+270.*rx(i1-2,i2+1,i3)-27.*rx(i1-2,i2+2,i3)+2.*rx(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*rx(i1-1,i2-3,i3)-27.*rx(i1-1,i2-2,i3)+270.*rx(i1-1,i2-1,i3)-490.*rx(i1-1,i2,i3)+270.*rx(i1-1,i2+1,i3)-27.*rx(i1-1,i2+2,i3)+2.*rx(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*rx(i1,i2-3,i3)-27.*rx(i1,i2-2,i3)+270.*rx(i1,i2-1,i3)-490.*rx(i1,i2,i3)+270.*rx(i1,i2+1,i3)-27.*rx(i1,i2+2,i3)+2.*rx(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*rx(i1+1,i2-3,i3)-27.*rx(i1+1,i2-2,i3)+270.*rx(i1+1,i2-1,i3)-490.*rx(i1+1,i2,i3)+270.*rx(i1+1,i2+1,i3)-27.*rx(i1+1,i2+2,i3)+2.*rx(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*rx(i1+2,i2-3,i3)-27.*rx(i1+2,i2-2,i3)+270.*rx(i1+2,i2-1,i3)-490.*rx(i1+2,i2,i3)+270.*rx(i1+2,i2+1,i3)-27.*rx(i1+2,i2+2,i3)+2.*rx(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*rx(i1+3,i2-3,i3)-27.*rx(i1+3,i2-2,i3)+270.*rx(i1+3,i2-1,i3)-490.*rx(i1+3,i2,i3)+270.*rx(i1+3,i2+1,i3)-27.*rx(i1+3,i2+2,i3)+2.*rx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        rxrrrss  = ((-rx(i1-3,i2-2,i3)+16.*rx(i1-3,i2-1,i3)-30.*rx(i1-3,i2,i3)+16.*rx(i1-3,i2+1,i3)-rx(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-rx(i1-2,i2-2,i3)+16.*rx(i1-2,i2-1,i3)-30.*rx(i1-2,i2,i3)+16.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-rx(i1-1,i2-2,i3)+16.*rx(i1-1,i2-1,i3)-30.*rx(i1-1,i2,i3)+16.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-rx(i1+1,i2-2,i3)+16.*rx(i1+1,i2-1,i3)-30.*rx(i1+1,i2,i3)+16.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-rx(i1+2,i2-2,i3)+16.*rx(i1+2,i2-1,i3)-30.*rx(i1+2,i2,i3)+16.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-rx(i1+3,i2-2,i3)+16.*rx(i1+3,i2-1,i3)-30.*rx(i1+3,i2,i3)+16.*rx(i1+3,i2+1,i3)-rx(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        rxsss    = (rx(i1,i2-3,i3)-8.*rx(i1,i2-2,i3)+13.*rx(i1,i2-1,i3)-13.*rx(i1,i2+1,i3)+8.*rx(i1,i2+2,i3)-rx(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        rxrsss   = ((rx(i1-2,i2-3,i3)-8.*rx(i1-2,i2-2,i3)+13.*rx(i1-2,i2-1,i3)-13.*rx(i1-2,i2+1,i3)+8.*rx(i1-2,i2+2,i3)-rx(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(rx(i1-1,i2-3,i3)-8.*rx(i1-1,i2-2,i3)+13.*rx(i1-1,i2-1,i3)-13.*rx(i1-1,i2+1,i3)+8.*rx(i1-1,i2+2,i3)-rx(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(rx(i1+1,i2-3,i3)-8.*rx(i1+1,i2-2,i3)+13.*rx(i1+1,i2-1,i3)-13.*rx(i1+1,i2+1,i3)+8.*rx(i1+1,i2+2,i3)-rx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(rx(i1+2,i2-3,i3)-8.*rx(i1+2,i2-2,i3)+13.*rx(i1+2,i2-1,i3)-13.*rx(i1+2,i2+1,i3)+8.*rx(i1+2,i2+2,i3)-rx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        rxrrsss  = (-(rx(i1-2,i2-3,i3)-8.*rx(i1-2,i2-2,i3)+13.*rx(i1-2,i2-1,i3)-13.*rx(i1-2,i2+1,i3)+8.*rx(i1-2,i2+2,i3)-rx(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(rx(i1-1,i2-3,i3)-8.*rx(i1-1,i2-2,i3)+13.*rx(i1-1,i2-1,i3)-13.*rx(i1-1,i2+1,i3)+8.*rx(i1-1,i2+2,i3)-rx(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(rx(i1,i2-3,i3)-8.*rx(i1,i2-2,i3)+13.*rx(i1,i2-1,i3)-13.*rx(i1,i2+1,i3)+8.*rx(i1,i2+2,i3)-rx(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(rx(i1+1,i2-3,i3)-8.*rx(i1+1,i2-2,i3)+13.*rx(i1+1,i2-1,i3)-13.*rx(i1+1,i2+1,i3)+8.*rx(i1+1,i2+2,i3)-rx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(rx(i1+2,i2-3,i3)-8.*rx(i1+2,i2-2,i3)+13.*rx(i1+2,i2-1,i3)-13.*rx(i1+2,i2+1,i3)+8.*rx(i1+2,i2+2,i3)-rx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        rxssss   = (-rx(i1,i2-3,i3)+12.*rx(i1,i2-2,i3)-39.*rx(i1,i2-1,i3)+56.*rx(i1,i2,i3)-39.*rx(i1,i2+1,i3)+12.*rx(i1,i2+2,i3)-rx(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        rxrssss  = ((-rx(i1-2,i2-3,i3)+12.*rx(i1-2,i2-2,i3)-39.*rx(i1-2,i2-1,i3)+56.*rx(i1-2,i2,i3)-39.*rx(i1-2,i2+1,i3)+12.*rx(i1-2,i2+2,i3)-rx(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-rx(i1-1,i2-3,i3)+12.*rx(i1-1,i2-2,i3)-39.*rx(i1-1,i2-1,i3)+56.*rx(i1-1,i2,i3)-39.*rx(i1-1,i2+1,i3)+12.*rx(i1-1,i2+2,i3)-rx(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-rx(i1+1,i2-3,i3)+12.*rx(i1+1,i2-2,i3)-39.*rx(i1+1,i2-1,i3)+56.*rx(i1+1,i2,i3)-39.*rx(i1+1,i2+1,i3)+12.*rx(i1+1,i2+2,i3)-rx(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-rx(i1+2,i2-3,i3)+12.*rx(i1+2,i2-2,i3)-39.*rx(i1+2,i2-1,i3)+56.*rx(i1+2,i2,i3)-39.*rx(i1+2,i2+1,i3)+12.*rx(i1+2,i2+2,i3)-rx(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        rxsssss  = (-rx(i1,i2-3,i3)+4.*rx(i1,i2-2,i3)-5.*rx(i1,i2-1,i3)+5.*rx(i1,i2+1,i3)-4.*rx(i1,i2+2,i3)+rx(i1,i2+3,i3))/(2.*dr(1)**5)
                                                        ryr      = (-ry(i1-3,i2,i3)+9.*ry(i1-2,i2,i3)-45.*ry(i1-1,i2,i3)+45.*ry(i1+1,i2,i3)-9.*ry(i1+2,i2,i3)+ry(i1+3,i2,i3))/(60.*dr(0))
                                                        ryrr     = (2.*ry(i1-3,i2,i3)-27.*ry(i1-2,i2,i3)+270.*ry(i1-1,i2,i3)-490.*ry(i1,i2,i3)+270.*ry(i1+1,i2,i3)-27.*ry(i1+2,i2,i3)+2.*ry(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        ryrrr    = (ry(i1-3,i2,i3)-8.*ry(i1-2,i2,i3)+13.*ry(i1-1,i2,i3)-13.*ry(i1+1,i2,i3)+8.*ry(i1+2,i2,i3)-ry(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        ryrrrr   = (-ry(i1-3,i2,i3)+12.*ry(i1-2,i2,i3)-39.*ry(i1-1,i2,i3)+56.*ry(i1,i2,i3)-39.*ry(i1+1,i2,i3)+12.*ry(i1+2,i2,i3)-ry(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        ryrrrrr  = (-ry(i1-3,i2,i3)+4.*ry(i1-2,i2,i3)-5.*ry(i1-1,i2,i3)+5.*ry(i1+1,i2,i3)-4.*ry(i1+2,i2,i3)+ry(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        rys      = (-ry(i1,i2-3,i3)+9.*ry(i1,i2-2,i3)-45.*ry(i1,i2-1,i3)+45.*ry(i1,i2+1,i3)-9.*ry(i1,i2+2,i3)+ry(i1,i2+3,i3))/(60.*dr(1))
                                                        ryrs     = (-(-ry(i1-3,i2-3,i3)+9.*ry(i1-3,i2-2,i3)-45.*ry(i1-3,i2-1,i3)+45.*ry(i1-3,i2+1,i3)-9.*ry(i1-3,i2+2,i3)+ry(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-ry(i1-2,i2-3,i3)+9.*ry(i1-2,i2-2,i3)-45.*ry(i1-2,i2-1,i3)+45.*ry(i1-2,i2+1,i3)-9.*ry(i1-2,i2+2,i3)+ry(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-ry(i1-1,i2-3,i3)+9.*ry(i1-1,i2-2,i3)-45.*ry(i1-1,i2-1,i3)+45.*ry(i1-1,i2+1,i3)-9.*ry(i1-1,i2+2,i3)+ry(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-ry(i1+1,i2-3,i3)+9.*ry(i1+1,i2-2,i3)-45.*ry(i1+1,i2-1,i3)+45.*ry(i1+1,i2+1,i3)-9.*ry(i1+1,i2+2,i3)+ry(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-ry(i1+2,i2-3,i3)+9.*ry(i1+2,i2-2,i3)-45.*ry(i1+2,i2-1,i3)+45.*ry(i1+2,i2+1,i3)-9.*ry(i1+2,i2+2,i3)+ry(i1+2,i2+3,i3))/(60.*dr(1))+(-ry(i1+3,i2-3,i3)+9.*ry(i1+3,i2-2,i3)-45.*ry(i1+3,i2-1,i3)+45.*ry(i1+3,i2+1,i3)-9.*ry(i1+3,i2+2,i3)+ry(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        ryrrs    = (2.*(-ry(i1-3,i2-3,i3)+9.*ry(i1-3,i2-2,i3)-45.*ry(i1-3,i2-1,i3)+45.*ry(i1-3,i2+1,i3)-9.*ry(i1-3,i2+2,i3)+ry(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-ry(i1-2,i2-3,i3)+9.*ry(i1-2,i2-2,i3)-45.*ry(i1-2,i2-1,i3)+45.*ry(i1-2,i2+1,i3)-9.*ry(i1-2,i2+2,i3)+ry(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-ry(i1-1,i2-3,i3)+9.*ry(i1-1,i2-2,i3)-45.*ry(i1-1,i2-1,i3)+45.*ry(i1-1,i2+1,i3)-9.*ry(i1-1,i2+2,i3)+ry(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-ry(i1,i2-3,i3)+9.*ry(i1,i2-2,i3)-45.*ry(i1,i2-1,i3)+45.*ry(i1,i2+1,i3)-9.*ry(i1,i2+2,i3)+ry(i1,i2+3,i3))/(60.*dr(1))+270.*(-ry(i1+1,i2-3,i3)+9.*ry(i1+1,i2-2,i3)-45.*ry(i1+1,i2-1,i3)+45.*ry(i1+1,i2+1,i3)-9.*ry(i1+1,i2+2,i3)+ry(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-ry(i1+2,i2-3,i3)+9.*ry(i1+2,i2-2,i3)-45.*ry(i1+2,i2-1,i3)+45.*ry(i1+2,i2+1,i3)-9.*ry(i1+2,i2+2,i3)+ry(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-ry(i1+3,i2-3,i3)+9.*ry(i1+3,i2-2,i3)-45.*ry(i1+3,i2-1,i3)+45.*ry(i1+3,i2+1,i3)-9.*ry(i1+3,i2+2,i3)+ry(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        ryrrrs   = ((ry(i1-3,i2-2,i3)-8.*ry(i1-3,i2-1,i3)+8.*ry(i1-3,i2+1,i3)-ry(i1-3,i2+2,i3))/(12.*dr(1))-8.*(ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))+13.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))-13.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))+8.*(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1))-(ry(i1+3,i2-2,i3)-8.*ry(i1+3,i2-1,i3)+8.*ry(i1+3,i2+1,i3)-ry(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        ryrrrrs  = (-(ry(i1-3,i2-2,i3)-8.*ry(i1-3,i2-1,i3)+8.*ry(i1-3,i2+1,i3)-ry(i1-3,i2+2,i3))/(12.*dr(1))+12.*(ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))-39.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))+56.*(ry(i1,i2-2,i3)-8.*ry(i1,i2-1,i3)+8.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1))-39.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))+12.*(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1))-(ry(i1+3,i2-2,i3)-8.*ry(i1+3,i2-1,i3)+8.*ry(i1+3,i2+1,i3)-ry(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        ryss     = (2.*ry(i1,i2-3,i3)-27.*ry(i1,i2-2,i3)+270.*ry(i1,i2-1,i3)-490.*ry(i1,i2,i3)+270.*ry(i1,i2+1,i3)-27.*ry(i1,i2+2,i3)+2.*ry(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        ryrss    = (-(2.*ry(i1-3,i2-3,i3)-27.*ry(i1-3,i2-2,i3)+270.*ry(i1-3,i2-1,i3)-490.*ry(i1-3,i2,i3)+270.*ry(i1-3,i2+1,i3)-27.*ry(i1-3,i2+2,i3)+2.*ry(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*ry(i1-2,i2-3,i3)-27.*ry(i1-2,i2-2,i3)+270.*ry(i1-2,i2-1,i3)-490.*ry(i1-2,i2,i3)+270.*ry(i1-2,i2+1,i3)-27.*ry(i1-2,i2+2,i3)+2.*ry(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*ry(i1-1,i2-3,i3)-27.*ry(i1-1,i2-2,i3)+270.*ry(i1-1,i2-1,i3)-490.*ry(i1-1,i2,i3)+270.*ry(i1-1,i2+1,i3)-27.*ry(i1-1,i2+2,i3)+2.*ry(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*ry(i1+1,i2-3,i3)-27.*ry(i1+1,i2-2,i3)+270.*ry(i1+1,i2-1,i3)-490.*ry(i1+1,i2,i3)+270.*ry(i1+1,i2+1,i3)-27.*ry(i1+1,i2+2,i3)+2.*ry(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*ry(i1+2,i2-3,i3)-27.*ry(i1+2,i2-2,i3)+270.*ry(i1+2,i2-1,i3)-490.*ry(i1+2,i2,i3)+270.*ry(i1+2,i2+1,i3)-27.*ry(i1+2,i2+2,i3)+2.*ry(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*ry(i1+3,i2-3,i3)-27.*ry(i1+3,i2-2,i3)+270.*ry(i1+3,i2-1,i3)-490.*ry(i1+3,i2,i3)+270.*ry(i1+3,i2+1,i3)-27.*ry(i1+3,i2+2,i3)+2.*ry(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        ryrrss   = (2.*(2.*ry(i1-3,i2-3,i3)-27.*ry(i1-3,i2-2,i3)+270.*ry(i1-3,i2-1,i3)-490.*ry(i1-3,i2,i3)+270.*ry(i1-3,i2+1,i3)-27.*ry(i1-3,i2+2,i3)+2.*ry(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*ry(i1-2,i2-3,i3)-27.*ry(i1-2,i2-2,i3)+270.*ry(i1-2,i2-1,i3)-490.*ry(i1-2,i2,i3)+270.*ry(i1-2,i2+1,i3)-27.*ry(i1-2,i2+2,i3)+2.*ry(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*ry(i1-1,i2-3,i3)-27.*ry(i1-1,i2-2,i3)+270.*ry(i1-1,i2-1,i3)-490.*ry(i1-1,i2,i3)+270.*ry(i1-1,i2+1,i3)-27.*ry(i1-1,i2+2,i3)+2.*ry(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*ry(i1,i2-3,i3)-27.*ry(i1,i2-2,i3)+270.*ry(i1,i2-1,i3)-490.*ry(i1,i2,i3)+270.*ry(i1,i2+1,i3)-27.*ry(i1,i2+2,i3)+2.*ry(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*ry(i1+1,i2-3,i3)-27.*ry(i1+1,i2-2,i3)+270.*ry(i1+1,i2-1,i3)-490.*ry(i1+1,i2,i3)+270.*ry(i1+1,i2+1,i3)-27.*ry(i1+1,i2+2,i3)+2.*ry(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*ry(i1+2,i2-3,i3)-27.*ry(i1+2,i2-2,i3)+270.*ry(i1+2,i2-1,i3)-490.*ry(i1+2,i2,i3)+270.*ry(i1+2,i2+1,i3)-27.*ry(i1+2,i2+2,i3)+2.*ry(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*ry(i1+3,i2-3,i3)-27.*ry(i1+3,i2-2,i3)+270.*ry(i1+3,i2-1,i3)-490.*ry(i1+3,i2,i3)+270.*ry(i1+3,i2+1,i3)-27.*ry(i1+3,i2+2,i3)+2.*ry(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        ryrrrss  = ((-ry(i1-3,i2-2,i3)+16.*ry(i1-3,i2-1,i3)-30.*ry(i1-3,i2,i3)+16.*ry(i1-3,i2+1,i3)-ry(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-ry(i1-2,i2-2,i3)+16.*ry(i1-2,i2-1,i3)-30.*ry(i1-2,i2,i3)+16.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-ry(i1-1,i2-2,i3)+16.*ry(i1-1,i2-1,i3)-30.*ry(i1-1,i2,i3)+16.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-ry(i1+1,i2-2,i3)+16.*ry(i1+1,i2-1,i3)-30.*ry(i1+1,i2,i3)+16.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-ry(i1+2,i2-2,i3)+16.*ry(i1+2,i2-1,i3)-30.*ry(i1+2,i2,i3)+16.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-ry(i1+3,i2-2,i3)+16.*ry(i1+3,i2-1,i3)-30.*ry(i1+3,i2,i3)+16.*ry(i1+3,i2+1,i3)-ry(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        rysss    = (ry(i1,i2-3,i3)-8.*ry(i1,i2-2,i3)+13.*ry(i1,i2-1,i3)-13.*ry(i1,i2+1,i3)+8.*ry(i1,i2+2,i3)-ry(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        ryrsss   = ((ry(i1-2,i2-3,i3)-8.*ry(i1-2,i2-2,i3)+13.*ry(i1-2,i2-1,i3)-13.*ry(i1-2,i2+1,i3)+8.*ry(i1-2,i2+2,i3)-ry(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(ry(i1-1,i2-3,i3)-8.*ry(i1-1,i2-2,i3)+13.*ry(i1-1,i2-1,i3)-13.*ry(i1-1,i2+1,i3)+8.*ry(i1-1,i2+2,i3)-ry(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(ry(i1+1,i2-3,i3)-8.*ry(i1+1,i2-2,i3)+13.*ry(i1+1,i2-1,i3)-13.*ry(i1+1,i2+1,i3)+8.*ry(i1+1,i2+2,i3)-ry(i1+1,i2+3,i3))/(8.*dr(1)**3)-(ry(i1+2,i2-3,i3)-8.*ry(i1+2,i2-2,i3)+13.*ry(i1+2,i2-1,i3)-13.*ry(i1+2,i2+1,i3)+8.*ry(i1+2,i2+2,i3)-ry(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        ryrrsss  = (-(ry(i1-2,i2-3,i3)-8.*ry(i1-2,i2-2,i3)+13.*ry(i1-2,i2-1,i3)-13.*ry(i1-2,i2+1,i3)+8.*ry(i1-2,i2+2,i3)-ry(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(ry(i1-1,i2-3,i3)-8.*ry(i1-1,i2-2,i3)+13.*ry(i1-1,i2-1,i3)-13.*ry(i1-1,i2+1,i3)+8.*ry(i1-1,i2+2,i3)-ry(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(ry(i1,i2-3,i3)-8.*ry(i1,i2-2,i3)+13.*ry(i1,i2-1,i3)-13.*ry(i1,i2+1,i3)+8.*ry(i1,i2+2,i3)-ry(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(ry(i1+1,i2-3,i3)-8.*ry(i1+1,i2-2,i3)+13.*ry(i1+1,i2-1,i3)-13.*ry(i1+1,i2+1,i3)+8.*ry(i1+1,i2+2,i3)-ry(i1+1,i2+3,i3))/(8.*dr(1)**3)-(ry(i1+2,i2-3,i3)-8.*ry(i1+2,i2-2,i3)+13.*ry(i1+2,i2-1,i3)-13.*ry(i1+2,i2+1,i3)+8.*ry(i1+2,i2+2,i3)-ry(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        ryssss   = (-ry(i1,i2-3,i3)+12.*ry(i1,i2-2,i3)-39.*ry(i1,i2-1,i3)+56.*ry(i1,i2,i3)-39.*ry(i1,i2+1,i3)+12.*ry(i1,i2+2,i3)-ry(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        ryrssss  = ((-ry(i1-2,i2-3,i3)+12.*ry(i1-2,i2-2,i3)-39.*ry(i1-2,i2-1,i3)+56.*ry(i1-2,i2,i3)-39.*ry(i1-2,i2+1,i3)+12.*ry(i1-2,i2+2,i3)-ry(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-ry(i1-1,i2-3,i3)+12.*ry(i1-1,i2-2,i3)-39.*ry(i1-1,i2-1,i3)+56.*ry(i1-1,i2,i3)-39.*ry(i1-1,i2+1,i3)+12.*ry(i1-1,i2+2,i3)-ry(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-ry(i1+1,i2-3,i3)+12.*ry(i1+1,i2-2,i3)-39.*ry(i1+1,i2-1,i3)+56.*ry(i1+1,i2,i3)-39.*ry(i1+1,i2+1,i3)+12.*ry(i1+1,i2+2,i3)-ry(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-ry(i1+2,i2-3,i3)+12.*ry(i1+2,i2-2,i3)-39.*ry(i1+2,i2-1,i3)+56.*ry(i1+2,i2,i3)-39.*ry(i1+2,i2+1,i3)+12.*ry(i1+2,i2+2,i3)-ry(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        rysssss  = (-ry(i1,i2-3,i3)+4.*ry(i1,i2-2,i3)-5.*ry(i1,i2-1,i3)+5.*ry(i1,i2+1,i3)-4.*ry(i1,i2+2,i3)+ry(i1,i2+3,i3))/(2.*dr(1)**5)
                                                        sxr      = (-sx(i1-3,i2,i3)+9.*sx(i1-2,i2,i3)-45.*sx(i1-1,i2,i3)+45.*sx(i1+1,i2,i3)-9.*sx(i1+2,i2,i3)+sx(i1+3,i2,i3))/(60.*dr(0))
                                                        sxrr     = (2.*sx(i1-3,i2,i3)-27.*sx(i1-2,i2,i3)+270.*sx(i1-1,i2,i3)-490.*sx(i1,i2,i3)+270.*sx(i1+1,i2,i3)-27.*sx(i1+2,i2,i3)+2.*sx(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        sxrrr    = (sx(i1-3,i2,i3)-8.*sx(i1-2,i2,i3)+13.*sx(i1-1,i2,i3)-13.*sx(i1+1,i2,i3)+8.*sx(i1+2,i2,i3)-sx(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        sxrrrr   = (-sx(i1-3,i2,i3)+12.*sx(i1-2,i2,i3)-39.*sx(i1-1,i2,i3)+56.*sx(i1,i2,i3)-39.*sx(i1+1,i2,i3)+12.*sx(i1+2,i2,i3)-sx(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        sxrrrrr  = (-sx(i1-3,i2,i3)+4.*sx(i1-2,i2,i3)-5.*sx(i1-1,i2,i3)+5.*sx(i1+1,i2,i3)-4.*sx(i1+2,i2,i3)+sx(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        sxs      = (-sx(i1,i2-3,i3)+9.*sx(i1,i2-2,i3)-45.*sx(i1,i2-1,i3)+45.*sx(i1,i2+1,i3)-9.*sx(i1,i2+2,i3)+sx(i1,i2+3,i3))/(60.*dr(1))
                                                        sxrs     = (-(-sx(i1-3,i2-3,i3)+9.*sx(i1-3,i2-2,i3)-45.*sx(i1-3,i2-1,i3)+45.*sx(i1-3,i2+1,i3)-9.*sx(i1-3,i2+2,i3)+sx(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-sx(i1-2,i2-3,i3)+9.*sx(i1-2,i2-2,i3)-45.*sx(i1-2,i2-1,i3)+45.*sx(i1-2,i2+1,i3)-9.*sx(i1-2,i2+2,i3)+sx(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-sx(i1-1,i2-3,i3)+9.*sx(i1-1,i2-2,i3)-45.*sx(i1-1,i2-1,i3)+45.*sx(i1-1,i2+1,i3)-9.*sx(i1-1,i2+2,i3)+sx(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-sx(i1+1,i2-3,i3)+9.*sx(i1+1,i2-2,i3)-45.*sx(i1+1,i2-1,i3)+45.*sx(i1+1,i2+1,i3)-9.*sx(i1+1,i2+2,i3)+sx(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-sx(i1+2,i2-3,i3)+9.*sx(i1+2,i2-2,i3)-45.*sx(i1+2,i2-1,i3)+45.*sx(i1+2,i2+1,i3)-9.*sx(i1+2,i2+2,i3)+sx(i1+2,i2+3,i3))/(60.*dr(1))+(-sx(i1+3,i2-3,i3)+9.*sx(i1+3,i2-2,i3)-45.*sx(i1+3,i2-1,i3)+45.*sx(i1+3,i2+1,i3)-9.*sx(i1+3,i2+2,i3)+sx(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        sxrrs    = (2.*(-sx(i1-3,i2-3,i3)+9.*sx(i1-3,i2-2,i3)-45.*sx(i1-3,i2-1,i3)+45.*sx(i1-3,i2+1,i3)-9.*sx(i1-3,i2+2,i3)+sx(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-sx(i1-2,i2-3,i3)+9.*sx(i1-2,i2-2,i3)-45.*sx(i1-2,i2-1,i3)+45.*sx(i1-2,i2+1,i3)-9.*sx(i1-2,i2+2,i3)+sx(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-sx(i1-1,i2-3,i3)+9.*sx(i1-1,i2-2,i3)-45.*sx(i1-1,i2-1,i3)+45.*sx(i1-1,i2+1,i3)-9.*sx(i1-1,i2+2,i3)+sx(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-sx(i1,i2-3,i3)+9.*sx(i1,i2-2,i3)-45.*sx(i1,i2-1,i3)+45.*sx(i1,i2+1,i3)-9.*sx(i1,i2+2,i3)+sx(i1,i2+3,i3))/(60.*dr(1))+270.*(-sx(i1+1,i2-3,i3)+9.*sx(i1+1,i2-2,i3)-45.*sx(i1+1,i2-1,i3)+45.*sx(i1+1,i2+1,i3)-9.*sx(i1+1,i2+2,i3)+sx(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-sx(i1+2,i2-3,i3)+9.*sx(i1+2,i2-2,i3)-45.*sx(i1+2,i2-1,i3)+45.*sx(i1+2,i2+1,i3)-9.*sx(i1+2,i2+2,i3)+sx(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-sx(i1+3,i2-3,i3)+9.*sx(i1+3,i2-2,i3)-45.*sx(i1+3,i2-1,i3)+45.*sx(i1+3,i2+1,i3)-9.*sx(i1+3,i2+2,i3)+sx(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        sxrrrs   = ((sx(i1-3,i2-2,i3)-8.*sx(i1-3,i2-1,i3)+8.*sx(i1-3,i2+1,i3)-sx(i1-3,i2+2,i3))/(12.*dr(1))-8.*(sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))+13.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))-13.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))+8.*(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1))-(sx(i1+3,i2-2,i3)-8.*sx(i1+3,i2-1,i3)+8.*sx(i1+3,i2+1,i3)-sx(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        sxrrrrs  = (-(sx(i1-3,i2-2,i3)-8.*sx(i1-3,i2-1,i3)+8.*sx(i1-3,i2+1,i3)-sx(i1-3,i2+2,i3))/(12.*dr(1))+12.*(sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))-39.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))+56.*(sx(i1,i2-2,i3)-8.*sx(i1,i2-1,i3)+8.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1))-39.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))+12.*(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1))-(sx(i1+3,i2-2,i3)-8.*sx(i1+3,i2-1,i3)+8.*sx(i1+3,i2+1,i3)-sx(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        sxss     = (2.*sx(i1,i2-3,i3)-27.*sx(i1,i2-2,i3)+270.*sx(i1,i2-1,i3)-490.*sx(i1,i2,i3)+270.*sx(i1,i2+1,i3)-27.*sx(i1,i2+2,i3)+2.*sx(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        sxrss    = (-(2.*sx(i1-3,i2-3,i3)-27.*sx(i1-3,i2-2,i3)+270.*sx(i1-3,i2-1,i3)-490.*sx(i1-3,i2,i3)+270.*sx(i1-3,i2+1,i3)-27.*sx(i1-3,i2+2,i3)+2.*sx(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*sx(i1-2,i2-3,i3)-27.*sx(i1-2,i2-2,i3)+270.*sx(i1-2,i2-1,i3)-490.*sx(i1-2,i2,i3)+270.*sx(i1-2,i2+1,i3)-27.*sx(i1-2,i2+2,i3)+2.*sx(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*sx(i1-1,i2-3,i3)-27.*sx(i1-1,i2-2,i3)+270.*sx(i1-1,i2-1,i3)-490.*sx(i1-1,i2,i3)+270.*sx(i1-1,i2+1,i3)-27.*sx(i1-1,i2+2,i3)+2.*sx(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*sx(i1+1,i2-3,i3)-27.*sx(i1+1,i2-2,i3)+270.*sx(i1+1,i2-1,i3)-490.*sx(i1+1,i2,i3)+270.*sx(i1+1,i2+1,i3)-27.*sx(i1+1,i2+2,i3)+2.*sx(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*sx(i1+2,i2-3,i3)-27.*sx(i1+2,i2-2,i3)+270.*sx(i1+2,i2-1,i3)-490.*sx(i1+2,i2,i3)+270.*sx(i1+2,i2+1,i3)-27.*sx(i1+2,i2+2,i3)+2.*sx(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*sx(i1+3,i2-3,i3)-27.*sx(i1+3,i2-2,i3)+270.*sx(i1+3,i2-1,i3)-490.*sx(i1+3,i2,i3)+270.*sx(i1+3,i2+1,i3)-27.*sx(i1+3,i2+2,i3)+2.*sx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        sxrrss   = (2.*(2.*sx(i1-3,i2-3,i3)-27.*sx(i1-3,i2-2,i3)+270.*sx(i1-3,i2-1,i3)-490.*sx(i1-3,i2,i3)+270.*sx(i1-3,i2+1,i3)-27.*sx(i1-3,i2+2,i3)+2.*sx(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sx(i1-2,i2-3,i3)-27.*sx(i1-2,i2-2,i3)+270.*sx(i1-2,i2-1,i3)-490.*sx(i1-2,i2,i3)+270.*sx(i1-2,i2+1,i3)-27.*sx(i1-2,i2+2,i3)+2.*sx(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sx(i1-1,i2-3,i3)-27.*sx(i1-1,i2-2,i3)+270.*sx(i1-1,i2-1,i3)-490.*sx(i1-1,i2,i3)+270.*sx(i1-1,i2+1,i3)-27.*sx(i1-1,i2+2,i3)+2.*sx(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*sx(i1,i2-3,i3)-27.*sx(i1,i2-2,i3)+270.*sx(i1,i2-1,i3)-490.*sx(i1,i2,i3)+270.*sx(i1,i2+1,i3)-27.*sx(i1,i2+2,i3)+2.*sx(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sx(i1+1,i2-3,i3)-27.*sx(i1+1,i2-2,i3)+270.*sx(i1+1,i2-1,i3)-490.*sx(i1+1,i2,i3)+270.*sx(i1+1,i2+1,i3)-27.*sx(i1+1,i2+2,i3)+2.*sx(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sx(i1+2,i2-3,i3)-27.*sx(i1+2,i2-2,i3)+270.*sx(i1+2,i2-1,i3)-490.*sx(i1+2,i2,i3)+270.*sx(i1+2,i2+1,i3)-27.*sx(i1+2,i2+2,i3)+2.*sx(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*sx(i1+3,i2-3,i3)-27.*sx(i1+3,i2-2,i3)+270.*sx(i1+3,i2-1,i3)-490.*sx(i1+3,i2,i3)+270.*sx(i1+3,i2+1,i3)-27.*sx(i1+3,i2+2,i3)+2.*sx(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        sxrrrss  = ((-sx(i1-3,i2-2,i3)+16.*sx(i1-3,i2-1,i3)-30.*sx(i1-3,i2,i3)+16.*sx(i1-3,i2+1,i3)-sx(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-sx(i1-2,i2-2,i3)+16.*sx(i1-2,i2-1,i3)-30.*sx(i1-2,i2,i3)+16.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-sx(i1-1,i2-2,i3)+16.*sx(i1-1,i2-1,i3)-30.*sx(i1-1,i2,i3)+16.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-sx(i1+1,i2-2,i3)+16.*sx(i1+1,i2-1,i3)-30.*sx(i1+1,i2,i3)+16.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-sx(i1+2,i2-2,i3)+16.*sx(i1+2,i2-1,i3)-30.*sx(i1+2,i2,i3)+16.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-sx(i1+3,i2-2,i3)+16.*sx(i1+3,i2-1,i3)-30.*sx(i1+3,i2,i3)+16.*sx(i1+3,i2+1,i3)-sx(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        sxsss    = (sx(i1,i2-3,i3)-8.*sx(i1,i2-2,i3)+13.*sx(i1,i2-1,i3)-13.*sx(i1,i2+1,i3)+8.*sx(i1,i2+2,i3)-sx(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        sxrsss   = ((sx(i1-2,i2-3,i3)-8.*sx(i1-2,i2-2,i3)+13.*sx(i1-2,i2-1,i3)-13.*sx(i1-2,i2+1,i3)+8.*sx(i1-2,i2+2,i3)-sx(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(sx(i1-1,i2-3,i3)-8.*sx(i1-1,i2-2,i3)+13.*sx(i1-1,i2-1,i3)-13.*sx(i1-1,i2+1,i3)+8.*sx(i1-1,i2+2,i3)-sx(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(sx(i1+1,i2-3,i3)-8.*sx(i1+1,i2-2,i3)+13.*sx(i1+1,i2-1,i3)-13.*sx(i1+1,i2+1,i3)+8.*sx(i1+1,i2+2,i3)-sx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sx(i1+2,i2-3,i3)-8.*sx(i1+2,i2-2,i3)+13.*sx(i1+2,i2-1,i3)-13.*sx(i1+2,i2+1,i3)+8.*sx(i1+2,i2+2,i3)-sx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        sxrrsss  = (-(sx(i1-2,i2-3,i3)-8.*sx(i1-2,i2-2,i3)+13.*sx(i1-2,i2-1,i3)-13.*sx(i1-2,i2+1,i3)+8.*sx(i1-2,i2+2,i3)-sx(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(sx(i1-1,i2-3,i3)-8.*sx(i1-1,i2-2,i3)+13.*sx(i1-1,i2-1,i3)-13.*sx(i1-1,i2+1,i3)+8.*sx(i1-1,i2+2,i3)-sx(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(sx(i1,i2-3,i3)-8.*sx(i1,i2-2,i3)+13.*sx(i1,i2-1,i3)-13.*sx(i1,i2+1,i3)+8.*sx(i1,i2+2,i3)-sx(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(sx(i1+1,i2-3,i3)-8.*sx(i1+1,i2-2,i3)+13.*sx(i1+1,i2-1,i3)-13.*sx(i1+1,i2+1,i3)+8.*sx(i1+1,i2+2,i3)-sx(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sx(i1+2,i2-3,i3)-8.*sx(i1+2,i2-2,i3)+13.*sx(i1+2,i2-1,i3)-13.*sx(i1+2,i2+1,i3)+8.*sx(i1+2,i2+2,i3)-sx(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        sxssss   = (-sx(i1,i2-3,i3)+12.*sx(i1,i2-2,i3)-39.*sx(i1,i2-1,i3)+56.*sx(i1,i2,i3)-39.*sx(i1,i2+1,i3)+12.*sx(i1,i2+2,i3)-sx(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        sxrssss  = ((-sx(i1-2,i2-3,i3)+12.*sx(i1-2,i2-2,i3)-39.*sx(i1-2,i2-1,i3)+56.*sx(i1-2,i2,i3)-39.*sx(i1-2,i2+1,i3)+12.*sx(i1-2,i2+2,i3)-sx(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-sx(i1-1,i2-3,i3)+12.*sx(i1-1,i2-2,i3)-39.*sx(i1-1,i2-1,i3)+56.*sx(i1-1,i2,i3)-39.*sx(i1-1,i2+1,i3)+12.*sx(i1-1,i2+2,i3)-sx(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-sx(i1+1,i2-3,i3)+12.*sx(i1+1,i2-2,i3)-39.*sx(i1+1,i2-1,i3)+56.*sx(i1+1,i2,i3)-39.*sx(i1+1,i2+1,i3)+12.*sx(i1+1,i2+2,i3)-sx(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-sx(i1+2,i2-3,i3)+12.*sx(i1+2,i2-2,i3)-39.*sx(i1+2,i2-1,i3)+56.*sx(i1+2,i2,i3)-39.*sx(i1+2,i2+1,i3)+12.*sx(i1+2,i2+2,i3)-sx(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        sxsssss  = (-sx(i1,i2-3,i3)+4.*sx(i1,i2-2,i3)-5.*sx(i1,i2-1,i3)+5.*sx(i1,i2+1,i3)-4.*sx(i1,i2+2,i3)+sx(i1,i2+3,i3))/(2.*dr(1)**5)
                                                        syr      = (-sy(i1-3,i2,i3)+9.*sy(i1-2,i2,i3)-45.*sy(i1-1,i2,i3)+45.*sy(i1+1,i2,i3)-9.*sy(i1+2,i2,i3)+sy(i1+3,i2,i3))/(60.*dr(0))
                                                        syrr     = (2.*sy(i1-3,i2,i3)-27.*sy(i1-2,i2,i3)+270.*sy(i1-1,i2,i3)-490.*sy(i1,i2,i3)+270.*sy(i1+1,i2,i3)-27.*sy(i1+2,i2,i3)+2.*sy(i1+3,i2,i3))/(180.*dr(0)**2)
                                                        syrrr    = (sy(i1-3,i2,i3)-8.*sy(i1-2,i2,i3)+13.*sy(i1-1,i2,i3)-13.*sy(i1+1,i2,i3)+8.*sy(i1+2,i2,i3)-sy(i1+3,i2,i3))/(8.*dr(0)**3)
                                                        syrrrr   = (-sy(i1-3,i2,i3)+12.*sy(i1-2,i2,i3)-39.*sy(i1-1,i2,i3)+56.*sy(i1,i2,i3)-39.*sy(i1+1,i2,i3)+12.*sy(i1+2,i2,i3)-sy(i1+3,i2,i3))/(6.*dr(0)**4)
                                                        syrrrrr  = (-sy(i1-3,i2,i3)+4.*sy(i1-2,i2,i3)-5.*sy(i1-1,i2,i3)+5.*sy(i1+1,i2,i3)-4.*sy(i1+2,i2,i3)+sy(i1+3,i2,i3))/(2.*dr(0)**5)
                                                        sys      = (-sy(i1,i2-3,i3)+9.*sy(i1,i2-2,i3)-45.*sy(i1,i2-1,i3)+45.*sy(i1,i2+1,i3)-9.*sy(i1,i2+2,i3)+sy(i1,i2+3,i3))/(60.*dr(1))
                                                        syrs     = (-(-sy(i1-3,i2-3,i3)+9.*sy(i1-3,i2-2,i3)-45.*sy(i1-3,i2-1,i3)+45.*sy(i1-3,i2+1,i3)-9.*sy(i1-3,i2+2,i3)+sy(i1-3,i2+3,i3))/(60.*dr(1))+9.*(-sy(i1-2,i2-3,i3)+9.*sy(i1-2,i2-2,i3)-45.*sy(i1-2,i2-1,i3)+45.*sy(i1-2,i2+1,i3)-9.*sy(i1-2,i2+2,i3)+sy(i1-2,i2+3,i3))/(60.*dr(1))-45.*(-sy(i1-1,i2-3,i3)+9.*sy(i1-1,i2-2,i3)-45.*sy(i1-1,i2-1,i3)+45.*sy(i1-1,i2+1,i3)-9.*sy(i1-1,i2+2,i3)+sy(i1-1,i2+3,i3))/(60.*dr(1))+45.*(-sy(i1+1,i2-3,i3)+9.*sy(i1+1,i2-2,i3)-45.*sy(i1+1,i2-1,i3)+45.*sy(i1+1,i2+1,i3)-9.*sy(i1+1,i2+2,i3)+sy(i1+1,i2+3,i3))/(60.*dr(1))-9.*(-sy(i1+2,i2-3,i3)+9.*sy(i1+2,i2-2,i3)-45.*sy(i1+2,i2-1,i3)+45.*sy(i1+2,i2+1,i3)-9.*sy(i1+2,i2+2,i3)+sy(i1+2,i2+3,i3))/(60.*dr(1))+(-sy(i1+3,i2-3,i3)+9.*sy(i1+3,i2-2,i3)-45.*sy(i1+3,i2-1,i3)+45.*sy(i1+3,i2+1,i3)-9.*sy(i1+3,i2+2,i3)+sy(i1+3,i2+3,i3))/(60.*dr(1)))/(60.*dr(0))
                                                        syrrs    = (2.*(-sy(i1-3,i2-3,i3)+9.*sy(i1-3,i2-2,i3)-45.*sy(i1-3,i2-1,i3)+45.*sy(i1-3,i2+1,i3)-9.*sy(i1-3,i2+2,i3)+sy(i1-3,i2+3,i3))/(60.*dr(1))-27.*(-sy(i1-2,i2-3,i3)+9.*sy(i1-2,i2-2,i3)-45.*sy(i1-2,i2-1,i3)+45.*sy(i1-2,i2+1,i3)-9.*sy(i1-2,i2+2,i3)+sy(i1-2,i2+3,i3))/(60.*dr(1))+270.*(-sy(i1-1,i2-3,i3)+9.*sy(i1-1,i2-2,i3)-45.*sy(i1-1,i2-1,i3)+45.*sy(i1-1,i2+1,i3)-9.*sy(i1-1,i2+2,i3)+sy(i1-1,i2+3,i3))/(60.*dr(1))-490.*(-sy(i1,i2-3,i3)+9.*sy(i1,i2-2,i3)-45.*sy(i1,i2-1,i3)+45.*sy(i1,i2+1,i3)-9.*sy(i1,i2+2,i3)+sy(i1,i2+3,i3))/(60.*dr(1))+270.*(-sy(i1+1,i2-3,i3)+9.*sy(i1+1,i2-2,i3)-45.*sy(i1+1,i2-1,i3)+45.*sy(i1+1,i2+1,i3)-9.*sy(i1+1,i2+2,i3)+sy(i1+1,i2+3,i3))/(60.*dr(1))-27.*(-sy(i1+2,i2-3,i3)+9.*sy(i1+2,i2-2,i3)-45.*sy(i1+2,i2-1,i3)+45.*sy(i1+2,i2+1,i3)-9.*sy(i1+2,i2+2,i3)+sy(i1+2,i2+3,i3))/(60.*dr(1))+2.*(-sy(i1+3,i2-3,i3)+9.*sy(i1+3,i2-2,i3)-45.*sy(i1+3,i2-1,i3)+45.*sy(i1+3,i2+1,i3)-9.*sy(i1+3,i2+2,i3)+sy(i1+3,i2+3,i3))/(60.*dr(1)))/(180.*dr(0)**2)
                                                        syrrrs   = ((sy(i1-3,i2-2,i3)-8.*sy(i1-3,i2-1,i3)+8.*sy(i1-3,i2+1,i3)-sy(i1-3,i2+2,i3))/(12.*dr(1))-8.*(sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))+13.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))-13.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))+8.*(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1))-(sy(i1+3,i2-2,i3)-8.*sy(i1+3,i2-1,i3)+8.*sy(i1+3,i2+1,i3)-sy(i1+3,i2+2,i3))/(12.*dr(1)))/(8.*dr(0)**3)
                                                        syrrrrs  = (-(sy(i1-3,i2-2,i3)-8.*sy(i1-3,i2-1,i3)+8.*sy(i1-3,i2+1,i3)-sy(i1-3,i2+2,i3))/(12.*dr(1))+12.*(sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))-39.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))+56.*(sy(i1,i2-2,i3)-8.*sy(i1,i2-1,i3)+8.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1))-39.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))+12.*(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1))-(sy(i1+3,i2-2,i3)-8.*sy(i1+3,i2-1,i3)+8.*sy(i1+3,i2+1,i3)-sy(i1+3,i2+2,i3))/(12.*dr(1)))/(6.*dr(0)**4)
                                                        syss     = (2.*sy(i1,i2-3,i3)-27.*sy(i1,i2-2,i3)+270.*sy(i1,i2-1,i3)-490.*sy(i1,i2,i3)+270.*sy(i1,i2+1,i3)-27.*sy(i1,i2+2,i3)+2.*sy(i1,i2+3,i3))/(180.*dr(1)**2)
                                                        syrss    = (-(2.*sy(i1-3,i2-3,i3)-27.*sy(i1-3,i2-2,i3)+270.*sy(i1-3,i2-1,i3)-490.*sy(i1-3,i2,i3)+270.*sy(i1-3,i2+1,i3)-27.*sy(i1-3,i2+2,i3)+2.*sy(i1-3,i2+3,i3))/(180.*dr(1)**2)+9.*(2.*sy(i1-2,i2-3,i3)-27.*sy(i1-2,i2-2,i3)+270.*sy(i1-2,i2-1,i3)-490.*sy(i1-2,i2,i3)+270.*sy(i1-2,i2+1,i3)-27.*sy(i1-2,i2+2,i3)+2.*sy(i1-2,i2+3,i3))/(180.*dr(1)**2)-45.*(2.*sy(i1-1,i2-3,i3)-27.*sy(i1-1,i2-2,i3)+270.*sy(i1-1,i2-1,i3)-490.*sy(i1-1,i2,i3)+270.*sy(i1-1,i2+1,i3)-27.*sy(i1-1,i2+2,i3)+2.*sy(i1-1,i2+3,i3))/(180.*dr(1)**2)+45.*(2.*sy(i1+1,i2-3,i3)-27.*sy(i1+1,i2-2,i3)+270.*sy(i1+1,i2-1,i3)-490.*sy(i1+1,i2,i3)+270.*sy(i1+1,i2+1,i3)-27.*sy(i1+1,i2+2,i3)+2.*sy(i1+1,i2+3,i3))/(180.*dr(1)**2)-9.*(2.*sy(i1+2,i2-3,i3)-27.*sy(i1+2,i2-2,i3)+270.*sy(i1+2,i2-1,i3)-490.*sy(i1+2,i2,i3)+270.*sy(i1+2,i2+1,i3)-27.*sy(i1+2,i2+2,i3)+2.*sy(i1+2,i2+3,i3))/(180.*dr(1)**2)+(2.*sy(i1+3,i2-3,i3)-27.*sy(i1+3,i2-2,i3)+270.*sy(i1+3,i2-1,i3)-490.*sy(i1+3,i2,i3)+270.*sy(i1+3,i2+1,i3)-27.*sy(i1+3,i2+2,i3)+2.*sy(i1+3,i2+3,i3))/(180.*dr(1)**2))/(60.*dr(0))
                                                        syrrss   = (2.*(2.*sy(i1-3,i2-3,i3)-27.*sy(i1-3,i2-2,i3)+270.*sy(i1-3,i2-1,i3)-490.*sy(i1-3,i2,i3)+270.*sy(i1-3,i2+1,i3)-27.*sy(i1-3,i2+2,i3)+2.*sy(i1-3,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sy(i1-2,i2-3,i3)-27.*sy(i1-2,i2-2,i3)+270.*sy(i1-2,i2-1,i3)-490.*sy(i1-2,i2,i3)+270.*sy(i1-2,i2+1,i3)-27.*sy(i1-2,i2+2,i3)+2.*sy(i1-2,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sy(i1-1,i2-3,i3)-27.*sy(i1-1,i2-2,i3)+270.*sy(i1-1,i2-1,i3)-490.*sy(i1-1,i2,i3)+270.*sy(i1-1,i2+1,i3)-27.*sy(i1-1,i2+2,i3)+2.*sy(i1-1,i2+3,i3))/(180.*dr(1)**2)-490.*(2.*sy(i1,i2-3,i3)-27.*sy(i1,i2-2,i3)+270.*sy(i1,i2-1,i3)-490.*sy(i1,i2,i3)+270.*sy(i1,i2+1,i3)-27.*sy(i1,i2+2,i3)+2.*sy(i1,i2+3,i3))/(180.*dr(1)**2)+270.*(2.*sy(i1+1,i2-3,i3)-27.*sy(i1+1,i2-2,i3)+270.*sy(i1+1,i2-1,i3)-490.*sy(i1+1,i2,i3)+270.*sy(i1+1,i2+1,i3)-27.*sy(i1+1,i2+2,i3)+2.*sy(i1+1,i2+3,i3))/(180.*dr(1)**2)-27.*(2.*sy(i1+2,i2-3,i3)-27.*sy(i1+2,i2-2,i3)+270.*sy(i1+2,i2-1,i3)-490.*sy(i1+2,i2,i3)+270.*sy(i1+2,i2+1,i3)-27.*sy(i1+2,i2+2,i3)+2.*sy(i1+2,i2+3,i3))/(180.*dr(1)**2)+2.*(2.*sy(i1+3,i2-3,i3)-27.*sy(i1+3,i2-2,i3)+270.*sy(i1+3,i2-1,i3)-490.*sy(i1+3,i2,i3)+270.*sy(i1+3,i2+1,i3)-27.*sy(i1+3,i2+2,i3)+2.*sy(i1+3,i2+3,i3))/(180.*dr(1)**2))/(180.*dr(0)**2)
                                                        syrrrss  = ((-sy(i1-3,i2-2,i3)+16.*sy(i1-3,i2-1,i3)-30.*sy(i1-3,i2,i3)+16.*sy(i1-3,i2+1,i3)-sy(i1-3,i2+2,i3))/(12.*dr(1)**2)-8.*(-sy(i1-2,i2-2,i3)+16.*sy(i1-2,i2-1,i3)-30.*sy(i1-2,i2,i3)+16.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1)**2)+13.*(-sy(i1-1,i2-2,i3)+16.*sy(i1-1,i2-1,i3)-30.*sy(i1-1,i2,i3)+16.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1)**2)-13.*(-sy(i1+1,i2-2,i3)+16.*sy(i1+1,i2-1,i3)-30.*sy(i1+1,i2,i3)+16.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1)**2)+8.*(-sy(i1+2,i2-2,i3)+16.*sy(i1+2,i2-1,i3)-30.*sy(i1+2,i2,i3)+16.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1)**2)-(-sy(i1+3,i2-2,i3)+16.*sy(i1+3,i2-1,i3)-30.*sy(i1+3,i2,i3)+16.*sy(i1+3,i2+1,i3)-sy(i1+3,i2+2,i3))/(12.*dr(1)**2))/(8.*dr(0)**3)
                                                        sysss    = (sy(i1,i2-3,i3)-8.*sy(i1,i2-2,i3)+13.*sy(i1,i2-1,i3)-13.*sy(i1,i2+1,i3)+8.*sy(i1,i2+2,i3)-sy(i1,i2+3,i3))/(8.*dr(1)**3)
                                                        syrsss   = ((sy(i1-2,i2-3,i3)-8.*sy(i1-2,i2-2,i3)+13.*sy(i1-2,i2-1,i3)-13.*sy(i1-2,i2+1,i3)+8.*sy(i1-2,i2+2,i3)-sy(i1-2,i2+3,i3))/(8.*dr(1)**3)-8.*(sy(i1-1,i2-3,i3)-8.*sy(i1-1,i2-2,i3)+13.*sy(i1-1,i2-1,i3)-13.*sy(i1-1,i2+1,i3)+8.*sy(i1-1,i2+2,i3)-sy(i1-1,i2+3,i3))/(8.*dr(1)**3)+8.*(sy(i1+1,i2-3,i3)-8.*sy(i1+1,i2-2,i3)+13.*sy(i1+1,i2-1,i3)-13.*sy(i1+1,i2+1,i3)+8.*sy(i1+1,i2+2,i3)-sy(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sy(i1+2,i2-3,i3)-8.*sy(i1+2,i2-2,i3)+13.*sy(i1+2,i2-1,i3)-13.*sy(i1+2,i2+1,i3)+8.*sy(i1+2,i2+2,i3)-sy(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0))
                                                        syrrsss  = (-(sy(i1-2,i2-3,i3)-8.*sy(i1-2,i2-2,i3)+13.*sy(i1-2,i2-1,i3)-13.*sy(i1-2,i2+1,i3)+8.*sy(i1-2,i2+2,i3)-sy(i1-2,i2+3,i3))/(8.*dr(1)**3)+16.*(sy(i1-1,i2-3,i3)-8.*sy(i1-1,i2-2,i3)+13.*sy(i1-1,i2-1,i3)-13.*sy(i1-1,i2+1,i3)+8.*sy(i1-1,i2+2,i3)-sy(i1-1,i2+3,i3))/(8.*dr(1)**3)-30.*(sy(i1,i2-3,i3)-8.*sy(i1,i2-2,i3)+13.*sy(i1,i2-1,i3)-13.*sy(i1,i2+1,i3)+8.*sy(i1,i2+2,i3)-sy(i1,i2+3,i3))/(8.*dr(1)**3)+16.*(sy(i1+1,i2-3,i3)-8.*sy(i1+1,i2-2,i3)+13.*sy(i1+1,i2-1,i3)-13.*sy(i1+1,i2+1,i3)+8.*sy(i1+1,i2+2,i3)-sy(i1+1,i2+3,i3))/(8.*dr(1)**3)-(sy(i1+2,i2-3,i3)-8.*sy(i1+2,i2-2,i3)+13.*sy(i1+2,i2-1,i3)-13.*sy(i1+2,i2+1,i3)+8.*sy(i1+2,i2+2,i3)-sy(i1+2,i2+3,i3))/(8.*dr(1)**3))/(12.*dr(0)**2)
                                                        syssss   = (-sy(i1,i2-3,i3)+12.*sy(i1,i2-2,i3)-39.*sy(i1,i2-1,i3)+56.*sy(i1,i2,i3)-39.*sy(i1,i2+1,i3)+12.*sy(i1,i2+2,i3)-sy(i1,i2+3,i3))/(6.*dr(1)**4)
                                                        syrssss  = ((-sy(i1-2,i2-3,i3)+12.*sy(i1-2,i2-2,i3)-39.*sy(i1-2,i2-1,i3)+56.*sy(i1-2,i2,i3)-39.*sy(i1-2,i2+1,i3)+12.*sy(i1-2,i2+2,i3)-sy(i1-2,i2+3,i3))/(6.*dr(1)**4)-8.*(-sy(i1-1,i2-3,i3)+12.*sy(i1-1,i2-2,i3)-39.*sy(i1-1,i2-1,i3)+56.*sy(i1-1,i2,i3)-39.*sy(i1-1,i2+1,i3)+12.*sy(i1-1,i2+2,i3)-sy(i1-1,i2+3,i3))/(6.*dr(1)**4)+8.*(-sy(i1+1,i2-3,i3)+12.*sy(i1+1,i2-2,i3)-39.*sy(i1+1,i2-1,i3)+56.*sy(i1+1,i2,i3)-39.*sy(i1+1,i2+1,i3)+12.*sy(i1+1,i2+2,i3)-sy(i1+1,i2+3,i3))/(6.*dr(1)**4)-(-sy(i1+2,i2-3,i3)+12.*sy(i1+2,i2-2,i3)-39.*sy(i1+2,i2-1,i3)+56.*sy(i1+2,i2,i3)-39.*sy(i1+2,i2+1,i3)+12.*sy(i1+2,i2+2,i3)-sy(i1+2,i2+3,i3))/(6.*dr(1)**4))/(12.*dr(0))
                                                        sysssss  = (-sy(i1,i2-3,i3)+4.*sy(i1,i2-2,i3)-5.*sy(i1,i2-1,i3)+5.*sy(i1,i2+1,i3)-4.*sy(i1,i2+2,i3)+sy(i1,i2+3,i3))/(2.*dr(1)**5)
                            ! ---------- Spatial derivatives of metrics rx, sx, ry, ... ---------
                                                        rxi = rx(i1,i2,i3)
                                                        ryi = ry(i1,i2,i3)
                                                        sxi = sx(i1,i2,i3)
                                                        syi = sy(i1,i2,i3)
                                                        rxx      = rxi*rxr+sxi*rxs
                                                        rxy      = ryi*rxr+syi*rxs
                                                        ryy      = ryi*ryr+syi*rys
                                                        sxx      = rxi*sxr+sxi*sxs
                                                        sxy      = ryi*sxr+syi*sxs
                                                        syy      = ryi*syr+syi*sys
                                                        rxxx     = rxi**2*rxrr+2.*rxi*sxi*rxrs+sxi**2*rxss+rxx*rxr+sxx*rxs
                                                        rxxy     = rxi*ryi*rxrr+(rxi*syi+ryi*sxi)*rxrs+sxi*syi*rxss+rxy*rxr+sxy*rxs
                                                        rxyy     = ryi**2*rxrr+2.*ryi*syi*rxrs+syi**2*rxss+ryy*rxr+syy*rxs
                                                        ryyy     = ryi**2*ryrr+2.*ryi*syi*ryrs+syi**2*ryss+ryy*ryr+syy*rys
                                                        sxxx     = rxi**2*sxrr+2.*rxi*sxi*sxrs+sxi**2*sxss+rxx*sxr+sxx*sxs
                                                        sxxy     = rxi*ryi*sxrr+(rxi*syi+ryi*sxi)*sxrs+sxi*syi*sxss+rxy*sxr+sxy*sxs
                                                        sxyy     = ryi**2*sxrr+2.*ryi*syi*sxrs+syi**2*sxss+ryy*sxr+syy*sxs
                                                        syyy     = ryi**2*syrr+2.*ryi*syi*syrs+syi**2*syss+ryy*syr+syy*sys
                                                        rxxxx    = rxi**3*rxrrr+3.*rxi**2*sxi*rxrrs+3.*rxi*sxi**2*rxrss+sxi**3*rxsss+3.*rxi*rxx*rxrr+(3.*rxi*sxx+3.*rxx*sxi)*rxrs+3.*sxi*sxx*rxss+rxxx*rxr+sxxx*rxs
                                                        rxxxy    = rxi**2*ryi*rxrrr+(rxi**2*syi+2.*rxi*ryi*sxi)*rxrrs+(2.*rxi*sxi*syi+ryi*sxi**2)*rxrss+sxi**2*syi*rxsss+(2.*rxi*rxy+rxx*ryi)*rxrr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*rxrs+(2.*sxi*sxy+sxx*syi)*rxss+rxxy*rxr+sxxy*rxs
                                                        rxxyy    = rxi*ryi**2*rxrrr+(2.*rxi*ryi*syi+ryi**2*sxi)*rxrrs+(rxi*syi**2+2.*ryi*sxi*syi)*rxrss+sxi*syi**2*rxsss+(rxi*ryy+2.*rxy*ryi)*rxrr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*rxrs+(sxi*syy+2.*sxy*syi)*rxss+rxyy*rxr+sxyy*rxs
                                                        rxyyy    = ryi**3*rxrrr+3.*ryi**2*syi*rxrrs+3.*ryi*syi**2*rxrss+syi**3*rxsss+3.*ryi*ryy*rxrr+(3.*ryi*syy+3.*ryy*syi)*rxrs+3.*syi*syy*rxss+ryyy*rxr+syyy*rxs
                                                        ryyyy    = ryi**3*ryrrr+3.*ryi**2*syi*ryrrs+3.*ryi*syi**2*ryrss+syi**3*rysss+3.*ryi*ryy*ryrr+(3.*ryi*syy+3.*ryy*syi)*ryrs+3.*syi*syy*ryss+ryyy*ryr+syyy*rys
                                                        sxxxx    = rxi**3*sxrrr+3.*rxi**2*sxi*sxrrs+3.*rxi*sxi**2*sxrss+sxi**3*sxsss+3.*rxi*rxx*sxrr+(3.*rxi*sxx+3.*rxx*sxi)*sxrs+3.*sxi*sxx*sxss+rxxx*sxr+sxxx*sxs
                                                        sxxxy    = rxi**2*ryi*sxrrr+(rxi**2*syi+2.*rxi*ryi*sxi)*sxrrs+(2.*rxi*sxi*syi+ryi*sxi**2)*sxrss+sxi**2*syi*sxsss+(2.*rxi*rxy+rxx*ryi)*sxrr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*sxrs+(2.*sxi*sxy+sxx*syi)*sxss+rxxy*sxr+sxxy*sxs
                                                        sxxyy    = rxi*ryi**2*sxrrr+(2.*rxi*ryi*syi+ryi**2*sxi)*sxrrs+(rxi*syi**2+2.*ryi*sxi*syi)*sxrss+sxi*syi**2*sxsss+(rxi*ryy+2.*rxy*ryi)*sxrr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*sxrs+(sxi*syy+2.*sxy*syi)*sxss+rxyy*sxr+sxyy*sxs
                                                        sxyyy    = ryi**3*sxrrr+3.*ryi**2*syi*sxrrs+3.*ryi*syi**2*sxrss+syi**3*sxsss+3.*ryi*ryy*sxrr+(3.*ryi*syy+3.*ryy*syi)*sxrs+3.*syi*syy*sxss+ryyy*sxr+syyy*sxs
                                                        syyyy    = ryi**3*syrrr+3.*ryi**2*syi*syrrs+3.*ryi*syi**2*syrss+syi**3*sysss+3.*ryi*ryy*syrr+(3.*ryi*syy+3.*ryy*syi)*syrs+3.*syi*syy*syss+ryyy*syr+syyy*sys
                                                        rxxxxx   = rxi**4*rxrrrr+4.*rxi**3*sxi*rxrrrs+6.*rxi**2*sxi**2*rxrrss+4.*rxi*sxi**3*rxrsss+sxi**4*rxssss+6.*rxi**2*rxx*rxrrr+(6.*rxi**2*sxx+12.*rxi*rxx*sxi)*rxrrs+(12.*rxi*sxi*sxx+6.*rxx*sxi**2)*rxrss+6.*sxi**2*sxx*rxsss+(4.*rxi*rxxx+3.*rxx**2)*rxrr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*rxrs+(4.*sxi*sxxx+3.*sxx**2)*rxss+rxxxx*rxr+sxxxx*rxs
                                                        rxxxxy   = rxi**3*ryi*rxrrrr+(rxi**3*syi+3.*rxi**2*ryi*sxi)*rxrrrs+(3.*rxi**2*sxi*syi+3.*rxi*ryi*sxi**2)*rxrrss+(3.*rxi*sxi**2*syi+ryi*sxi**3)*rxrsss+sxi**3*syi*rxssss+(3.*rxi**2*rxy+3.*rxi*rxx*ryi)*rxrrr+(3.*rxi**2*sxy+(3.*rxx*syi+6.*rxy*sxi+3.*ryi*sxx)*rxi+3.*rxx*ryi*sxi)*rxrrs+((6.*sxi*sxy+3.*sxx*syi)*rxi+3.*rxy*sxi**2+(3.*rxx*syi+3.*ryi*sxx)*sxi)*rxrss+(3.*sxi**2*sxy+3.*sxi*sxx*syi)*rxsss+(3.*rxi*rxxy+3.*rxx*rxy+rxxx*ryi)*rxrr+(3.*rxi*sxxy+3.*rxx*sxy+rxxx*syi+3.*rxxy*sxi+3.*rxy*sxx+ryi*sxxx)*rxrs+(3.*sxi*sxxy+3.*sxx*sxy+sxxx*syi)*rxss+rxxxy*rxr+sxxxy*rxs
                                                        rxxxyy   = rxi**2*ryi**2*rxrrrr+(2.*rxi**2*ryi*syi+2.*rxi*ryi**2*sxi)*rxrrrs+(rxi**2*syi**2+4.*rxi*ryi*sxi*syi+ryi**2*sxi**2)*rxrrss+(2.*rxi*sxi*syi**2+2.*ryi*sxi**2*syi)*rxrsss+sxi**2*syi**2*rxssss+(rxi**2*ryy+4.*rxi*rxy*ryi+rxx*ryi**2)*rxrrr+(rxi**2*syy+(4.*rxy*syi+4.*ryi*sxy+2.*ryy*sxi)*rxi+ryi**2*sxx+(2.*rxx*syi+4.*rxy*sxi)*ryi)*rxrrs+((2.*sxi*syy+4.*sxy*syi)*rxi+(4.*sxi*sxy+2.*sxx*syi)*ryi+ryy*sxi**2+4.*rxy*syi*sxi+rxx*syi**2)*rxrss+(sxi**2*syy+4.*sxi*sxy*syi+sxx*syi**2)*rxsss+(2.*rxi*rxyy+rxx*ryy+2.*rxxy*ryi+2.*rxy**2)*rxrr+(2.*rxi*sxyy+rxx*syy+2.*rxxy*syi+4.*rxy*sxy+2.*rxyy*sxi+2.*ryi*sxxy+ryy*sxx)*rxrs+(2.*sxi*sxyy+sxx*syy+2.*sxxy*syi+2.*sxy**2)*rxss+rxxyy*rxr+sxxyy*rxs
                                                        rxxyyy   = rxi*ryi**3*rxrrrr+(3.*rxi*ryi**2*syi+ryi**3*sxi)*rxrrrs+(3.*rxi*ryi*syi**2+3.*ryi**2*sxi*syi)*rxrrss+(rxi*syi**3+3.*ryi*sxi*syi**2)*rxrsss+sxi*syi**3*rxssss+(3.*rxi*ryi*ryy+3.*rxy*ryi**2)*rxrrr+(3.*ryi**2*sxy+(3.*rxi*syy+6.*rxy*syi+3.*ryy*sxi)*ryi+3.*ryy*rxi*syi)*rxrrs+((3.*sxi*syy+6.*sxy*syi)*ryi+3.*rxy*syi**2+(3.*rxi*syy+3.*ryy*sxi)*syi)*rxrss+(3.*sxi*syi*syy+3.*sxy*syi**2)*rxsss+(rxi*ryyy+3.*rxy*ryy+3.*rxyy*ryi)*rxrr+(rxi*syyy+3.*rxy*syy+3.*rxyy*syi+3.*ryi*sxyy+3.*ryy*sxy+ryyy*sxi)*rxrs+(sxi*syyy+3.*sxy*syy+3.*sxyy*syi)*rxss+rxyyy*rxr+sxyyy*rxs
                                                        rxyyyy   = ryi**4*rxrrrr+4.*ryi**3*syi*rxrrrs+6.*ryi**2*syi**2*rxrrss+4.*ryi*syi**3*rxrsss+syi**4*rxssss+6.*ryi**2*ryy*rxrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*rxrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*rxrss+6.*syi**2*syy*rxsss+(4.*ryi*ryyy+3.*ryy**2)*rxrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*rxrs+(4.*syi*syyy+3.*syy**2)*rxss+ryyyy*rxr+syyyy*rxs
                                                        ryyyyy   = ryi**4*ryrrrr+4.*ryi**3*syi*ryrrrs+6.*ryi**2*syi**2*ryrrss+4.*ryi*syi**3*ryrsss+syi**4*ryssss+6.*ryi**2*ryy*ryrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*ryrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*ryrss+6.*syi**2*syy*rysss+(4.*ryi*ryyy+3.*ryy**2)*ryrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*ryrs+(4.*syi*syyy+3.*syy**2)*ryss+ryyyy*ryr+syyyy*rys
                                                        sxxxxx   = rxi**4*sxrrrr+4.*rxi**3*sxi*sxrrrs+6.*rxi**2*sxi**2*sxrrss+4.*rxi*sxi**3*sxrsss+sxi**4*sxssss+6.*rxi**2*rxx*sxrrr+(6.*rxi**2*sxx+12.*rxi*rxx*sxi)*sxrrs+(12.*rxi*sxi*sxx+6.*rxx*sxi**2)*sxrss+6.*sxi**2*sxx*sxsss+(4.*rxi*rxxx+3.*rxx**2)*sxrr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*sxrs+(4.*sxi*sxxx+3.*sxx**2)*sxss+rxxxx*sxr+sxxxx*sxs
                                                        sxxxxy   = rxi**3*ryi*sxrrrr+(rxi**3*syi+3.*rxi**2*ryi*sxi)*sxrrrs+(3.*rxi**2*sxi*syi+3.*rxi*ryi*sxi**2)*sxrrss+(3.*rxi*sxi**2*syi+ryi*sxi**3)*sxrsss+sxi**3*syi*sxssss+(3.*rxi**2*rxy+3.*rxi*rxx*ryi)*sxrrr+(3.*rxi**2*sxy+(3.*rxx*syi+6.*rxy*sxi+3.*ryi*sxx)*rxi+3.*rxx*ryi*sxi)*sxrrs+((6.*sxi*sxy+3.*sxx*syi)*rxi+3.*rxy*sxi**2+(3.*rxx*syi+3.*ryi*sxx)*sxi)*sxrss+(3.*sxi**2*sxy+3.*sxi*sxx*syi)*sxsss+(3.*rxi*rxxy+3.*rxx*rxy+rxxx*ryi)*sxrr+(3.*rxi*sxxy+3.*rxx*sxy+rxxx*syi+3.*rxxy*sxi+3.*rxy*sxx+ryi*sxxx)*sxrs+(3.*sxi*sxxy+3.*sxx*sxy+sxxx*syi)*sxss+rxxxy*sxr+sxxxy*sxs
                                                        sxxxyy   = rxi**2*ryi**2*sxrrrr+(2.*rxi**2*ryi*syi+2.*rxi*ryi**2*sxi)*sxrrrs+(rxi**2*syi**2+4.*rxi*ryi*sxi*syi+ryi**2*sxi**2)*sxrrss+(2.*rxi*sxi*syi**2+2.*ryi*sxi**2*syi)*sxrsss+sxi**2*syi**2*sxssss+(rxi**2*ryy+4.*rxi*rxy*ryi+rxx*ryi**2)*sxrrr+(rxi**2*syy+(4.*rxy*syi+4.*ryi*sxy+2.*ryy*sxi)*rxi+ryi**2*sxx+(2.*rxx*syi+4.*rxy*sxi)*ryi)*sxrrs+((2.*sxi*syy+4.*sxy*syi)*rxi+(4.*sxi*sxy+2.*sxx*syi)*ryi+ryy*sxi**2+4.*rxy*syi*sxi+rxx*syi**2)*sxrss+(sxi**2*syy+4.*sxi*sxy*syi+sxx*syi**2)*sxsss+(2.*rxi*rxyy+rxx*ryy+2.*rxxy*ryi+2.*rxy**2)*sxrr+(2.*rxi*sxyy+rxx*syy+2.*rxxy*syi+4.*rxy*sxy+2.*rxyy*sxi+2.*ryi*sxxy+ryy*sxx)*sxrs+(2.*sxi*sxyy+sxx*syy+2.*sxxy*syi+2.*sxy**2)*sxss+rxxyy*sxr+sxxyy*sxs
                                                        sxxyyy   = rxi*ryi**3*sxrrrr+(3.*rxi*ryi**2*syi+ryi**3*sxi)*sxrrrs+(3.*rxi*ryi*syi**2+3.*ryi**2*sxi*syi)*sxrrss+(rxi*syi**3+3.*ryi*sxi*syi**2)*sxrsss+sxi*syi**3*sxssss+(3.*rxi*ryi*ryy+3.*rxy*ryi**2)*sxrrr+(3.*ryi**2*sxy+(3.*rxi*syy+6.*rxy*syi+3.*ryy*sxi)*ryi+3.*ryy*rxi*syi)*sxrrs+((3.*sxi*syy+6.*sxy*syi)*ryi+3.*rxy*syi**2+(3.*rxi*syy+3.*ryy*sxi)*syi)*sxrss+(3.*sxi*syi*syy+3.*sxy*syi**2)*sxsss+(rxi*ryyy+3.*rxy*ryy+3.*rxyy*ryi)*sxrr+(rxi*syyy+3.*rxy*syy+3.*rxyy*syi+3.*ryi*sxyy+3.*ryy*sxy+ryyy*sxi)*sxrs+(sxi*syyy+3.*sxy*syy+3.*sxyy*syi)*sxss+rxyyy*sxr+sxyyy*sxs
                                                        sxyyyy   = ryi**4*sxrrrr+4.*ryi**3*syi*sxrrrs+6.*ryi**2*syi**2*sxrrss+4.*ryi*syi**3*sxrsss+syi**4*sxssss+6.*ryi**2*ryy*sxrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*sxrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*sxrss+6.*syi**2*syy*sxsss+(4.*ryi*ryyy+3.*ryy**2)*sxrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*sxrs+(4.*syi*syyy+3.*syy**2)*sxss+ryyyy*sxr+syyyy*sxs
                                                        syyyyy   = ryi**4*syrrrr+4.*ryi**3*syi*syrrrs+6.*ryi**2*syi**2*syrrss+4.*ryi*syi**3*syrsss+syi**4*syssss+6.*ryi**2*ryy*syrrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*syrrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*syrss+6.*syi**2*syy*sysss+(4.*ryi*ryyy+3.*ryy**2)*syrr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*syrs+(4.*syi*syyy+3.*syy**2)*syss+ryyyy*syr+syyyy*sys
                                                        rxxxxxx  = rxi**5*rxrrrrr+5.*sxi*rxi**4*rxrrrrs+10.*rxi**3*sxi**2*rxrrrss+10.*rxi**2*sxi**3*rxrrsss+5.*rxi*sxi**4*rxrssss+sxi**5*rxsssss+10.*rxi**3*rxx*rxrrrr+(10.*rxi**3*sxx+30.*rxi**2*rxx*sxi)*rxrrrs+(30.*rxi**2*sxi*sxx+30.*rxi*rxx*sxi**2)*rxrrss+(30.*rxi*sxi**2*sxx+10.*rxx*sxi**3)*rxrsss+10.*sxi**3*sxx*rxssss+(10.*rxi**2*rxxx+15.*rxi*rxx**2)*rxrrr+(10.*rxi**2*sxxx+(30.*rxx*sxx+20.*rxxx*sxi)*rxi+15.*rxx**2*sxi)*rxrrs+((20.*sxi*sxxx+15.*sxx**2)*rxi+10.*rxxx*sxi**2+30.*rxx*sxx*sxi)*rxrss+(10.*sxi**2*sxxx+15.*sxi*sxx**2)*rxsss+(5.*rxi*rxxxx+10.*rxx*rxxx)*rxrr+(5.*rxi*sxxxx+10.*rxx*sxxx+10.*rxxx*sxx+5.*rxxxx*sxi)*rxrs+(5.*sxi*sxxxx+10.*sxx*sxxx)*rxss+rxxxxx*rxr+sxxxxx*rxs
                                                        rxxxxxy  = ryi*rxi**4*rxrrrrr+(rxi**4*syi+4.*rxi**3*ryi*sxi)*rxrrrrs+(4.*rxi**3*sxi*syi+6.*rxi**2*ryi*sxi**2)*rxrrrss+(6.*rxi**2*sxi**2*syi+4.*rxi*ryi*sxi**3)*rxrrsss+(4.*rxi*sxi**3*syi+ryi*sxi**4)*rxrssss+syi*sxi**4*rxsssss+(4.*rxi**3*rxy+6.*rxi**2*rxx*ryi)*rxrrrr+(4.*rxi**3*sxy+(6.*rxx*syi+12.*rxy*sxi+6.*ryi*sxx)*rxi**2+12.*rxx*ryi*sxi*rxi)*rxrrrs+((12.*sxi*sxy+6.*sxx*syi)*rxi**2+(12.*rxy*sxi**2+(12.*rxx*syi+12.*ryi*sxx)*sxi)*rxi+6.*rxx*ryi*sxi**2)*rxrrss+((12.*sxi**2*sxy+12.*sxi*sxx*syi)*rxi+4.*rxy*sxi**3+(6.*rxx*syi+6.*ryi*sxx)*sxi**2)*rxrsss+(4.*sxi**3*sxy+6.*sxi**2*sxx*syi)*rxssss+(6.*rxxy*rxi**2+(12.*rxx*rxy+4.*rxxx*ryi)*rxi+3.*rxx**2*ryi)*rxrrr+(6.*rxi**2*sxxy+(12.*rxx*sxy+4.*rxxx*syi+12.*rxxy*sxi+12.*rxy*sxx+4.*ryi*sxxx)*rxi+(12.*rxx*rxy+4.*rxxx*ryi)*sxi+6.*rxx*sxx*ryi+3.*rxx**2*syi)*rxrrs+((12.*sxi*sxxy+12.*sxx*sxy+4.*sxxx*syi)*rxi+6.*rxxy*sxi**2+(12.*rxx*sxy+4.*rxxx*syi+12.*rxy*sxx+4.*ryi*sxxx)*sxi+3.*sxx**2*ryi+6.*rxx*sxx*syi)*rxrss+(6.*sxi**2*sxxy+(12.*sxx*sxy+4.*sxxx*syi)*sxi+3.*sxx**2*syi)*rxsss+(4.*rxi*rxxxy+6.*rxx*rxxy+4.*rxxx*rxy+rxxxx*ryi)*rxrr+(4.*rxi*sxxxy+6.*rxx*sxxy+4.*rxxx*sxy+rxxxx*syi+4.*rxxxy*sxi+6.*rxxy*sxx+4.*rxy*sxxx+ryi*sxxxx)*rxrs+(4.*sxi*sxxxy+6.*sxx*sxxy+4.*sxxx*sxy+sxxxx*syi)*rxss+rxxxxy*rxr+sxxxxy*rxs
                                                        rxxxxyy  = rxi**3*ryi**2*rxrrrrr+(2.*rxi**3*ryi*syi+3.*rxi**2*ryi**2*sxi)*rxrrrrs+(rxi**3*syi**2+6.*rxi**2*ryi*sxi*syi+3.*rxi*ryi**2*sxi**2)*rxrrrss+(3.*rxi**2*sxi*syi**2+6.*rxi*ryi*sxi**2*syi+ryi**2*sxi**3)*rxrrsss+(3.*rxi*sxi**2*syi**2+2.*ryi*sxi**3*syi)*rxrssss+sxi**3*syi**2*rxsssss+(rxi**3*ryy+6.*rxi**2*rxy*ryi+3.*rxi*rxx*ryi**2)*rxrrrr+(rxi**3*syy+(6.*rxy*syi+6.*ryi*sxy+3.*ryy*sxi)*rxi**2+(6.*rxx*ryi*syi+12.*rxy*ryi*sxi+3.*ryi**2*sxx)*rxi+3.*rxx*ryi**2*sxi)*rxrrrs+((3.*sxi*syy+6.*sxy*syi)*rxi**2+(3.*ryy*sxi**2+(12.*rxy*syi+12.*ryi*sxy)*sxi+6.*sxx*syi*ryi+3.*rxx*syi**2)*rxi+6.*rxy*ryi*sxi**2+(6.*rxx*ryi*syi+3.*ryi**2*sxx)*sxi)*rxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*rxi+ryy*sxi**3+(6.*rxy*syi+6.*ryi*sxy)*sxi**2+(3.*rxx*syi**2+6.*ryi*sxx*syi)*sxi)*rxrsss+(sxi**3*syy+6.*sxi**2*sxy*syi+3.*sxi*sxx*syi**2)*rxssss+(3.*rxyy*rxi**2+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*rxi+rxxx*ryi**2+6.*rxy*rxx*ryi)*rxrrr+(3.*rxi**2*sxyy+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+6.*ryi*sxxy+3.*ryy*sxx)*rxi+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*sxi+ryi**2*sxxx+(6.*rxx*sxy+2.*rxxx*syi+6.*rxy*sxx)*ryi+6.*rxy*rxx*syi)*rxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*rxi+3.*rxyy*sxi**2+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*ryi*sxxy+3.*ryy*sxx)*sxi+(6.*sxx*sxy+2.*sxxx*syi)*ryi+rxxx*syi**2+(6.*rxx*sxy+6.*rxy*sxx)*syi)*rxrss+(3.*sxi**2*sxyy+(3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*sxi+sxxx*syi**2+6.*sxx*sxy*syi)*rxsss+(3.*rxi*rxxyy+3.*rxx*rxyy+rxxx*ryy+2.*rxxxy*ryi+6.*rxxy*rxy)*rxrr+(3.*rxi*sxxyy+3.*rxx*sxyy+rxxx*syy+2.*rxxxy*syi+6.*rxxy*sxy+3.*rxxyy*sxi+6.*rxy*sxxy+3.*rxyy*sxx+2.*ryi*sxxxy+ryy*sxxx)*rxrs+(3.*sxi*sxxyy+3.*sxx*sxyy+sxxx*syy+2.*sxxxy*syi+6.*sxxy*sxy)*rxss+rxxxyy*rxr+sxxxyy*rxs
                                                        rxxxyyy  = rxi**2*ryi**3*rxrrrrr+(3.*rxi**2*ryi**2*syi+2.*rxi*ryi**3*sxi)*rxrrrrs+(3.*rxi**2*ryi*syi**2+6.*rxi*ryi**2*sxi*syi+ryi**3*sxi**2)*rxrrrss+(rxi**2*syi**3+6.*rxi*ryi*sxi*syi**2+3.*ryi**2*sxi**2*syi)*rxrrsss+(2.*rxi*sxi*syi**3+3.*ryi*sxi**2*syi**2)*rxrssss+sxi**2*syi**3*rxsssss+(3.*rxi**2*ryi*ryy+6.*rxi*rxy*ryi**2+rxx*ryi**3)*rxrrrr+(ryi**3*sxx+(6.*rxi*sxy+3.*rxx*syi+6.*rxy*sxi)*ryi**2+(3.*rxi**2*syy+12.*rxi*rxy*syi+6.*rxi*ryy*sxi)*ryi+3.*ryy*rxi**2*syi)*rxrrrs+((6.*sxi*sxy+3.*sxx*syi)*ryi**2+(3.*rxx*syi**2+(12.*rxi*sxy+12.*rxy*sxi)*syi+6.*sxi*syy*rxi+3.*ryy*sxi**2)*ryi+6.*rxy*rxi*syi**2+(3.*rxi**2*syy+6.*rxi*ryy*sxi)*syi)*rxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*ryi+rxx*syi**3+(6.*rxi*sxy+6.*rxy*sxi)*syi**2+(6.*rxi*sxi*syy+3.*ryy*sxi**2)*syi)*rxrsss+(3.*sxi**2*syi*syy+6.*sxi*sxy*syi**2+sxx*syi**3)*rxssss+(3.*rxxy*ryi**2+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*ryi+ryyy*rxi**2+6.*rxy*ryy*rxi)*rxrrr+(3.*ryi**2*sxxy+(6.*rxi*sxyy+3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*ryi+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*syi+rxi**2*syyy+(6.*rxy*syy+6.*ryy*sxy+2.*ryyy*sxi)*rxi+6.*rxy*ryy*sxi)*rxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*ryi+3.*rxxy*syi**2+(6.*rxi*sxyy+3.*rxx*syy+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*syi+(2.*sxi*syyy+6.*sxy*syy)*rxi+ryyy*sxi**2+(6.*rxy*syy+6.*ryy*sxy)*sxi)*rxrss+(3.*sxxy*syi**2+(6.*sxi*sxyy+3.*sxx*syy+6.*sxy**2)*syi+sxi**2*syyy+6.*sxy*syy*sxi)*rxsss+(2.*rxi*rxyyy+rxx*ryyy+3.*rxxy*ryy+3.*rxxyy*ryi+6.*rxy*rxyy)*rxrr+(2.*rxi*sxyyy+rxx*syyy+3.*rxxy*syy+3.*rxxyy*syi+6.*rxy*sxyy+6.*rxyy*sxy+2.*rxyyy*sxi+3.*ryi*sxxyy+3.*ryy*sxxy+ryyy*sxx)*rxrs+(2.*sxi*sxyyy+sxx*syyy+3.*sxxy*syy+3.*sxxyy*syi+6.*sxy*sxyy)*rxss+rxxyyy*rxr+sxxyyy*rxs
                                                        rxxyyyy  = rxi*ryi**4*rxrrrrr+(4.*rxi*ryi**3*syi+ryi**4*sxi)*rxrrrrs+(6.*rxi*ryi**2*syi**2+4.*ryi**3*sxi*syi)*rxrrrss+(4.*rxi*ryi*syi**3+6.*ryi**2*sxi*syi**2)*rxrrsss+(rxi*syi**4+4.*ryi*sxi*syi**3)*rxrssss+sxi*syi**4*rxsssss+(6.*rxi*ryi**2*ryy+4.*rxy*ryi**3)*rxrrrr+(4.*ryi**3*sxy+(6.*rxi*syy+12.*rxy*syi+6.*ryy*sxi)*ryi**2+12.*ryy*rxi*syi*ryi)*rxrrrs+((6.*sxi*syy+12.*sxy*syi)*ryi**2+(12.*rxy*syi**2+(12.*rxi*syy+12.*ryy*sxi)*syi)*ryi+6.*ryy*rxi*syi**2)*rxrrss+((12.*sxi*syi*syy+12.*sxy*syi**2)*ryi+4.*rxy*syi**3+(6.*rxi*syy+6.*ryy*sxi)*syi**2)*rxrsss+(6.*sxi*syi**2*syy+4.*sxy*syi**3)*rxssss+(6.*rxyy*ryi**2+(4.*rxi*ryyy+12.*rxy*ryy)*ryi+3.*ryy**2*rxi)*rxrrr+(6.*ryi**2*sxyy+(4.*rxi*syyy+12.*rxy*syy+12.*rxyy*syi+12.*ryy*sxy+4.*ryyy*sxi)*ryi+(4.*rxi*ryyy+12.*rxy*ryy)*syi+6.*ryy*syy*rxi+3.*ryy**2*sxi)*rxrrs+((4.*sxi*syyy+12.*sxy*syy+12.*sxyy*syi)*ryi+6.*rxyy*syi**2+(4.*rxi*syyy+12.*rxy*syy+12.*ryy*sxy+4.*ryyy*sxi)*syi+3.*syy**2*rxi+6.*ryy*syy*sxi)*rxrss+(6.*sxyy*syi**2+(4.*sxi*syyy+12.*sxy*syy)*syi+3.*syy**2*sxi)*rxsss+(rxi*ryyyy+4.*rxy*ryyy+6.*rxyy*ryy+4.*rxyyy*ryi)*rxrr+(rxi*syyyy+4.*rxy*syyy+6.*rxyy*syy+4.*rxyyy*syi+4.*ryi*sxyyy+6.*ryy*sxyy+4.*ryyy*sxy+ryyyy*sxi)*rxrs+(sxi*syyyy+4.*sxy*syyy+6.*sxyy*syy+4.*sxyyy*syi)*rxss+rxyyyy*rxr+sxyyyy*rxs
                                                        rxyyyyy  = ryi**5*rxrrrrr+5.*syi*ryi**4*rxrrrrs+10.*ryi**3*syi**2*rxrrrss+10.*ryi**2*syi**3*rxrrsss+5.*ryi*syi**4*rxrssss+syi**5*rxsssss+10.*ryi**3*ryy*rxrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*rxrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*rxrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*rxrsss+10.*syi**3*syy*rxssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*rxrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*rxrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*rxrss+(10.*syi**2*syyy+15.*syi*syy**2)*rxsss+(5.*ryi*ryyyy+10.*ryy*ryyy)*rxrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*rxrs+(5.*syi*syyyy+10.*syy*syyy)*rxss+ryyyyy*rxr+syyyyy*rxs
                                                        ryyyyyy  = ryi**5*ryrrrrr+5.*syi*ryi**4*ryrrrrs+10.*ryi**3*syi**2*ryrrrss+10.*ryi**2*syi**3*ryrrsss+5.*ryi*syi**4*ryrssss+syi**5*rysssss+10.*ryi**3*ryy*ryrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*ryrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*ryrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*ryrsss+10.*syi**3*syy*ryssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*ryrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*ryrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*ryrss+(10.*syi**2*syyy+15.*syi*syy**2)*rysss+(5.*ryi*ryyyy+10.*ryy*ryyy)*ryrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*ryrs+(5.*syi*syyyy+10.*syy*syyy)*ryss+ryyyyy*ryr+syyyyy*rys
                                                        sxxxxxx  = rxi**5*sxrrrrr+5.*sxi*rxi**4*sxrrrrs+10.*rxi**3*sxi**2*sxrrrss+10.*rxi**2*sxi**3*sxrrsss+5.*rxi*sxi**4*sxrssss+sxi**5*sxsssss+10.*rxi**3*rxx*sxrrrr+(10.*rxi**3*sxx+30.*rxi**2*rxx*sxi)*sxrrrs+(30.*rxi**2*sxi*sxx+30.*rxi*rxx*sxi**2)*sxrrss+(30.*rxi*sxi**2*sxx+10.*rxx*sxi**3)*sxrsss+10.*sxi**3*sxx*sxssss+(10.*rxi**2*rxxx+15.*rxi*rxx**2)*sxrrr+(10.*rxi**2*sxxx+(30.*rxx*sxx+20.*rxxx*sxi)*rxi+15.*rxx**2*sxi)*sxrrs+((20.*sxi*sxxx+15.*sxx**2)*rxi+10.*rxxx*sxi**2+30.*rxx*sxx*sxi)*sxrss+(10.*sxi**2*sxxx+15.*sxi*sxx**2)*sxsss+(5.*rxi*rxxxx+10.*rxx*rxxx)*sxrr+(5.*rxi*sxxxx+10.*rxx*sxxx+10.*rxxx*sxx+5.*rxxxx*sxi)*sxrs+(5.*sxi*sxxxx+10.*sxx*sxxx)*sxss+rxxxxx*sxr+sxxxxx*sxs
                                                        sxxxxxy  = ryi*rxi**4*sxrrrrr+(rxi**4*syi+4.*rxi**3*ryi*sxi)*sxrrrrs+(4.*rxi**3*sxi*syi+6.*rxi**2*ryi*sxi**2)*sxrrrss+(6.*rxi**2*sxi**2*syi+4.*rxi*ryi*sxi**3)*sxrrsss+(4.*rxi*sxi**3*syi+ryi*sxi**4)*sxrssss+syi*sxi**4*sxsssss+(4.*rxi**3*rxy+6.*rxi**2*rxx*ryi)*sxrrrr+(4.*rxi**3*sxy+(6.*rxx*syi+12.*rxy*sxi+6.*ryi*sxx)*rxi**2+12.*rxx*ryi*sxi*rxi)*sxrrrs+((12.*sxi*sxy+6.*sxx*syi)*rxi**2+(12.*rxy*sxi**2+(12.*rxx*syi+12.*ryi*sxx)*sxi)*rxi+6.*rxx*ryi*sxi**2)*sxrrss+((12.*sxi**2*sxy+12.*sxi*sxx*syi)*rxi+4.*rxy*sxi**3+(6.*rxx*syi+6.*ryi*sxx)*sxi**2)*sxrsss+(4.*sxi**3*sxy+6.*sxi**2*sxx*syi)*sxssss+(6.*rxxy*rxi**2+(12.*rxx*rxy+4.*rxxx*ryi)*rxi+3.*rxx**2*ryi)*sxrrr+(6.*rxi**2*sxxy+(12.*rxx*sxy+4.*rxxx*syi+12.*rxxy*sxi+12.*rxy*sxx+4.*ryi*sxxx)*rxi+(12.*rxx*rxy+4.*rxxx*ryi)*sxi+6.*rxx*sxx*ryi+3.*rxx**2*syi)*sxrrs+((12.*sxi*sxxy+12.*sxx*sxy+4.*sxxx*syi)*rxi+6.*rxxy*sxi**2+(12.*rxx*sxy+4.*rxxx*syi+12.*rxy*sxx+4.*ryi*sxxx)*sxi+3.*sxx**2*ryi+6.*rxx*sxx*syi)*sxrss+(6.*sxi**2*sxxy+(12.*sxx*sxy+4.*sxxx*syi)*sxi+3.*sxx**2*syi)*sxsss+(4.*rxi*rxxxy+6.*rxx*rxxy+4.*rxxx*rxy+rxxxx*ryi)*sxrr+(4.*rxi*sxxxy+6.*rxx*sxxy+4.*rxxx*sxy+rxxxx*syi+4.*rxxxy*sxi+6.*rxxy*sxx+4.*rxy*sxxx+ryi*sxxxx)*sxrs+(4.*sxi*sxxxy+6.*sxx*sxxy+4.*sxxx*sxy+sxxxx*syi)*sxss+rxxxxy*sxr+sxxxxy*sxs
                                                        sxxxxyy  = rxi**3*ryi**2*sxrrrrr+(2.*rxi**3*ryi*syi+3.*rxi**2*ryi**2*sxi)*sxrrrrs+(rxi**3*syi**2+6.*rxi**2*ryi*sxi*syi+3.*rxi*ryi**2*sxi**2)*sxrrrss+(3.*rxi**2*sxi*syi**2+6.*rxi*ryi*sxi**2*syi+ryi**2*sxi**3)*sxrrsss+(3.*rxi*sxi**2*syi**2+2.*ryi*sxi**3*syi)*sxrssss+sxi**3*syi**2*sxsssss+(rxi**3*ryy+6.*rxi**2*rxy*ryi+3.*rxi*rxx*ryi**2)*sxrrrr+(rxi**3*syy+(6.*rxy*syi+6.*ryi*sxy+3.*ryy*sxi)*rxi**2+(6.*rxx*ryi*syi+12.*rxy*ryi*sxi+3.*ryi**2*sxx)*rxi+3.*rxx*ryi**2*sxi)*sxrrrs+((3.*sxi*syy+6.*sxy*syi)*rxi**2+(3.*ryy*sxi**2+(12.*rxy*syi+12.*ryi*sxy)*sxi+6.*sxx*syi*ryi+3.*rxx*syi**2)*rxi+6.*rxy*ryi*sxi**2+(6.*rxx*ryi*syi+3.*ryi**2*sxx)*sxi)*sxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*rxi+ryy*sxi**3+(6.*rxy*syi+6.*ryi*sxy)*sxi**2+(3.*rxx*syi**2+6.*ryi*sxx*syi)*sxi)*sxrsss+(sxi**3*syy+6.*sxi**2*sxy*syi+3.*sxi*sxx*syi**2)*sxssss+(3.*rxyy*rxi**2+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*rxi+rxxx*ryi**2+6.*rxy*rxx*ryi)*sxrrr+(3.*rxi**2*sxyy+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+6.*ryi*sxxy+3.*ryy*sxx)*rxi+(3.*rxx*ryy+6.*rxxy*ryi+6.*rxy**2)*sxi+ryi**2*sxxx+(6.*rxx*sxy+2.*rxxx*syi+6.*rxy*sxx)*ryi+6.*rxy*rxx*syi)*sxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*rxi+3.*rxyy*sxi**2+(3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*ryi*sxxy+3.*ryy*sxx)*sxi+(6.*sxx*sxy+2.*sxxx*syi)*ryi+rxxx*syi**2+(6.*rxx*sxy+6.*rxy*sxx)*syi)*sxrss+(3.*sxi**2*sxyy+(3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*sxi+sxxx*syi**2+6.*sxx*sxy*syi)*sxsss+(3.*rxi*rxxyy+3.*rxx*rxyy+rxxx*ryy+2.*rxxxy*ryi+6.*rxxy*rxy)*sxrr+(3.*rxi*sxxyy+3.*rxx*sxyy+rxxx*syy+2.*rxxxy*syi+6.*rxxy*sxy+3.*rxxyy*sxi+6.*rxy*sxxy+3.*rxyy*sxx+2.*ryi*sxxxy+ryy*sxxx)*sxrs+(3.*sxi*sxxyy+3.*sxx*sxyy+sxxx*syy+2.*sxxxy*syi+6.*sxxy*sxy)*sxss+rxxxyy*sxr+sxxxyy*sxs
                                                        sxxxyyy  = rxi**2*ryi**3*sxrrrrr+(3.*rxi**2*ryi**2*syi+2.*rxi*ryi**3*sxi)*sxrrrrs+(3.*rxi**2*ryi*syi**2+6.*rxi*ryi**2*sxi*syi+ryi**3*sxi**2)*sxrrrss+(rxi**2*syi**3+6.*rxi*ryi*sxi*syi**2+3.*ryi**2*sxi**2*syi)*sxrrsss+(2.*rxi*sxi*syi**3+3.*ryi*sxi**2*syi**2)*sxrssss+sxi**2*syi**3*sxsssss+(3.*rxi**2*ryi*ryy+6.*rxi*rxy*ryi**2+rxx*ryi**3)*sxrrrr+(ryi**3*sxx+(6.*rxi*sxy+3.*rxx*syi+6.*rxy*sxi)*ryi**2+(3.*rxi**2*syy+12.*rxi*rxy*syi+6.*rxi*ryy*sxi)*ryi+3.*ryy*rxi**2*syi)*sxrrrs+((6.*sxi*sxy+3.*sxx*syi)*ryi**2+(3.*rxx*syi**2+(12.*rxi*sxy+12.*rxy*sxi)*syi+6.*sxi*syy*rxi+3.*ryy*sxi**2)*ryi+6.*rxy*rxi*syi**2+(3.*rxi**2*syy+6.*rxi*ryy*sxi)*syi)*sxrrss+((3.*sxi**2*syy+12.*sxi*sxy*syi+3.*sxx*syi**2)*ryi+rxx*syi**3+(6.*rxi*sxy+6.*rxy*sxi)*syi**2+(6.*rxi*sxi*syy+3.*ryy*sxi**2)*syi)*sxrsss+(3.*sxi**2*syi*syy+6.*sxi*sxy*syi**2+sxx*syi**3)*sxssss+(3.*rxxy*ryi**2+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*ryi+ryyy*rxi**2+6.*rxy*ryy*rxi)*sxrrr+(3.*ryi**2*sxxy+(6.*rxi*sxyy+3.*rxx*syy+6.*rxxy*syi+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*ryi+(6.*rxi*rxyy+3.*rxx*ryy+6.*rxy**2)*syi+rxi**2*syyy+(6.*rxy*syy+6.*ryy*sxy+2.*ryyy*sxi)*rxi+6.*rxy*ryy*sxi)*sxrrs+((6.*sxi*sxyy+3.*sxx*syy+6.*sxxy*syi+6.*sxy**2)*ryi+3.*rxxy*syi**2+(6.*rxi*sxyy+3.*rxx*syy+12.*rxy*sxy+6.*rxyy*sxi+3.*ryy*sxx)*syi+(2.*sxi*syyy+6.*sxy*syy)*rxi+ryyy*sxi**2+(6.*rxy*syy+6.*ryy*sxy)*sxi)*sxrss+(3.*sxxy*syi**2+(6.*sxi*sxyy+3.*sxx*syy+6.*sxy**2)*syi+sxi**2*syyy+6.*sxy*syy*sxi)*sxsss+(2.*rxi*rxyyy+rxx*ryyy+3.*rxxy*ryy+3.*rxxyy*ryi+6.*rxy*rxyy)*sxrr+(2.*rxi*sxyyy+rxx*syyy+3.*rxxy*syy+3.*rxxyy*syi+6.*rxy*sxyy+6.*rxyy*sxy+2.*rxyyy*sxi+3.*ryi*sxxyy+3.*ryy*sxxy+ryyy*sxx)*sxrs+(2.*sxi*sxyyy+sxx*syyy+3.*sxxy*syy+3.*sxxyy*syi+6.*sxy*sxyy)*sxss+rxxyyy*sxr+sxxyyy*sxs
                                                        sxxyyyy  = rxi*ryi**4*sxrrrrr+(4.*rxi*ryi**3*syi+ryi**4*sxi)*sxrrrrs+(6.*rxi*ryi**2*syi**2+4.*ryi**3*sxi*syi)*sxrrrss+(4.*rxi*ryi*syi**3+6.*ryi**2*sxi*syi**2)*sxrrsss+(rxi*syi**4+4.*ryi*sxi*syi**3)*sxrssss+sxi*syi**4*sxsssss+(6.*rxi*ryi**2*ryy+4.*rxy*ryi**3)*sxrrrr+(4.*ryi**3*sxy+(6.*rxi*syy+12.*rxy*syi+6.*ryy*sxi)*ryi**2+12.*ryy*rxi*syi*ryi)*sxrrrs+((6.*sxi*syy+12.*sxy*syi)*ryi**2+(12.*rxy*syi**2+(12.*rxi*syy+12.*ryy*sxi)*syi)*ryi+6.*ryy*rxi*syi**2)*sxrrss+((12.*sxi*syi*syy+12.*sxy*syi**2)*ryi+4.*rxy*syi**3+(6.*rxi*syy+6.*ryy*sxi)*syi**2)*sxrsss+(6.*sxi*syi**2*syy+4.*sxy*syi**3)*sxssss+(6.*rxyy*ryi**2+(4.*rxi*ryyy+12.*rxy*ryy)*ryi+3.*ryy**2*rxi)*sxrrr+(6.*ryi**2*sxyy+(4.*rxi*syyy+12.*rxy*syy+12.*rxyy*syi+12.*ryy*sxy+4.*ryyy*sxi)*ryi+(4.*rxi*ryyy+12.*rxy*ryy)*syi+6.*ryy*syy*rxi+3.*ryy**2*sxi)*sxrrs+((4.*sxi*syyy+12.*sxy*syy+12.*sxyy*syi)*ryi+6.*rxyy*syi**2+(4.*rxi*syyy+12.*rxy*syy+12.*ryy*sxy+4.*ryyy*sxi)*syi+3.*syy**2*rxi+6.*ryy*syy*sxi)*sxrss+(6.*sxyy*syi**2+(4.*sxi*syyy+12.*sxy*syy)*syi+3.*syy**2*sxi)*sxsss+(rxi*ryyyy+4.*rxy*ryyy+6.*rxyy*ryy+4.*rxyyy*ryi)*sxrr+(rxi*syyyy+4.*rxy*syyy+6.*rxyy*syy+4.*rxyyy*syi+4.*ryi*sxyyy+6.*ryy*sxyy+4.*ryyy*sxy+ryyyy*sxi)*sxrs+(sxi*syyyy+4.*sxy*syyy+6.*sxyy*syy+4.*sxyyy*syi)*sxss+rxyyyy*sxr+sxyyyy*sxs
                                                        sxyyyyy  = ryi**5*sxrrrrr+5.*syi*ryi**4*sxrrrrs+10.*ryi**3*syi**2*sxrrrss+10.*ryi**2*syi**3*sxrrsss+5.*ryi*syi**4*sxrssss+syi**5*sxsssss+10.*ryi**3*ryy*sxrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*sxrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*sxrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*sxrsss+10.*syi**3*syy*sxssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*sxrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*sxrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*sxrss+(10.*syi**2*syyy+15.*syi*syy**2)*sxsss+(5.*ryi*ryyyy+10.*ryy*ryyy)*sxrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*sxrs+(5.*syi*syyyy+10.*syy*syyy)*sxss+ryyyyy*sxr+syyyyy*sxs
                                                        syyyyyy  = ryi**5*syrrrrr+5.*syi*ryi**4*syrrrrs+10.*ryi**3*syi**2*syrrrss+10.*ryi**2*syi**3*syrrsss+5.*ryi*syi**4*syrssss+syi**5*sysssss+10.*ryi**3*ryy*syrrrr+(10.*ryi**3*syy+30.*ryi**2*ryy*syi)*syrrrs+(30.*ryi**2*syi*syy+30.*ryi*ryy*syi**2)*syrrss+(30.*ryi*syi**2*syy+10.*ryy*syi**3)*syrsss+10.*syi**3*syy*syssss+(10.*ryi**2*ryyy+15.*ryi*ryy**2)*syrrr+(10.*ryi**2*syyy+(30.*ryy*syy+20.*ryyy*syi)*ryi+15.*ryy**2*syi)*syrrs+((20.*syi*syyy+15.*syy**2)*ryi+10.*ryyy*syi**2+30.*ryy*syy*syi)*syrss+(10.*syi**2*syyy+15.*syi*syy**2)*sysss+(5.*ryi*ryyyy+10.*ryy*ryyy)*syrr+(5.*ryi*syyyy+10.*ryy*syyy+10.*ryyy*syy+5.*ryyyy*syi)*syrs+(5.*syi*syyyy+10.*syy*syyy)*syss+ryyyyy*syr+syyyyy*sys
                            ! ---- end evalMetrics eq evalMetrics ---
                            ! ---------- Sixth spatial derivatives of u ---------
                                                        uxx      = rxi**2*urr+2.*rxi*sxi*urs+sxi**2*uss+rxx*ur+sxx*us
                                                        uxxxx    = rxi**4*urrrr+4.*rxi**3*sxi*urrrs+6.*rxi**2*sxi**2*urrss+4.*rxi*sxi**3*ursss+sxi**4*ussss+6.*rxi**2*rxx*urrr+(6.*rxi**2*sxx+12.*rxi*rxx*sxi)*urrs+(12.*rxi*sxi*sxx+6.*rxx*sxi**2)*urss+6.*sxi**2*sxx*usss+(4.*rxi*rxxx+3.*rxx**2)*urr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*urs+(4.*sxi*sxxx+3.*sxx**2)*uss+rxxxx*ur+sxxxx*us
                                                        uxxxxxx  = rxi**6*urrrrrr+sxi**6*ussssss+(15.*rxi**4*sxx+60.*rxi**3*rxx*sxi)*urrrrs+(60.*rxi**3*sxi*sxx+90.*rxi**2*rxx*sxi**2)*urrrss+(90.*rxi**2*sxi**2*sxx+60.*rxi*rxx*sxi**3)*urrsss+(60.*rxi*sxi**3*sxx+15.*rxx*sxi**4)*urssss+(20.*rxi**3*rxxx+45.*rxi**2*rxx**2)*urrrr+(20.*rxi**3*sxxx+(90.*rxx*sxx+60.*rxxx*sxi)*rxi**2+90.*rxx**2*sxi*rxi)*urrrs+((60.*sxi*sxxx+45.*sxx**2)*rxi**2+(180.*rxx*sxi*sxx+60.*rxxx*sxi**2)*rxi+45.*rxx**2*sxi**2)*urrss+((60.*sxi**2*sxxx+90.*sxi*sxx**2)*rxi+20.*rxxx*sxi**3+90.*rxx*sxx*sxi**2)*ursss+(20.*sxi**3*sxxx+45.*sxi**2*sxx**2)*ussss+(15.*rxi**2*rxxxx+60.*rxi*rxx*rxxx+15.*rxx**3)*urrr+(15.*rxi**2*sxxxx+(60.*rxx*sxxx+60.*rxxx*sxx+30.*rxxxx*sxi)*rxi+60.*rxxx*rxx*sxi+45.*sxx*rxx**2)*urrs+((30.*sxi*sxxxx+60.*sxx*sxxx)*rxi+15.*rxxxx*sxi**2+(60.*rxx*sxxx+60.*rxxx*sxx)*sxi+45.*sxx**2*rxx)*urss+(15.*sxi**2*sxxxx+60.*sxi*sxx*sxxx+15.*sxx**3)*usss+(6.*rxi*rxxxxx+15.*rxx*rxxxx+10.*rxxx**2)*urr+(6.*rxi*sxxxxx+15.*rxx*sxxxx+20.*rxxx*sxxx+15.*rxxxx*sxx+6.*rxxxxx*sxi)*urs+(6.*sxi*sxxxxx+15.*sxx*sxxxx+10.*sxxx**2)*uss+rxxxxxx*ur+sxxxxxx*us+6.*rxi**5*sxi*urrrrrs+15.*rxi**4*sxi**2*urrrrss+20.*rxi**3*sxi**3*urrrsss+15.*rxi**2*sxi**4*urrssss+6.*rxi*sxi**5*ursssss+15.*rxi**4*rxx*urrrrr+15.*sxi**4*sxx*usssss
                                                        uyy      = ryi**2*urr+2.*ryi*syi*urs+syi**2*uss+ryy*ur+syy*us
                                                        uxxyy    = rxi**2*ryi**2*urrrr+(2.*rxi**2*ryi*syi+2.*rxi*ryi**2*sxi)*urrrs+(rxi**2*syi**2+4.*rxi*ryi*sxi*syi+ryi**2*sxi**2)*urrss+(2.*rxi*sxi*syi**2+2.*ryi*sxi**2*syi)*ursss+sxi**2*syi**2*ussss+(rxi**2*ryy+4.*rxi*rxy*ryi+rxx*ryi**2)*urrr+(rxi**2*syy+(4.*rxy*syi+4.*ryi*sxy+2.*ryy*sxi)*rxi+ryi**2*sxx+(2.*rxx*syi+4.*rxy*sxi)*ryi)*urrs+((2.*sxi*syy+4.*sxy*syi)*rxi+(4.*sxi*sxy+2.*sxx*syi)*ryi+ryy*sxi**2+4.*rxy*syi*sxi+rxx*syi**2)*urss+(sxi**2*syy+4.*sxi*sxy*syi+sxx*syi**2)*usss+(2.*rxi*rxyy+rxx*ryy+2.*rxxy*ryi+2.*rxy**2)*urr+(2.*rxi*sxyy+rxx*syy+2.*rxxy*syi+4.*rxy*sxy+2.*rxyy*sxi+2.*ryi*sxxy+ryy*sxx)*urs+(2.*sxi*sxyy+sxx*syy+2.*sxxy*syi+2.*sxy**2)*uss+rxxyy*ur+sxxyy*us
                                                        uxxxxyy  = syi**2*sxi**4*ussssss+ryi**2*rxi**4*urrrrrr+(12.*rxy**2*rxx+3.*ryy*rxx**2+(12.*rxx*rxxy+8.*rxxx*rxy)*ryi+rxxxx*ryi**2+6.*rxxyy*rxi**2+(12.*rxx*rxyy+4.*rxxx*ryy+8.*rxxxy*ryi+24.*rxxy*rxy)*rxi)*urrr+((12.*rxx*rxyy+4.*rxxx*ryy+8.*rxxxy*ryi+24.*rxxy*rxy)*sxi+12.*rxy**2*sxx+(24.*rxy*sxy+6.*ryy*sxx)*rxx+(12.*rxx*rxxy+8.*rxxx*rxy)*syi+3.*syy*rxx**2+(12.*rxx*sxxy+8.*rxxx*sxy+2.*rxxxx*syi+12.*rxxy*sxx+8.*rxy*sxxx)*ryi+ryi**2*sxxxx+6.*rxi**2*sxxyy+(12.*rxx*sxyy+4.*rxxx*syy+8.*rxxxy*syi+24.*rxxy*sxy+12.*rxxyy*sxi+24.*rxy*sxxy+12.*rxyy*sxx+8.*ryi*sxxxy+4.*ryy*sxxx)*rxi)*urrs+((12.*rxx*sxyy+4.*rxxx*syy+8.*rxxxy*syi+24.*rxxy*sxy+24.*rxy*sxxy+12.*rxyy*sxx+8.*ryi*sxxxy+4.*ryy*sxxx)*sxi+24.*rxy*sxy*sxx+3.*ryy*sxx**2+(6.*sxx*syy+12.*sxy**2)*rxx+(12.*rxx*sxxy+8.*rxxx*sxy+12.*rxxy*sxx+8.*rxy*sxxx)*syi+rxxxx*syi**2+(12.*sxx*sxxy+8.*sxxx*sxy+2.*sxxxx*syi)*ryi+(12.*sxi*sxxyy+12.*sxx*sxyy+4.*sxxx*syy+8.*sxxxy*syi+24.*sxxy*sxy)*rxi+6.*rxxyy*sxi**2)*urss+((12.*sxx*sxyy+4.*sxxx*syy+8.*sxxxy*syi+24.*sxxy*sxy)*sxi+12.*sxy**2*sxx+3.*syy*sxx**2+(12.*sxx*sxxy+8.*sxxx*sxy)*syi+sxxxx*syi**2+6.*sxi**2*sxxyy)*usss+(4.*rxi*rxxxyy+6.*rxx*rxxyy+4.*rxxx*rxyy+rxxxx*ryy+2.*rxxxxy*ryi+8.*rxxxy*rxy+6.*rxxy**2)*urr+(4.*rxi*sxxxyy+6.*rxx*sxxyy+4.*rxxx*sxyy+rxxxx*syy+2.*rxxxxy*syi+8.*rxxxy*sxy+4.*rxxxyy*sxi+12.*rxxy*sxxy+6.*rxxyy*sxx+8.*rxy*sxxxy+4.*rxyy*sxxx+2.*ryi*sxxxxy+ryy*sxxxx)*urs+(4.*sxi*sxxxyy+6.*sxx*sxxyy+4.*sxxx*sxyy+sxxxx*syy+2.*sxxxxy*syi+8.*sxxxy*sxy+6.*sxxy**2)*uss+rxxxxyy*ur+sxxxxyy*us+(2.*rxi**4*ryi*syi+4.*rxi**3*ryi**2*sxi)*urrrrrs+(4.*rxi**3*sxi*syi**2+12.*rxi**2*ryi*sxi**2*syi+4.*rxi*ryi**2*sxi**3)*urrrsss+(rxi**4*syi**2+8.*rxi**3*ryi*sxi*syi+6.*rxi**2*ryi**2*sxi**2)*urrrrss+(6.*rxi**2*sxi**2*syi**2+8.*rxi*ryi*sxi**3*syi+ryi**2*sxi**4)*urrssss+(4.*rxi*sxi**3*syi**2+2.*ryi*sxi**4*syi)*ursssss+(rxi**4*ryy+8.*rxi**3*rxy*ryi+6.*rxi**2*rxx*ryi**2)*urrrrr+(12.*rxx*ryi**2*sxi*rxi+(8.*rxy*syi+8.*ryi*sxy+4.*ryy*sxi)*rxi**3+(12.*rxx*ryi*syi+24.*rxy*ryi*sxi+6.*ryi**2*sxx)*rxi**2+syy*rxi**4)*urrrrs+(6.*rxx*ryi**2*sxi**2+(24.*rxy*ryi*sxi**2+(24.*rxx*ryi*syi+12.*ryi**2*sxx)*sxi)*rxi+(4.*sxi*syy+8.*sxy*syi)*rxi**3+(6.*ryy*sxi**2+(24.*rxy*syi+24.*ryi*sxy)*sxi+12.*sxx*syi*ryi+6.*rxx*syi**2)*rxi**2)*urrrss+(8.*rxy*ryi*sxi**3+(12.*rxx*ryi*syi+6.*ryi**2*sxx)*sxi**2+(4.*ryy*sxi**3+(24.*rxy*syi+24.*ryi*sxy)*sxi**2+(12.*rxx*syi**2+24.*ryi*sxx*syi)*sxi)*rxi+(6.*sxi**2*syy+24.*sxi*sxy*syi+6.*sxx*syi**2)*rxi**2)*urrsss+((4.*sxi**3*syy+24.*sxi**2*sxy*syi+12.*sxi*sxx*syi**2)*rxi+(8.*rxy*syi+8.*ryi*sxy)*sxi**3+(6.*rxx*syi**2+12.*ryi*sxx*syi)*sxi**2+ryy*sxi**4)*urssss+(sxi**4*syy+8.*sxi**3*sxy*syi+6.*sxi**2*sxx*syi**2)*usssss+(3.*rxx**2*ryi**2+(6.*rxx*ryy+12.*rxxy*ryi+12.*rxy**2)*rxi**2+(24.*rxx*rxy*ryi+4.*rxxx*ryi**2)*rxi+4.*rxyy*rxi**3)*urrrr+((24.*rxx*rxy*ryi+4.*rxxx*ryi**2)*sxi+6.*rxx**2*syi*ryi+6.*rxx*sxx*ryi**2+(6.*rxx*syy+12.*rxxy*syi+24.*rxy*sxy+12.*rxyy*sxi+12.*ryi*sxxy+6.*ryy*sxx)*rxi**2+((12.*rxx*ryy+24.*rxxy*ryi+24.*rxy**2)*sxi+4.*ryi**2*sxxx+(24.*rxx*sxy+8.*rxxx*syi+24.*rxy*sxx)*ryi+24.*rxy*rxx*syi)*rxi+4.*rxi**3*sxyy)*urrrs+((4.*ryi**2*sxxx+(24.*rxx*sxy+8.*rxxx*syi+24.*rxy*sxx)*ryi+24.*rxy*rxx*syi)*sxi+3.*rxx**2*syi**2+12.*rxx*sxx*syi*ryi+3.*sxx**2*ryi**2+(12.*sxi*sxyy+6.*sxx*syy+12.*sxxy*syi+12.*sxy**2)*rxi**2+(12.*rxyy*sxi**2+(12.*rxx*syy+24.*rxxy*syi+48.*rxy*sxy+24.*ryi*sxxy+12.*ryy*sxx)*sxi+(24.*sxx*sxy+8.*sxxx*syi)*ryi+4.*rxxx*syi**2+(24.*rxx*sxy+24.*rxy*sxx)*syi)*rxi+(6.*rxx*ryy+12.*rxxy*ryi+12.*rxy**2)*sxi**2)*urrss+(((24.*sxx*sxy+8.*sxxx*syi)*ryi+4.*rxxx*syi**2+(24.*rxx*sxy+24.*rxy*sxx)*syi)*sxi+6.*rxx*sxx*syi**2+6.*sxx**2*syi*ryi+(12.*sxi**2*sxyy+(12.*sxx*syy+24.*sxxy*syi+24.*sxy**2)*sxi+4.*sxxx*syi**2+24.*sxx*sxy*syi)*rxi+4.*rxyy*sxi**3+(6.*rxx*syy+12.*rxxy*syi+24.*rxy*sxy+12.*ryi*sxxy+6.*ryy*sxx)*sxi**2)*ursss+((24.*sxx*sxy*syi+4.*sxxx*syi**2)*sxi+3.*sxx**2*syi**2+4.*sxi**3*sxyy+(6.*sxx*syy+12.*sxxy*syi+12.*sxy**2)*sxi**2)*ussss
                                                        uyyyy    = ryi**4*urrrr+4.*ryi**3*syi*urrrs+6.*ryi**2*syi**2*urrss+4.*ryi*syi**3*ursss+syi**4*ussss+6.*ryi**2*ryy*urrr+(6.*ryi**2*syy+12.*ryi*ryy*syi)*urrs+(12.*ryi*syi*syy+6.*ryy*syi**2)*urss+6.*syi**2*syy*usss+(4.*ryi*ryyy+3.*ryy**2)*urr+(4.*ryi*syyy+6.*ryy*syy+4.*ryyy*syi)*urs+(4.*syi*syyy+3.*syy**2)*uss+ryyyy*ur+syyyy*us
                                                        uxxyyyy  = ((12.*rxi*rxyy+6.*rxx*ryy+12.*rxy**2)*syi**2+(12.*sxi*sxyy+6.*sxx*syy+12.*sxxy*syi+12.*sxy**2)*ryi**2+(12.*rxxy*syi**2+(24.*rxi*sxyy+12.*rxx*syy+48.*rxy*sxy+24.*rxyy*sxi+12.*ryy*sxx)*syi+(8.*sxi*syyy+24.*sxy*syy)*rxi+4.*ryyy*sxi**2+(24.*rxy*syy+24.*ryy*sxy)*sxi)*ryi+3.*syy**2*rxi**2+3.*ryy**2*sxi**2+12.*ryy*syy*sxi*rxi+(4.*rxi**2*syyy+(24.*rxy*syy+24.*ryy*sxy+8.*ryyy*sxi)*rxi+24.*rxy*ryy*sxi)*syi)*urrss+((12.*rxi*sxyy+6.*rxx*syy+24.*rxy*sxy+12.*rxyy*sxi+6.*ryy*sxx)*syi**2+4.*rxxy*syi**3+(12.*sxxy*syi**2+(24.*sxi*sxyy+12.*sxx*syy+24.*sxy**2)*syi+4.*sxi**2*syyy+24.*sxy*syy*sxi)*ryi+6.*ryy*syy*sxi**2+6.*syy**2*sxi*rxi+((8.*sxi*syyy+24.*sxy*syy)*rxi+4.*ryyy*sxi**2+(24.*rxy*syy+24.*ryy*sxy)*sxi)*syi)*ursss+((12.*sxi*sxyy+6.*sxx*syy+12.*sxy**2)*syi**2+4.*sxxy*syi**3+3.*syy**2*sxi**2+(4.*sxi**2*syyy+24.*sxi*sxy*syy)*syi)*ussss+(6.*rxxyy*ryi**2+(8.*rxi*rxyyy+4.*rxx*ryyy+12.*rxxy*ryy+24.*rxy*rxyy)*ryi+ryyyy*rxi**2+12.*rxy**2*ryy+3.*rxx*ryy**2+(8.*rxy*ryyy+12.*rxyy*ryy)*rxi)*urrr+(6.*ryi**2*sxxyy+(8.*rxi*sxyyy+4.*rxx*syyy+12.*rxxy*syy+12.*rxxyy*syi+24.*rxy*sxyy+24.*rxyy*sxy+8.*rxyyy*sxi+12.*ryy*sxxy+4.*ryyy*sxx)*ryi+rxi**2*syyyy+12.*rxy**2*syy+(6.*rxx*syy+24.*rxy*sxy)*ryy+(8.*rxy*ryyy+12.*rxyy*ryy)*sxi+3.*ryy**2*sxx+(8.*rxy*syyy+12.*rxyy*syy+12.*ryy*sxyy+8.*ryyy*sxy+2.*ryyyy*sxi)*rxi+(8.*rxi*rxyyy+4.*rxx*ryyy+12.*rxxy*ryy+24.*rxy*rxyy)*syi)*urrs+(6.*rxxyy*syi**2+(8.*sxi*sxyyy+4.*sxx*syyy+12.*sxxy*syy+12.*sxxyy*syi+24.*sxy*sxyy)*ryi+24.*rxy*sxy*syy+(6.*sxx*syy+12.*sxy**2)*ryy+3.*rxx*syy**2+(8.*rxy*syyy+12.*rxyy*syy+12.*ryy*sxyy+8.*ryyy*sxy)*sxi+ryyyy*sxi**2+(2.*sxi*syyyy+8.*sxy*syyy+12.*sxyy*syy)*rxi+(8.*rxi*sxyyy+4.*rxx*syyy+12.*rxxy*syy+24.*rxy*sxyy+24.*rxyy*sxy+8.*rxyyy*sxi+12.*ryy*sxxy+4.*ryyy*sxx)*syi)*urss+(6.*sxxyy*syi**2+12.*sxy**2*syy+3.*sxx*syy**2+(8.*sxy*syyy+12.*sxyy*syy)*sxi+sxi**2*syyyy+(8.*sxi*sxyyy+4.*sxx*syyy+12.*sxxy*syy+24.*sxy*sxyy)*syi)*usss+(2.*rxi*rxyyyy+rxx*ryyyy+4.*rxxy*ryyy+6.*rxxyy*ryy+4.*rxxyyy*ryi+8.*rxy*rxyyy+6.*rxyy**2)*urr+(2.*rxi*sxyyyy+rxx*syyyy+4.*rxxy*syyy+6.*rxxyy*syy+4.*rxxyyy*syi+8.*rxy*sxyyy+12.*rxyy*sxyy+8.*rxyyy*sxy+2.*rxyyyy*sxi+4.*ryi*sxxyyy+6.*ryy*sxxyy+4.*ryyy*sxxy+ryyyy*sxx)*urs+(2.*sxi*sxyyyy+sxx*syyyy+4.*sxxy*syyy+6.*sxxyy*syy+4.*sxxyyy*syi+8.*sxy*sxyyy+6.*sxyy**2)*uss+rxxyyyy*ur+sxxyyyy*us+(4.*rxi**2*ryi**3*syi+2.*rxi*ryi**4*sxi)*urrrrrs+(4.*rxi**2*ryi*syi**3+12.*rxi*ryi**2*sxi*syi**2+4.*ryi**3*sxi**2*syi)*urrrsss+(6.*rxi**2*ryi**2*syi**2+8.*rxi*ryi**3*sxi*syi+ryi**4*sxi**2)*urrrrss+(rxi**2*syi**4+8.*rxi*ryi*sxi*syi**3+6.*ryi**2*sxi**2*syi**2)*urrssss+(2.*rxi*sxi*syi**4+4.*ryi*sxi**2*syi**3)*ursssss+(6.*rxi**2*ryi**2*ryy+8.*rxi*rxy*ryi**3+rxx*ryi**4)*urrrrr+(ryi**4*sxx+12.*ryy*rxi**2*syi*ryi+(8.*rxi*sxy+4.*rxx*syi+8.*rxy*sxi)*ryi**3+(6.*rxi**2*syy+24.*rxi*rxy*syi+12.*rxi*ryy*sxi)*ryi**2)*urrrrs+((24.*rxy*rxi*syi**2+(12.*rxi**2*syy+24.*rxi*ryy*sxi)*syi)*ryi+(8.*sxi*sxy+4.*sxx*syi)*ryi**3+(6.*rxx*syi**2+(24.*rxi*sxy+24.*rxy*sxi)*syi+12.*sxi*syy*rxi+6.*ryy*sxi**2)*ryi**2+6.*ryy*rxi**2*syi**2)*urrrss+((4.*rxx*syi**3+(24.*rxi*sxy+24.*rxy*sxi)*syi**2+(24.*rxi*sxi*syy+12.*ryy*sxi**2)*syi)*ryi+(6.*sxi**2*syy+24.*sxi*sxy*syi+6.*sxx*syi**2)*ryi**2+(6.*rxi**2*syy+12.*rxi*ryy*sxi)*syi**2+8.*rxy*rxi*syi**3)*urrsss+((12.*sxi**2*syi*syy+24.*sxi*sxy*syi**2+4.*sxx*syi**3)*ryi+(12.*rxi*sxi*syy+6.*ryy*sxi**2)*syi**2+(8.*rxi*sxy+8.*rxy*sxi)*syi**3+rxx*syi**4)*urssss+(6.*sxi**2*syi**2*syy+8.*sxi*sxy*syi**3+sxx*syi**4)*usssss+((12.*rxi*rxyy+6.*rxx*ryy+12.*rxy**2)*ryi**2+(4.*rxi**2*ryyy+24.*rxi*rxy*ryy)*ryi+4.*rxxy*ryi**3+3.*ryy**2*rxi**2)*urrrr+(4.*ryi**3*sxxy+(12.*rxi*sxyy+6.*rxx*syy+12.*rxxy*syi+24.*rxy*sxy+12.*rxyy*sxi+6.*ryy*sxx)*ryi**2+((24.*rxi*rxyy+12.*rxx*ryy+24.*rxy**2)*syi+4.*rxi**2*syyy+(24.*rxy*syy+24.*ryy*sxy+8.*ryyy*sxi)*rxi+24.*rxy*ryy*sxi)*ryi+6.*ryy*syy*rxi**2+6.*ryy**2*sxi*rxi+(4.*rxi**2*ryyy+24.*rxi*rxy*ryy)*syi)*urrrs+rxi**2*ryi**4*urrrrrr+sxi**2*syi**4*ussssss
                                                        uyyyyyy  = ryi**6*urrrrrr+syi**6*ussssss+(15.*ryi**4*syy+60.*ryi**3*ryy*syi)*urrrrs+(60.*ryi**3*syi*syy+90.*ryi**2*ryy*syi**2)*urrrss+(90.*ryi**2*syi**2*syy+60.*ryi*ryy*syi**3)*urrsss+(60.*ryi*syi**3*syy+15.*ryy*syi**4)*urssss+(20.*ryi**3*ryyy+45.*ryi**2*ryy**2)*urrrr+(20.*ryi**3*syyy+(90.*ryy*syy+60.*ryyy*syi)*ryi**2+90.*ryy**2*syi*ryi)*urrrs+((60.*syi*syyy+45.*syy**2)*ryi**2+(180.*ryy*syi*syy+60.*ryyy*syi**2)*ryi+45.*ryy**2*syi**2)*urrss+((60.*syi**2*syyy+90.*syi*syy**2)*ryi+20.*ryyy*syi**3+90.*ryy*syy*syi**2)*ursss+(20.*syi**3*syyy+45.*syi**2*syy**2)*ussss+(15.*ryi**2*ryyyy+60.*ryi*ryy*ryyy+15.*ryy**3)*urrr+(15.*ryi**2*syyyy+(60.*ryy*syyy+60.*ryyy*syy+30.*ryyyy*syi)*ryi+60.*ryyy*ryy*syi+45.*syy*ryy**2)*urrs+((30.*syi*syyyy+60.*syy*syyy)*ryi+15.*ryyyy*syi**2+(60.*ryy*syyy+60.*ryyy*syy)*syi+45.*syy**2*ryy)*urss+(15.*syi**2*syyyy+60.*syi*syy*syyy+15.*syy**3)*usss+(6.*ryi*ryyyyy+15.*ryy*ryyyy+10.*ryyy**2)*urr+(6.*ryi*syyyyy+15.*ryy*syyyy+20.*ryyy*syyy+15.*ryyyy*syy+6.*ryyyyy*syi)*urs+(6.*syi*syyyyy+15.*syy*syyyy+10.*syyy**2)*uss+ryyyyyy*ur+syyyyyy*us+6.*syi*ryi**5*urrrrrs+15.*ryi**4*syi**2*urrrrss+20.*ryi**3*syi**3*urrrsss+15.*ryi**2*syi**4*urrssss+6.*ryi*syi**5*ursssss+15.*ryi**4*ryy*urrrrr+15.*syi**4*syy*usssss
                            ! ---------- END CURVILINEAR  ---------
                                                            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
                            ! Scaling for equations so leading terms are undivided differences
                                                        scale1 = (dr(axis)**2/rFactor)**1/c2; 
                                                        scale2 = (dr(axis)**2/rFactor)**2/c4;
                                                        scale3 = (dr(axis)**2/rFactor)**3/c6; 
                            ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
                                                        r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
                                                        r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
                                                        r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3
                            ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: uxx,uxxxx,uxxxxxx=",3(1pe9.2,1x))') i1,i2,uxx,uxxxx,uxxxxxx
                            ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
                            ! Order=6: (see MakeGetDerivativesMacro.maple output)
                            ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
                                                        a3(0,0) = ( (  3./2.) )   ! coeff of u(-1) in c2*( uxx + uyy )*scale1
                                                        a3(0,1) = ( (-3./20.) )   ! coeff of u(-2) 
                                                        a3(0,2) = ( ( 1./90.) )   ! coeff of u(-3)
                            ! Order=4:
                            ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
                                                        a3(1,0) = ( (-13./2.) )
                                                        a3(1,1) = ( (     2.) )
                                                        a3(1,2) = ( ( -1./6.) )
                            ! Order=2
                            ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
                                                        a3(2,0) = ( (    15.) )
                                                        a3(2,1) = ( (    -6.) )
                                                        a3(2,2) = ( (     1.) )
                            ! Find the inverse -- We could save these inverses
                                                        det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
                                                        det=1./det;
                                                        a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
                                                        a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
                                                        a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
                                                        a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
                                                        a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
                                                        a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
                                                        a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
                                                        a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
                                                        a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 
                          !   ! check inverse
                          !   if( .true. )then
                          !     do m1=0,2
                          !       do m2=0,2
                          !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
                          !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
                          !       end do
                          !     end do
                          !   end if
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(2,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                else
                    ! write(*,*) "START OF ASSIGN GHOST CBC order=6"
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                    ! extram = numGhost-1 
                    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
                    ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
                    !----------------------------------------------------------------
                    ! ------ Fill in three ghost by 6th-order compatibility ---------
                    ! ------ Using extrapolated values as initial guesses -----------
                    !----------------------------------------------------------------
                                        uc=0
                                        firstTimeForCBC6 = .true.
                                        f1=0.; f2=0.; f3=0.; 
                                          do i3=n3a,n3b
                                          do i2=n2a,n2b
                                          do i1=n1a,n1b
                                            if( mask(i1,i2,i3).gt.0 )then
                                                ghost=1
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost = 2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost 
                                                ghost = 3
                                                l1=i1-is1*ghost
                                                l2=i2-is2*ghost
                                                l3=i3-is3*ghost       
                        ! --- get the compatibility forcings at order=4 ---
                        ! ** FIX ME ****
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
                                                                    call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
                                                                    call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxx )
                                                                    call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyy )
                                                                    call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyy )
                                                                    call ogDeriv(ep,0,6,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxxxx )
                                                                    call ogDeriv(ep,0,4,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxxyy )
                                                                    call ogDeriv(ep,0,2,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyyyy )
                                                                    call ogDeriv(ep,0,0,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyyyy )
                                                                        call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
                                                                        call ogDeriv(ep,0,2,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzz )
                                                                        call ogDeriv(ep,0,0,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzz )
                                                                        call ogDeriv(ep,0,0,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzz )
                                                                        call ogDeriv(ep,0,4,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxxzz )
                                                                        call ogDeriv(ep,0,2,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzzzz )
                                                                        call ogDeriv(ep,0,0,4,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyyzz )
                                                                        call ogDeriv(ep,0,0,2,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzzzz )
                                                                        call ogDeriv(ep,0,0,0,6,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzzzz )
                                                                        call ogDeriv(ep,0,2,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyyzz )
                                                                f1 = -c2*( uexx + ueyy + uezz )
                                                                f2 = -c4*( uexxxx + ueyyyy + uezzzz + 2.*(uexxyy + uexxzz + ueyyzz) )
                                                                f3 = -c6*(       uexxxxxx + ueyyyyyy + uezzzzzz + 3.*( uexxxxyy + uexxyyyy + uexxxxzz + uexxzzzz + ueyyyyzz + ueyyzzzz) + 6.*( uexxyyzz ) )
                                                        else
                              ! Fix me for standard forcings 
                                                            f1=0.; f2=0.; f3=0.;
                                                        end if
                        ! u_tt = c^2*Lap(u) + f 
                        ! u_tttt = c^2*Lap(u_tt) + f_tt 
                        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
                        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
                        ! First evaluate the derivatives using the wrong values at the ghost
                        !     uxx     : 6th order
                        !     uxxxx   : 4th order
                        !     uxxxxxx : 2nd order
                          ! -- 3D ---
                          ! This next seems broken: 
                          ! getSixthDerivatives3d(6,curvilinear,OPTION,i1,i2,i3)
                                                    stop 6363
                                                f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
                                                f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
                                                f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
                        ! end if
                        ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                        ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                        ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)
                                                uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
                                                uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
                                                uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      
                        ! if( .true. )then
                        !   getTZ(3,0,0,0,0,j1,j2,j3,t,uc,ue1 )
                        !   getTZ(3,0,0,0,0,k1,k2,k3,t,uc,ue2 )
                        !   getTZ(3,0,0,0,0,l1,l2,l3,t,uc,ue3 )
                        !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
                        ! end if
                        ! if( numGhost.gt.3 )then
                        !   ! extrap an extra ghost for upwinding 
                        !   ghost = 4
                        !   j1=i1-is1*ghost
                        !   j2=i2-is2*ghost
                        !   j3=i3-is3*ghost 
                        !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                        ! end if
                                            end if ! mask .gt. 0
                                          end do
                                          end do
                                          end do
                      ! ------ fill in ghost values from uTemp ----
                                        if( .true. )then
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost         
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost   
                            ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
                            ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
                                                        u(j1,j2,j3,uc) = (7.*u(j1+is1,j2+is2,j3+is3,uc)-21.*u(j1+is1+is1,j2+is2+is2,j3+is3+is3,uc)+35.*u(j1+is1+2*is1,j2+is2+2*is2,j3+is3+2*is3,uc)-35.*u(j1+is1+3*is1,j2+is2+3*is2,j3+is3+3*is3,uc)+21.*u(j1+is1+4*is1,j2+is2+4*is2,j3+is3+4*is3,uc)-7.*u(j1+is1+5*is1,j2+is2+5*is2,j3+is3+5*is3,uc)+u(j1+is1+6*is1,j2+is2+6*is2,j3+is3+6*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(7.*u(i1,i2,i3,uc)-21.*u(i1+is1,i2+is2,i3+is3,uc)+35.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-35.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+21.*u(i1+4*is1,i2+4*is2,i3+4*is3,uc)-7.*u(i1+5*is1,i2+5*is2,i3+5*is3,uc)+u(i1+6*is1,i2+6*is2,i3+6*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(7.*u(j1,j2,j3,uc)-21.*u(j1+is1,j2+is2,j3+is3,uc)+35.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-35.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+21.*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-7.*u(j1+5*is1,j2+5*is2,j3+5*is3,uc)+u(j1+6*is1,j2+6*is2,j3+6*is3,uc))
                                                    ghost = 3
                                                    l1=i1-is1*ghost
                                                    l2=i2-is2*ghost
                                                    l3=i3-is3*ghost           
                                                    u(l1,l2,l3,uc)=(7.*u(k1,k2,k3,uc)-21.*u(k1+is1,k2+is2,k3+is3,uc)+35.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-35.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+21.*u(k1+4*is1,k2+4*is2,k3+4*is3,uc)-7.*u(k1+5*is1,k2+5*is2,k3+5*is3,uc)+u(k1+6*is1,k2+6*is2,k3+6*is3,uc))            
                                                    if( numGhost.gt.3 )then
                            !  extrap 4th ghost (UPW)
                                                        ghost = 4
                                                        j1=i1-is1*ghost
                                                        j2=i2-is2*ghost
                                                        j3=i3-is3*ghost           
                                                        u(j1,j2,j3,uc)=(7.*u(l1,l2,l3,uc)-21.*u(l1+is1,l2+is2,l3+is3,uc)+35.*u(l1+2*is1,l2+2*is2,l3+2*is3,uc)-35.*u(l1+3*is1,l2+3*is2,l3+3*is3,uc)+21.*u(l1+4*is1,l2+4*is2,l3+4*is3,uc)-7.*u(l1+5*is1,l2+5*is2,l3+5*is3,uc)+u(l1+6*is1,l2+6*is2,l3+6*is3,uc))            
                                                    end if        
                                                end if    
                                              end do
                                              end do
                                              end do
                                        end if
                    ! write(*,*) "CBC6 stop here for now"
                    ! stop 6666  
                                end if
                            end if     
                        end if    

            else if( orderOfAccuracy.eq.8 )then   
                stop 888
            else

                write(*,'("CgWave::bcOpt:ERROR:Dirichlet CBC unexpected orderOfAccuracy=",i6)') orderOfAccuracy
                stop 8888

            end if

        else if( boundaryCondition(side,axis).eq.neumann )then

      ! ------ NEUMANN ----------
            if( bcApproach.eq.useCompatibilityBoundaryConditions )then
                if( orderOfAccuracy.eq.2 )then

                        if( forcingOption.eq.noForcing )then
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                            ! No forcing, do nothing 
                          ! --- NEUMANN 2=2 rectangular ---
                          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*gg 
                          !  *check me* 
                                                    b0 = -2.*dxn*a0/a1 
                                                    b1 =  2.*dxn/a1 
                                                    u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+    u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*gg
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                            ! No forcing, do nothing 
                          ! --- NEUMANN 2=2 rectangular ---
                          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*gg 
                          !  *check me* 
                                                    b0 = -2.*dxn*a0/a1 
                                                    b1 =  2.*dxn/a1 
                                                    u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+    u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*gg
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                end if
                            else
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                          ! compute the outward normal (an1,an2,an3)
                                                            an1 = rsxy(i1,i2,i3,axis,0)
                                                            an2 = rsxy(i1,i2,i3,axis,1)
                                                            if( nd.eq.2 )then
                                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                            else
                                                              an3 = rsxy(i1,i2,i3,axis,2)
                                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                              an3=an3*aNormi
                                                            end if
                            ! No forcing, do nothing 
                          ! ------ curvilinear grid: -------
                          ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                          ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                          ! =>
                          !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                          ! ----- NEUMANN 2=2 curvilinear ----
                          ! ur = ( u(i+1) - u(i-1) )/2*dr
                          ! ur = ur0 -> 
                          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                                    urv(0) = ur2(i1,i2,i3,uc)
                                                    urv(1) = us2(i1,i2,i3,uc)
                                                        t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                                        t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
                                                        ur0 = (gg - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                                    u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                          ! compute the outward normal (an1,an2,an3)
                                                            an1 = rsxy(i1,i2,i3,axis,0)
                                                            an2 = rsxy(i1,i2,i3,axis,1)
                                                            if( nd.eq.2 )then
                                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                            else
                                                              an3 = rsxy(i1,i2,i3,axis,2)
                                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                              an3=an3*aNormi
                                                            end if
                            ! No forcing, do nothing 
                          ! ------ curvilinear grid: -------
                          ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                          ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                          ! =>
                          !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                          ! ----- NEUMANN 2=2 curvilinear ----
                          ! ur = ( u(i+1) - u(i-1) )/2*dr
                          ! ur = ur0 -> 
                          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                                    urv(0) = ur2(i1,i2,i3,uc)
                                                    urv(1) = us2(i1,i2,i3,uc)
                                                        urv(2) = ut2(i1,i2,i3,uc)
                                                        t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                                        t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                                        t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                                      ur0 = ( gg - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                                    u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                end if
                            end if 
                        else
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex )
                                                                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
                                                                gg = an1*uex + an2*uey
                                                        else
                                                            gg=0.;  gtt=0.; nDotGradF=0.; 
                                                        end if
                          ! --- NEUMANN 2=2 rectangular ---
                          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*gg 
                          !  *check me* 
                                                    b0 = -2.*dxn*a0/a1 
                                                    b1 =  2.*dxn/a1 
                                                    u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+    u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*gg
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                ! ----- 3D  -----
                                                                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex )
                                                                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey )
                                                                call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez )
                                                                gg = an1*uex + an2*uey + an3*uez
                                                        else
                                                            gg=0.;  gtt=0.; nDotGradF=0.; 
                                                        end if
                          ! --- NEUMANN 2=2 rectangular ---
                          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*gg 
                          !  *check me* 
                                                    b0 = -2.*dxn*a0/a1 
                                                    b1 =  2.*dxn/a1 
                                                    u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+    u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*gg
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                end if
                            else
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                          ! compute the outward normal (an1,an2,an3)
                                                            an1 = rsxy(i1,i2,i3,axis,0)
                                                            an2 = rsxy(i1,i2,i3,axis,1)
                                                            if( nd.eq.2 )then
                                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                            else
                                                              an3 = rsxy(i1,i2,i3,axis,2)
                                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                              an3=an3*aNormi
                                                            end if
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                                                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex )
                                                                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
                                                                gg = an1*uex + an2*uey
                                                        else
                                                            gg=0.;  gtt=0.; nDotGradF=0.; 
                                                        end if
                          ! ------ curvilinear grid: -------
                          ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                          ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                          ! =>
                          !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                          ! ----- NEUMANN 2=2 curvilinear ----
                          ! ur = ( u(i+1) - u(i-1) )/2*dr
                          ! ur = ur0 -> 
                          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                                    urv(0) = ur2(i1,i2,i3,uc)
                                                    urv(1) = us2(i1,i2,i3,uc)
                                                        t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                                        t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
                                                        ur0 = (gg - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                                    u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                                            m1a=gridIndexRange(0,0)-extram
                                            m1b=gridIndexRange(1,0)+extram
                                            m2a=gridIndexRange(0,1)-extram
                                            m2b=gridIndexRange(1,1)+extram
                                            if( nd.eq.2 )then
                                                m3a=gridIndexRange(0,2)
                                                m3b=gridIndexRange(1,2)
                                            else
                                                m3a=gridIndexRange(0,2)-extram
                                                m3b=gridIndexRange(1,2)+extram
                                            end if
                                            if( axis.eq.0 )then
                                              m1a=gridIndexRange(side,axis)
                                              m1b=gridIndexRange(side,axis)
                                            else if( axis.eq.1 )then
                                              m2a=gridIndexRange(side,axis)
                                              m2b=gridIndexRange(side,axis)
                                            else
                                              m3a=gridIndexRange(side,axis)
                                              m3b=gridIndexRange(side,axis)
                                            end if
                                        gg=0.; nDotGradF=0.; gtt=0.; 
                                        do i3=m3a,m3b
                                        do i2=m2a,m2b
                                        do i1=m1a,m1b
                      ! first ghost pt:
                                            j1=i1-is1
                                            j2=i2-is2
                                            j3=i3-is3
                                            if( mask(i1,i2,i3).gt.0 )then
                          ! compute the outward normal (an1,an2,an3)
                                                            an1 = rsxy(i1,i2,i3,axis,0)
                                                            an2 = rsxy(i1,i2,i3,axis,1)
                                                            if( nd.eq.2 )then
                                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                            else
                                                              an3 = rsxy(i1,i2,i3,axis,2)
                                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                              an1=an1*aNormi
                                                              an2=an2*aNormi
                                                              an3=an3*aNormi
                                                            end if
                                                        if( assignTwilightZone.eq.1 )then
                              ! compute RHS from TZ
                                ! ----- 3D  -----
                                                                call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex )
                                                                call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey )
                                                                call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez )
                                                                gg = an1*uex + an2*uey + an3*uez
                                                        else
                                                            gg=0.;  gtt=0.; nDotGradF=0.; 
                                                        end if
                          ! ------ curvilinear grid: -------
                          ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                          ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                          ! =>
                          !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                          ! ----- NEUMANN 2=2 curvilinear ----
                          ! ur = ( u(i+1) - u(i-1) )/2*dr
                          ! ur = ur0 -> 
                          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                                    urv(0) = ur2(i1,i2,i3,uc)
                                                    urv(1) = us2(i1,i2,i3,uc)
                                                        urv(2) = ut2(i1,i2,i3,uc)
                                                        t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                                        t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                                        t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                                      ur0 = ( gg - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                                    u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                          ! ----- Assign extra ghost ----
                                                    if( numGhost.gt.1 )then
                                                        ghost =2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost   
                            ! extrap second ghost (UPW)
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                                    end if
                                            else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                                    if( numGhost.gt.1 )then
                            ! extrap second ghost (UPW)
                                                        ghost = 2
                                                        k1=i1-is1*ghost
                                                        k2=i2-is2*ghost
                                                        k3=i3-is3*ghost              
                                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                                    end if
                                            end if
                                          end do
                                          end do
                                          end do
                                end if
                            end if     
                        end if

                else if( orderOfAccuracy.eq.4 )then

                        if( forcingOption.eq.noForcing )then
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                              ! No forcing, do nothing 
                            ! ---------- RECTANGULAR  ---------
                                                        uxxx = uxxx22r(i1,i2,i3,0)
                                                        uxxy = uxxy22r(i1,i2,i3,0)
                                                        uxyy = uxyy22r(i1,i2,i3,0)
                                                        uyyy = uyyy22r(i1,i2,i3,0)
                            ! --- NEUMANN 4=4 rectangular ---
                            ! u_tt = c^2*Lap(u) + f 
                            !   u.n = g
                            ! g_tt = c^2 n.grad( Lap(u) ) + n.grad(f)
                            ! ux = [ u(-2) - 8*u(-1) + 8*u(1) - u(2) ]/(12*h) 
                            ! uxxx = (-u(-1) +2*u(-1) - 2*u(1) + u(2) ]/(2*h^3)
                              ! eval equation with wrong values at ghost: 
                                                            r1 =  an1*ux42r(i1,i2,i3,0) + an2*uy42r(i1,i2,i3,0) - gg
                              ! note: an1=-1 on left side ans an1=+1 on right side
                              ! **CHECK ME**
                                                            a11 =  8./(12.*dx(axis))  ! coeff of u(-1)
                                                            a12 = -1./(12.*dx(axis))  ! coeff of u(-2)
                                                            r2 = c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) + nDotGradF - gtt
                              ! **CHECK ME**
                                                            a21 = -c2*( 2./(2.*dx(axis)**3) )
                                                            a22 =  c2*( 1./(2.*dx(axis)**3) )
                              ! define the residual functions for the discrete delta method
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx22r(i1,i2,i3,0)
                                                                    uxxy = uxxy22r(i1,i2,i3,0)
                                                                    uxyy = uxyy22r(i1,i2,i3,0)
                                                                    uyyy = uyyy22r(i1,i2,i3,0)
                                                                    r1a = (an1*ux42r(i1,i2,i3,0)+an2*uy42r(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx22r(i1,i2,i3,0)
                                                                    uxxy = uxxy22r(i1,i2,i3,0)
                                                                    uxyy = uxyy22r(i1,i2,i3,0)
                                                                    uyyy = uyyy22r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux42r(i1,i2,i3,0)+an2*uy42r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx22r(i1,i2,i3,0)
                                                                    uxxy = uxxy22r(i1,i2,i3,0)
                                                                    uxyy = uxyy22r(i1,i2,i3,0)
                                                                    uyyy = uyyy22r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux42r(i1,i2,i3,0)+an2*uy42r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "rectangular" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," rectangular 4")') t,side,axis,maxDiff
                                            end if
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                              ! No forcing, do nothing 
                            ! evaluate 3rd derivatives : uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 
                            ! ---------- RECTANGULAR  ---------
                                                        uxxx = uxxx23r(i1,i2,i3,0)
                                                        uxxy = uxxy23r(i1,i2,i3,0)
                                                        uxxz = uxxz23r(i1,i2,i3,0)
                                                        uxyy = uxyy23r(i1,i2,i3,0)
                                                        uxzz = uxzz23r(i1,i2,i3,0)
                                                        uyyy = uyyy23r(i1,i2,i3,0)
                                                        uyyz = uyyz23r(i1,i2,i3,0)
                                                        uyzz = uyzz23r(i1,i2,i3,0)
                                                        uzzz = uzzz23r(i1,i2,i3,0)
                            ! --- NEUMANN 4=4 rectangular ---
                            ! u_tt = c^2*Lap(u) + f 
                            !   u.n = g
                            ! g_tt = c^2 n.grad( Lap(u) ) + n.grad(f)
                            ! ux = [ u(-2) - 8*u(-1) + 8*u(1) - u(2) ]/(12*h) 
                            ! uxxx = (-u(-1) +2*u(-1) - 2*u(1) + u(2) ]/(2*h^3)
                              ! 3D 
                                                            r1 =  an1*ux43r(i1,i2,i3,0) + an2*uy43r(i1,i2,i3,0) + an3*uz43r(i1,i2,i3,0) - gg
                              ! **CHECK ME**
                                                            a11 =  8./(12.*dx(axis))  ! coeff of u(-1)
                                                            a12 = -1./(12.*dx(axis))  ! coeff of u(-2)  
                                                            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt
                              ! **CHECK ME**
                                                            a21 = -c2*( 2./(2.*dx(axis)**3) )
                                                            a22 =  c2*( 1./(2.*dx(axis)**3) )
                              ! define the residual functions for the discrete delta method
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx23r(i1,i2,i3,0)
                                                                    uxxy = uxxy23r(i1,i2,i3,0)
                                                                    uxxz = uxxz23r(i1,i2,i3,0)
                                                                    uxyy = uxyy23r(i1,i2,i3,0)
                                                                    uxzz = uxzz23r(i1,i2,i3,0)
                                                                    uyyy = uyyy23r(i1,i2,i3,0)
                                                                    uyyz = uyyz23r(i1,i2,i3,0)
                                                                    uyzz = uyzz23r(i1,i2,i3,0)
                                                                    uzzz = uzzz23r(i1,i2,i3,0)
                                                                    r1a = (an1*ux43r(i1,i2,i3,0)+an2*uy43r(i1,i2,i3,0)+an3*uz43r(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx23r(i1,i2,i3,0)
                                                                    uxxy = uxxy23r(i1,i2,i3,0)
                                                                    uxxz = uxxz23r(i1,i2,i3,0)
                                                                    uxyy = uxyy23r(i1,i2,i3,0)
                                                                    uxzz = uxzz23r(i1,i2,i3,0)
                                                                    uyyy = uyyy23r(i1,i2,i3,0)
                                                                    uyyz = uyyz23r(i1,i2,i3,0)
                                                                    uyzz = uyzz23r(i1,i2,i3,0)
                                                                    uzzz = uzzz23r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux43r(i1,i2,i3,0)+an2*uy43r(i1,i2,i3,0)+an3*uz43r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx23r(i1,i2,i3,0)
                                                                    uxxy = uxxy23r(i1,i2,i3,0)
                                                                    uxxz = uxxz23r(i1,i2,i3,0)
                                                                    uxyy = uxyy23r(i1,i2,i3,0)
                                                                    uxzz = uxzz23r(i1,i2,i3,0)
                                                                    uyyy = uyyy23r(i1,i2,i3,0)
                                                                    uyyz = uyyz23r(i1,i2,i3,0)
                                                                    uyzz = uyzz23r(i1,i2,i3,0)
                                                                    uzzz = uzzz23r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux43r(i1,i2,i3,0)+an2*uy43r(i1,i2,i3,0)+an3*uz43r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "rectangular" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," rectangular 4")') t,side,axis,maxDiff
                                            end if
                                end if
                            else
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                            ! compute the outward normal (an1,an2,an3)
                                                                an1 = rsxy(i1,i2,i3,axis,0)
                                                                an2 = rsxy(i1,i2,i3,axis,1)
                                                                if( nd.eq.2 )then
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                else
                                                                  an3 = rsxy(i1,i2,i3,axis,2)
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                  an3=an3*aNormi
                                                                end if
                              ! No forcing, do nothing 
                            ! ---------- START CURVILINEAR  ---------
                            ! ---------- Parametric derivatives ---------
                                                        ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                        urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                        urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                        us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                        urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                        urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                        uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                        urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                        usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                        rxr    = (rx(i1-2,i2,i3)-8.*rx(i1-1,i2,i3)+8.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0))
                                                        rxrr   = (-rx(i1-2,i2,i3)+16.*rx(i1-1,i2,i3)-30.*rx(i1,i2,i3)+16.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rxs    = (rx(i1,i2-2,i3)-8.*rx(i1,i2-1,i3)+8.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1))
                                                        rxrs   = ((rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))-(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        rxss   = (-rx(i1,i2-2,i3)+16.*rx(i1,i2-1,i3)-30.*rx(i1,i2,i3)+16.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        ryr    = (ry(i1-2,i2,i3)-8.*ry(i1-1,i2,i3)+8.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0))
                                                        ryrr   = (-ry(i1-2,i2,i3)+16.*ry(i1-1,i2,i3)-30.*ry(i1,i2,i3)+16.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rys    = (ry(i1,i2-2,i3)-8.*ry(i1,i2-1,i3)+8.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1))
                                                        ryrs   = ((ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))-8.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))+8.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))-(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        ryss   = (-ry(i1,i2-2,i3)+16.*ry(i1,i2-1,i3)-30.*ry(i1,i2,i3)+16.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        sxr    = (sx(i1-2,i2,i3)-8.*sx(i1-1,i2,i3)+8.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0))
                                                        sxrr   = (-sx(i1-2,i2,i3)+16.*sx(i1-1,i2,i3)-30.*sx(i1,i2,i3)+16.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sxs    = (sx(i1,i2-2,i3)-8.*sx(i1,i2-1,i3)+8.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1))
                                                        sxrs   = ((sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))-(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        sxss   = (-sx(i1,i2-2,i3)+16.*sx(i1,i2-1,i3)-30.*sx(i1,i2,i3)+16.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        syr    = (sy(i1-2,i2,i3)-8.*sy(i1-1,i2,i3)+8.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0))
                                                        syrr   = (-sy(i1-2,i2,i3)+16.*sy(i1-1,i2,i3)-30.*sy(i1,i2,i3)+16.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sys    = (sy(i1,i2-2,i3)-8.*sy(i1,i2-1,i3)+8.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1))
                                                        syrs   = ((sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))-(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        syss   = (-sy(i1,i2-2,i3)+16.*sy(i1,i2-1,i3)-30.*sy(i1,i2,i3)+16.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1)**2)
                            ! ---------- Spatial derivatives of metrics rx, sx, ry, ... ---------
                                                        rxi = rx(i1,i2,i3)
                                                        ryi = ry(i1,i2,i3)
                                                        sxi = sx(i1,i2,i3)
                                                        syi = sy(i1,i2,i3)
                                                        rxx = rxi*rxr+sxi*rxs
                                                        rxxx = rxi**2*rxrr+2.*rxi*sxi*rxrs+sxi**2*rxss+rxx*rxr+sxx*rxs
                                                        rxy = ryi*rxr+syi*rxs
                                                        rxxy = ryi*rxi*rxrr+(rxi*syi+ryi*sxi)*rxrs+syi*sxi*rxss+rxy*rxr+sxy*rxs
                                                        rxyy = ryi**2*rxrr+2.*ryi*syi*rxrs+syi**2*rxss+ryy*rxr+syy*rxs
                                                        ryy = ryi*ryr+syi*rys
                                                        ryyy = ryi**2*ryrr+2.*ryi*syi*ryrs+syi**2*ryss+ryy*ryr+syy*rys
                                                        sxx = rxi*sxr+sxi*sxs
                                                        sxxx = rxi**2*sxrr+2.*rxi*sxi*sxrs+sxi**2*sxss+rxx*sxr+sxx*sxs
                                                        sxy = ryi*sxr+syi*sxs
                                                        sxxy = ryi*rxi*sxrr+(rxi*syi+ryi*sxi)*sxrs+syi*sxi*sxss+rxy*sxr+sxy*sxs
                                                        sxyy = ryi**2*sxrr+2.*ryi*syi*sxrs+syi**2*sxss+ryy*sxr+syy*sxs
                                                        syy = ryi*syr+syi*sys
                                                        syyy = ryi**2*syrr+2.*ryi*syi*syrs+syi**2*syss+ryy*syr+syy*sys
                            ! ---- end evalMetrics eq evalMetrics ---
                            ! ---------- Third spatial derivatives of u ---------
                                                        uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                        uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                        uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                        uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                            ! ---------- END CURVILINEAR  ---------
                            ! ------ curvilinear grid: -------
                              ! eval equation with wrong values at ghost:
                                                            r1 =  an1*ux42(i1,i2,i3,0) + an2*uy42(i1,i2,i3,0) - gg
                                                            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1)
                              ! crv(1) = an1*rsxy(i1,i2,i3,1,0) + an2*rsxy(i1,i2,i3,1,1)
                              ! **CHECK ME**
                                                            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
                                                            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)
                                                            r2 = c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) + nDotGradF - gtt
                  ! uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                  ! uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                  ! uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                  ! uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                              ! uxxx = rxi**3*urrr +3.*rxi*rxx*urr + rxxx*ur
                              ! uxyy = ryi**2*rxi*urrr +(rxi*ryy+2.*rxy*ryi)*urr+rxyy*ur
                              ! uxxy = ryi*rxi**2*urrr +(2.*rxi*rxy+rxx*ryi)*urr+rxxy*ur
                              ! Coeff of terms involving urrr (do not include terms involving urr and ur as these used 2nd-order values)
                                                            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) )*( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )
                              ! if( axis.eq.0 )then
                              !   crv(axis) = (an1*rxi + an2*ryi )*( rxi**2 + ryi**2 )
                              !   ! crv(axis) = an1*( rxi**3 + ryi**2*rxi ) + !   !             an2*( ryi**3 + ryi*rxi**2 )
                              ! else
                              !   crv(axis) = (an1*sxi + an2*syi )*( sxi**2 + syi**2 )
                              !   ! crv(axis) = an1*( sxi**3 + syi**2*sxi ) + !   !             an2*( syi**3 + syi*sxi**2 )              
                              ! end if
                              ! crv(1) = an1*rsxy(i1,i2,i3,1,0)**3 + an2*rsxy(i1,i2,i3,1,1)**3
                              ! **CHECK ME**
                                                            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
                                                            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1a = (an1*ux42(i1,i2,i3,0)+an2*uy42(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux42(i1,i2,i3,0)+an2*uy42(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux42(i1,i2,i3,0)+an2*uy42(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "curvilinear" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," curvilinear 4")') t,side,axis,maxDiff
                                            end if
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                            ! compute the outward normal (an1,an2,an3)
                                                                an1 = rsxy(i1,i2,i3,axis,0)
                                                                an2 = rsxy(i1,i2,i3,axis,1)
                                                                if( nd.eq.2 )then
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                else
                                                                  an3 = rsxy(i1,i2,i3,axis,2)
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                  an3=an3*aNormi
                                                                end if
                              ! No forcing, do nothing 
                            ! evaluate 3rd derivatives : uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 
                            ! ---------- START CURVILINEAR  ---------
                            ! ---------- Parametric derivatives ---------
                                                        ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                        urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                        urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                        us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                        urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                        urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                        uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                        urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                        usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                        ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                        urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                        urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                        ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                        urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                        usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                        utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                        urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                        ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                        uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                                        rxr    = (rx(i1-2,i2,i3)-8.*rx(i1-1,i2,i3)+8.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0))
                                                        rxrr   = (-rx(i1-2,i2,i3)+16.*rx(i1-1,i2,i3)-30.*rx(i1,i2,i3)+16.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rxs    = (rx(i1,i2-2,i3)-8.*rx(i1,i2-1,i3)+8.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1))
                                                        rxrs   = ((rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))-(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        rxss   = (-rx(i1,i2-2,i3)+16.*rx(i1,i2-1,i3)-30.*rx(i1,i2,i3)+16.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        rxt    = (rx(i1,i2,i3-2)-8.*rx(i1,i2,i3-1)+8.*rx(i1,i2,i3+1)-rx(i1,i2,i3+2))/(12.*dr(2))
                                                        rxrt   = ((rx(i1-2,i2,i3-2)-8.*rx(i1-2,i2,i3-1)+8.*rx(i1-2,i2,i3+1)-rx(i1-2,i2,i3+2))/(12.*dr(2))-8.*(rx(i1-1,i2,i3-2)-8.*rx(i1-1,i2,i3-1)+8.*rx(i1-1,i2,i3+1)-rx(i1-1,i2,i3+2))/(12.*dr(2))+8.*(rx(i1+1,i2,i3-2)-8.*rx(i1+1,i2,i3-1)+8.*rx(i1+1,i2,i3+1)-rx(i1+1,i2,i3+2))/(12.*dr(2))-(rx(i1+2,i2,i3-2)-8.*rx(i1+2,i2,i3-1)+8.*rx(i1+2,i2,i3+1)-rx(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        rxst   = ((rx(i1,i2-2,i3-2)-8.*rx(i1,i2-2,i3-1)+8.*rx(i1,i2-2,i3+1)-rx(i1,i2-2,i3+2))/(12.*dr(2))-8.*(rx(i1,i2-1,i3-2)-8.*rx(i1,i2-1,i3-1)+8.*rx(i1,i2-1,i3+1)-rx(i1,i2-1,i3+2))/(12.*dr(2))+8.*(rx(i1,i2+1,i3-2)-8.*rx(i1,i2+1,i3-1)+8.*rx(i1,i2+1,i3+1)-rx(i1,i2+1,i3+2))/(12.*dr(2))-(rx(i1,i2+2,i3-2)-8.*rx(i1,i2+2,i3-1)+8.*rx(i1,i2+2,i3+1)-rx(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        rxtt   = (-rx(i1,i2,i3-2)+16.*rx(i1,i2,i3-1)-30.*rx(i1,i2,i3)+16.*rx(i1,i2,i3+1)-rx(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        ryr    = (ry(i1-2,i2,i3)-8.*ry(i1-1,i2,i3)+8.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0))
                                                        ryrr   = (-ry(i1-2,i2,i3)+16.*ry(i1-1,i2,i3)-30.*ry(i1,i2,i3)+16.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rys    = (ry(i1,i2-2,i3)-8.*ry(i1,i2-1,i3)+8.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1))
                                                        ryrs   = ((ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))-8.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))+8.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))-(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        ryss   = (-ry(i1,i2-2,i3)+16.*ry(i1,i2-1,i3)-30.*ry(i1,i2,i3)+16.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        ryt    = (ry(i1,i2,i3-2)-8.*ry(i1,i2,i3-1)+8.*ry(i1,i2,i3+1)-ry(i1,i2,i3+2))/(12.*dr(2))
                                                        ryrt   = ((ry(i1-2,i2,i3-2)-8.*ry(i1-2,i2,i3-1)+8.*ry(i1-2,i2,i3+1)-ry(i1-2,i2,i3+2))/(12.*dr(2))-8.*(ry(i1-1,i2,i3-2)-8.*ry(i1-1,i2,i3-1)+8.*ry(i1-1,i2,i3+1)-ry(i1-1,i2,i3+2))/(12.*dr(2))+8.*(ry(i1+1,i2,i3-2)-8.*ry(i1+1,i2,i3-1)+8.*ry(i1+1,i2,i3+1)-ry(i1+1,i2,i3+2))/(12.*dr(2))-(ry(i1+2,i2,i3-2)-8.*ry(i1+2,i2,i3-1)+8.*ry(i1+2,i2,i3+1)-ry(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        ryst   = ((ry(i1,i2-2,i3-2)-8.*ry(i1,i2-2,i3-1)+8.*ry(i1,i2-2,i3+1)-ry(i1,i2-2,i3+2))/(12.*dr(2))-8.*(ry(i1,i2-1,i3-2)-8.*ry(i1,i2-1,i3-1)+8.*ry(i1,i2-1,i3+1)-ry(i1,i2-1,i3+2))/(12.*dr(2))+8.*(ry(i1,i2+1,i3-2)-8.*ry(i1,i2+1,i3-1)+8.*ry(i1,i2+1,i3+1)-ry(i1,i2+1,i3+2))/(12.*dr(2))-(ry(i1,i2+2,i3-2)-8.*ry(i1,i2+2,i3-1)+8.*ry(i1,i2+2,i3+1)-ry(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        rytt   = (-ry(i1,i2,i3-2)+16.*ry(i1,i2,i3-1)-30.*ry(i1,i2,i3)+16.*ry(i1,i2,i3+1)-ry(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        sxr    = (sx(i1-2,i2,i3)-8.*sx(i1-1,i2,i3)+8.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0))
                                                        sxrr   = (-sx(i1-2,i2,i3)+16.*sx(i1-1,i2,i3)-30.*sx(i1,i2,i3)+16.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sxs    = (sx(i1,i2-2,i3)-8.*sx(i1,i2-1,i3)+8.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1))
                                                        sxrs   = ((sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))-(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        sxss   = (-sx(i1,i2-2,i3)+16.*sx(i1,i2-1,i3)-30.*sx(i1,i2,i3)+16.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        sxt    = (sx(i1,i2,i3-2)-8.*sx(i1,i2,i3-1)+8.*sx(i1,i2,i3+1)-sx(i1,i2,i3+2))/(12.*dr(2))
                                                        sxrt   = ((sx(i1-2,i2,i3-2)-8.*sx(i1-2,i2,i3-1)+8.*sx(i1-2,i2,i3+1)-sx(i1-2,i2,i3+2))/(12.*dr(2))-8.*(sx(i1-1,i2,i3-2)-8.*sx(i1-1,i2,i3-1)+8.*sx(i1-1,i2,i3+1)-sx(i1-1,i2,i3+2))/(12.*dr(2))+8.*(sx(i1+1,i2,i3-2)-8.*sx(i1+1,i2,i3-1)+8.*sx(i1+1,i2,i3+1)-sx(i1+1,i2,i3+2))/(12.*dr(2))-(sx(i1+2,i2,i3-2)-8.*sx(i1+2,i2,i3-1)+8.*sx(i1+2,i2,i3+1)-sx(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        sxst   = ((sx(i1,i2-2,i3-2)-8.*sx(i1,i2-2,i3-1)+8.*sx(i1,i2-2,i3+1)-sx(i1,i2-2,i3+2))/(12.*dr(2))-8.*(sx(i1,i2-1,i3-2)-8.*sx(i1,i2-1,i3-1)+8.*sx(i1,i2-1,i3+1)-sx(i1,i2-1,i3+2))/(12.*dr(2))+8.*(sx(i1,i2+1,i3-2)-8.*sx(i1,i2+1,i3-1)+8.*sx(i1,i2+1,i3+1)-sx(i1,i2+1,i3+2))/(12.*dr(2))-(sx(i1,i2+2,i3-2)-8.*sx(i1,i2+2,i3-1)+8.*sx(i1,i2+2,i3+1)-sx(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        sxtt   = (-sx(i1,i2,i3-2)+16.*sx(i1,i2,i3-1)-30.*sx(i1,i2,i3)+16.*sx(i1,i2,i3+1)-sx(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        syr    = (sy(i1-2,i2,i3)-8.*sy(i1-1,i2,i3)+8.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0))
                                                        syrr   = (-sy(i1-2,i2,i3)+16.*sy(i1-1,i2,i3)-30.*sy(i1,i2,i3)+16.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sys    = (sy(i1,i2-2,i3)-8.*sy(i1,i2-1,i3)+8.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1))
                                                        syrs   = ((sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))-(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        syss   = (-sy(i1,i2-2,i3)+16.*sy(i1,i2-1,i3)-30.*sy(i1,i2,i3)+16.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        syt    = (sy(i1,i2,i3-2)-8.*sy(i1,i2,i3-1)+8.*sy(i1,i2,i3+1)-sy(i1,i2,i3+2))/(12.*dr(2))
                                                        syrt   = ((sy(i1-2,i2,i3-2)-8.*sy(i1-2,i2,i3-1)+8.*sy(i1-2,i2,i3+1)-sy(i1-2,i2,i3+2))/(12.*dr(2))-8.*(sy(i1-1,i2,i3-2)-8.*sy(i1-1,i2,i3-1)+8.*sy(i1-1,i2,i3+1)-sy(i1-1,i2,i3+2))/(12.*dr(2))+8.*(sy(i1+1,i2,i3-2)-8.*sy(i1+1,i2,i3-1)+8.*sy(i1+1,i2,i3+1)-sy(i1+1,i2,i3+2))/(12.*dr(2))-(sy(i1+2,i2,i3-2)-8.*sy(i1+2,i2,i3-1)+8.*sy(i1+2,i2,i3+1)-sy(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        syst   = ((sy(i1,i2-2,i3-2)-8.*sy(i1,i2-2,i3-1)+8.*sy(i1,i2-2,i3+1)-sy(i1,i2-2,i3+2))/(12.*dr(2))-8.*(sy(i1,i2-1,i3-2)-8.*sy(i1,i2-1,i3-1)+8.*sy(i1,i2-1,i3+1)-sy(i1,i2-1,i3+2))/(12.*dr(2))+8.*(sy(i1,i2+1,i3-2)-8.*sy(i1,i2+1,i3-1)+8.*sy(i1,i2+1,i3+1)-sy(i1,i2+1,i3+2))/(12.*dr(2))-(sy(i1,i2+2,i3-2)-8.*sy(i1,i2+2,i3-1)+8.*sy(i1,i2+2,i3+1)-sy(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        sytt   = (-sy(i1,i2,i3-2)+16.*sy(i1,i2,i3-1)-30.*sy(i1,i2,i3)+16.*sy(i1,i2,i3+1)-sy(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        rzr    = (rz(i1-2,i2,i3)-8.*rz(i1-1,i2,i3)+8.*rz(i1+1,i2,i3)-rz(i1+2,i2,i3))/(12.*dr(0))
                                                        rzrr   = (-rz(i1-2,i2,i3)+16.*rz(i1-1,i2,i3)-30.*rz(i1,i2,i3)+16.*rz(i1+1,i2,i3)-rz(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rzs    = (rz(i1,i2-2,i3)-8.*rz(i1,i2-1,i3)+8.*rz(i1,i2+1,i3)-rz(i1,i2+2,i3))/(12.*dr(1))
                                                        rzrs   = ((rz(i1-2,i2-2,i3)-8.*rz(i1-2,i2-1,i3)+8.*rz(i1-2,i2+1,i3)-rz(i1-2,i2+2,i3))/(12.*dr(1))-8.*(rz(i1-1,i2-2,i3)-8.*rz(i1-1,i2-1,i3)+8.*rz(i1-1,i2+1,i3)-rz(i1-1,i2+2,i3))/(12.*dr(1))+8.*(rz(i1+1,i2-2,i3)-8.*rz(i1+1,i2-1,i3)+8.*rz(i1+1,i2+1,i3)-rz(i1+1,i2+2,i3))/(12.*dr(1))-(rz(i1+2,i2-2,i3)-8.*rz(i1+2,i2-1,i3)+8.*rz(i1+2,i2+1,i3)-rz(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        rzss   = (-rz(i1,i2-2,i3)+16.*rz(i1,i2-1,i3)-30.*rz(i1,i2,i3)+16.*rz(i1,i2+1,i3)-rz(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        rzt    = (rz(i1,i2,i3-2)-8.*rz(i1,i2,i3-1)+8.*rz(i1,i2,i3+1)-rz(i1,i2,i3+2))/(12.*dr(2))
                                                        rzrt   = ((rz(i1-2,i2,i3-2)-8.*rz(i1-2,i2,i3-1)+8.*rz(i1-2,i2,i3+1)-rz(i1-2,i2,i3+2))/(12.*dr(2))-8.*(rz(i1-1,i2,i3-2)-8.*rz(i1-1,i2,i3-1)+8.*rz(i1-1,i2,i3+1)-rz(i1-1,i2,i3+2))/(12.*dr(2))+8.*(rz(i1+1,i2,i3-2)-8.*rz(i1+1,i2,i3-1)+8.*rz(i1+1,i2,i3+1)-rz(i1+1,i2,i3+2))/(12.*dr(2))-(rz(i1+2,i2,i3-2)-8.*rz(i1+2,i2,i3-1)+8.*rz(i1+2,i2,i3+1)-rz(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        rzst   = ((rz(i1,i2-2,i3-2)-8.*rz(i1,i2-2,i3-1)+8.*rz(i1,i2-2,i3+1)-rz(i1,i2-2,i3+2))/(12.*dr(2))-8.*(rz(i1,i2-1,i3-2)-8.*rz(i1,i2-1,i3-1)+8.*rz(i1,i2-1,i3+1)-rz(i1,i2-1,i3+2))/(12.*dr(2))+8.*(rz(i1,i2+1,i3-2)-8.*rz(i1,i2+1,i3-1)+8.*rz(i1,i2+1,i3+1)-rz(i1,i2+1,i3+2))/(12.*dr(2))-(rz(i1,i2+2,i3-2)-8.*rz(i1,i2+2,i3-1)+8.*rz(i1,i2+2,i3+1)-rz(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        rztt   = (-rz(i1,i2,i3-2)+16.*rz(i1,i2,i3-1)-30.*rz(i1,i2,i3)+16.*rz(i1,i2,i3+1)-rz(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        szr    = (sz(i1-2,i2,i3)-8.*sz(i1-1,i2,i3)+8.*sz(i1+1,i2,i3)-sz(i1+2,i2,i3))/(12.*dr(0))
                                                        szrr   = (-sz(i1-2,i2,i3)+16.*sz(i1-1,i2,i3)-30.*sz(i1,i2,i3)+16.*sz(i1+1,i2,i3)-sz(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        szs    = (sz(i1,i2-2,i3)-8.*sz(i1,i2-1,i3)+8.*sz(i1,i2+1,i3)-sz(i1,i2+2,i3))/(12.*dr(1))
                                                        szrs   = ((sz(i1-2,i2-2,i3)-8.*sz(i1-2,i2-1,i3)+8.*sz(i1-2,i2+1,i3)-sz(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sz(i1-1,i2-2,i3)-8.*sz(i1-1,i2-1,i3)+8.*sz(i1-1,i2+1,i3)-sz(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sz(i1+1,i2-2,i3)-8.*sz(i1+1,i2-1,i3)+8.*sz(i1+1,i2+1,i3)-sz(i1+1,i2+2,i3))/(12.*dr(1))-(sz(i1+2,i2-2,i3)-8.*sz(i1+2,i2-1,i3)+8.*sz(i1+2,i2+1,i3)-sz(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        szss   = (-sz(i1,i2-2,i3)+16.*sz(i1,i2-1,i3)-30.*sz(i1,i2,i3)+16.*sz(i1,i2+1,i3)-sz(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        szt    = (sz(i1,i2,i3-2)-8.*sz(i1,i2,i3-1)+8.*sz(i1,i2,i3+1)-sz(i1,i2,i3+2))/(12.*dr(2))
                                                        szrt   = ((sz(i1-2,i2,i3-2)-8.*sz(i1-2,i2,i3-1)+8.*sz(i1-2,i2,i3+1)-sz(i1-2,i2,i3+2))/(12.*dr(2))-8.*(sz(i1-1,i2,i3-2)-8.*sz(i1-1,i2,i3-1)+8.*sz(i1-1,i2,i3+1)-sz(i1-1,i2,i3+2))/(12.*dr(2))+8.*(sz(i1+1,i2,i3-2)-8.*sz(i1+1,i2,i3-1)+8.*sz(i1+1,i2,i3+1)-sz(i1+1,i2,i3+2))/(12.*dr(2))-(sz(i1+2,i2,i3-2)-8.*sz(i1+2,i2,i3-1)+8.*sz(i1+2,i2,i3+1)-sz(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        szst   = ((sz(i1,i2-2,i3-2)-8.*sz(i1,i2-2,i3-1)+8.*sz(i1,i2-2,i3+1)-sz(i1,i2-2,i3+2))/(12.*dr(2))-8.*(sz(i1,i2-1,i3-2)-8.*sz(i1,i2-1,i3-1)+8.*sz(i1,i2-1,i3+1)-sz(i1,i2-1,i3+2))/(12.*dr(2))+8.*(sz(i1,i2+1,i3-2)-8.*sz(i1,i2+1,i3-1)+8.*sz(i1,i2+1,i3+1)-sz(i1,i2+1,i3+2))/(12.*dr(2))-(sz(i1,i2+2,i3-2)-8.*sz(i1,i2+2,i3-1)+8.*sz(i1,i2+2,i3+1)-sz(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        sztt   = (-sz(i1,i2,i3-2)+16.*sz(i1,i2,i3-1)-30.*sz(i1,i2,i3)+16.*sz(i1,i2,i3+1)-sz(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        txr    = (tx(i1-2,i2,i3)-8.*tx(i1-1,i2,i3)+8.*tx(i1+1,i2,i3)-tx(i1+2,i2,i3))/(12.*dr(0))
                                                        txrr   = (-tx(i1-2,i2,i3)+16.*tx(i1-1,i2,i3)-30.*tx(i1,i2,i3)+16.*tx(i1+1,i2,i3)-tx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        txs    = (tx(i1,i2-2,i3)-8.*tx(i1,i2-1,i3)+8.*tx(i1,i2+1,i3)-tx(i1,i2+2,i3))/(12.*dr(1))
                                                        txrs   = ((tx(i1-2,i2-2,i3)-8.*tx(i1-2,i2-1,i3)+8.*tx(i1-2,i2+1,i3)-tx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(tx(i1-1,i2-2,i3)-8.*tx(i1-1,i2-1,i3)+8.*tx(i1-1,i2+1,i3)-tx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(tx(i1+1,i2-2,i3)-8.*tx(i1+1,i2-1,i3)+8.*tx(i1+1,i2+1,i3)-tx(i1+1,i2+2,i3))/(12.*dr(1))-(tx(i1+2,i2-2,i3)-8.*tx(i1+2,i2-1,i3)+8.*tx(i1+2,i2+1,i3)-tx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        txss   = (-tx(i1,i2-2,i3)+16.*tx(i1,i2-1,i3)-30.*tx(i1,i2,i3)+16.*tx(i1,i2+1,i3)-tx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        txt    = (tx(i1,i2,i3-2)-8.*tx(i1,i2,i3-1)+8.*tx(i1,i2,i3+1)-tx(i1,i2,i3+2))/(12.*dr(2))
                                                        txrt   = ((tx(i1-2,i2,i3-2)-8.*tx(i1-2,i2,i3-1)+8.*tx(i1-2,i2,i3+1)-tx(i1-2,i2,i3+2))/(12.*dr(2))-8.*(tx(i1-1,i2,i3-2)-8.*tx(i1-1,i2,i3-1)+8.*tx(i1-1,i2,i3+1)-tx(i1-1,i2,i3+2))/(12.*dr(2))+8.*(tx(i1+1,i2,i3-2)-8.*tx(i1+1,i2,i3-1)+8.*tx(i1+1,i2,i3+1)-tx(i1+1,i2,i3+2))/(12.*dr(2))-(tx(i1+2,i2,i3-2)-8.*tx(i1+2,i2,i3-1)+8.*tx(i1+2,i2,i3+1)-tx(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        txst   = ((tx(i1,i2-2,i3-2)-8.*tx(i1,i2-2,i3-1)+8.*tx(i1,i2-2,i3+1)-tx(i1,i2-2,i3+2))/(12.*dr(2))-8.*(tx(i1,i2-1,i3-2)-8.*tx(i1,i2-1,i3-1)+8.*tx(i1,i2-1,i3+1)-tx(i1,i2-1,i3+2))/(12.*dr(2))+8.*(tx(i1,i2+1,i3-2)-8.*tx(i1,i2+1,i3-1)+8.*tx(i1,i2+1,i3+1)-tx(i1,i2+1,i3+2))/(12.*dr(2))-(tx(i1,i2+2,i3-2)-8.*tx(i1,i2+2,i3-1)+8.*tx(i1,i2+2,i3+1)-tx(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        txtt   = (-tx(i1,i2,i3-2)+16.*tx(i1,i2,i3-1)-30.*tx(i1,i2,i3)+16.*tx(i1,i2,i3+1)-tx(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        tyr    = (ty(i1-2,i2,i3)-8.*ty(i1-1,i2,i3)+8.*ty(i1+1,i2,i3)-ty(i1+2,i2,i3))/(12.*dr(0))
                                                        tyrr   = (-ty(i1-2,i2,i3)+16.*ty(i1-1,i2,i3)-30.*ty(i1,i2,i3)+16.*ty(i1+1,i2,i3)-ty(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        tys    = (ty(i1,i2-2,i3)-8.*ty(i1,i2-1,i3)+8.*ty(i1,i2+1,i3)-ty(i1,i2+2,i3))/(12.*dr(1))
                                                        tyrs   = ((ty(i1-2,i2-2,i3)-8.*ty(i1-2,i2-1,i3)+8.*ty(i1-2,i2+1,i3)-ty(i1-2,i2+2,i3))/(12.*dr(1))-8.*(ty(i1-1,i2-2,i3)-8.*ty(i1-1,i2-1,i3)+8.*ty(i1-1,i2+1,i3)-ty(i1-1,i2+2,i3))/(12.*dr(1))+8.*(ty(i1+1,i2-2,i3)-8.*ty(i1+1,i2-1,i3)+8.*ty(i1+1,i2+1,i3)-ty(i1+1,i2+2,i3))/(12.*dr(1))-(ty(i1+2,i2-2,i3)-8.*ty(i1+2,i2-1,i3)+8.*ty(i1+2,i2+1,i3)-ty(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        tyss   = (-ty(i1,i2-2,i3)+16.*ty(i1,i2-1,i3)-30.*ty(i1,i2,i3)+16.*ty(i1,i2+1,i3)-ty(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        tyt    = (ty(i1,i2,i3-2)-8.*ty(i1,i2,i3-1)+8.*ty(i1,i2,i3+1)-ty(i1,i2,i3+2))/(12.*dr(2))
                                                        tyrt   = ((ty(i1-2,i2,i3-2)-8.*ty(i1-2,i2,i3-1)+8.*ty(i1-2,i2,i3+1)-ty(i1-2,i2,i3+2))/(12.*dr(2))-8.*(ty(i1-1,i2,i3-2)-8.*ty(i1-1,i2,i3-1)+8.*ty(i1-1,i2,i3+1)-ty(i1-1,i2,i3+2))/(12.*dr(2))+8.*(ty(i1+1,i2,i3-2)-8.*ty(i1+1,i2,i3-1)+8.*ty(i1+1,i2,i3+1)-ty(i1+1,i2,i3+2))/(12.*dr(2))-(ty(i1+2,i2,i3-2)-8.*ty(i1+2,i2,i3-1)+8.*ty(i1+2,i2,i3+1)-ty(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        tyst   = ((ty(i1,i2-2,i3-2)-8.*ty(i1,i2-2,i3-1)+8.*ty(i1,i2-2,i3+1)-ty(i1,i2-2,i3+2))/(12.*dr(2))-8.*(ty(i1,i2-1,i3-2)-8.*ty(i1,i2-1,i3-1)+8.*ty(i1,i2-1,i3+1)-ty(i1,i2-1,i3+2))/(12.*dr(2))+8.*(ty(i1,i2+1,i3-2)-8.*ty(i1,i2+1,i3-1)+8.*ty(i1,i2+1,i3+1)-ty(i1,i2+1,i3+2))/(12.*dr(2))-(ty(i1,i2+2,i3-2)-8.*ty(i1,i2+2,i3-1)+8.*ty(i1,i2+2,i3+1)-ty(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        tytt   = (-ty(i1,i2,i3-2)+16.*ty(i1,i2,i3-1)-30.*ty(i1,i2,i3)+16.*ty(i1,i2,i3+1)-ty(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        tzr    = (tz(i1-2,i2,i3)-8.*tz(i1-1,i2,i3)+8.*tz(i1+1,i2,i3)-tz(i1+2,i2,i3))/(12.*dr(0))
                                                        tzrr   = (-tz(i1-2,i2,i3)+16.*tz(i1-1,i2,i3)-30.*tz(i1,i2,i3)+16.*tz(i1+1,i2,i3)-tz(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        tzs    = (tz(i1,i2-2,i3)-8.*tz(i1,i2-1,i3)+8.*tz(i1,i2+1,i3)-tz(i1,i2+2,i3))/(12.*dr(1))
                                                        tzrs   = ((tz(i1-2,i2-2,i3)-8.*tz(i1-2,i2-1,i3)+8.*tz(i1-2,i2+1,i3)-tz(i1-2,i2+2,i3))/(12.*dr(1))-8.*(tz(i1-1,i2-2,i3)-8.*tz(i1-1,i2-1,i3)+8.*tz(i1-1,i2+1,i3)-tz(i1-1,i2+2,i3))/(12.*dr(1))+8.*(tz(i1+1,i2-2,i3)-8.*tz(i1+1,i2-1,i3)+8.*tz(i1+1,i2+1,i3)-tz(i1+1,i2+2,i3))/(12.*dr(1))-(tz(i1+2,i2-2,i3)-8.*tz(i1+2,i2-1,i3)+8.*tz(i1+2,i2+1,i3)-tz(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        tzss   = (-tz(i1,i2-2,i3)+16.*tz(i1,i2-1,i3)-30.*tz(i1,i2,i3)+16.*tz(i1,i2+1,i3)-tz(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        tzt    = (tz(i1,i2,i3-2)-8.*tz(i1,i2,i3-1)+8.*tz(i1,i2,i3+1)-tz(i1,i2,i3+2))/(12.*dr(2))
                                                        tzrt   = ((tz(i1-2,i2,i3-2)-8.*tz(i1-2,i2,i3-1)+8.*tz(i1-2,i2,i3+1)-tz(i1-2,i2,i3+2))/(12.*dr(2))-8.*(tz(i1-1,i2,i3-2)-8.*tz(i1-1,i2,i3-1)+8.*tz(i1-1,i2,i3+1)-tz(i1-1,i2,i3+2))/(12.*dr(2))+8.*(tz(i1+1,i2,i3-2)-8.*tz(i1+1,i2,i3-1)+8.*tz(i1+1,i2,i3+1)-tz(i1+1,i2,i3+2))/(12.*dr(2))-(tz(i1+2,i2,i3-2)-8.*tz(i1+2,i2,i3-1)+8.*tz(i1+2,i2,i3+1)-tz(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        tzst   = ((tz(i1,i2-2,i3-2)-8.*tz(i1,i2-2,i3-1)+8.*tz(i1,i2-2,i3+1)-tz(i1,i2-2,i3+2))/(12.*dr(2))-8.*(tz(i1,i2-1,i3-2)-8.*tz(i1,i2-1,i3-1)+8.*tz(i1,i2-1,i3+1)-tz(i1,i2-1,i3+2))/(12.*dr(2))+8.*(tz(i1,i2+1,i3-2)-8.*tz(i1,i2+1,i3-1)+8.*tz(i1,i2+1,i3+1)-tz(i1,i2+1,i3+2))/(12.*dr(2))-(tz(i1,i2+2,i3-2)-8.*tz(i1,i2+2,i3-1)+8.*tz(i1,i2+2,i3+1)-tz(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        tztt   = (-tz(i1,i2,i3-2)+16.*tz(i1,i2,i3-1)-30.*tz(i1,i2,i3)+16.*tz(i1,i2,i3+1)-tz(i1,i2,i3+2))/(12.*dr(2)**2)
                            ! ---------- Spatial derivatives of metrics rx, sx, ry, ... ---------
                                                        rxi = rx(i1,i2,i3)
                                                        ryi = ry(i1,i2,i3)
                                                        sxi = sx(i1,i2,i3)
                                                        syi = sy(i1,i2,i3)
                                                        rzi = rz(i1,i2,i3)
                                                        szi = sz(i1,i2,i3)
                                                        txi = tx(i1,i2,i3)
                                                        tyi = ty(i1,i2,i3)
                                                        tzi = tz(i1,i2,i3)
                                                        rxx = rxi*rxr+sxi*rxs+txi*rxt
                                                        rxxx = rxi**2*rxrr+2.*rxi*sxi*rxrs+2.*rxi*txi*rxrt+sxi**2*rxss+2.*sxi*txi*rxst+txi**2*rxtt+rxx*rxr+sxx*rxs+txx*rxt
                                                        rxy = ryi*rxr+syi*rxs+tyi*rxt
                                                        rxxy = ryi*rxi*rxrr+(rxi*syi+ryi*sxi)*rxrs+syi*sxi*rxss+(rxi*tyi+ryi*txi)*rxrt+(sxi*tyi+syi*txi)*rxst+tyi*txi*rxtt+rxy*rxr+sxy*rxs+txy*rxt
                                                        rxyy = ryi**2*rxrr+2.*ryi*syi*rxrs+2.*ryi*tyi*rxrt+syi**2*rxss+2.*syi*tyi*rxst+tyi**2*rxtt+ryy*rxr+syy*rxs+tyy*rxt
                                                        rxz = rzi*rxr+szi*rxs+tzi*rxt
                                                        rxxz = rzi*rxi*rxrr+(rxi*szi+rzi*sxi)*rxrs+szi*sxi*rxss+(rxi*tzi+rzi*txi)*rxrt+(sxi*tzi+szi*txi)*rxst+tzi*txi*rxtt+rxz*rxr+sxz*rxs+txz*rxt
                                                        rxyz = rzi*ryi*rxrr+(ryi*szi+rzi*syi)*rxrs+szi*syi*rxss+(ryi*tzi+rzi*tyi)*rxrt+(syi*tzi+szi*tyi)*rxst+tzi*tyi*rxtt+ryz*rxr+syz*rxs+tyz*rxt
                                                        rxzz = rzi**2*rxrr+2.*rzi*szi*rxrs+2.*rzi*tzi*rxrt+szi**2*rxss+2.*szi*tzi*rxst+tzi**2*rxtt+rzz*rxr+szz*rxs+tzz*rxt
                                                        ryy = ryi*ryr+syi*rys+tyi*ryt
                                                        ryyy = ryi**2*ryrr+2.*ryi*syi*ryrs+2.*ryi*tyi*ryrt+syi**2*ryss+2.*syi*tyi*ryst+tyi**2*rytt+ryy*ryr+syy*rys+tyy*ryt
                                                        ryz = rzi*ryr+szi*rys+tzi*ryt
                                                        ryyz = rzi*ryi*ryrr+(ryi*szi+rzi*syi)*ryrs+szi*syi*ryss+(ryi*tzi+rzi*tyi)*ryrt+(syi*tzi+szi*tyi)*ryst+tzi*tyi*rytt+ryz*ryr+syz*rys+tyz*ryt
                                                        ryzz = rzi**2*ryrr+2.*rzi*szi*ryrs+2.*rzi*tzi*ryrt+szi**2*ryss+2.*szi*tzi*ryst+tzi**2*rytt+rzz*ryr+szz*rys+tzz*ryt
                                                        rzz = rzi*rzr+szi*rzs+tzi*rzt
                                                        rzzz = rzi**2*rzrr+2.*rzi*szi*rzrs+2.*rzi*tzi*rzrt+szi**2*rzss+2.*szi*tzi*rzst+tzi**2*rztt+rzz*rzr+szz*rzs+tzz*rzt
                                                        sxx = rxi*sxr+sxi*sxs+txi*sxt
                                                        sxxx = rxi**2*sxrr+2.*rxi*sxi*sxrs+2.*rxi*txi*sxrt+sxi**2*sxss+2.*sxi*txi*sxst+txi**2*sxtt+rxx*sxr+sxx*sxs+txx*sxt
                                                        sxy = ryi*sxr+syi*sxs+tyi*sxt
                                                        sxxy = ryi*rxi*sxrr+(rxi*syi+ryi*sxi)*sxrs+syi*sxi*sxss+(rxi*tyi+ryi*txi)*sxrt+(sxi*tyi+syi*txi)*sxst+tyi*txi*sxtt+rxy*sxr+sxy*sxs+txy*sxt
                                                        sxyy = ryi**2*sxrr+2.*ryi*syi*sxrs+2.*ryi*tyi*sxrt+syi**2*sxss+2.*syi*tyi*sxst+tyi**2*sxtt+ryy*sxr+syy*sxs+tyy*sxt
                                                        sxz = rzi*sxr+szi*sxs+tzi*sxt
                                                        sxxz = rzi*rxi*sxrr+(rxi*szi+rzi*sxi)*sxrs+szi*sxi*sxss+(rxi*tzi+rzi*txi)*sxrt+(sxi*tzi+szi*txi)*sxst+tzi*txi*sxtt+rxz*sxr+sxz*sxs+txz*sxt
                                                        sxyz = rzi*ryi*sxrr+(ryi*szi+rzi*syi)*sxrs+szi*syi*sxss+(ryi*tzi+rzi*tyi)*sxrt+(syi*tzi+szi*tyi)*sxst+tzi*tyi*sxtt+ryz*sxr+syz*sxs+tyz*sxt
                                                        sxzz = rzi**2*sxrr+2.*rzi*szi*sxrs+2.*rzi*tzi*sxrt+szi**2*sxss+2.*szi*tzi*sxst+tzi**2*sxtt+rzz*sxr+szz*sxs+tzz*sxt
                                                        syy = ryi*syr+syi*sys+tyi*syt
                                                        syyy = ryi**2*syrr+2.*ryi*syi*syrs+2.*ryi*tyi*syrt+syi**2*syss+2.*syi*tyi*syst+tyi**2*sytt+ryy*syr+syy*sys+tyy*syt
                                                        syz = rzi*syr+szi*sys+tzi*syt
                                                        syyz = rzi*ryi*syrr+(ryi*szi+rzi*syi)*syrs+szi*syi*syss+(ryi*tzi+rzi*tyi)*syrt+(syi*tzi+szi*tyi)*syst+tzi*tyi*sytt+ryz*syr+syz*sys+tyz*syt
                                                        syzz = rzi**2*syrr+2.*rzi*szi*syrs+2.*rzi*tzi*syrt+szi**2*syss+2.*szi*tzi*syst+tzi**2*sytt+rzz*syr+szz*sys+tzz*syt
                                                        szz = rzi*szr+szi*szs+tzi*szt
                                                        szzz = rzi**2*szrr+2.*rzi*szi*szrs+2.*rzi*tzi*szrt+szi**2*szss+2.*szi*tzi*szst+tzi**2*sztt+rzz*szr+szz*szs+tzz*szt
                                                        txx = rxi*txr+sxi*txs+txi*txt
                                                        txxx = rxi**2*txrr+2.*rxi*sxi*txrs+2.*rxi*txi*txrt+sxi**2*txss+2.*sxi*txi*txst+txi**2*txtt+rxx*txr+sxx*txs+txx*txt
                                                        txy = ryi*txr+syi*txs+tyi*txt
                                                        txxy = ryi*rxi*txrr+(rxi*syi+ryi*sxi)*txrs+syi*sxi*txss+(rxi*tyi+ryi*txi)*txrt+(sxi*tyi+syi*txi)*txst+tyi*txi*txtt+rxy*txr+sxy*txs+txy*txt
                                                        txyy = ryi**2*txrr+2.*ryi*syi*txrs+2.*ryi*tyi*txrt+syi**2*txss+2.*syi*tyi*txst+tyi**2*txtt+ryy*txr+syy*txs+tyy*txt
                                                        txz = rzi*txr+szi*txs+tzi*txt
                                                        txxz = rzi*rxi*txrr+(rxi*szi+rzi*sxi)*txrs+szi*sxi*txss+(rxi*tzi+rzi*txi)*txrt+(sxi*tzi+szi*txi)*txst+tzi*txi*txtt+rxz*txr+sxz*txs+txz*txt
                                                        txyz = rzi*ryi*txrr+(ryi*szi+rzi*syi)*txrs+szi*syi*txss+(ryi*tzi+rzi*tyi)*txrt+(syi*tzi+szi*tyi)*txst+tzi*tyi*txtt+ryz*txr+syz*txs+tyz*txt
                                                        txzz = rzi**2*txrr+2.*rzi*szi*txrs+2.*rzi*tzi*txrt+szi**2*txss+2.*szi*tzi*txst+tzi**2*txtt+rzz*txr+szz*txs+tzz*txt
                                                        tyy = ryi*tyr+syi*tys+tyi*tyt
                                                        tyyy = ryi**2*tyrr+2.*ryi*syi*tyrs+2.*ryi*tyi*tyrt+syi**2*tyss+2.*syi*tyi*tyst+tyi**2*tytt+ryy*tyr+syy*tys+tyy*tyt
                                                        tyz = rzi*tyr+szi*tys+tzi*tyt
                                                        tyyz = rzi*ryi*tyrr+(ryi*szi+rzi*syi)*tyrs+szi*syi*tyss+(ryi*tzi+rzi*tyi)*tyrt+(syi*tzi+szi*tyi)*tyst+tzi*tyi*tytt+ryz*tyr+syz*tys+tyz*tyt
                                                        tyzz = rzi**2*tyrr+2.*rzi*szi*tyrs+2.*rzi*tzi*tyrt+szi**2*tyss+2.*szi*tzi*tyst+tzi**2*tytt+rzz*tyr+szz*tys+tzz*tyt
                                                        tzz = rzi*tzr+szi*tzs+tzi*tzt
                                                        tzzz = rzi**2*tzrr+2.*rzi*szi*tzrs+2.*rzi*tzi*tzrt+szi**2*tzss+2.*szi*tzi*tzst+tzi**2*tztt+rzz*tzr+szz*tzs+tzz*tzt
                            ! ---- end evalMetrics eq evalMetrics ---
                            ! ---------- Third spatial derivatives of u ---------
                                                        uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                        uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                        uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                        uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                        uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                        uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                        uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                        uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                        uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                        uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                            ! ---------- END CURVILINEAR  ---------
                            ! ------ curvilinear grid: -------
                              ! 3D 
                                                            r1 =  an1*ux43(i1,i2,i3,0) + an2*uy43(i1,i2,i3,0) + an3*uz43(i1,i2,i3,0) - gg
                                                            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2)
                              ! **CHECK ME**
                                                            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
                                                            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)
                                                            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt
                              ! crv(axis) = an1*rsxy(i1,i2,i3,axis,0)**3 + an2*rsxy(i1,i2,i3,axis,1)**3 + an3*rsxy(i1,i2,i3,axis,2)**3
                              ! Coeff of "urrr" term *check me*
                                                            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2) )* (    rsxy(i1,i2,i3,axis,0)**2  + rsxy(i1,i2,i3,axis,1)**2  + rsxy(i1,i2,i3,axis,2)**2 )
                              ! if( axis.eq.0 )then
                              !   crv(axis) = ( an1*rxi + an2*ryi + an3*rzi )*( rxi**2 + ryi**2 + rzi**2 ) 
                              !   ! crv(axis) = an1*( rxi*( rxi**2 + ryi**2 + rzi**2 ) ) + !   !             an2*( ryi*( rxi**2 + ryi**2 + rzi**2 ) ) + !   !             an3*( rzi*( rxi**2 + ryi**2 + rzi**2 ) ) 
                              ! else if( axis.eq.1 )then
                              !   crv(axis) = ( an1*sxi + an2*syi + an3*szi )*( sxi**2 + syi**2 + szi**2 ) 
                              ! else           
                              !   crv(axis) = ( an1*txi + an2*tyi + an3*tzi )*( txi**2 + tyi**2 + tzi**2 ) 
                              ! end if
                              ! **CHECK ME**
                                                            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
                                                            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )            
                              ! define the residual functions for the discrete delta method
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                                    ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                                    urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                                    urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                                    ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                                    urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                                    usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                                    utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                                    urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                                    ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                                    uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                                    uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                                    uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                                    uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                                    uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                                    uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                                    uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1a = (an1*ux43(i1,i2,i3,0)+an2*uy43(i1,i2,i3,0)+an3*uz43(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                                    ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                                    urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                                    urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                                    ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                                    urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                                    usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                                    utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                                    urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                                    ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                                    uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                                    uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                                    uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                                    uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                                    uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                                    uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                                    uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux43(i1,i2,i3,0)+an2*uy43(i1,i2,i3,0)+an3*uz43(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                                    ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                                    urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                                    urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                                    ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                                    urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                                    usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                                    utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                                    urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                                    ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                                    uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                                    uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                                    uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                                    uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                                    uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                                    uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                                    uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux43(i1,i2,i3,0)+an2*uy43(i1,i2,i3,0)+an3*uz43(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "curvilinear" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," curvilinear 4")') t,side,axis,maxDiff
                                            end if
                                end if
                            end if 
                        else
                            if( gridType.eq.rectangular )then
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex )
                                                                    call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
                                                                    gg = an1*uex + an2*uey
                                                                        call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettx )
                                                                        call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetty )
                                                                        gtt = an1*( uettx ) + an2*( uetty )
                                                                        call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxx )
                                                                        call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyy )
                                                                        call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxy )
                                                                        call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyy )
                                                                        nDotGradF = an1*( uettx - c2*( uexxx + uexyy ) ) + an2*( uetty - c2*( uexxy + ueyyy ) )
                                                            else
                                                                gg=0.;  gtt=0.; nDotGradF=0.; 
                                                            end if
                            ! ---------- RECTANGULAR  ---------
                                                        uxxx = uxxx22r(i1,i2,i3,0)
                                                        uxxy = uxxy22r(i1,i2,i3,0)
                                                        uxyy = uxyy22r(i1,i2,i3,0)
                                                        uyyy = uyyy22r(i1,i2,i3,0)
                            ! --- NEUMANN 4=4 rectangular ---
                            ! u_tt = c^2*Lap(u) + f 
                            !   u.n = g
                            ! g_tt = c^2 n.grad( Lap(u) ) + n.grad(f)
                            ! ux = [ u(-2) - 8*u(-1) + 8*u(1) - u(2) ]/(12*h) 
                            ! uxxx = (-u(-1) +2*u(-1) - 2*u(1) + u(2) ]/(2*h^3)
                              ! eval equation with wrong values at ghost: 
                                                            r1 =  an1*ux42r(i1,i2,i3,0) + an2*uy42r(i1,i2,i3,0) - gg
                              ! note: an1=-1 on left side ans an1=+1 on right side
                              ! **CHECK ME**
                                                            a11 =  8./(12.*dx(axis))  ! coeff of u(-1)
                                                            a12 = -1./(12.*dx(axis))  ! coeff of u(-2)
                                                            r2 = c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) + nDotGradF - gtt
                              ! **CHECK ME**
                                                            a21 = -c2*( 2./(2.*dx(axis)**3) )
                                                            a22 =  c2*( 1./(2.*dx(axis)**3) )
                              ! define the residual functions for the discrete delta method
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx22r(i1,i2,i3,0)
                                                                    uxxy = uxxy22r(i1,i2,i3,0)
                                                                    uxyy = uxyy22r(i1,i2,i3,0)
                                                                    uyyy = uyyy22r(i1,i2,i3,0)
                                                                    r1a = (an1*ux42r(i1,i2,i3,0)+an2*uy42r(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx22r(i1,i2,i3,0)
                                                                    uxxy = uxxy22r(i1,i2,i3,0)
                                                                    uxyy = uxyy22r(i1,i2,i3,0)
                                                                    uyyy = uyyy22r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux42r(i1,i2,i3,0)+an2*uy42r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx22r(i1,i2,i3,0)
                                                                    uxxy = uxxy22r(i1,i2,i3,0)
                                                                    uxyy = uxyy22r(i1,i2,i3,0)
                                                                    uyyy = uyyy22r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux42r(i1,i2,i3,0)+an2*uy42r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "rectangular" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," rectangular 4")') t,side,axis,maxDiff
                                            end if
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                      ! compute the outward normal (an1,an2,an3)
                                            an1 = 0.
                                            an2 = 0.
                                            an3 = 0.
                                            if( axis.eq.0 )then
                                              an1=-is
                                            else if( axis.eq.1 )then
                                              an2=-is
                                            else
                                              an3=-is
                                            end if
                                            dxn=dx(axis)
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                  ! ----- 3D  -----
                                                                    call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex )
                                                                    call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey )
                                                                    call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez )
                                                                    gg = an1*uex + an2*uey + an3*uez
                                                                        call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettx )
                                                                        call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uetty )
                                                                        call ogDeriv(ep,2,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettz )
                                                                        gtt = an1*( uettx ) + an2*( uetty ) + an3*( uettz )
                                                                        call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxx )
                                                                        call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxy )
                                                                        call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexyy )
                                                                        call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyy )
                                                                        call ogDeriv(ep,0,2,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxz )
                                                                        call ogDeriv(ep,0,1,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexzz )
                                                                        call ogDeriv(ep,0,0,2,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyz )
                                                                        call ogDeriv(ep,0,0,1,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyzz )
                                                                        call ogDeriv(ep,0,0,0,3,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzz )
                                                                        nDotGradF = an1*( uettx - c2*( uexxx + uexyy + uexzz ) ) + an2*( uetty - c2*( uexxy + ueyyy + ueyzz ) ) + an3*( uettz - c2*( uexxz + ueyyz + uezzz ) )
                                                            else
                                                                gg=0.;  gtt=0.; nDotGradF=0.; 
                                                            end if
                            ! evaluate 3rd derivatives : uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 
                            ! ---------- RECTANGULAR  ---------
                                                        uxxx = uxxx23r(i1,i2,i3,0)
                                                        uxxy = uxxy23r(i1,i2,i3,0)
                                                        uxxz = uxxz23r(i1,i2,i3,0)
                                                        uxyy = uxyy23r(i1,i2,i3,0)
                                                        uxzz = uxzz23r(i1,i2,i3,0)
                                                        uyyy = uyyy23r(i1,i2,i3,0)
                                                        uyyz = uyyz23r(i1,i2,i3,0)
                                                        uyzz = uyzz23r(i1,i2,i3,0)
                                                        uzzz = uzzz23r(i1,i2,i3,0)
                            ! --- NEUMANN 4=4 rectangular ---
                            ! u_tt = c^2*Lap(u) + f 
                            !   u.n = g
                            ! g_tt = c^2 n.grad( Lap(u) ) + n.grad(f)
                            ! ux = [ u(-2) - 8*u(-1) + 8*u(1) - u(2) ]/(12*h) 
                            ! uxxx = (-u(-1) +2*u(-1) - 2*u(1) + u(2) ]/(2*h^3)
                              ! 3D 
                                                            r1 =  an1*ux43r(i1,i2,i3,0) + an2*uy43r(i1,i2,i3,0) + an3*uz43r(i1,i2,i3,0) - gg
                              ! **CHECK ME**
                                                            a11 =  8./(12.*dx(axis))  ! coeff of u(-1)
                                                            a12 = -1./(12.*dx(axis))  ! coeff of u(-2)  
                                                            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt
                              ! **CHECK ME**
                                                            a21 = -c2*( 2./(2.*dx(axis)**3) )
                                                            a22 =  c2*( 1./(2.*dx(axis)**3) )
                              ! define the residual functions for the discrete delta method
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx23r(i1,i2,i3,0)
                                                                    uxxy = uxxy23r(i1,i2,i3,0)
                                                                    uxxz = uxxz23r(i1,i2,i3,0)
                                                                    uxyy = uxyy23r(i1,i2,i3,0)
                                                                    uxzz = uxzz23r(i1,i2,i3,0)
                                                                    uyyy = uyyy23r(i1,i2,i3,0)
                                                                    uyyz = uyyz23r(i1,i2,i3,0)
                                                                    uyzz = uyzz23r(i1,i2,i3,0)
                                                                    uzzz = uzzz23r(i1,i2,i3,0)
                                                                    r1a = (an1*ux43r(i1,i2,i3,0)+an2*uy43r(i1,i2,i3,0)+an3*uz43r(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx23r(i1,i2,i3,0)
                                                                    uxxy = uxxy23r(i1,i2,i3,0)
                                                                    uxxz = uxxz23r(i1,i2,i3,0)
                                                                    uxyy = uxyy23r(i1,i2,i3,0)
                                                                    uxzz = uxzz23r(i1,i2,i3,0)
                                                                    uyyy = uyyy23r(i1,i2,i3,0)
                                                                    uyyz = uyyz23r(i1,i2,i3,0)
                                                                    uyzz = uyzz23r(i1,i2,i3,0)
                                                                    uzzz = uzzz23r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux43r(i1,i2,i3,0)+an2*uy43r(i1,i2,i3,0)+an3*uz43r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- RECTANGULAR  ---------
                                                                    uxxx = uxxx23r(i1,i2,i3,0)
                                                                    uxxy = uxxy23r(i1,i2,i3,0)
                                                                    uxxz = uxxz23r(i1,i2,i3,0)
                                                                    uxyy = uxyy23r(i1,i2,i3,0)
                                                                    uxzz = uxzz23r(i1,i2,i3,0)
                                                                    uyyy = uyyy23r(i1,i2,i3,0)
                                                                    uyyz = uyyz23r(i1,i2,i3,0)
                                                                    uyzz = uyzz23r(i1,i2,i3,0)
                                                                    uzzz = uzzz23r(i1,i2,i3,0)
                                                                    r1b =  (an1*ux43r(i1,i2,i3,0)+an2*uy43r(i1,i2,i3,0)+an3*uz43r(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "rectangular" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," rectangular 4")') t,side,axis,maxDiff
                                            end if
                                end if
                            else
                                if( nd.eq.2 )then
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                            ! compute the outward normal (an1,an2,an3)
                                                                an1 = rsxy(i1,i2,i3,axis,0)
                                                                an2 = rsxy(i1,i2,i3,axis,1)
                                                                if( nd.eq.2 )then
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                else
                                                                  an3 = rsxy(i1,i2,i3,axis,2)
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                  an3=an3*aNormi
                                                                end if
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                                                    call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex )
                                                                    call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
                                                                    gg = an1*uex + an2*uey
                                                                        call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettx )
                                                                        call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetty )
                                                                        gtt = an1*( uettx ) + an2*( uetty )
                                                                        call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxx )
                                                                        call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyy )
                                                                        call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxy )
                                                                        call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyy )
                                                                        nDotGradF = an1*( uettx - c2*( uexxx + uexyy ) ) + an2*( uetty - c2*( uexxy + ueyyy ) )
                                                            else
                                                                gg=0.;  gtt=0.; nDotGradF=0.; 
                                                            end if
                            ! ---------- START CURVILINEAR  ---------
                            ! ---------- Parametric derivatives ---------
                                                        ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                        urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                        urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                        us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                        urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                        urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                        uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                        urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                        usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                        rxr    = (rx(i1-2,i2,i3)-8.*rx(i1-1,i2,i3)+8.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0))
                                                        rxrr   = (-rx(i1-2,i2,i3)+16.*rx(i1-1,i2,i3)-30.*rx(i1,i2,i3)+16.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rxs    = (rx(i1,i2-2,i3)-8.*rx(i1,i2-1,i3)+8.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1))
                                                        rxrs   = ((rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))-(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        rxss   = (-rx(i1,i2-2,i3)+16.*rx(i1,i2-1,i3)-30.*rx(i1,i2,i3)+16.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        ryr    = (ry(i1-2,i2,i3)-8.*ry(i1-1,i2,i3)+8.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0))
                                                        ryrr   = (-ry(i1-2,i2,i3)+16.*ry(i1-1,i2,i3)-30.*ry(i1,i2,i3)+16.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rys    = (ry(i1,i2-2,i3)-8.*ry(i1,i2-1,i3)+8.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1))
                                                        ryrs   = ((ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))-8.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))+8.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))-(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        ryss   = (-ry(i1,i2-2,i3)+16.*ry(i1,i2-1,i3)-30.*ry(i1,i2,i3)+16.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        sxr    = (sx(i1-2,i2,i3)-8.*sx(i1-1,i2,i3)+8.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0))
                                                        sxrr   = (-sx(i1-2,i2,i3)+16.*sx(i1-1,i2,i3)-30.*sx(i1,i2,i3)+16.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sxs    = (sx(i1,i2-2,i3)-8.*sx(i1,i2-1,i3)+8.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1))
                                                        sxrs   = ((sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))-(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        sxss   = (-sx(i1,i2-2,i3)+16.*sx(i1,i2-1,i3)-30.*sx(i1,i2,i3)+16.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        syr    = (sy(i1-2,i2,i3)-8.*sy(i1-1,i2,i3)+8.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0))
                                                        syrr   = (-sy(i1-2,i2,i3)+16.*sy(i1-1,i2,i3)-30.*sy(i1,i2,i3)+16.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sys    = (sy(i1,i2-2,i3)-8.*sy(i1,i2-1,i3)+8.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1))
                                                        syrs   = ((sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))-(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        syss   = (-sy(i1,i2-2,i3)+16.*sy(i1,i2-1,i3)-30.*sy(i1,i2,i3)+16.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1)**2)
                            ! ---------- Spatial derivatives of metrics rx, sx, ry, ... ---------
                                                        rxi = rx(i1,i2,i3)
                                                        ryi = ry(i1,i2,i3)
                                                        sxi = sx(i1,i2,i3)
                                                        syi = sy(i1,i2,i3)
                                                        rxx = rxi*rxr+sxi*rxs
                                                        rxxx = rxi**2*rxrr+2.*rxi*sxi*rxrs+sxi**2*rxss+rxx*rxr+sxx*rxs
                                                        rxy = ryi*rxr+syi*rxs
                                                        rxxy = ryi*rxi*rxrr+(rxi*syi+ryi*sxi)*rxrs+syi*sxi*rxss+rxy*rxr+sxy*rxs
                                                        rxyy = ryi**2*rxrr+2.*ryi*syi*rxrs+syi**2*rxss+ryy*rxr+syy*rxs
                                                        ryy = ryi*ryr+syi*rys
                                                        ryyy = ryi**2*ryrr+2.*ryi*syi*ryrs+syi**2*ryss+ryy*ryr+syy*rys
                                                        sxx = rxi*sxr+sxi*sxs
                                                        sxxx = rxi**2*sxrr+2.*rxi*sxi*sxrs+sxi**2*sxss+rxx*sxr+sxx*sxs
                                                        sxy = ryi*sxr+syi*sxs
                                                        sxxy = ryi*rxi*sxrr+(rxi*syi+ryi*sxi)*sxrs+syi*sxi*sxss+rxy*sxr+sxy*sxs
                                                        sxyy = ryi**2*sxrr+2.*ryi*syi*sxrs+syi**2*sxss+ryy*sxr+syy*sxs
                                                        syy = ryi*syr+syi*sys
                                                        syyy = ryi**2*syrr+2.*ryi*syi*syrs+syi**2*syss+ryy*syr+syy*sys
                            ! ---- end evalMetrics eq evalMetrics ---
                            ! ---------- Third spatial derivatives of u ---------
                                                        uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                        uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                        uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                        uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                            ! ---------- END CURVILINEAR  ---------
                            ! ------ curvilinear grid: -------
                              ! eval equation with wrong values at ghost:
                                                            r1 =  an1*ux42(i1,i2,i3,0) + an2*uy42(i1,i2,i3,0) - gg
                                                            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1)
                              ! crv(1) = an1*rsxy(i1,i2,i3,1,0) + an2*rsxy(i1,i2,i3,1,1)
                              ! **CHECK ME**
                                                            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
                                                            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)
                                                            r2 = c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) + nDotGradF - gtt
                  ! uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                  ! uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                  ! uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                  ! uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                              ! uxxx = rxi**3*urrr +3.*rxi*rxx*urr + rxxx*ur
                              ! uxyy = ryi**2*rxi*urrr +(rxi*ryy+2.*rxy*ryi)*urr+rxyy*ur
                              ! uxxy = ryi*rxi**2*urrr +(2.*rxi*rxy+rxx*ryi)*urr+rxxy*ur
                              ! Coeff of terms involving urrr (do not include terms involving urr and ur as these used 2nd-order values)
                                                            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) )*( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )
                              ! if( axis.eq.0 )then
                              !   crv(axis) = (an1*rxi + an2*ryi )*( rxi**2 + ryi**2 )
                              !   ! crv(axis) = an1*( rxi**3 + ryi**2*rxi ) + !   !             an2*( ryi**3 + ryi*rxi**2 )
                              ! else
                              !   crv(axis) = (an1*sxi + an2*syi )*( sxi**2 + syi**2 )
                              !   ! crv(axis) = an1*( sxi**3 + syi**2*sxi ) + !   !             an2*( syi**3 + syi*sxi**2 )              
                              ! end if
                              ! crv(1) = an1*rsxy(i1,i2,i3,1,0)**3 + an2*rsxy(i1,i2,i3,1,1)**3
                              ! **CHECK ME**
                                                            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
                                                            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1a = (an1*ux42(i1,i2,i3,0)+an2*uy42(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux42(i1,i2,i3,0)+an2*uy42(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux42(i1,i2,i3,0)+an2*uy42(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy)+an2*(uxxy+uyyy)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "curvilinear" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," curvilinear 4")') t,side,axis,maxDiff
                                            end if
                                else
                    ! Mixed BC: a0*u + a1*u.n = 
                                        a0=0.
                                        a1=1.
                    ! STAGE I always fill in first ghost from 2nd-order scheme 
                    ! rectangular case:
                    !---------------------------------------------------------------
                    ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
                    !---------------------------------------------------------------
                    ! assign extram points in the tangential directions
                                        extram = numGhost-1 
                      ! ------------------- 4 4 NEUMANN CBC --------------------
                                            maxDiff=0. ! for checkCoeff
                                            gg=0.
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                ghost =1 
                                                j1=i1-is1*ghost
                                                j2=i2-is2*ghost
                                                j3=i3-is3*ghost
                                                ghost =2
                                                k1=i1-is1*ghost
                                                k2=i2-is2*ghost
                                                k3=i3-is3*ghost   
                                                if( mask(i1,i2,i3).gt.0 )then
                            ! compute the outward normal (an1,an2,an3)
                                                                an1 = rsxy(i1,i2,i3,axis,0)
                                                                an2 = rsxy(i1,i2,i3,axis,1)
                                                                if( nd.eq.2 )then
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                else
                                                                  an3 = rsxy(i1,i2,i3,axis,2)
                                                                  aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                                                  an1=an1*aNormi
                                                                  an2=an2*aNormi
                                                                  an3=an3*aNormi
                                                                end if
                                                            if( assignTwilightZone.eq.1 )then
                                ! compute RHS from TZ
                                  ! ----- 3D  -----
                                                                    call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex )
                                                                    call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey )
                                                                    call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez )
                                                                    gg = an1*uex + an2*uey + an3*uez
                                                                        call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettx )
                                                                        call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uetty )
                                                                        call ogDeriv(ep,2,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettz )
                                                                        gtt = an1*( uettx ) + an2*( uetty ) + an3*( uettz )
                                                                        call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxx )
                                                                        call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxy )
                                                                        call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexyy )
                                                                        call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyy )
                                                                        call ogDeriv(ep,0,2,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxz )
                                                                        call ogDeriv(ep,0,1,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexzz )
                                                                        call ogDeriv(ep,0,0,2,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyz )
                                                                        call ogDeriv(ep,0,0,1,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyzz )
                                                                        call ogDeriv(ep,0,0,0,3,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzz )
                                                                        nDotGradF = an1*( uettx - c2*( uexxx + uexyy + uexzz ) ) + an2*( uetty - c2*( uexxy + ueyyy + ueyzz ) ) + an3*( uettz - c2*( uexxz + ueyyz + uezzz ) )
                                                            else
                                                                gg=0.;  gtt=0.; nDotGradF=0.; 
                                                            end if
                            ! evaluate 3rd derivatives : uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 
                            ! ---------- START CURVILINEAR  ---------
                            ! ---------- Parametric derivatives ---------
                                                        ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                        urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                        urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                        us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                        urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                        urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                        uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                        urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                        usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                        ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                        urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                        urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                        ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                        urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                        usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                        utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                        urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                        ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                        uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                                        rxr    = (rx(i1-2,i2,i3)-8.*rx(i1-1,i2,i3)+8.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0))
                                                        rxrr   = (-rx(i1-2,i2,i3)+16.*rx(i1-1,i2,i3)-30.*rx(i1,i2,i3)+16.*rx(i1+1,i2,i3)-rx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rxs    = (rx(i1,i2-2,i3)-8.*rx(i1,i2-1,i3)+8.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1))
                                                        rxrs   = ((rx(i1-2,i2-2,i3)-8.*rx(i1-2,i2-1,i3)+8.*rx(i1-2,i2+1,i3)-rx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(rx(i1-1,i2-2,i3)-8.*rx(i1-1,i2-1,i3)+8.*rx(i1-1,i2+1,i3)-rx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(rx(i1+1,i2-2,i3)-8.*rx(i1+1,i2-1,i3)+8.*rx(i1+1,i2+1,i3)-rx(i1+1,i2+2,i3))/(12.*dr(1))-(rx(i1+2,i2-2,i3)-8.*rx(i1+2,i2-1,i3)+8.*rx(i1+2,i2+1,i3)-rx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        rxss   = (-rx(i1,i2-2,i3)+16.*rx(i1,i2-1,i3)-30.*rx(i1,i2,i3)+16.*rx(i1,i2+1,i3)-rx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        rxt    = (rx(i1,i2,i3-2)-8.*rx(i1,i2,i3-1)+8.*rx(i1,i2,i3+1)-rx(i1,i2,i3+2))/(12.*dr(2))
                                                        rxrt   = ((rx(i1-2,i2,i3-2)-8.*rx(i1-2,i2,i3-1)+8.*rx(i1-2,i2,i3+1)-rx(i1-2,i2,i3+2))/(12.*dr(2))-8.*(rx(i1-1,i2,i3-2)-8.*rx(i1-1,i2,i3-1)+8.*rx(i1-1,i2,i3+1)-rx(i1-1,i2,i3+2))/(12.*dr(2))+8.*(rx(i1+1,i2,i3-2)-8.*rx(i1+1,i2,i3-1)+8.*rx(i1+1,i2,i3+1)-rx(i1+1,i2,i3+2))/(12.*dr(2))-(rx(i1+2,i2,i3-2)-8.*rx(i1+2,i2,i3-1)+8.*rx(i1+2,i2,i3+1)-rx(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        rxst   = ((rx(i1,i2-2,i3-2)-8.*rx(i1,i2-2,i3-1)+8.*rx(i1,i2-2,i3+1)-rx(i1,i2-2,i3+2))/(12.*dr(2))-8.*(rx(i1,i2-1,i3-2)-8.*rx(i1,i2-1,i3-1)+8.*rx(i1,i2-1,i3+1)-rx(i1,i2-1,i3+2))/(12.*dr(2))+8.*(rx(i1,i2+1,i3-2)-8.*rx(i1,i2+1,i3-1)+8.*rx(i1,i2+1,i3+1)-rx(i1,i2+1,i3+2))/(12.*dr(2))-(rx(i1,i2+2,i3-2)-8.*rx(i1,i2+2,i3-1)+8.*rx(i1,i2+2,i3+1)-rx(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        rxtt   = (-rx(i1,i2,i3-2)+16.*rx(i1,i2,i3-1)-30.*rx(i1,i2,i3)+16.*rx(i1,i2,i3+1)-rx(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        ryr    = (ry(i1-2,i2,i3)-8.*ry(i1-1,i2,i3)+8.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0))
                                                        ryrr   = (-ry(i1-2,i2,i3)+16.*ry(i1-1,i2,i3)-30.*ry(i1,i2,i3)+16.*ry(i1+1,i2,i3)-ry(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rys    = (ry(i1,i2-2,i3)-8.*ry(i1,i2-1,i3)+8.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1))
                                                        ryrs   = ((ry(i1-2,i2-2,i3)-8.*ry(i1-2,i2-1,i3)+8.*ry(i1-2,i2+1,i3)-ry(i1-2,i2+2,i3))/(12.*dr(1))-8.*(ry(i1-1,i2-2,i3)-8.*ry(i1-1,i2-1,i3)+8.*ry(i1-1,i2+1,i3)-ry(i1-1,i2+2,i3))/(12.*dr(1))+8.*(ry(i1+1,i2-2,i3)-8.*ry(i1+1,i2-1,i3)+8.*ry(i1+1,i2+1,i3)-ry(i1+1,i2+2,i3))/(12.*dr(1))-(ry(i1+2,i2-2,i3)-8.*ry(i1+2,i2-1,i3)+8.*ry(i1+2,i2+1,i3)-ry(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        ryss   = (-ry(i1,i2-2,i3)+16.*ry(i1,i2-1,i3)-30.*ry(i1,i2,i3)+16.*ry(i1,i2+1,i3)-ry(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        ryt    = (ry(i1,i2,i3-2)-8.*ry(i1,i2,i3-1)+8.*ry(i1,i2,i3+1)-ry(i1,i2,i3+2))/(12.*dr(2))
                                                        ryrt   = ((ry(i1-2,i2,i3-2)-8.*ry(i1-2,i2,i3-1)+8.*ry(i1-2,i2,i3+1)-ry(i1-2,i2,i3+2))/(12.*dr(2))-8.*(ry(i1-1,i2,i3-2)-8.*ry(i1-1,i2,i3-1)+8.*ry(i1-1,i2,i3+1)-ry(i1-1,i2,i3+2))/(12.*dr(2))+8.*(ry(i1+1,i2,i3-2)-8.*ry(i1+1,i2,i3-1)+8.*ry(i1+1,i2,i3+1)-ry(i1+1,i2,i3+2))/(12.*dr(2))-(ry(i1+2,i2,i3-2)-8.*ry(i1+2,i2,i3-1)+8.*ry(i1+2,i2,i3+1)-ry(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        ryst   = ((ry(i1,i2-2,i3-2)-8.*ry(i1,i2-2,i3-1)+8.*ry(i1,i2-2,i3+1)-ry(i1,i2-2,i3+2))/(12.*dr(2))-8.*(ry(i1,i2-1,i3-2)-8.*ry(i1,i2-1,i3-1)+8.*ry(i1,i2-1,i3+1)-ry(i1,i2-1,i3+2))/(12.*dr(2))+8.*(ry(i1,i2+1,i3-2)-8.*ry(i1,i2+1,i3-1)+8.*ry(i1,i2+1,i3+1)-ry(i1,i2+1,i3+2))/(12.*dr(2))-(ry(i1,i2+2,i3-2)-8.*ry(i1,i2+2,i3-1)+8.*ry(i1,i2+2,i3+1)-ry(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        rytt   = (-ry(i1,i2,i3-2)+16.*ry(i1,i2,i3-1)-30.*ry(i1,i2,i3)+16.*ry(i1,i2,i3+1)-ry(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        sxr    = (sx(i1-2,i2,i3)-8.*sx(i1-1,i2,i3)+8.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0))
                                                        sxrr   = (-sx(i1-2,i2,i3)+16.*sx(i1-1,i2,i3)-30.*sx(i1,i2,i3)+16.*sx(i1+1,i2,i3)-sx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sxs    = (sx(i1,i2-2,i3)-8.*sx(i1,i2-1,i3)+8.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1))
                                                        sxrs   = ((sx(i1-2,i2-2,i3)-8.*sx(i1-2,i2-1,i3)+8.*sx(i1-2,i2+1,i3)-sx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sx(i1-1,i2-2,i3)-8.*sx(i1-1,i2-1,i3)+8.*sx(i1-1,i2+1,i3)-sx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sx(i1+1,i2-2,i3)-8.*sx(i1+1,i2-1,i3)+8.*sx(i1+1,i2+1,i3)-sx(i1+1,i2+2,i3))/(12.*dr(1))-(sx(i1+2,i2-2,i3)-8.*sx(i1+2,i2-1,i3)+8.*sx(i1+2,i2+1,i3)-sx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        sxss   = (-sx(i1,i2-2,i3)+16.*sx(i1,i2-1,i3)-30.*sx(i1,i2,i3)+16.*sx(i1,i2+1,i3)-sx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        sxt    = (sx(i1,i2,i3-2)-8.*sx(i1,i2,i3-1)+8.*sx(i1,i2,i3+1)-sx(i1,i2,i3+2))/(12.*dr(2))
                                                        sxrt   = ((sx(i1-2,i2,i3-2)-8.*sx(i1-2,i2,i3-1)+8.*sx(i1-2,i2,i3+1)-sx(i1-2,i2,i3+2))/(12.*dr(2))-8.*(sx(i1-1,i2,i3-2)-8.*sx(i1-1,i2,i3-1)+8.*sx(i1-1,i2,i3+1)-sx(i1-1,i2,i3+2))/(12.*dr(2))+8.*(sx(i1+1,i2,i3-2)-8.*sx(i1+1,i2,i3-1)+8.*sx(i1+1,i2,i3+1)-sx(i1+1,i2,i3+2))/(12.*dr(2))-(sx(i1+2,i2,i3-2)-8.*sx(i1+2,i2,i3-1)+8.*sx(i1+2,i2,i3+1)-sx(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        sxst   = ((sx(i1,i2-2,i3-2)-8.*sx(i1,i2-2,i3-1)+8.*sx(i1,i2-2,i3+1)-sx(i1,i2-2,i3+2))/(12.*dr(2))-8.*(sx(i1,i2-1,i3-2)-8.*sx(i1,i2-1,i3-1)+8.*sx(i1,i2-1,i3+1)-sx(i1,i2-1,i3+2))/(12.*dr(2))+8.*(sx(i1,i2+1,i3-2)-8.*sx(i1,i2+1,i3-1)+8.*sx(i1,i2+1,i3+1)-sx(i1,i2+1,i3+2))/(12.*dr(2))-(sx(i1,i2+2,i3-2)-8.*sx(i1,i2+2,i3-1)+8.*sx(i1,i2+2,i3+1)-sx(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        sxtt   = (-sx(i1,i2,i3-2)+16.*sx(i1,i2,i3-1)-30.*sx(i1,i2,i3)+16.*sx(i1,i2,i3+1)-sx(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        syr    = (sy(i1-2,i2,i3)-8.*sy(i1-1,i2,i3)+8.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0))
                                                        syrr   = (-sy(i1-2,i2,i3)+16.*sy(i1-1,i2,i3)-30.*sy(i1,i2,i3)+16.*sy(i1+1,i2,i3)-sy(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        sys    = (sy(i1,i2-2,i3)-8.*sy(i1,i2-1,i3)+8.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1))
                                                        syrs   = ((sy(i1-2,i2-2,i3)-8.*sy(i1-2,i2-1,i3)+8.*sy(i1-2,i2+1,i3)-sy(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sy(i1-1,i2-2,i3)-8.*sy(i1-1,i2-1,i3)+8.*sy(i1-1,i2+1,i3)-sy(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sy(i1+1,i2-2,i3)-8.*sy(i1+1,i2-1,i3)+8.*sy(i1+1,i2+1,i3)-sy(i1+1,i2+2,i3))/(12.*dr(1))-(sy(i1+2,i2-2,i3)-8.*sy(i1+2,i2-1,i3)+8.*sy(i1+2,i2+1,i3)-sy(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        syss   = (-sy(i1,i2-2,i3)+16.*sy(i1,i2-1,i3)-30.*sy(i1,i2,i3)+16.*sy(i1,i2+1,i3)-sy(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        syt    = (sy(i1,i2,i3-2)-8.*sy(i1,i2,i3-1)+8.*sy(i1,i2,i3+1)-sy(i1,i2,i3+2))/(12.*dr(2))
                                                        syrt   = ((sy(i1-2,i2,i3-2)-8.*sy(i1-2,i2,i3-1)+8.*sy(i1-2,i2,i3+1)-sy(i1-2,i2,i3+2))/(12.*dr(2))-8.*(sy(i1-1,i2,i3-2)-8.*sy(i1-1,i2,i3-1)+8.*sy(i1-1,i2,i3+1)-sy(i1-1,i2,i3+2))/(12.*dr(2))+8.*(sy(i1+1,i2,i3-2)-8.*sy(i1+1,i2,i3-1)+8.*sy(i1+1,i2,i3+1)-sy(i1+1,i2,i3+2))/(12.*dr(2))-(sy(i1+2,i2,i3-2)-8.*sy(i1+2,i2,i3-1)+8.*sy(i1+2,i2,i3+1)-sy(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        syst   = ((sy(i1,i2-2,i3-2)-8.*sy(i1,i2-2,i3-1)+8.*sy(i1,i2-2,i3+1)-sy(i1,i2-2,i3+2))/(12.*dr(2))-8.*(sy(i1,i2-1,i3-2)-8.*sy(i1,i2-1,i3-1)+8.*sy(i1,i2-1,i3+1)-sy(i1,i2-1,i3+2))/(12.*dr(2))+8.*(sy(i1,i2+1,i3-2)-8.*sy(i1,i2+1,i3-1)+8.*sy(i1,i2+1,i3+1)-sy(i1,i2+1,i3+2))/(12.*dr(2))-(sy(i1,i2+2,i3-2)-8.*sy(i1,i2+2,i3-1)+8.*sy(i1,i2+2,i3+1)-sy(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        sytt   = (-sy(i1,i2,i3-2)+16.*sy(i1,i2,i3-1)-30.*sy(i1,i2,i3)+16.*sy(i1,i2,i3+1)-sy(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        rzr    = (rz(i1-2,i2,i3)-8.*rz(i1-1,i2,i3)+8.*rz(i1+1,i2,i3)-rz(i1+2,i2,i3))/(12.*dr(0))
                                                        rzrr   = (-rz(i1-2,i2,i3)+16.*rz(i1-1,i2,i3)-30.*rz(i1,i2,i3)+16.*rz(i1+1,i2,i3)-rz(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        rzs    = (rz(i1,i2-2,i3)-8.*rz(i1,i2-1,i3)+8.*rz(i1,i2+1,i3)-rz(i1,i2+2,i3))/(12.*dr(1))
                                                        rzrs   = ((rz(i1-2,i2-2,i3)-8.*rz(i1-2,i2-1,i3)+8.*rz(i1-2,i2+1,i3)-rz(i1-2,i2+2,i3))/(12.*dr(1))-8.*(rz(i1-1,i2-2,i3)-8.*rz(i1-1,i2-1,i3)+8.*rz(i1-1,i2+1,i3)-rz(i1-1,i2+2,i3))/(12.*dr(1))+8.*(rz(i1+1,i2-2,i3)-8.*rz(i1+1,i2-1,i3)+8.*rz(i1+1,i2+1,i3)-rz(i1+1,i2+2,i3))/(12.*dr(1))-(rz(i1+2,i2-2,i3)-8.*rz(i1+2,i2-1,i3)+8.*rz(i1+2,i2+1,i3)-rz(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        rzss   = (-rz(i1,i2-2,i3)+16.*rz(i1,i2-1,i3)-30.*rz(i1,i2,i3)+16.*rz(i1,i2+1,i3)-rz(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        rzt    = (rz(i1,i2,i3-2)-8.*rz(i1,i2,i3-1)+8.*rz(i1,i2,i3+1)-rz(i1,i2,i3+2))/(12.*dr(2))
                                                        rzrt   = ((rz(i1-2,i2,i3-2)-8.*rz(i1-2,i2,i3-1)+8.*rz(i1-2,i2,i3+1)-rz(i1-2,i2,i3+2))/(12.*dr(2))-8.*(rz(i1-1,i2,i3-2)-8.*rz(i1-1,i2,i3-1)+8.*rz(i1-1,i2,i3+1)-rz(i1-1,i2,i3+2))/(12.*dr(2))+8.*(rz(i1+1,i2,i3-2)-8.*rz(i1+1,i2,i3-1)+8.*rz(i1+1,i2,i3+1)-rz(i1+1,i2,i3+2))/(12.*dr(2))-(rz(i1+2,i2,i3-2)-8.*rz(i1+2,i2,i3-1)+8.*rz(i1+2,i2,i3+1)-rz(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        rzst   = ((rz(i1,i2-2,i3-2)-8.*rz(i1,i2-2,i3-1)+8.*rz(i1,i2-2,i3+1)-rz(i1,i2-2,i3+2))/(12.*dr(2))-8.*(rz(i1,i2-1,i3-2)-8.*rz(i1,i2-1,i3-1)+8.*rz(i1,i2-1,i3+1)-rz(i1,i2-1,i3+2))/(12.*dr(2))+8.*(rz(i1,i2+1,i3-2)-8.*rz(i1,i2+1,i3-1)+8.*rz(i1,i2+1,i3+1)-rz(i1,i2+1,i3+2))/(12.*dr(2))-(rz(i1,i2+2,i3-2)-8.*rz(i1,i2+2,i3-1)+8.*rz(i1,i2+2,i3+1)-rz(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        rztt   = (-rz(i1,i2,i3-2)+16.*rz(i1,i2,i3-1)-30.*rz(i1,i2,i3)+16.*rz(i1,i2,i3+1)-rz(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        szr    = (sz(i1-2,i2,i3)-8.*sz(i1-1,i2,i3)+8.*sz(i1+1,i2,i3)-sz(i1+2,i2,i3))/(12.*dr(0))
                                                        szrr   = (-sz(i1-2,i2,i3)+16.*sz(i1-1,i2,i3)-30.*sz(i1,i2,i3)+16.*sz(i1+1,i2,i3)-sz(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        szs    = (sz(i1,i2-2,i3)-8.*sz(i1,i2-1,i3)+8.*sz(i1,i2+1,i3)-sz(i1,i2+2,i3))/(12.*dr(1))
                                                        szrs   = ((sz(i1-2,i2-2,i3)-8.*sz(i1-2,i2-1,i3)+8.*sz(i1-2,i2+1,i3)-sz(i1-2,i2+2,i3))/(12.*dr(1))-8.*(sz(i1-1,i2-2,i3)-8.*sz(i1-1,i2-1,i3)+8.*sz(i1-1,i2+1,i3)-sz(i1-1,i2+2,i3))/(12.*dr(1))+8.*(sz(i1+1,i2-2,i3)-8.*sz(i1+1,i2-1,i3)+8.*sz(i1+1,i2+1,i3)-sz(i1+1,i2+2,i3))/(12.*dr(1))-(sz(i1+2,i2-2,i3)-8.*sz(i1+2,i2-1,i3)+8.*sz(i1+2,i2+1,i3)-sz(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        szss   = (-sz(i1,i2-2,i3)+16.*sz(i1,i2-1,i3)-30.*sz(i1,i2,i3)+16.*sz(i1,i2+1,i3)-sz(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        szt    = (sz(i1,i2,i3-2)-8.*sz(i1,i2,i3-1)+8.*sz(i1,i2,i3+1)-sz(i1,i2,i3+2))/(12.*dr(2))
                                                        szrt   = ((sz(i1-2,i2,i3-2)-8.*sz(i1-2,i2,i3-1)+8.*sz(i1-2,i2,i3+1)-sz(i1-2,i2,i3+2))/(12.*dr(2))-8.*(sz(i1-1,i2,i3-2)-8.*sz(i1-1,i2,i3-1)+8.*sz(i1-1,i2,i3+1)-sz(i1-1,i2,i3+2))/(12.*dr(2))+8.*(sz(i1+1,i2,i3-2)-8.*sz(i1+1,i2,i3-1)+8.*sz(i1+1,i2,i3+1)-sz(i1+1,i2,i3+2))/(12.*dr(2))-(sz(i1+2,i2,i3-2)-8.*sz(i1+2,i2,i3-1)+8.*sz(i1+2,i2,i3+1)-sz(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        szst   = ((sz(i1,i2-2,i3-2)-8.*sz(i1,i2-2,i3-1)+8.*sz(i1,i2-2,i3+1)-sz(i1,i2-2,i3+2))/(12.*dr(2))-8.*(sz(i1,i2-1,i3-2)-8.*sz(i1,i2-1,i3-1)+8.*sz(i1,i2-1,i3+1)-sz(i1,i2-1,i3+2))/(12.*dr(2))+8.*(sz(i1,i2+1,i3-2)-8.*sz(i1,i2+1,i3-1)+8.*sz(i1,i2+1,i3+1)-sz(i1,i2+1,i3+2))/(12.*dr(2))-(sz(i1,i2+2,i3-2)-8.*sz(i1,i2+2,i3-1)+8.*sz(i1,i2+2,i3+1)-sz(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        sztt   = (-sz(i1,i2,i3-2)+16.*sz(i1,i2,i3-1)-30.*sz(i1,i2,i3)+16.*sz(i1,i2,i3+1)-sz(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        txr    = (tx(i1-2,i2,i3)-8.*tx(i1-1,i2,i3)+8.*tx(i1+1,i2,i3)-tx(i1+2,i2,i3))/(12.*dr(0))
                                                        txrr   = (-tx(i1-2,i2,i3)+16.*tx(i1-1,i2,i3)-30.*tx(i1,i2,i3)+16.*tx(i1+1,i2,i3)-tx(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        txs    = (tx(i1,i2-2,i3)-8.*tx(i1,i2-1,i3)+8.*tx(i1,i2+1,i3)-tx(i1,i2+2,i3))/(12.*dr(1))
                                                        txrs   = ((tx(i1-2,i2-2,i3)-8.*tx(i1-2,i2-1,i3)+8.*tx(i1-2,i2+1,i3)-tx(i1-2,i2+2,i3))/(12.*dr(1))-8.*(tx(i1-1,i2-2,i3)-8.*tx(i1-1,i2-1,i3)+8.*tx(i1-1,i2+1,i3)-tx(i1-1,i2+2,i3))/(12.*dr(1))+8.*(tx(i1+1,i2-2,i3)-8.*tx(i1+1,i2-1,i3)+8.*tx(i1+1,i2+1,i3)-tx(i1+1,i2+2,i3))/(12.*dr(1))-(tx(i1+2,i2-2,i3)-8.*tx(i1+2,i2-1,i3)+8.*tx(i1+2,i2+1,i3)-tx(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        txss   = (-tx(i1,i2-2,i3)+16.*tx(i1,i2-1,i3)-30.*tx(i1,i2,i3)+16.*tx(i1,i2+1,i3)-tx(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        txt    = (tx(i1,i2,i3-2)-8.*tx(i1,i2,i3-1)+8.*tx(i1,i2,i3+1)-tx(i1,i2,i3+2))/(12.*dr(2))
                                                        txrt   = ((tx(i1-2,i2,i3-2)-8.*tx(i1-2,i2,i3-1)+8.*tx(i1-2,i2,i3+1)-tx(i1-2,i2,i3+2))/(12.*dr(2))-8.*(tx(i1-1,i2,i3-2)-8.*tx(i1-1,i2,i3-1)+8.*tx(i1-1,i2,i3+1)-tx(i1-1,i2,i3+2))/(12.*dr(2))+8.*(tx(i1+1,i2,i3-2)-8.*tx(i1+1,i2,i3-1)+8.*tx(i1+1,i2,i3+1)-tx(i1+1,i2,i3+2))/(12.*dr(2))-(tx(i1+2,i2,i3-2)-8.*tx(i1+2,i2,i3-1)+8.*tx(i1+2,i2,i3+1)-tx(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        txst   = ((tx(i1,i2-2,i3-2)-8.*tx(i1,i2-2,i3-1)+8.*tx(i1,i2-2,i3+1)-tx(i1,i2-2,i3+2))/(12.*dr(2))-8.*(tx(i1,i2-1,i3-2)-8.*tx(i1,i2-1,i3-1)+8.*tx(i1,i2-1,i3+1)-tx(i1,i2-1,i3+2))/(12.*dr(2))+8.*(tx(i1,i2+1,i3-2)-8.*tx(i1,i2+1,i3-1)+8.*tx(i1,i2+1,i3+1)-tx(i1,i2+1,i3+2))/(12.*dr(2))-(tx(i1,i2+2,i3-2)-8.*tx(i1,i2+2,i3-1)+8.*tx(i1,i2+2,i3+1)-tx(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        txtt   = (-tx(i1,i2,i3-2)+16.*tx(i1,i2,i3-1)-30.*tx(i1,i2,i3)+16.*tx(i1,i2,i3+1)-tx(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        tyr    = (ty(i1-2,i2,i3)-8.*ty(i1-1,i2,i3)+8.*ty(i1+1,i2,i3)-ty(i1+2,i2,i3))/(12.*dr(0))
                                                        tyrr   = (-ty(i1-2,i2,i3)+16.*ty(i1-1,i2,i3)-30.*ty(i1,i2,i3)+16.*ty(i1+1,i2,i3)-ty(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        tys    = (ty(i1,i2-2,i3)-8.*ty(i1,i2-1,i3)+8.*ty(i1,i2+1,i3)-ty(i1,i2+2,i3))/(12.*dr(1))
                                                        tyrs   = ((ty(i1-2,i2-2,i3)-8.*ty(i1-2,i2-1,i3)+8.*ty(i1-2,i2+1,i3)-ty(i1-2,i2+2,i3))/(12.*dr(1))-8.*(ty(i1-1,i2-2,i3)-8.*ty(i1-1,i2-1,i3)+8.*ty(i1-1,i2+1,i3)-ty(i1-1,i2+2,i3))/(12.*dr(1))+8.*(ty(i1+1,i2-2,i3)-8.*ty(i1+1,i2-1,i3)+8.*ty(i1+1,i2+1,i3)-ty(i1+1,i2+2,i3))/(12.*dr(1))-(ty(i1+2,i2-2,i3)-8.*ty(i1+2,i2-1,i3)+8.*ty(i1+2,i2+1,i3)-ty(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        tyss   = (-ty(i1,i2-2,i3)+16.*ty(i1,i2-1,i3)-30.*ty(i1,i2,i3)+16.*ty(i1,i2+1,i3)-ty(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        tyt    = (ty(i1,i2,i3-2)-8.*ty(i1,i2,i3-1)+8.*ty(i1,i2,i3+1)-ty(i1,i2,i3+2))/(12.*dr(2))
                                                        tyrt   = ((ty(i1-2,i2,i3-2)-8.*ty(i1-2,i2,i3-1)+8.*ty(i1-2,i2,i3+1)-ty(i1-2,i2,i3+2))/(12.*dr(2))-8.*(ty(i1-1,i2,i3-2)-8.*ty(i1-1,i2,i3-1)+8.*ty(i1-1,i2,i3+1)-ty(i1-1,i2,i3+2))/(12.*dr(2))+8.*(ty(i1+1,i2,i3-2)-8.*ty(i1+1,i2,i3-1)+8.*ty(i1+1,i2,i3+1)-ty(i1+1,i2,i3+2))/(12.*dr(2))-(ty(i1+2,i2,i3-2)-8.*ty(i1+2,i2,i3-1)+8.*ty(i1+2,i2,i3+1)-ty(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        tyst   = ((ty(i1,i2-2,i3-2)-8.*ty(i1,i2-2,i3-1)+8.*ty(i1,i2-2,i3+1)-ty(i1,i2-2,i3+2))/(12.*dr(2))-8.*(ty(i1,i2-1,i3-2)-8.*ty(i1,i2-1,i3-1)+8.*ty(i1,i2-1,i3+1)-ty(i1,i2-1,i3+2))/(12.*dr(2))+8.*(ty(i1,i2+1,i3-2)-8.*ty(i1,i2+1,i3-1)+8.*ty(i1,i2+1,i3+1)-ty(i1,i2+1,i3+2))/(12.*dr(2))-(ty(i1,i2+2,i3-2)-8.*ty(i1,i2+2,i3-1)+8.*ty(i1,i2+2,i3+1)-ty(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        tytt   = (-ty(i1,i2,i3-2)+16.*ty(i1,i2,i3-1)-30.*ty(i1,i2,i3)+16.*ty(i1,i2,i3+1)-ty(i1,i2,i3+2))/(12.*dr(2)**2)
                                                        tzr    = (tz(i1-2,i2,i3)-8.*tz(i1-1,i2,i3)+8.*tz(i1+1,i2,i3)-tz(i1+2,i2,i3))/(12.*dr(0))
                                                        tzrr   = (-tz(i1-2,i2,i3)+16.*tz(i1-1,i2,i3)-30.*tz(i1,i2,i3)+16.*tz(i1+1,i2,i3)-tz(i1+2,i2,i3))/(12.*dr(0)**2)
                                                        tzs    = (tz(i1,i2-2,i3)-8.*tz(i1,i2-1,i3)+8.*tz(i1,i2+1,i3)-tz(i1,i2+2,i3))/(12.*dr(1))
                                                        tzrs   = ((tz(i1-2,i2-2,i3)-8.*tz(i1-2,i2-1,i3)+8.*tz(i1-2,i2+1,i3)-tz(i1-2,i2+2,i3))/(12.*dr(1))-8.*(tz(i1-1,i2-2,i3)-8.*tz(i1-1,i2-1,i3)+8.*tz(i1-1,i2+1,i3)-tz(i1-1,i2+2,i3))/(12.*dr(1))+8.*(tz(i1+1,i2-2,i3)-8.*tz(i1+1,i2-1,i3)+8.*tz(i1+1,i2+1,i3)-tz(i1+1,i2+2,i3))/(12.*dr(1))-(tz(i1+2,i2-2,i3)-8.*tz(i1+2,i2-1,i3)+8.*tz(i1+2,i2+1,i3)-tz(i1+2,i2+2,i3))/(12.*dr(1)))/(12.*dr(0))
                                                        tzss   = (-tz(i1,i2-2,i3)+16.*tz(i1,i2-1,i3)-30.*tz(i1,i2,i3)+16.*tz(i1,i2+1,i3)-tz(i1,i2+2,i3))/(12.*dr(1)**2)
                                                        tzt    = (tz(i1,i2,i3-2)-8.*tz(i1,i2,i3-1)+8.*tz(i1,i2,i3+1)-tz(i1,i2,i3+2))/(12.*dr(2))
                                                        tzrt   = ((tz(i1-2,i2,i3-2)-8.*tz(i1-2,i2,i3-1)+8.*tz(i1-2,i2,i3+1)-tz(i1-2,i2,i3+2))/(12.*dr(2))-8.*(tz(i1-1,i2,i3-2)-8.*tz(i1-1,i2,i3-1)+8.*tz(i1-1,i2,i3+1)-tz(i1-1,i2,i3+2))/(12.*dr(2))+8.*(tz(i1+1,i2,i3-2)-8.*tz(i1+1,i2,i3-1)+8.*tz(i1+1,i2,i3+1)-tz(i1+1,i2,i3+2))/(12.*dr(2))-(tz(i1+2,i2,i3-2)-8.*tz(i1+2,i2,i3-1)+8.*tz(i1+2,i2,i3+1)-tz(i1+2,i2,i3+2))/(12.*dr(2)))/(12.*dr(0))
                                                        tzst   = ((tz(i1,i2-2,i3-2)-8.*tz(i1,i2-2,i3-1)+8.*tz(i1,i2-2,i3+1)-tz(i1,i2-2,i3+2))/(12.*dr(2))-8.*(tz(i1,i2-1,i3-2)-8.*tz(i1,i2-1,i3-1)+8.*tz(i1,i2-1,i3+1)-tz(i1,i2-1,i3+2))/(12.*dr(2))+8.*(tz(i1,i2+1,i3-2)-8.*tz(i1,i2+1,i3-1)+8.*tz(i1,i2+1,i3+1)-tz(i1,i2+1,i3+2))/(12.*dr(2))-(tz(i1,i2+2,i3-2)-8.*tz(i1,i2+2,i3-1)+8.*tz(i1,i2+2,i3+1)-tz(i1,i2+2,i3+2))/(12.*dr(2)))/(12.*dr(1))
                                                        tztt   = (-tz(i1,i2,i3-2)+16.*tz(i1,i2,i3-1)-30.*tz(i1,i2,i3)+16.*tz(i1,i2,i3+1)-tz(i1,i2,i3+2))/(12.*dr(2)**2)
                            ! ---------- Spatial derivatives of metrics rx, sx, ry, ... ---------
                                                        rxi = rx(i1,i2,i3)
                                                        ryi = ry(i1,i2,i3)
                                                        sxi = sx(i1,i2,i3)
                                                        syi = sy(i1,i2,i3)
                                                        rzi = rz(i1,i2,i3)
                                                        szi = sz(i1,i2,i3)
                                                        txi = tx(i1,i2,i3)
                                                        tyi = ty(i1,i2,i3)
                                                        tzi = tz(i1,i2,i3)
                                                        rxx = rxi*rxr+sxi*rxs+txi*rxt
                                                        rxxx = rxi**2*rxrr+2.*rxi*sxi*rxrs+2.*rxi*txi*rxrt+sxi**2*rxss+2.*sxi*txi*rxst+txi**2*rxtt+rxx*rxr+sxx*rxs+txx*rxt
                                                        rxy = ryi*rxr+syi*rxs+tyi*rxt
                                                        rxxy = ryi*rxi*rxrr+(rxi*syi+ryi*sxi)*rxrs+syi*sxi*rxss+(rxi*tyi+ryi*txi)*rxrt+(sxi*tyi+syi*txi)*rxst+tyi*txi*rxtt+rxy*rxr+sxy*rxs+txy*rxt
                                                        rxyy = ryi**2*rxrr+2.*ryi*syi*rxrs+2.*ryi*tyi*rxrt+syi**2*rxss+2.*syi*tyi*rxst+tyi**2*rxtt+ryy*rxr+syy*rxs+tyy*rxt
                                                        rxz = rzi*rxr+szi*rxs+tzi*rxt
                                                        rxxz = rzi*rxi*rxrr+(rxi*szi+rzi*sxi)*rxrs+szi*sxi*rxss+(rxi*tzi+rzi*txi)*rxrt+(sxi*tzi+szi*txi)*rxst+tzi*txi*rxtt+rxz*rxr+sxz*rxs+txz*rxt
                                                        rxyz = rzi*ryi*rxrr+(ryi*szi+rzi*syi)*rxrs+szi*syi*rxss+(ryi*tzi+rzi*tyi)*rxrt+(syi*tzi+szi*tyi)*rxst+tzi*tyi*rxtt+ryz*rxr+syz*rxs+tyz*rxt
                                                        rxzz = rzi**2*rxrr+2.*rzi*szi*rxrs+2.*rzi*tzi*rxrt+szi**2*rxss+2.*szi*tzi*rxst+tzi**2*rxtt+rzz*rxr+szz*rxs+tzz*rxt
                                                        ryy = ryi*ryr+syi*rys+tyi*ryt
                                                        ryyy = ryi**2*ryrr+2.*ryi*syi*ryrs+2.*ryi*tyi*ryrt+syi**2*ryss+2.*syi*tyi*ryst+tyi**2*rytt+ryy*ryr+syy*rys+tyy*ryt
                                                        ryz = rzi*ryr+szi*rys+tzi*ryt
                                                        ryyz = rzi*ryi*ryrr+(ryi*szi+rzi*syi)*ryrs+szi*syi*ryss+(ryi*tzi+rzi*tyi)*ryrt+(syi*tzi+szi*tyi)*ryst+tzi*tyi*rytt+ryz*ryr+syz*rys+tyz*ryt
                                                        ryzz = rzi**2*ryrr+2.*rzi*szi*ryrs+2.*rzi*tzi*ryrt+szi**2*ryss+2.*szi*tzi*ryst+tzi**2*rytt+rzz*ryr+szz*rys+tzz*ryt
                                                        rzz = rzi*rzr+szi*rzs+tzi*rzt
                                                        rzzz = rzi**2*rzrr+2.*rzi*szi*rzrs+2.*rzi*tzi*rzrt+szi**2*rzss+2.*szi*tzi*rzst+tzi**2*rztt+rzz*rzr+szz*rzs+tzz*rzt
                                                        sxx = rxi*sxr+sxi*sxs+txi*sxt
                                                        sxxx = rxi**2*sxrr+2.*rxi*sxi*sxrs+2.*rxi*txi*sxrt+sxi**2*sxss+2.*sxi*txi*sxst+txi**2*sxtt+rxx*sxr+sxx*sxs+txx*sxt
                                                        sxy = ryi*sxr+syi*sxs+tyi*sxt
                                                        sxxy = ryi*rxi*sxrr+(rxi*syi+ryi*sxi)*sxrs+syi*sxi*sxss+(rxi*tyi+ryi*txi)*sxrt+(sxi*tyi+syi*txi)*sxst+tyi*txi*sxtt+rxy*sxr+sxy*sxs+txy*sxt
                                                        sxyy = ryi**2*sxrr+2.*ryi*syi*sxrs+2.*ryi*tyi*sxrt+syi**2*sxss+2.*syi*tyi*sxst+tyi**2*sxtt+ryy*sxr+syy*sxs+tyy*sxt
                                                        sxz = rzi*sxr+szi*sxs+tzi*sxt
                                                        sxxz = rzi*rxi*sxrr+(rxi*szi+rzi*sxi)*sxrs+szi*sxi*sxss+(rxi*tzi+rzi*txi)*sxrt+(sxi*tzi+szi*txi)*sxst+tzi*txi*sxtt+rxz*sxr+sxz*sxs+txz*sxt
                                                        sxyz = rzi*ryi*sxrr+(ryi*szi+rzi*syi)*sxrs+szi*syi*sxss+(ryi*tzi+rzi*tyi)*sxrt+(syi*tzi+szi*tyi)*sxst+tzi*tyi*sxtt+ryz*sxr+syz*sxs+tyz*sxt
                                                        sxzz = rzi**2*sxrr+2.*rzi*szi*sxrs+2.*rzi*tzi*sxrt+szi**2*sxss+2.*szi*tzi*sxst+tzi**2*sxtt+rzz*sxr+szz*sxs+tzz*sxt
                                                        syy = ryi*syr+syi*sys+tyi*syt
                                                        syyy = ryi**2*syrr+2.*ryi*syi*syrs+2.*ryi*tyi*syrt+syi**2*syss+2.*syi*tyi*syst+tyi**2*sytt+ryy*syr+syy*sys+tyy*syt
                                                        syz = rzi*syr+szi*sys+tzi*syt
                                                        syyz = rzi*ryi*syrr+(ryi*szi+rzi*syi)*syrs+szi*syi*syss+(ryi*tzi+rzi*tyi)*syrt+(syi*tzi+szi*tyi)*syst+tzi*tyi*sytt+ryz*syr+syz*sys+tyz*syt
                                                        syzz = rzi**2*syrr+2.*rzi*szi*syrs+2.*rzi*tzi*syrt+szi**2*syss+2.*szi*tzi*syst+tzi**2*sytt+rzz*syr+szz*sys+tzz*syt
                                                        szz = rzi*szr+szi*szs+tzi*szt
                                                        szzz = rzi**2*szrr+2.*rzi*szi*szrs+2.*rzi*tzi*szrt+szi**2*szss+2.*szi*tzi*szst+tzi**2*sztt+rzz*szr+szz*szs+tzz*szt
                                                        txx = rxi*txr+sxi*txs+txi*txt
                                                        txxx = rxi**2*txrr+2.*rxi*sxi*txrs+2.*rxi*txi*txrt+sxi**2*txss+2.*sxi*txi*txst+txi**2*txtt+rxx*txr+sxx*txs+txx*txt
                                                        txy = ryi*txr+syi*txs+tyi*txt
                                                        txxy = ryi*rxi*txrr+(rxi*syi+ryi*sxi)*txrs+syi*sxi*txss+(rxi*tyi+ryi*txi)*txrt+(sxi*tyi+syi*txi)*txst+tyi*txi*txtt+rxy*txr+sxy*txs+txy*txt
                                                        txyy = ryi**2*txrr+2.*ryi*syi*txrs+2.*ryi*tyi*txrt+syi**2*txss+2.*syi*tyi*txst+tyi**2*txtt+ryy*txr+syy*txs+tyy*txt
                                                        txz = rzi*txr+szi*txs+tzi*txt
                                                        txxz = rzi*rxi*txrr+(rxi*szi+rzi*sxi)*txrs+szi*sxi*txss+(rxi*tzi+rzi*txi)*txrt+(sxi*tzi+szi*txi)*txst+tzi*txi*txtt+rxz*txr+sxz*txs+txz*txt
                                                        txyz = rzi*ryi*txrr+(ryi*szi+rzi*syi)*txrs+szi*syi*txss+(ryi*tzi+rzi*tyi)*txrt+(syi*tzi+szi*tyi)*txst+tzi*tyi*txtt+ryz*txr+syz*txs+tyz*txt
                                                        txzz = rzi**2*txrr+2.*rzi*szi*txrs+2.*rzi*tzi*txrt+szi**2*txss+2.*szi*tzi*txst+tzi**2*txtt+rzz*txr+szz*txs+tzz*txt
                                                        tyy = ryi*tyr+syi*tys+tyi*tyt
                                                        tyyy = ryi**2*tyrr+2.*ryi*syi*tyrs+2.*ryi*tyi*tyrt+syi**2*tyss+2.*syi*tyi*tyst+tyi**2*tytt+ryy*tyr+syy*tys+tyy*tyt
                                                        tyz = rzi*tyr+szi*tys+tzi*tyt
                                                        tyyz = rzi*ryi*tyrr+(ryi*szi+rzi*syi)*tyrs+szi*syi*tyss+(ryi*tzi+rzi*tyi)*tyrt+(syi*tzi+szi*tyi)*tyst+tzi*tyi*tytt+ryz*tyr+syz*tys+tyz*tyt
                                                        tyzz = rzi**2*tyrr+2.*rzi*szi*tyrs+2.*rzi*tzi*tyrt+szi**2*tyss+2.*szi*tzi*tyst+tzi**2*tytt+rzz*tyr+szz*tys+tzz*tyt
                                                        tzz = rzi*tzr+szi*tzs+tzi*tzt
                                                        tzzz = rzi**2*tzrr+2.*rzi*szi*tzrs+2.*rzi*tzi*tzrt+szi**2*tzss+2.*szi*tzi*tzst+tzi**2*tztt+rzz*tzr+szz*tzs+tzz*tzt
                            ! ---- end evalMetrics eq evalMetrics ---
                            ! ---------- Third spatial derivatives of u ---------
                                                        uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                        uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                        uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                        uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                        uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                        uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                        uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                        uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                        uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                        uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                            ! ---------- END CURVILINEAR  ---------
                            ! ------ curvilinear grid: -------
                              ! 3D 
                                                            r1 =  an1*ux43(i1,i2,i3,0) + an2*uy43(i1,i2,i3,0) + an3*uz43(i1,i2,i3,0) - gg
                                                            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2)
                              ! **CHECK ME**
                                                            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
                                                            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)
                                                            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt
                              ! crv(axis) = an1*rsxy(i1,i2,i3,axis,0)**3 + an2*rsxy(i1,i2,i3,axis,1)**3 + an3*rsxy(i1,i2,i3,axis,2)**3
                              ! Coeff of "urrr" term *check me*
                                                            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2) )* (    rsxy(i1,i2,i3,axis,0)**2  + rsxy(i1,i2,i3,axis,1)**2  + rsxy(i1,i2,i3,axis,2)**2 )
                              ! if( axis.eq.0 )then
                              !   crv(axis) = ( an1*rxi + an2*ryi + an3*rzi )*( rxi**2 + ryi**2 + rzi**2 ) 
                              !   ! crv(axis) = an1*( rxi*( rxi**2 + ryi**2 + rzi**2 ) ) + !   !             an2*( ryi*( rxi**2 + ryi**2 + rzi**2 ) ) + !   !             an3*( rzi*( rxi**2 + ryi**2 + rzi**2 ) ) 
                              ! else if( axis.eq.1 )then
                              !   crv(axis) = ( an1*sxi + an2*syi + an3*szi )*( sxi**2 + syi**2 + szi**2 ) 
                              ! else           
                              !   crv(axis) = ( an1*txi + an2*tyi + an3*tzi )*( txi**2 + tyi**2 + tzi**2 ) 
                              ! end if
                              ! **CHECK ME**
                                                            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
                                                            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )            
                              ! define the residual functions for the discrete delta method
                                                                if( checkCoeff.eq.1 )then
                                  ! --- Check coefficients a11,a12,... by discrete delta ---
                                                                    u1Save = u(j1,j2,j3,0)
                                                                    u2Save = u(k1,k2,k3,0)
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=0.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                                    ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                                    urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                                    urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                                    ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                                    urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                                    usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                                    utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                                    urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                                    ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                                    uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                                    uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                                    uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                                    uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                                    uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                                    uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                                    uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1a = (an1*ux43(i1,i2,i3,0)+an2*uy43(i1,i2,i3,0)+an3*uz43(i1,i2,i3,0))
                                                                    r2a = (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    u(j1,j2,j3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                                    ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                                    urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                                    urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                                    ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                                    urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                                    usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                                    utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                                    urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                                    ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                                    uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                                    uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                                    uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                                    uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                                    uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                                    uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                                    uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux43(i1,i2,i3,0)+an2*uy43(i1,i2,i3,0)+an3*uz43(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a11c = r1b - r1a
                                                                    a21c = r2b - r2a
                                                                    u(j1,j2,j3,0)=0.
                                                                    u(k1,k2,k3,0)=1.
                                  ! ---------- START CURVILINEAR  ---------
                                  ! ---------- Parametric derivatives ---------
                                                                    ur     = (u(i1-2,i2,i3,0)-8.*u(i1-1,i2,i3,0)+8.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0))
                                                                    urr    = (-u(i1-2,i2,i3,0)+16.*u(i1-1,i2,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1+1,i2,i3,0)-u(i1+2,i2,i3,0))/(12.*dr(0)**2)
                                                                    urrr   = (-u(i1-2,i2,i3,0)+2.*u(i1-1,i2,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+2,i2,i3,0))/(2.*dr(0)**3)
                                                                    us     = (u(i1,i2-2,i3,0)-8.*u(i1,i2-1,i3,0)+8.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1))
                                                                    urs    = ((u(i1-2,i2-2,i3,0)-8.*u(i1-2,i2-1,i3,0)+8.*u(i1-2,i2+1,i3,0)-u(i1-2,i2+2,i3,0))/(12.*dr(1))-8.*(u(i1-1,i2-2,i3,0)-8.*u(i1-1,i2-1,i3,0)+8.*u(i1-1,i2+1,i3,0)-u(i1-1,i2+2,i3,0))/(12.*dr(1))+8.*(u(i1+1,i2-2,i3,0)-8.*u(i1+1,i2-1,i3,0)+8.*u(i1+1,i2+1,i3,0)-u(i1+1,i2+2,i3,0))/(12.*dr(1))-(u(i1+2,i2-2,i3,0)-8.*u(i1+2,i2-1,i3,0)+8.*u(i1+2,i2+1,i3,0)-u(i1+2,i2+2,i3,0))/(12.*dr(1)))/(12.*dr(0))
                                                                    urrs   = ((-u(i1-1,i2-1,i3,0)+u(i1-1,i2+1,i3,0))/(2.*dr(1))-2.*(-u(i1,i2-1,i3,0)+u(i1,i2+1,i3,0))/(2.*dr(1))+(-u(i1+1,i2-1,i3,0)+u(i1+1,i2+1,i3,0))/(2.*dr(1)))/(dr(0)**2)
                                                                    uss    = (-u(i1,i2-2,i3,0)+16.*u(i1,i2-1,i3,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2+1,i3,0)-u(i1,i2+2,i3,0))/(12.*dr(1)**2)
                                                                    urss   = (-(u(i1-1,i2-1,i3,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2+1,i3,0))/(dr(1)**2)+(u(i1+1,i2-1,i3,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2+1,i3,0))/(dr(1)**2))/(2.*dr(0))
                                                                    usss   = (-u(i1,i2-2,i3,0)+2.*u(i1,i2-1,i3,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+2,i3,0))/(2.*dr(1)**3)
                                                                    ut     = (u(i1,i2,i3-2,0)-8.*u(i1,i2,i3-1,0)+8.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2))
                                                                    urt    = ((u(i1-2,i2,i3-2,0)-8.*u(i1-2,i2,i3-1,0)+8.*u(i1-2,i2,i3+1,0)-u(i1-2,i2,i3+2,0))/(12.*dr(2))-8.*(u(i1-1,i2,i3-2,0)-8.*u(i1-1,i2,i3-1,0)+8.*u(i1-1,i2,i3+1,0)-u(i1-1,i2,i3+2,0))/(12.*dr(2))+8.*(u(i1+1,i2,i3-2,0)-8.*u(i1+1,i2,i3-1,0)+8.*u(i1+1,i2,i3+1,0)-u(i1+1,i2,i3+2,0))/(12.*dr(2))-(u(i1+2,i2,i3-2,0)-8.*u(i1+2,i2,i3-1,0)+8.*u(i1+2,i2,i3+1,0)-u(i1+2,i2,i3+2,0))/(12.*dr(2)))/(12.*dr(0))
                                                                    urrt   = ((-u(i1-1,i2,i3-1,0)+u(i1-1,i2,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2,i3-1,0)+u(i1+1,i2,i3+1,0))/(2.*dr(2)))/(dr(0)**2)
                                                                    ust    = ((u(i1,i2-2,i3-2,0)-8.*u(i1,i2-2,i3-1,0)+8.*u(i1,i2-2,i3+1,0)-u(i1,i2-2,i3+2,0))/(12.*dr(2))-8.*(u(i1,i2-1,i3-2,0)-8.*u(i1,i2-1,i3-1,0)+8.*u(i1,i2-1,i3+1,0)-u(i1,i2-1,i3+2,0))/(12.*dr(2))+8.*(u(i1,i2+1,i3-2,0)-8.*u(i1,i2+1,i3-1,0)+8.*u(i1,i2+1,i3+1,0)-u(i1,i2+1,i3+2,0))/(12.*dr(2))-(u(i1,i2+2,i3-2,0)-8.*u(i1,i2+2,i3-1,0)+8.*u(i1,i2+2,i3+1,0)-u(i1,i2+2,i3+2,0))/(12.*dr(2)))/(12.*dr(1))
                                                                    urst   = (-(-(-u(i1-1,i2-1,i3-1,0)+u(i1-1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1-1,i2+1,i3-1,0)+u(i1-1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1))+(-(-u(i1+1,i2-1,i3-1,0)+u(i1+1,i2-1,i3+1,0))/(2.*dr(2))+(-u(i1+1,i2+1,i3-1,0)+u(i1+1,i2+1,i3+1,0))/(2.*dr(2)))/(2.*dr(1)))/(2.*dr(0))
                                                                    usst   = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))-2.*(-u(i1,i2,i3-1,0)+u(i1,i2,i3+1,0))/(2.*dr(2))+(-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
                                                                    utt    = (-u(i1,i2,i3-2,0)+16.*u(i1,i2,i3-1,0)-30.*u(i1,i2,i3,0)+16.*u(i1,i2,i3+1,0)-u(i1,i2,i3+2,0))/(12.*dr(2)**2)
                                                                    urtt   = (-(u(i1-1,i2,i3-1,0)-2.*u(i1-1,i2,i3,0)+u(i1-1,i2,i3+1,0))/(dr(2)**2)+(u(i1+1,i2,i3-1,0)-2.*u(i1+1,i2,i3,0)+u(i1+1,i2,i3+1,0))/(dr(2)**2))/(2.*dr(0))
                                                                    ustt   = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))
                                                                    uttt   = (-u(i1,i2,i3-2,0)+2.*u(i1,i2,i3-1,0)-2.*u(i1,i2,i3+1,0)+u(i1,i2,i3+2,0))/(2.*dr(2)**3)
                                  ! ---- end nothing eq evalMetrics ---
                                  ! ---------- Third spatial derivatives of u ---------
                                                                    uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi**2*txi*urrt+6.*rxi*sxi*txi*urst+3.*txi*sxi**2*usst+3.*rxi*txi**2*urtt+3.*txi**2*sxi*ustt+txi**3*uttt+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+(3.*rxi*txx+3.*rxx*txi)*urt+(3.*sxi*txx+3.*sxx*txi)*ust+3.*txx*txi*utt+rxxx*ur+sxxx*us+txxx*ut
                                                                    uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(rxi**2*tyi+2.*rxi*ryi*txi)*urrt+(2.*rxi*sxi*tyi+2.*rxi*syi*txi+2.*ryi*sxi*txi)*urst+(sxi**2*tyi+2.*sxi*syi*txi)*usst+(2.*rxi*txi*tyi+ryi*txi**2)*urtt+(2.*sxi*txi*tyi+syi*txi**2)*ustt+tyi*txi**2*uttt+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+(2.*rxi*txy+rxx*tyi+2.*rxy*txi+ryi*txx)*urt+(2.*sxi*txy+sxx*tyi+2.*sxy*txi+syi*txx)*ust+(2.*txi*txy+txx*tyi)*utt+rxxy*ur+sxxy*us+txxy*ut
                                                                    uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(tyi*ryi*rxi+ryi*(rxi*tyi+ryi*txi))*urrt+(tyi*(rxi*syi+ryi*sxi)+syi*(rxi*tyi+ryi*txi)+ryi*(sxi*tyi+syi*txi))*urst+(syi*(sxi*tyi+syi*txi)+tyi*syi*sxi)*usst+(tyi*(rxi*tyi+ryi*txi)+ryi*tyi*txi)*urtt+(tyi*(sxi*tyi+syi*txi)+syi*tyi*txi)*ustt+tyi**2*txi*uttt+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+(rxi*tyy+2.*rxy*tyi+2.*ryi*txy+ryy*txi)*urt+(sxi*tyy+2.*sxy*tyi+2.*syi*txy+syy*txi)*ust+(txi*tyy+2.*txy*tyi)*utt+rxyy*ur+sxyy*us+txyy*ut
                                                                    uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi**2*tyi*urrt+6.*ryi*tyi*syi*urst+3.*tyi*syi**2*usst+3.*ryi*tyi**2*urtt+3.*tyi**2*syi*ustt+tyi**3*uttt+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+(3.*ryi*tyy+3.*ryy*tyi)*urt+(3.*syi*tyy+3.*syy*tyi)*ust+3.*tyy*tyi*utt+ryyy*ur+syyy*us+tyyy*ut
                                                                    uxxz = rzi*rxi**2*urrr+(rxi**2*szi+2.*rxi*rzi*sxi)*urrs+(2.*rxi*sxi*szi+rzi*sxi**2)*urss+szi*sxi**2*usss+(rxi**2*tzi+2.*rxi*rzi*txi)*urrt+(2.*rxi*sxi*tzi+2.*rxi*szi*txi+2.*rzi*sxi*txi)*urst+(sxi**2*tzi+2.*sxi*szi*txi)*usst+(2.*rxi*txi*tzi+rzi*txi**2)*urtt+(2.*sxi*txi*tzi+szi*txi**2)*ustt+tzi*txi**2*uttt+(2.*rxi*rxz+rxx*rzi)*urr+(2.*rxi*sxz+rxx*szi+2.*rxz*sxi+rzi*sxx)*urs+(2.*sxi*sxz+sxx*szi)*uss+(2.*rxi*txz+rxx*tzi+2.*rxz*txi+rzi*txx)*urt+(2.*sxi*txz+sxx*tzi+2.*sxz*txi+szi*txx)*ust+(2.*txi*txz+txx*tzi)*utt+rxxz*ur+sxxz*us+txxz*ut
                                                                    uxyz = rzi*ryi*rxi*urrr+(szi*ryi*rxi+rzi*(rxi*syi+ryi*sxi))*urrs+(rzi*syi*sxi+szi*(rxi*syi+ryi*sxi))*urss+szi*syi*sxi*usss+(tzi*ryi*rxi+rzi*(rxi*tyi+ryi*txi))*urrt+(tzi*(rxi*syi+ryi*sxi)+szi*(rxi*tyi+ryi*txi)+rzi*(sxi*tyi+syi*txi))*urst+(szi*(sxi*tyi+syi*txi)+tzi*syi*sxi)*usst+(tzi*(rxi*tyi+ryi*txi)+rzi*tyi*txi)*urtt+(tzi*(sxi*tyi+syi*txi)+szi*tyi*txi)*ustt+tzi*tyi*txi*uttt+(rxi*ryz+rxy*rzi+rxz*ryi)*urr+(rxi*syz+rxy*szi+rxz*syi+ryi*sxz+ryz*sxi+rzi*sxy)*urs+(sxi*syz+sxy*szi+sxz*syi)*uss+(rxi*tyz+rxy*tzi+rxz*tyi+ryi*txz+ryz*txi+rzi*txy)*urt+(sxi*tyz+sxy*tzi+sxz*tyi+syi*txz+syz*txi+szi*txy)*ust+(txi*tyz+txy*tzi+txz*tyi)*utt+rxyz*ur+sxyz*us+txyz*ut
                                                                    uyyz = rzi*ryi**2*urrr+(ryi**2*szi+2.*ryi*rzi*syi)*urrs+(2.*ryi*syi*szi+rzi*syi**2)*urss+szi*syi**2*usss+(ryi**2*tzi+2.*ryi*rzi*tyi)*urrt+(2.*ryi*syi*tzi+2.*ryi*szi*tyi+2.*rzi*syi*tyi)*urst+(syi**2*tzi+2.*syi*szi*tyi)*usst+(2.*ryi*tyi*tzi+rzi*tyi**2)*urtt+(2.*syi*tyi*tzi+szi*tyi**2)*ustt+tzi*tyi**2*uttt+(2.*ryi*ryz+ryy*rzi)*urr+(2.*ryi*syz+ryy*szi+2.*ryz*syi+rzi*syy)*urs+(2.*syi*syz+syy*szi)*uss+(2.*ryi*tyz+ryy*tzi+2.*ryz*tyi+rzi*tyy)*urt+(2.*syi*tyz+syy*tzi+2.*syz*tyi+szi*tyy)*ust+(2.*tyi*tyz+tyy*tzi)*utt+ryyz*ur+syyz*us+tyyz*ut
                                                                    uxzz = rzi**2*rxi*urrr+(szi*rzi*rxi+rzi*(rxi*szi+rzi*sxi))*urrs+(rzi*szi*sxi+szi*(rxi*szi+rzi*sxi))*urss+szi**2*sxi*usss+(tzi*rzi*rxi+rzi*(rxi*tzi+rzi*txi))*urrt+(tzi*(rxi*szi+rzi*sxi)+szi*(rxi*tzi+rzi*txi)+rzi*(sxi*tzi+szi*txi))*urst+(szi*(sxi*tzi+szi*txi)+tzi*szi*sxi)*usst+(tzi*(rxi*tzi+rzi*txi)+rzi*tzi*txi)*urtt+(tzi*(sxi*tzi+szi*txi)+szi*tzi*txi)*ustt+tzi**2*txi*uttt+(rxi*rzz+2.*rxz*rzi)*urr+(rxi*szz+2.*rxz*szi+2.*rzi*sxz+rzz*sxi)*urs+(sxi*szz+2.*sxz*szi)*uss+(rxi*tzz+2.*rxz*tzi+2.*rzi*txz+rzz*txi)*urt+(sxi*tzz+2.*sxz*tzi+2.*szi*txz+szz*txi)*ust+(txi*tzz+2.*txz*tzi)*utt+rxzz*ur+sxzz*us+txzz*ut
                                                                    uyzz = rzi**2*ryi*urrr+(szi*rzi*ryi+rzi*(ryi*szi+rzi*syi))*urrs+(rzi*szi*syi+szi*(ryi*szi+rzi*syi))*urss+szi**2*syi*usss+(tzi*rzi*ryi+rzi*(ryi*tzi+rzi*tyi))*urrt+(tzi*(ryi*szi+rzi*syi)+szi*(ryi*tzi+rzi*tyi)+rzi*(syi*tzi+szi*tyi))*urst+(szi*(syi*tzi+szi*tyi)+tzi*szi*syi)*usst+(tzi*(ryi*tzi+rzi*tyi)+rzi*tzi*tyi)*urtt+(tzi*(syi*tzi+szi*tyi)+szi*tzi*tyi)*ustt+tzi**2*tyi*uttt+(ryi*rzz+2.*ryz*rzi)*urr+(ryi*szz+2.*ryz*szi+2.*rzi*syz+rzz*syi)*urs+(syi*szz+2.*syz*szi)*uss+(ryi*tzz+2.*ryz*tzi+2.*rzi*tyz+rzz*tyi)*urt+(syi*tzz+2.*syz*tzi+2.*szi*tyz+szz*tyi)*ust+(tyi*tzz+2.*tyz*tzi)*utt+ryzz*ur+syzz*us+tyzz*ut
                                                                    uzzz = rzi**3*urrr+3.*rzi**2*szi*urrs+3.*rzi*szi**2*urss+szi**3*usss+3.*rzi**2*tzi*urrt+6.*rzi*tzi*szi*urst+3.*tzi*szi**2*usst+3.*rzi*tzi**2*urtt+3.*tzi**2*szi*ustt+tzi**3*uttt+3.*rzi*rzz*urr+(3.*rzi*szz+3.*rzz*szi)*urs+3.*szz*szi*uss+(3.*rzi*tzz+3.*rzz*tzi)*urt+(3.*szi*tzz+3.*szz*tzi)*ust+3.*tzz*tzi*utt+rzzz*ur+szzz*us+tzzz*ut
                                  ! ---------- END CURVILINEAR  ---------
                                                                    r1b =  (an1*ux43(i1,i2,i3,0)+an2*uy43(i1,i2,i3,0)+an3*uz43(i1,i2,i3,0))
                                                                    r2b =  (c2*(an1*(uxxx+uxyy+uxzz)+an2*(uxxy+uyyy+uyzz)+an3*(uxxz+uyyz+uzzz)))
                                                                    a12c = r1b - r1a
                                                                    a22c = r2b - r2a
                                                                    u(j1,j2,j3,0) = u1Save  
                                                                    u(k1,k2,k3,0) = u2Save      
                                                                    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))
                                  ! #If "curvilinear" eq "curvilinear"
                                  ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
                                  ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
                                  ! #End
                                                                end if 
                                                    f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
                                                    f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2
                                                    det = a11*a22 - a21*a12
                                                    uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
                                                    uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
                                                    if( .false. )then
                                                        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
                                                        call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
                                                        write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey
                                                    end if
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! this case done below 
                                                end if
                                              end do
                                              end do
                                              end do
                      ! ------ fill in ghost values from uTemp ----
                                              do i3=n3a,n3b
                                              do i2=n2a,n2b
                                              do i1=n1a,n1b
                                                if( mask(i1,i2,i3).gt.0 )then
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost 
                                                    u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
                                                    u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if        
                                                else if( mask(i1,i2,i3).lt.0 )then
                          ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                                    ghost = 1 
                                                    j1=i1-is1*ghost
                                                    j2=i2-is2*ghost
                                                    j3=i3-is3*ghost
                                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                                    ghost = 2
                                                    k1=i1-is1*ghost
                                                    k2=i2-is2*ghost
                                                    k3=i3-is3*ghost           
                                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                                    if( numGhost.gt.2 )then
                            !  extrap third ghost (UPW)
                                                        ghost = 3
                                                        l1=i1-is1*ghost
                                                        l2=i2-is2*ghost
                                                        l3=i3-is3*ghost           
                                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                                    end if
                                                end if    
                                              end do
                                              end do
                                              end do
                                            if( checkCoeff.eq.1 )then
                                                write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," curvilinear 4")') t,side,axis,maxDiff
                                            end if
                                end if
                            end if     
                        end if

                else if( orderOfAccuracy.eq.6 )then   
                    stop 666
                else if( orderOfAccuracy.eq.8 )then   
                    stop 888
                else

                    write(*,'("CgWave::bcOpt:ERROR:neumann CBC unexpected orderOfAccuracy=",i6)') orderOfAccuracy
                  stop 8888
                end if

            else ! one-sided 
                if( orderOfAccuracy.eq.2 )then
             ! BC: a0*T + a1*T.n = 
             ! a0=mixedCoeff(uc,side,axis,grid)
             ! a1=mixedNormalCoeff(uc,side,axis,grid)
                          a0=0.
                          a1=1.
             ! rectangular case:
                          if( gridType.eq.rectangular )then
               ! compute the outward normal (an1,an2,an3)
                              an1 = 0.
                              an2 = 0.
                              an3 = 0.
                              if( axis.eq.0 )then
                                an1=-is
                              else if( axis.eq.1 )then
                                an2=-is
                              else
                                an3=-is
                              end if
                              dxn=dx(axis)
                              b0=-4.*dxn*a0/a1-10./3.
                              b1=4.*(dxn/a1)
                          end if
                          ff=0.
                            do i3=n3a,n3b
                            do i2=n2a,n2b
                            do i1=n1a,n1b
              ! first ghost pt:
                            j1=i1-is1
                            j2=i2-is2
                            j3=i3-is3
              ! 2nd ghost:
                            k1=j1-is1
                            k2=j2-is2
                            k3=j3-is3
              ! 3rd ghost:
                            l1=k1-is1
                            l2=k2-is2
                            l3=k3-is3    
                            if( mask(i1,i2,i3).gt.0 )then
                                if( gridType.eq.curvilinear )then
                  ! compute the outward normal (an1,an2,an3)
                                            an1 = rsxy(i1,i2,i3,axis,0)
                                            an2 = rsxy(i1,i2,i3,axis,1)
                                            if( nd.eq.2 )then
                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                            else
                                              an3 = rsxy(i1,i2,i3,axis,2)
                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                              an3=an3*aNormi
                                            end if
                                end if
                                    if( assignTwilightZone.eq.1 )then
                    ! compute RHS from TZ
                                        if( nd.eq.2 )then
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
                                            ff = a0*ue + a1*( an1*uex + an2*uey )
                                        else
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
                                            call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
                                            ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                        end if
                                    else if( assignKnownSolutionAtBoundaries.eq.1 )then
                    ! -- we set inhomogeneous Neumann values for some known solutions 
                                        if( knownSolutionOption.eq.planeWave )then
                      ! --- evaluate RHS for the plane wave solution ---
                                            if( nd.eq.2 )then
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                uez   = kzPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if 
                                        else if( knownSolutionOption.eq.gaussianPlaneWave )then
                      ! Do nothing for Gaussian plane wave solution for now
                                            ff = 0.
                                        else if( knownSolutionOption.eq.boxHelmholtz ) then
                      ! --- evaluate RHS the boxHelmholtz solution ---
                                            if( nd.eq.2 )then
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
                                                uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else if( knownSolutionOption.eq.polyPeriodic ) then
                      ! --- evaluate RHS the polyPeriodic solution ---
                                            if( nd.eq.2 )then
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) ) *coswt
                                                uex = (      a1PolyPeriodic                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                        ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                uex = (      a1PolyPeriodic                                                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                                                        ) *coswt
                                                uez = (                                              c1PolyPeriodic                                                    ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else
                                            stop 9876
                                        end if 
                                    end if
                ! 2=4: 
                ! --- assign 2 ghost points using:
                !  (1) Apply Neumann BC to 4th order
                !  (2) Extrap. 2nd ghost to 5th order
                                if( gridType.eq.rectangular )then
                  ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
                                    if( orderOfAccuracy.eq.2 )then
                    ! --- NEUMANN 2=2 rectangular ---
                    !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
                    !  *check me* 
                                        b0 = -2.*dxn*a0/a1 
                                        b1 =  2.*dxn/a1 
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*ff
                                    else 
                   !  --- NEUMANN 2=4 rectangular ---
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.+b1*ff
                                    end if
                                else 
                  ! ------ curvilinear grid: -------
                  ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                  ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                  ! =>
                  !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                                    if( orderOfAccuracy.eq.2 )then
                    ! ----- NEUMANN 2=2 curvilinear ----
                    ! ur = ( u(i+1) - u(i-1) )/2*dr
                    ! ur = ur0 -> 
                    ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                    ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                        urv(0) = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
                                        urv(1) = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                          ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                      end if
                                      u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                                    else
                    ! ---- NEUMANN 2 4 curvilinear ----
                    !       d14(kd) = 1./(12.*dr(kd))
                    !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
                    !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)
                    ! ur = f -> 
                    ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
                    ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)
                    ! A - B = 
                    !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 
                                        urv(0) = (u(i1-2,i2,i3,uc)-8.*u(i1-1,i2,i3,uc)+8.*u(i1+1,i2,i3,uc)-u(i1+2,i2,i3,uc))/(12.*dr(0))
                                        urv(1) = (u(i1,i2-2,i3,uc)-8.*u(i1,i2-1,i3,uc)+8.*u(i1,i2+1,i3,uc)-u(i1,i2+2,i3,uc))/(12.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (u(i1,i2,i3-2,uc)-8.*u(i1,i2,i3-1,uc)+8.*u(i1,i2,i3+1,uc)-u(i1,i2,i3+2,uc))/(12.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                        end if
                                        u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-4.*is*dr(axis)*ur0
                                    end if ! order =4 
                                end if ! curvilinear grid 
                ! ----- Assign extra ghost ----
                                if( orderOfAccuracy.eq.2) then
                                    if( numGhost.gt.1 )then
                    ! extrap second ghost (UPW)
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                  ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
                  ! extrap second ghost
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost (UPW)
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777        
                                end if
                            else if( mask(i1,i2,i3).lt.0 )then
                ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                if( orderOfAccuracy.eq.2 )then
                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                    if( numGhost.gt.1 )then
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost 
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777
                                end if
                            end if
                            end do
                            end do
                            end do

                else if( orderOfAccuracy.eq.4 )then
             ! BC: a0*T + a1*T.n = 
             ! a0=mixedCoeff(uc,side,axis,grid)
             ! a1=mixedNormalCoeff(uc,side,axis,grid)
                          a0=0.
                          a1=1.
             ! rectangular case:
                          if( gridType.eq.rectangular )then
               ! compute the outward normal (an1,an2,an3)
                              an1 = 0.
                              an2 = 0.
                              an3 = 0.
                              if( axis.eq.0 )then
                                an1=-is
                              else if( axis.eq.1 )then
                                an2=-is
                              else
                                an3=-is
                              end if
                              dxn=dx(axis)
                              b0=-4.*dxn*a0/a1-10./3.
                              b1=4.*(dxn/a1)
                          end if
                          ff=0.
                            do i3=n3a,n3b
                            do i2=n2a,n2b
                            do i1=n1a,n1b
              ! first ghost pt:
                            j1=i1-is1
                            j2=i2-is2
                            j3=i3-is3
              ! 2nd ghost:
                            k1=j1-is1
                            k2=j2-is2
                            k3=j3-is3
              ! 3rd ghost:
                            l1=k1-is1
                            l2=k2-is2
                            l3=k3-is3    
                            if( mask(i1,i2,i3).gt.0 )then
                                if( gridType.eq.curvilinear )then
                  ! compute the outward normal (an1,an2,an3)
                                            an1 = rsxy(i1,i2,i3,axis,0)
                                            an2 = rsxy(i1,i2,i3,axis,1)
                                            if( nd.eq.2 )then
                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                            else
                                              an3 = rsxy(i1,i2,i3,axis,2)
                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                              an3=an3*aNormi
                                            end if
                                end if
                                    if( assignTwilightZone.eq.1 )then
                    ! compute RHS from TZ
                                        if( nd.eq.2 )then
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
                                            ff = a0*ue + a1*( an1*uex + an2*uey )
                                        else
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
                                            call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
                                            ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                        end if
                                    else if( assignKnownSolutionAtBoundaries.eq.1 )then
                    ! -- we set inhomogeneous Neumann values for some known solutions 
                                        if( knownSolutionOption.eq.planeWave )then
                      ! --- evaluate RHS for the plane wave solution ---
                                            if( nd.eq.2 )then
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                uez   = kzPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if 
                                        else if( knownSolutionOption.eq.gaussianPlaneWave )then
                      ! Do nothing for Gaussian plane wave solution for now
                                            ff = 0.
                                        else if( knownSolutionOption.eq.boxHelmholtz ) then
                      ! --- evaluate RHS the boxHelmholtz solution ---
                                            if( nd.eq.2 )then
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
                                                uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else if( knownSolutionOption.eq.polyPeriodic ) then
                      ! --- evaluate RHS the polyPeriodic solution ---
                                            if( nd.eq.2 )then
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) ) *coswt
                                                uex = (      a1PolyPeriodic                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                        ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                uex = (      a1PolyPeriodic                                                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                                                        ) *coswt
                                                uez = (                                              c1PolyPeriodic                                                    ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else
                                            stop 9876
                                        end if 
                                    end if
                ! 4=4: 
                ! --- assign 2 ghost points using:
                !  (1) Apply Neumann BC to 4th order
                !  (2) Extrap. 2nd ghost to 5th order
                                if( gridType.eq.rectangular )then
                  ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
                                    if( orderOfAccuracy.eq.2 )then
                    ! --- NEUMANN 4=2 rectangular ---
                    !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
                    !  *check me* 
                                        b0 = -2.*dxn*a0/a1 
                                        b1 =  2.*dxn/a1 
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*ff
                                    else 
                   !  --- NEUMANN 4=4 rectangular ---
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.+b1*ff
                                    end if
                                else 
                  ! ------ curvilinear grid: -------
                  ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                  ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                  ! =>
                  !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                                    if( orderOfAccuracy.eq.2 )then
                    ! ----- NEUMANN 4=2 curvilinear ----
                    ! ur = ( u(i+1) - u(i-1) )/2*dr
                    ! ur = ur0 -> 
                    ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                    ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                        urv(0) = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
                                        urv(1) = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                          ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                      end if
                                      u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                                    else
                    ! ---- NEUMANN 4 4 curvilinear ----
                    !       d14(kd) = 1./(12.*dr(kd))
                    !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
                    !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)
                    ! ur = f -> 
                    ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
                    ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)
                    ! A - B = 
                    !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 
                                        urv(0) = (u(i1-2,i2,i3,uc)-8.*u(i1-1,i2,i3,uc)+8.*u(i1+1,i2,i3,uc)-u(i1+2,i2,i3,uc))/(12.*dr(0))
                                        urv(1) = (u(i1,i2-2,i3,uc)-8.*u(i1,i2-1,i3,uc)+8.*u(i1,i2+1,i3,uc)-u(i1,i2+2,i3,uc))/(12.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (u(i1,i2,i3-2,uc)-8.*u(i1,i2,i3-1,uc)+8.*u(i1,i2,i3+1,uc)-u(i1,i2,i3+2,uc))/(12.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                        end if
                                        u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-4.*is*dr(axis)*ur0
                                    end if ! order =4 
                                end if ! curvilinear grid 
                ! ----- Assign extra ghost ----
                                if( orderOfAccuracy.eq.2) then
                                    if( numGhost.gt.1 )then
                    ! extrap second ghost (UPW)
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                  ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
                  ! extrap second ghost
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost (UPW)
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777        
                                end if
                            else if( mask(i1,i2,i3).lt.0 )then
                ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                if( orderOfAccuracy.eq.2 )then
                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                    if( numGhost.gt.1 )then
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost 
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777
                                end if
                            end if
                            end do
                            end do
                            end do

                else if( orderOfAccuracy.eq.6 )then   
             ! BC: a0*T + a1*T.n = 
             ! a0=mixedCoeff(uc,side,axis,grid)
             ! a1=mixedNormalCoeff(uc,side,axis,grid)
                          a0=0.
                          a1=1.
             ! rectangular case:
                          if( gridType.eq.rectangular )then
               ! compute the outward normal (an1,an2,an3)
                              an1 = 0.
                              an2 = 0.
                              an3 = 0.
                              if( axis.eq.0 )then
                                an1=-is
                              else if( axis.eq.1 )then
                                an2=-is
                              else
                                an3=-is
                              end if
                              dxn=dx(axis)
                              b0=-4.*dxn*a0/a1-10./3.
                              b1=4.*(dxn/a1)
                          end if
                          ff=0.
                            do i3=n3a,n3b
                            do i2=n2a,n2b
                            do i1=n1a,n1b
              ! first ghost pt:
                            j1=i1-is1
                            j2=i2-is2
                            j3=i3-is3
              ! 2nd ghost:
                            k1=j1-is1
                            k2=j2-is2
                            k3=j3-is3
              ! 3rd ghost:
                            l1=k1-is1
                            l2=k2-is2
                            l3=k3-is3    
                            if( mask(i1,i2,i3).gt.0 )then
                                if( gridType.eq.curvilinear )then
                  ! compute the outward normal (an1,an2,an3)
                                            an1 = rsxy(i1,i2,i3,axis,0)
                                            an2 = rsxy(i1,i2,i3,axis,1)
                                            if( nd.eq.2 )then
                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                            else
                                              an3 = rsxy(i1,i2,i3,axis,2)
                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                              an3=an3*aNormi
                                            end if
                                end if
                                    if( assignTwilightZone.eq.1 )then
                    ! compute RHS from TZ
                                        if( nd.eq.2 )then
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
                                            ff = a0*ue + a1*( an1*uex + an2*uey )
                                        else
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
                                            call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
                                            ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                        end if
                                    else if( assignKnownSolutionAtBoundaries.eq.1 )then
                    ! -- we set inhomogeneous Neumann values for some known solutions 
                                        if( knownSolutionOption.eq.planeWave )then
                      ! --- evaluate RHS for the plane wave solution ---
                                            if( nd.eq.2 )then
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                uez   = kzPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if 
                                        else if( knownSolutionOption.eq.gaussianPlaneWave )then
                      ! Do nothing for Gaussian plane wave solution for now
                                            ff = 0.
                                        else if( knownSolutionOption.eq.boxHelmholtz ) then
                      ! --- evaluate RHS the boxHelmholtz solution ---
                                            if( nd.eq.2 )then
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
                                                uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else if( knownSolutionOption.eq.polyPeriodic ) then
                      ! --- evaluate RHS the polyPeriodic solution ---
                                            if( nd.eq.2 )then
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) ) *coswt
                                                uex = (      a1PolyPeriodic                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                        ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                uex = (      a1PolyPeriodic                                                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                                                        ) *coswt
                                                uez = (                                              c1PolyPeriodic                                                    ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else
                                            stop 9876
                                        end if 
                                    end if
                ! 6=4: 
                ! --- assign 2 ghost points using:
                !  (1) Apply Neumann BC to 4th order
                !  (2) Extrap. 2nd ghost to 5th order
                                if( gridType.eq.rectangular )then
                  ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
                                    if( orderOfAccuracy.eq.2 )then
                    ! --- NEUMANN 6=2 rectangular ---
                    !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
                    !  *check me* 
                                        b0 = -2.*dxn*a0/a1 
                                        b1 =  2.*dxn/a1 
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*ff
                                    else 
                   !  --- NEUMANN 6=4 rectangular ---
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.+b1*ff
                                    end if
                                else 
                  ! ------ curvilinear grid: -------
                  ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                  ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                  ! =>
                  !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                                    if( orderOfAccuracy.eq.2 )then
                    ! ----- NEUMANN 6=2 curvilinear ----
                    ! ur = ( u(i+1) - u(i-1) )/2*dr
                    ! ur = ur0 -> 
                    ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                    ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                        urv(0) = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
                                        urv(1) = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                          ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                      end if
                                      u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                                    else
                    ! ---- NEUMANN 6 4 curvilinear ----
                    !       d14(kd) = 1./(12.*dr(kd))
                    !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
                    !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)
                    ! ur = f -> 
                    ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
                    ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)
                    ! A - B = 
                    !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 
                                        urv(0) = (u(i1-2,i2,i3,uc)-8.*u(i1-1,i2,i3,uc)+8.*u(i1+1,i2,i3,uc)-u(i1+2,i2,i3,uc))/(12.*dr(0))
                                        urv(1) = (u(i1,i2-2,i3,uc)-8.*u(i1,i2-1,i3,uc)+8.*u(i1,i2+1,i3,uc)-u(i1,i2+2,i3,uc))/(12.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (u(i1,i2,i3-2,uc)-8.*u(i1,i2,i3-1,uc)+8.*u(i1,i2,i3+1,uc)-u(i1,i2,i3+2,uc))/(12.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                        end if
                                        u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-4.*is*dr(axis)*ur0
                                    end if ! order =4 
                                end if ! curvilinear grid 
                ! ----- Assign extra ghost ----
                                if( orderOfAccuracy.eq.2) then
                                    if( numGhost.gt.1 )then
                    ! extrap second ghost (UPW)
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                  ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
                  ! extrap second ghost
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost (UPW)
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777        
                                end if
                            else if( mask(i1,i2,i3).lt.0 )then
                ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                if( orderOfAccuracy.eq.2 )then
                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                    if( numGhost.gt.1 )then
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost 
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777
                                end if
                            end if
                            end do
                            end do
                            end do

                else if( orderOfAccuracy.eq.8 )then   

             ! BC: a0*T + a1*T.n = 
             ! a0=mixedCoeff(uc,side,axis,grid)
             ! a1=mixedNormalCoeff(uc,side,axis,grid)
                          a0=0.
                          a1=1.
             ! rectangular case:
                          if( gridType.eq.rectangular )then
               ! compute the outward normal (an1,an2,an3)
                              an1 = 0.
                              an2 = 0.
                              an3 = 0.
                              if( axis.eq.0 )then
                                an1=-is
                              else if( axis.eq.1 )then
                                an2=-is
                              else
                                an3=-is
                              end if
                              dxn=dx(axis)
                              b0=-4.*dxn*a0/a1-10./3.
                              b1=4.*(dxn/a1)
                          end if
                          ff=0.
                            do i3=n3a,n3b
                            do i2=n2a,n2b
                            do i1=n1a,n1b
              ! first ghost pt:
                            j1=i1-is1
                            j2=i2-is2
                            j3=i3-is3
              ! 2nd ghost:
                            k1=j1-is1
                            k2=j2-is2
                            k3=j3-is3
              ! 3rd ghost:
                            l1=k1-is1
                            l2=k2-is2
                            l3=k3-is3    
                            if( mask(i1,i2,i3).gt.0 )then
                                if( gridType.eq.curvilinear )then
                  ! compute the outward normal (an1,an2,an3)
                                            an1 = rsxy(i1,i2,i3,axis,0)
                                            an2 = rsxy(i1,i2,i3,axis,1)
                                            if( nd.eq.2 )then
                                              aNormi = (-is)/sqrt(an1**2+an2**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                            else
                                              an3 = rsxy(i1,i2,i3,axis,2)
                                              aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
                                              an1=an1*aNormi
                                              an2=an2*aNormi
                                              an3=an3*aNormi
                                            end if
                                end if
                                    if( assignTwilightZone.eq.1 )then
                    ! compute RHS from TZ
                                        if( nd.eq.2 )then
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
                                            ff = a0*ue + a1*( an1*uex + an2*uey )
                                        else
                                            call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
                                            call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
                                            call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
                                            call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
                                            ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                        end if
                                    else if( assignKnownSolutionAtBoundaries.eq.1 )then
                    ! -- we set inhomogeneous Neumann values for some known solutions 
                                        if( knownSolutionOption.eq.planeWave )then
                      ! --- evaluate RHS for the plane wave solution ---
                                            if( nd.eq.2 )then
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
                                                uex   = kxPlaneWave*cosPW
                                                uey   = kyPlaneWave*cosPw
                                                uez   = kzPlaneWave*cosPw
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if 
                                        else if( knownSolutionOption.eq.gaussianPlaneWave )then
                      ! Do nothing for Gaussian plane wave solution for now
                                            ff = 0.
                                        else if( knownSolutionOption.eq.boxHelmholtz ) then
                      ! --- evaluate RHS the boxHelmholtz solution ---
                                            if( nd.eq.2 )then
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
                                                uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
                                                uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
                                                uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else if( knownSolutionOption.eq.polyPeriodic ) then
                      ! --- evaluate RHS the polyPeriodic solution ---
                                            if( nd.eq.2 )then
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) ) *coswt
                                                uex = (      a1PolyPeriodic                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                        ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey )
                                            else
                                                ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
                                                uex = (      a1PolyPeriodic                                                                                            ) *coswt
                                                uey = (                          b1PolyPeriodic                                                                        ) *coswt
                                                uez = (                                              c1PolyPeriodic                                                    ) *coswt
                                                ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
                                            end if
                                        else
                                            stop 9876
                                        end if 
                                    end if
                ! 8=4: 
                ! --- assign 2 ghost points using:
                !  (1) Apply Neumann BC to 4th order
                !  (2) Extrap. 2nd ghost to 5th order
                                if( gridType.eq.rectangular )then
                  ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
                                    if( orderOfAccuracy.eq.2 )then
                    ! --- NEUMANN 8=2 rectangular ---
                    !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
                    !  *check me* 
                                        b0 = -2.*dxn*a0/a1 
                                        b1 =  2.*dxn/a1 
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)+ b1*ff
                                    else 
                   !  --- NEUMANN 8=4 rectangular ---
                                        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.+b1*ff
                                    end if
                                else 
                  ! ------ curvilinear grid: -------
                  ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
                  ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
                  ! =>
                  !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 
                                    if( orderOfAccuracy.eq.2 )then
                    ! ----- NEUMANN 8=2 curvilinear ----
                    ! ur = ( u(i+1) - u(i-1) )/2*dr
                    ! ur = ur0 -> 
                    ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
                    ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 
                                        urv(0) = (-u(i1-1,i2,i3,uc)+u(i1+1,i2,i3,uc))/(2.*dr(0))
                                        urv(1) = (-u(i1,i2-1,i3,uc)+u(i1,i2+1,i3,uc))/(2.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (-u(i1,i2,i3-1,uc)+u(i1,i2,i3+1,uc))/(2.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                          ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                      end if
                                      u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0
                                    else
                    ! ---- NEUMANN 8 4 curvilinear ----
                    !       d14(kd) = 1./(12.*dr(kd))
                    !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
                    !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)
                    ! ur = f -> 
                    ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
                    ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)
                    ! A - B = 
                    !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 
                                        urv(0) = (u(i1-2,i2,i3,uc)-8.*u(i1-1,i2,i3,uc)+8.*u(i1+1,i2,i3,uc)-u(i1+2,i2,i3,uc))/(12.*dr(0))
                                        urv(1) = (u(i1,i2-2,i3,uc)-8.*u(i1,i2-1,i3,uc)+8.*u(i1,i2+1,i3,uc)-u(i1,i2+2,i3,uc))/(12.*dr(1))
                                        if( nd.eq.2 )then
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )
                                            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
                                        else
                                            urv(2) = (u(i1,i2,i3-2,uc)-8.*u(i1,i2,i3-1,uc)+8.*u(i1,i2,i3+1,uc)-u(i1,i2,i3+2,uc))/(12.*dr(2))
                                            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
                                            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
                                            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
                                            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
                                        end if
                                        u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)+6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)-4.*is*dr(axis)*ur0
                                    end if ! order =4 
                                end if ! curvilinear grid 
                ! ----- Assign extra ghost ----
                                if( orderOfAccuracy.eq.2) then
                                    if( numGhost.gt.1 )then
                    ! extrap second ghost (UPW)
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))          
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                  ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
                  ! extrap second ghost
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost (UPW)
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777        
                                end if
                            else if( mask(i1,i2,i3).lt.0 )then
                ! ----- extrap ghost outside interp. pts on physical boundaries ------
                                if( orderOfAccuracy.eq.2 )then
                                    u(j1,j2,j3,uc)=(3.*u(i1,i2,i3,uc)-3.*u(i1+is1,i2+is2,i3+is3,uc)+u(i1+2*is1,i2+2*is2,i3+2*is3,uc))
                                    if( numGhost.gt.1 )then
                                        u(k1,k2,k3,uc)=(3.*u(j1,j2,j3,uc)-3.*u(j1+is1,j2+is2,j3+is3,uc)+u(j1+2*is1,j2+2*is2,j3+2*is3,uc))
                                    end if
                                else if( orderOfAccuracy.eq.4 )then
                                    u(j1,j2,j3,uc)=(5.*u(i1,i2,i3,uc)-10.*u(i1+is1,i2+is2,i3+is3,uc)+10.*u(i1+2*is1,i2+2*is2,i3+2*is3,uc)-5.*u(i1+3*is1,i2+3*is2,i3+3*is3,uc)+u(i1+4*is1,i2+4*is2,i3+4*is3,uc))
                                    u(k1,k2,k3,uc)=(5.*u(j1,j2,j3,uc)-10.*u(j1+is1,j2+is2,j3+is3,uc)+10.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)-5.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)+u(j1+4*is1,j2+4*is2,j3+4*is3,uc))
                                    if( numGhost.gt.2 )then
                    !  extrap third ghost 
                                        u(l1,l2,l3,uc)=(5.*u(k1,k2,k3,uc)-10.*u(k1+is1,k2+is2,k3+is3,uc)+10.*u(k1+2*is1,k2+2*is2,k3+2*is3,uc)-5.*u(k1+3*is1,k2+3*is2,k3+3*is3,uc)+u(k1+4*is1,k2+4*is2,k3+4*is3,uc))            
                                    end if
                                else
                                    write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
                                    stop 7777
                                end if
                            end if
                            end do
                            end do
                            end do
                else

                    write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
                    stop 8888
                end if
            end if


        else if(  boundaryCondition(side,axis).eq.dirichlet .or. boundaryCondition(side,axis).eq.exactBC .or. boundaryCondition(side,axis).le.0 )then
      ! do nothing

        else
            write(*,'("bcOptWave: unexpected boundaryCondition=",i4)') boundaryCondition(side,axis)
            stop 5151
        end if 

      end do ! end side
      end do ! end axis

  !  --- Assign ghost points outside corners ---
    if( .false. .and. orderOfAccuracy.eq.6 .and. nd.eq.2 .and. gridType.eq.rectangular )then
        if( forcingOption.eq.noForcing )then
        ! ---------------------------------
        ! --- assign corners and edges: ---
        ! ---------------------------------
                if( nd.eq.2 )then
          ! --- TWO DIMENSIONS ----
                    do side2=0,1
                    do side1=0,1
                        if( boundaryCondition(side1,0).gt.0 .and. boundaryCondition(side2,1).gt.0 )then
              ! **fix me** for exact BCs
                            if( ( boundaryCondition(side1,0).ne.dirichlet .and. boundaryCondition(side1,0).ne.neumann ) .or. ( boundaryCondition(side2,1).ne.dirichlet .and. boundaryCondition(side2,1).ne.neumann ) )then
                                write(*,*) "Un-supported corner bcs =",boundaryCondition(side1,0),boundaryCondition(side2,1)
                                stop 2222
                            end if
                            symSign = +1. ! even symmetry for D-D or N-N corners
                            if( (boundaryCondition(side1,0).eq.dirichlet .and. boundaryCondition(side2,1).eq.neumann   ) .or. (boundaryCondition(side1,0).eq.neumann   .and. boundaryCondition(side2,1).eq.dirichlet ) ) then
                                symSign=-1.;
                            end if
                            is1 = 1-2*side1
                            is2 = 1-2*side2
                            i1 = gridIndexRange(side1,0)
                            i2 = gridIndexRange(side2,1)
                            i3 = gridIndexRange(    0,2)
                            do m2=0,numGhost
                            do m1=0,numGhost
                                j1 = i1-is1*m1; j2=i2-is2*m2; j3=i3; ! ghost 
                                k1 = i1+is1*m1; k2=i2+is2*m2; k3=i3; ! interior point 
                                u(j1,j2,j3,0) = symSign*u(k1,k2,k3,0)
                            end do
                            end do
                        end if 
                    end do
                    end do
                else
          ! --- THREE DIMENSIONS ----
                    write(*,*) "symmetry corners -- finish me in 3D"
                    stop 9999
                    do side3=0,1
                    do side2=0,1
                    do side1=0,1
                    end do
                    end do
                    end do
                end if
        else
        ! ---------------------------------
        ! --- assign corners and edges: ---
        ! ---------------------------------
                if( nd.eq.2 )then
          ! --- TWO DIMENSIONS ----
                    do side2=0,1
                    do side1=0,1
                        if( boundaryCondition(side1,0).gt.0 .and. boundaryCondition(side2,1).gt.0 )then
              ! **fix me** for exact BCs
                            if( ( boundaryCondition(side1,0).ne.dirichlet .and. boundaryCondition(side1,0).ne.neumann ) .or. ( boundaryCondition(side2,1).ne.dirichlet .and. boundaryCondition(side2,1).ne.neumann ) )then
                                write(*,*) "Un-supported corner bcs =",boundaryCondition(side1,0),boundaryCondition(side2,1)
                                stop 2222
                            end if
                            symSign = +1. ! even symmetry for D-D or N-N corners
                            if( (boundaryCondition(side1,0).eq.dirichlet .and. boundaryCondition(side2,1).eq.neumann   ) .or. (boundaryCondition(side1,0).eq.neumann   .and. boundaryCondition(side2,1).eq.dirichlet ) ) then
                                symSign=-1.;
                            end if
                            is1 = 1-2*side1
                            is2 = 1-2*side2
                            i1 = gridIndexRange(side1,0)
                            i2 = gridIndexRange(side2,1)
                            i3 = gridIndexRange(    0,2)
                            do m2=0,numGhost
                            do m1=0,numGhost
                                j1 = i1-is1*m1; j2=i2-is2*m2; j3=i3; ! ghost 
                                k1 = i1+is1*m1; k2=i2+is2*m2; k3=i3; ! interior point 
                                u(j1,j2,j3,0) = symSign*u(k1,k2,k3,0)
                                    if( assignTwilightZone.eq.1 )then
                                                call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
                                                call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
                                        u(j1,j2,j3,0) = u(j1,j2,j3,0) + ue1 - symSign*ue2 
                                    else
                    ! finish me 
                                    end if
                            end do
                            end do
                        end if 
                    end do
                    end do
                else
          ! --- THREE DIMENSIONS ----
                    write(*,*) "symmetry corners -- finish me in 3D"
                    stop 9999
                    do side3=0,1
                    do side2=0,1
                    do side1=0,1
                    end do
                    end do
                    end do
                end if
        end if
    else
      ! ---------------------------------
      ! --- assign corners and edges: ---
      ! ---------------------------------
     ! From op/src/BoundaryConditionParameters.h
     ! enum CornerBoundaryConditionEnum
     !  {
     !    doNothingCorner=-1,  
     !    extrapolateCorner=0,
     !    symmetryCorner,  // should be replaced by the one of the odd,even below -- keep for compatibility
     !    taylor2ndOrder,  // should be replaced by the taylor2ndOrderOddCorner below -- keep for compatibility
     !    evenSymmetryCorner,
     !    oddSymmetryCorner,
     !    taylor2ndOrderEvenCorner,
     !    taylor4thOrderEvenCorner,
     !    vectorSymmetryAxis1Corner,       // even symmetry on all variables except normal component of the "velocity"
     !    vectorSymmetryAxis2Corner, 
     !    vectorSymmetryAxis3Corner
     !  };
            do side3=0,2
            do side2=0,2
            do side1=0,2
                if( orderOfAccuracy.ge.4. .and. boundaryCondition(side1,0).eq.neumann .and. boundaryCondition(side2,1).eq.neumann .and. ( nd.eq.2 .or. boundaryCondition(side3,2).eq.neumann ) )then
          ! ---- This is a Neumann-Neumann corner ----
                    cornerBC(side1,side2,side3)=extrapolateCorner
          ! if( t.le.2*dt  )then
          !   write(*,'("Assign special Neumann corners conditions ")')
          ! end if
          ! cornerBC(side1,side2,side3)=taylor4thOrderEvenCorner
          ! cornerBC(side1,side2,side3)=evenSymmetryCorner
          ! cornerBC(side1,side2,side3)=0 
                else if(            boundaryCondition(side1,0).eq.exactBC .and. boundaryCondition(side2,1).eq.exactBC .and. ( nd.eq.2 .or. boundaryCondition(side3,2).eq.exactBC ) )then
          ! ---- Do nothing at this exact corner 
                    cornerBC(side1,side2,side3)=-1
                else 
                    cornerBC(side1,side2,side3)=0         ! extrapolateCorner=0, (BoundaryConditionParameters)
                end if 
            end do
            end do
            end do
      ! orderOfExtrapolationForCorners=5
            orderOfExtrapolationForCorners= orderOfAccuracy+1
            iparc(0)=uc
            iparc(1)=uc
            iparc(2)=0                              ! useWhereMask;
            iparc(3)=orderOfExtrapolationForCorners
            iparc(4)=numGhost                       ! numberOfCornerGhostLinesToAssign
            iparc(5)=0                              ! cornerExtrapolationOption : 0=extrap along diagonals
            iparc(6)=0                              ! vectorSymmetryCornerComponent
            iparc(7)=gridType
            rparc(0)=epsx ! normEps
      ! Note: is it ok to use gridIndexRange instead of indexRange here: ??
            call fixBoundaryCornersOpt( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,0,uc,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, u,mask,rsxy, gridIndexRange, dimRange, isPeriodic, boundaryCondition, cornerBC, iparc, rparc )
    end if

    return
    end

