! ==================================================================================
!
!        Optimized Assign Boundary Conditions for CgWave
!        -----------------------------------------------
!
! ==================================================================================


! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
#Include "defineDiffOrder2f.h"
#Include "defineDiffOrder4f.h"

#Include "knownSolutionMacros.h"

! define macros to evaluate higher derivatives (from maple/makeGetDerivativesMacros.maple)
!! ** June 13, 2023 : TURN OFF ??
! #Include "../maple/defineGetDerivativesMacros.h"

! NEW VERSION WITH DISTINCTIVE NAMES: *bug fixed: Nov 24, 2023
#Include "../maple/defineGetThirdDerivativesMacros.h"



! define macros to evaluate derivatives for the 6th order method (from maple/makeGetDerivativesMacros.maple)
!! turned off May 4, 2023
!! #Include "../maple/defineGetSixthDerivativesMacros.h"


! From bcOptSmFOS.bf
! DataBase *pdb = &parameters.dbase;
! double precision pdb  ! pointer to data base
! ====================================================================
! Look up an integer parameter from the data base
! ====================================================================
#beginMacro getIntParameter(name)
 ok=getInt(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** bcOptWave:getInt:ERROR: unable to find name")') 
   stop 1122
 end if
#endMacro

! ====================================================================
! Look up a real parameter from the data base
! ====================================================================
#beginMacro getRealParameter(name)
 ok=getReal(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** bcOptWave:getReal:ERROR: unable to find name")') 
   stop 1133
 end if
#endMacro



! General begin loops macro
#beginMacro beginLoops(n1a,n1b,n2a,n2b,n3a,n3b)
do i3=n3a,n3b
do i2=n2a,n2b
do i1=n1a,n1b
#endMacro

#beginMacro endLoops()
end do
end do
end do
#endMacro


#beginMacro beginLoops2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro
#beginMacro endLoops2d()
 end do
 end do
#endMacro

#beginMacro beginLoopsMask2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro
#beginMacro endLoopsMask2d()
 end if
 end do
 end do
#endMacro

#beginMacro beginGhostLoops2d()
 i3=n3a
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

#beginMacro beginLoops3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro

#beginMacro endLoops3d()
 end do
 end do
 end do
#endMacro

#beginMacro beginLoopsMask3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro

#beginMacro endLoopsMask3d()
 end if
 end do
 end do
 end do
#endMacro

#beginMacro beginGhostLoops3d()
 do i3=nn3a,nn3b
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

! ----- define extrapolation formulae ------

#defineMacro extrap2(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   2.*uu(k1,k2,k3,kc)\
                  -uu(k1+  ks1,k2+  ks2,k3+  ks3,kc))

#defineMacro extrap3(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   3.*uu(k1,k2,k3,kc)\
               -3.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
                  +uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc))

#defineMacro extrap4(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   4.*uu(k1,k2,k3,kc)\
               -6.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
               +4.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
                  -uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc))

#defineMacro extrap5(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   5.*uu(k1,k2,k3,kc)\
              -10.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +10.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
               -5.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
                  +uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc))

#defineMacro extrap6(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   6.*uu(k1,k2,k3,kc)\
              -15.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +20.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -15.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
               +6.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
               -   uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc) )

#defineMacro extrap7(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   7.*uu(k1,k2,k3,kc)\
              -21.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +35.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -35.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
              +21.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
               -7.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
                +  uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc) )

#defineMacro extrap8(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   8.*uu(k1,k2,k3,kc)\
              -28.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +56.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -70.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
              +56.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
              -28.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
               +8.*uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc)\
                -  uu(k1+7*ks1,k2+7*ks2,k3+7*ks3,kc) )

#defineMacro extrap9(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   9.*uu(k1,k2,k3,kc)\
              -36.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +84.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
             -126.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
             +126.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
              -84.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
              +36.*uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc)\
               -9.*uu(k1+7*ks1,k2+7*ks2,k3+7*ks3,kc)\
                  +uu(k1+8*ks1,k2+8*ks2,k3+8*ks3,kc) )            



! ************************************************************************************************
!  This macro is used for looping over the faces of a grid to assign booundary conditions
!
! extra: extra points to assign
!          Case 1: extra=numberOfGhostPoints -- for assigning extended boundaries
!          Case 2: extra=-1 -- for assigning ghost points but not including extended boundaries
! numberOfGhostPoints : number of ghost points (1 for 2nd order, 2 for fourth-order ...)
!
!
! Output:
!  n1a,n1b,n2a,n2b,n3a,n3b : from gridIndexRange
!  nn1a,nn1b,nn2a,nn2b,nn3a,nn3b : includes "extra" points
! 
! ***********************************************************************************************
#beginMacro beginLoopOverSides(extra,numberOfGhostPoints)
 extra1a=extra
 extra1b=extra
 extra2a=extra
 extra2b=extra
 if( nd.eq.3 )then
   extra3a=extra
   extra3b=extra
 else
   extra3a=0
   extra3b=0
 end if
 if( bc(0,0).lt.0 )then
   extra1a=max(0,extra1a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( bc(0,0).eq.0 )then
   extra1a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( bc(1,0).lt.0 )then
   extra1b=max(0,extra1b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( bc(1,0).eq.0 )then
   extra1b=numberOfGhostPoints
 end if

 if( bc(0,1).lt.0 )then
   extra2a=max(0,extra2a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( bc(0,1).eq.0 )then
   extra2a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( bc(1,1).lt.0 )then
   extra2b=max(0,extra2b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( bc(1,1).eq.0 )then
   extra2b=numberOfGhostPoints
 end if

 if(  nd.eq.3 )then
  if( bc(0,2).lt.0 )then
    extra3a=max(0,extra3a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
  else if( bc(0,2).eq.0 )then
    extra3a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
  end if
  ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
  if( bc(1,2).lt.0 )then
    extra3b=max(0,extra3b) ! over-ride extra=-1 : assign ends in periodic directions
  else if( bc(1,2).eq.0 )then
    extra3b=numberOfGhostPoints
  end if
 end if

 do axis=0,nd-1
 do side=0,1

   if( .true. .or. bc(side,axis).gt.0 )then ! we may set ghost outside interp for implicit

     ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,bc(side,axis)

     n1a=gridIndexRange(0,0)
     n1b=gridIndexRange(1,0)
     n2a=gridIndexRange(0,1)
     n2b=gridIndexRange(1,1)
     n3a=gridIndexRange(0,2)
     n3b=gridIndexRange(1,2)
     if( axis.eq.0 )then
       n1a=gridIndexRange(side,axis)
       n1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       n2a=gridIndexRange(side,axis)
       n2b=gridIndexRange(side,axis)
     else
       n3a=gridIndexRange(side,axis)
       n3b=gridIndexRange(side,axis)
     end if


     nn1a=gridIndexRange(0,0)-extra1a
     nn1b=gridIndexRange(1,0)+extra1b
     nn2a=gridIndexRange(0,1)-extra2a
     nn2b=gridIndexRange(1,1)+extra2b
     nn3a=gridIndexRange(0,2)-extra3a
     nn3b=gridIndexRange(1,2)+extra3b
     if( axis.eq.0 )then
       nn1a=gridIndexRange(side,axis)
       nn1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       nn2a=gridIndexRange(side,axis)
       nn2b=gridIndexRange(side,axis)
     else
       nn3a=gridIndexRange(side,axis)
       nn3b=gridIndexRange(side,axis)
     end if

     is=1-2*side

     is1=0
     is2=0
     is3=0
     if( axis.eq.0 )then
       is1=1-2*side
     else if( axis.eq.1 )then
       is2=1-2*side
     else if( axis.eq.2 )then
       is3=1-2*side
     else
       stop 5
     end if
     
     axisp1=mod(axis+1,nd)
     axisp2=mod(axis+2,nd)
     
     i3=n3a

     if( debug.gt.31 )then
       write(*,'(" bcOptWave: grid,side,axis=",3i3,", \
         loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i5)') grid,side,axis,\
         n1a,n1b,n2a,n2b,n3a,n3b

       write(*,'(" bcOptWave: extra,extra1a,extra2a,extra3a=",4i4,", \
         loop bounds: nn1a,nn1b,nn2a,nn2b,nn3a,nn3b=",6i5)') extra,extra1a,extra2a,extra3a,\
         nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
     end if

   end if ! if bc>0 

   assignTwilightZone=twilightZone

#endMacro

#beginMacro endLoopOverSides()
 end do ! end side
 end do ! end axis
#endMacro


#beginMacro getNormal2d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2))
 an1=an1*aNormi
 an2=an2*aNormi
#endMacro

#beginMacro getNormal3d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 an3 = rsxy(i1,i2,i3,axis,2)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2+ an3**2))
 an1=an1*aNormi
 an2=an2*aNormi
 an3=an3*aNormi
#endMacro





! =========================================================================
! Compute the normal on a curvilinear grid.
!
! Assumes is=1-2*side is defined. 
! =========================================================================
#beginMacro getNormal(j1,j2,j3)
    an1 = rsxy(j1,j2,j3,axis,0)
    an2 = rsxy(j1,j2,j3,axis,1)
    if( nd.eq.2 )then
     aNormi = (-is)/sqrt(an1**2+an2**2)
     an1=an1*aNormi
     an2=an2*aNormi
    else
     an3 = rsxy(j1,j2,j3,axis,2)
     aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
     an1=an1*aNormi
     an2=an2*aNormi
     an3=an3*aNormi
    end if
#endMacro

! ========================================================================================
!  Assign ghost points outside corners
! ========================================================================================
#beginMacro assignCornerGhostsMacro()
  ! ---------------------------------
  ! --- assign corners and edges: ---
  ! ---------------------------------

 ! From op/src/BoundaryConditionParameters.h
 ! enum CornerBoundaryConditionEnum
 !  {
 !    doNothingCorner=-1,  
 !    extrapolateCorner=0,
 !    symmetryCorner,  // should be replaced by the one of the odd,even below -- keep for compatibility
 !    taylor2ndOrder,  // should be replaced by the taylor2ndOrderOddCorner below -- keep for compatibility
 !    evenSymmetryCorner,
 !    oddSymmetryCorner,
 !    taylor2ndOrderEvenCorner,
 !    taylor4thOrderEvenCorner,
 !    vectorSymmetryAxis1Corner,       // even symmetry on all variables except normal component of the "velocity"
 !    vectorSymmetryAxis2Corner, 
 !    vectorSymmetryAxis3Corner
 !  };

  if( nd.eq.3 )then
    write(*,'("assignCornerGhost -- *check me for 3D : stop here for now")')
    stop 666
  end if


  do side3=0,2
  do side2=0,2
  do side1=0,2
    cornerBC(side1,side2,side3)=0
  end do
  end do
  end do

  ! ** FIX ME :
  !   cornerBC(0:2,0:2,0:2) : 2=edge in 3D 
  do side3=0,1
  do side2=0,1
  do side1=0,1
    if( orderOfAccuracy.ge.4. .and. bc(side1,0).eq.neumann .and. \
                                    bc(side2,1).eq.neumann .and. \
                     ( nd.eq.2 .or. bc(side3,2).eq.neumann ) )then
      ! ---- This is a Neumann-Neumann corner ----
      cornerBC(side1,side2,side3)=extrapolateCorner

      ! if( t.le.2*dt  )then
      !   write(*,'("Assign special Neumann corners conditions ")')
      ! end if
      ! cornerBC(side1,side2,side3)=taylor4thOrderEvenCorner
      ! cornerBC(side1,side2,side3)=evenSymmetryCorner
      ! cornerBC(side1,side2,side3)=0 
    else if(            bc(side1,0).eq.exactBC .and. \
                        bc(side2,1).eq.exactBC .and. \
         ( nd.eq.2 .or. bc(side3,2).eq.exactBC ) )then

      ! ---- Do nothing at this exact corner 

      cornerBC(side1,side2,side3)=-1

    else 
      cornerBC(side1,side2,side3)=0         ! extrapolateCorner=0, (BoundaryConditionParameters)
    end if 
  end do
  end do
  end do

  ! orderOfExtrapolationForCorners=5
  orderOfExtrapolationForCorners= orderOfAccuracy+1

  iparc(0)=uc
  iparc(1)=uc
  iparc(2)=0                              ! useWhereMask;
  iparc(3)=orderOfExtrapolationForCorners
  iparc(4)=numGhost                       ! numberOfCornerGhostLinesToAssign
  iparc(5)=0                              ! cornerExtrapolationOption : 0=extrap along diagonals
  iparc(6)=0                              ! vectorSymmetryCornerComponent
  iparc(7)=gridType

  rparc(0)=epsx ! normEps

  ! Note: is it ok to use gridIndexRange instead of indexRange here: ??
  call fixBoundaryCornersOpt( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,0,uc,\
             nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, u,mask,rsxy, gridIndexRange, dimRange, \
             isPeriodic, boundaryCondition, cornerBC, iparc, rparc )
#endMacro




! ===================================================================================================
! Macro: Extrapolate Ghost Points 
!  WIDTH    forumala 
!   2         2 -1 
!   3         3 -3 1
!   4         4 -6 4 1
!   5         5 -10 10 -5 1
!   6
! ===================================================================================================
#beginMacro extrapolateGhost(WIDTH)

  #If #WIDTH eq "2"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap2(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #WIDTH eq "3"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap3(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #WIDTH eq "4"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap4(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #WIDTH eq "5"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap5(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #WIDTH eq "6"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap6(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #WIDTH eq "7"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap7(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #WIDTH eq "8"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap8(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #WIDTH eq "9"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap9(u,i1,i2,i3,n,is1,is2,is3)
  #Else
     write(*,'("bcOptWave: unexpected width=WIDTH")') 
    stop 1010
  #End

  ! OLD WAY: extrap all ghost, this may overwite ghost points on extended dirichlet boundaries
  ! ghost-loops will assign extra points in tangential directions
  ! if( t.le. 2*dt )then
  !    write(*,'("extrapolateGhost: side,axis=",2i3," nn1a,nn1b,nn2a,nn2b,nn3a,nn3b=",6i5)') side,axis,nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
  ! end if 
  ! beginGhostLoops3d()  

  ! New way: Exclude the ends when adjacent boundaries are dirichlet or exact: *wdh* Dec 2, 2023
  extram=numGhost
  getRestrictedLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
  if( .false. .and. t.le. 2*dt )then
    write(*,'("extrapolateGhost: grid,side,axis=",3i3," m1a,m1b,m2a,m2b,m3a,m3b=",6i5)') grid,side,axis,m1a,m1b,m2a,m2b,m3a,m3b
  end if  

  beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
  
    if( mask(i1,i2,i3).ne.0 )then
     
      ! -- extrapolate ghost ---
      do ghost=1,numGhost
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost

        u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
        ! write(*,'("extrap: u(",3i4,")=",1pe10.2)') j1,j2,j3,u(j1,j2,j3,uc)

      end do
       
    end if ! mask .ne. 0
  endLoops3d()
#endMacro


! ============================================================================================
! Macro: evaluate the solution on the boundary for Dirichlet BCs
! ============================================================================================
#beginMacro getDirichletForcing(ff,i1,i2,i3)
  if( assignTwilightZone.eq.1 )then
    ! compute RHS from TZ
    if( nd.eq.2 )then
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
    else
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
    end if
    ff = ue
  else if( assignKnownSolutionAtBoundaries.eq.1 )then
    ! -- we set inhomogeneous Dirichlet values for some known solutions 
    if( knownSolutionOption.eq.planeWave )then
      ! --- evaluate the plane wave solution ---
      if( nd.eq.2 )then
        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
      else
        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
      end if 

    else if( knownSolutionOption.eq.gaussianPlaneWave ) then
      ! Eval the Gaussian plane wave solution
      !    u = exp( -beta*(xi^2) )*cos( k0*xi )
      !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
      !  
      if( nd.eq.2 )then
        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
      else
        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
      end if 
      ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      

    else if( knownSolutionOption.eq.boxHelmholtz ) then
      ! --- evaluate the boxHelmholtz solution ---
      ! For multi-freq we add up all the component frequencies
      ff = 0. 
      do freq=0,numberOfFrequencies-1
        ! kx = kxBoxHelmholtz + twoPi*freq
        ! ky = kyBoxHelmholtz + twoPi*freq
        ! kz = kzBoxHelmholtz + twoPi*freq
        ! coswt = cos( frequencyArray(freq)*t )

        getBoxHelmholtzParameters( freq, omega, kx,ky,kz, F90 )
        coswt = cos( omega*t )
        if( nd.eq.2 )then
          ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
        else
          ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
        end if 
      end do

    else if( knownSolutionOption.eq.polyPeriodic ) then
      ! --- evaluate the polyPeriodic solution ---
      if( nd.eq.2 )then
        ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
      else
        ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
      end if 

    else
      stop 9876
    end if 
  end if
#endMacro      

! ===================================================================================================
! Macro: Assign boundary and ghost points on Dirichlet boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro assignDirichletBoundaryAndGhost(ORDER)

  #If #ORDER eq "2"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap3(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "4"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap5(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "6"
    ! #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap6(u,i1,i2,i3,n,is1,is2,is3)
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap7(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "8"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap9(u,i1,i2,i3,n,is1,is2,is3)
  #Else
     write(*,'("bcOptWave: unexpected order=ORDER")') 
    stop 1010
  #End

  ff=0.
  if( addForcingBC.eq.1 )then  
    beginLoops3d()
      if( mask(i1,i2,i3).ne.0 )then
       
        ! --- get the RHS to the Dirichlet BC ---
        getDirichletForcing(ff,i1,i2,i3)

        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=ff
    
        ! -- extrapolate ghost ---
        do ghost=1,numGhost
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost

          u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 

        end do

      end if ! mask .ne. 0
    endLoops3d()

  else

    ! --- no forcing ----
    if( numGhost.eq.1 )then
      ghost=1
      beginLoops3d()
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=0.
        ! -- extrapolate ghost ---
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost         
        u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
      endLoops3d()      
    else 
      beginLoops3d()
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=0.
        ! -- extrapolate ghost ---
        do ghost=1,numGhost
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost
          u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
        end do
      endLoops3d()
    end if

    if( .false. )then
      ! -- two loops ---
      ! --- no forcing ----
      beginLoops3d()
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=0.
      endLoops3d()

      ! -- extrapolate ghost ---
      do ghost=1,numGhost
        beginLoops3d() 
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost               
          u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
        endLoops3d()    
      end do
    end if

  endif

#endMacro


! ============================================================================================
! Macro: evaluate the solution on the boundary for Dirichlet BCs
!    Solving
!        u_tt = c^2 * Delta( u ) + f(x,y,z,t)
!        u = g
! For TZ at order=2:
!    ff = ue_tt - c^2*Delta(ue) 
!    gtt = g_tt = uett
!  order=4:
!    fLap 
!    ftt
!    gtttt
! ============================================================================================
#beginMacro getDirichletCompatibilityForcing(FORCING,DIM,ORDER,ff,gtt,fLap,ftt,gtttt)
  #If #FORCING eq "noForcing"
    ! No forcing, do nothing 
  #Else
    if( assignTwilightZone.eq.1 )then
      ! compute RHS from TZ
      #If #DIM eq "2"
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
        ueLap = uexx + ueyy
        call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
        #If #ORDER eq "4"
          call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettxx )
          call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettyy )
          uettLap = uettxx + uettyy

          call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx )
          call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
          call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )

          ueLap2 = uexxxx + 2.*uexxyy + ueyyyy ! Lap^2( u )

          call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )

        #End
      #Else
        ! 3D 
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
        call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
        ueLap = uexx + ueyy + uezz
        call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
        #If #ORDER eq "4"
          call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettxx )
          call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettyy )
          call ogDeriv(ep,2,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettzz )
          uettLap = uettxx + uettyy + uettzz

          call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxx )
          call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyy )
          call ogDeriv(ep,0,0,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzz )
          call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyy )
          call ogDeriv(ep,0,2,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzz )
          call ogDeriv(ep,0,0,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzz )

          ueLap2 = uexxxx + 2.*( uexxyy + uexxzz + ueyyzz)  + ueyyyy + uezzzz ! Lap^2( u )

          call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )

        #End      

      #End
      ff = uett - c2*ueLap
      gtt = uett

      #If #ORDER eq "4"
        fLap = uettLap - c2*ueLap2 
        ftt  = uetttt - c2*uettLap
        gtttt = uetttt
      #End    


    else
      ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
    end if
  #End
#endMacro      


! ===================================================================================================
! Macro: Assign the boundary values on Dirichlet boundaries
!
!  NOTE: DIM AND GRIDTYPE NOT CURRENTLY USED
!  FORCE : USEFORCING or NOFORCING 
! ===================================================================================================
#beginMacro assignDirichletBoundary(DIM,ORDER,GRIDTYPE)

  ! if( t.le.2*dt )then
  !   write(*,'("assign extended Dirichlet BC: side,axis=",2i2," nn1a,nn1b,nn2a,nn2b,nn3a,nn3b=",6i3)') side,axis,nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
  ! end if

  ff=0.
  if( addForcingBC.eq.1 )then
    ! beginLoops3d()
    ! *wdh* Dec 1, 2023: assign extended bndry
    beginLoops(nn1a,nn1b,nn2a,nn2b,nn3a,nn3b)
      if( mask(i1,i2,i3).ne.0 )then
       
        ! --- get the RHS to the Dirichlet BC ---
        ! #If #FORCING eq "USEFORCING" *wdh* This was a bug, turned off Nov 22, 2023
        getDirichletForcing(ff,i1,i2,i3)
        ! #End
    
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=ff

        ! write(*,'("assignDirichletBndry: side,axis=",2i2," i1,i2=",2i3," ff=",e10.2)') side,axis,i1,i2,ff
    
      end if ! mask .ne. 0
    endLoops3d()
  else
    ! Homogenous BCs 
    ! beginLoops3d()
    beginLoops(nn1a,nn1b,nn2a,nn2b,nn3a,nn3b)
      u(i1,i2,i3,uc)=0.
    endLoops3d() 

  end if

#endMacro

! ===================================================================================================
! Macro: Assign the boundary values on "exact" boundaries
!
! ===================================================================================================
#beginMacro assignExactBoundary()

  ! assign extram points in the tangential directions
  extram = numGhost 
  getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  ff=0.
  beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
    if( mask(i1,i2,i3).ne.0 )then
     
      do ghost=0,numGhost
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost

        getDirichletForcing(ff,j1,j2,j3)

        u(j1,j2,j3,uc) = ff

      end do
  
    end if ! mask .ne. 0
  endLoops3d()

#endMacro



! ===================================================================================================
! Macro: get loop bounds over boundaries with extram points in tangential directions 
! ===================================================================================================
#beginMacro getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
  m1a=gridIndexRange(0,0)-extram
  m1b=gridIndexRange(1,0)+extram
  m2a=gridIndexRange(0,1)-extram
  m2b=gridIndexRange(1,1)+extram
  if( nd.eq.2 )then
    m3a=gridIndexRange(0,2)
    m3b=gridIndexRange(1,2)
  else
    m3a=gridIndexRange(0,2)-extram
    m3b=gridIndexRange(1,2)+extram
  end if
  if( axis.eq.0 )then
   m1a=gridIndexRange(side,axis)
   m1b=gridIndexRange(side,axis)
  else if( axis.eq.1 )then
   m2a=gridIndexRange(side,axis)
   m2b=gridIndexRange(side,axis)
  else
   m3a=gridIndexRange(side,axis)
   m3b=gridIndexRange(side,axis)
  end if
#endMacro

! ===================================================================================================
! Macro: get loop bounds over boundaries with extram points in tangential directions 
!   Do NOT include the end grid points when adjacent sides are Dirichlet BCs
!   since we assume the extended dirichlet boundary has been assigned
!
!                |                         |
!   BC=Neumann   +                         + BC=Dirichlet
!                |                         |
!          G--G--B--+--+--+-- ...  --+--+--B--G--G
!            m1a |                     m1b |
!                X                         X
!
! ===================================================================================================
#beginMacro getRestrictedLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  ! Assume sides with axis=0 are adjacent sides (fixed later)
  if( bc(0,0)==dirichlet .or. bc(0,0)==exactBC )then
    m1a= gridIndexRange(0,0)+1
  else
    m1a=gridIndexRange(0,0)-extram
  end if
  if( bc(1,0)==dirichlet .or. bc(1,0)==exactBC )then
    m1b = gridIndexRange(1,0)-1
  else
    m1b = gridIndexRange(1,0)+extram
  end if

  ! Assume sides with axis=1 are adjacent sides (fixed later)
  if( bc(0,1)==dirichlet .or. bc(0,1)==exactBC )then
    m2a= gridIndexRange(0,1)+1
  else
    m2a=gridIndexRange(0,1)-extram
  end if
  if( bc(1,1)==dirichlet .or. bc(1,1)==exactBC )then
    m2b = gridIndexRange(1,1)-1
  else
    m2b = gridIndexRange(1,1)+extram
  end if  

  if( nd.eq.2 )then
    m3a=gridIndexRange(0,2)
    m3b=gridIndexRange(1,2)
  else
    if( bc(0,2)==dirichlet .or. bc(0,2)==exactBC )then
      m3a= gridIndexRange(0,2)+1
    else
      m3a=gridIndexRange(0,2)-extram
    end if
    if( bc(1,2)==dirichlet .or. bc(1,2)==exactBC )then
      m3b = gridIndexRange(1,2)-1
    else
      m3b = gridIndexRange(1,2)+extram
    end if
  end if

  if( axis.eq.0 )then
    m1a=gridIndexRange(side,axis)
    m1b=gridIndexRange(side,axis)
  else if( axis.eq.1 )then
    m2a=gridIndexRange(side,axis)
    m2b=gridIndexRange(side,axis)
  else
    m3a=gridIndexRange(side,axis)
    m3b=gridIndexRange(side,axis)
  end if

#endMacro  


! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 2,4,6,8
! FORCING : noForcing, forcing
! ===================================================================================================
#beginMacro assignDirichletGhostCompatibility(DIM,ORDER,GRIDTYPE,FORCING)

  !---------------------------------------------------------------
  ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
  !---------------------------------------------------------------
  ! assign extram points in the tangential directions
  extram = numGhost-1 
  getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  ! Try this: *wdh* Dec 2, 2023 : Exclude the ends when adjacent boundaries are dirichlet or exact:
  ! getRestrictedLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  ! if( t.le. 2*dt )then
  !    write(*,'("dirichlet CBC: Stage I: side,axis=",2i3," m1a,m1b,m2a,m2b,m3a,m3b=",6i3)') side,axis,m1a,m1b,m2a,m2b,m3a,m3b
  ! end if

  ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
  beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)

   #If #ORDER eq "2"
    if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 
   #Else
    if( mask(i1,i2,i3).ne.0 )then ! fill ghost outside interp points too for order 4 *wdh* Dec 13, 2023
   #End

      ghost =1 
      j1=i1-is1*ghost; j2=i2-is2*ghost; j3=i3-is3*ghost

      #If #ORDER eq "4"
        ! Save original values so we can restore end points that we have filled in with a 2nd order approximation
        ! We really only need to save the end points, but do this for now
        k1=i1-is1*2; k2=i2-is2*2; k3=i3-is3*2;       
        uTemp(j1,j2,j3,0)=u(j1,j2,j3,0)
        uTemp(k1,k2,k3,0)=u(k1,k2,k3,0)

        ! if( j1==7 .and. j2==-1 )then
        !   write(*,'(" BC1: j1,j2=",2i3," set uTemp=",e10.2)') j1,j2,uTemp(j1,j2,j3,0)
        ! end if         

      #End

      ! --- get the compatibility forcings for order=2 ---
      getDirichletCompatibilityForcing(FORCING,DIM,2,ff,gtt,fLap,ftt,gtttt)

      ! u_tt = c^2*Lap(u) + f 
      #If #GRIDTYPE eq "rectangular"
        ! uLap = ulaplacian22r or ulaplacian23r 
        uLap = ulaplacian2 ## DIM ## r(i1,i2,i3,0)
        r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
        a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
      #Else
        ! uLap = ulaplacian22 or ulaplacian23 
        uLap = ulaplacian2 ## DIM(i1,i2,i3,0)
        r1 = uLap + (ff - gtt)/c2
        #If #DIM eq "2"
          a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
        #Else
          a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
        #End
      #End

 
      u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 


        ! if( j1==7 .and. j2==-1 )then
        !   write(*,'(" BC2: j1,j2=",2i3," set u=",e10.2)') j1,j2,u(j1,j2,j3,0)
        ! end if 

      ! if( .false. )then
      !   ! check the error
      !   call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
      !   write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
      ! end if

      #If #ORDER eq "2" 
        if( numGhost.gt.1 )then
          ghost =2
          k1=i1-is1*ghost
          k2=i2-is2*ghost
          k3=i3-is3*ghost   
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if
      #End

    else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
      ! ----- extrap ghost outside interp. pts on physical boundaries ------
      ! This should have been done already
      ! ghost = 1 
      ! j1=i1-is1*ghost
      ! j2=i2-is2*ghost
      ! j3=i3-is3*ghost
      ! u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)

      ! #If #ORDER eq "2" 
      !   if( numGhost.gt.1 )then
      !     ! extrap second ghost (UPW)
      !     ghost = 2
      !     k1=i1-is1*ghost
      !     k2=i2-is2*ghost
      !     k3=i3-is3*ghost              
      !     u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
      !   end if
      ! #End
    end if ! mask 
  endLoops()


  #If #ORDER eq "4"

    !----------------------------------------------------------------
    ! --- STAGE II fill in first ghost by 4th-order compatibility ---
    !----------------------------------------------------------------

    #If #GRIDTYPE eq "curvilinear"
      ! Compute and save v = Lap(u) at some points near the boundary
      !  for use below to compute Lap^2 (u)
      !          |
      !        +-X-+
      !          |
      !        +-X-+
      !          |
      !        +-X-+
      !          |
      !        +-X-+
      !          |
      !         r=0 
      ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

      beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
        ! eval Lap(u) on ghost, boundary and first line in:
        if( mask(i1,i2,i3).ne.0 )then 
          v(i1-is1,i2-is2,i3-is3,0) = ulaplacian2 ## DIM(i1-is1,i2-is2,i3-is3,0)
          v(i1    ,i2    ,i3    ,0) = ulaplacian2 ## DIM(i1    ,i2    ,i3    ,0)
          v(i1+is1,i2+is2,i3+is3,0) = ulaplacian2 ## DIM(i1+is1,i2+is2,i3+is3,0)
        end if
      endLoops()      

    #End

    ! --- fill in two ghost using 4th- order compatibility ---

    ! Exclude the ends when adjacent boundaries are dirichlet or exact:
    ! TURN THIS ON -- DEc 20, 2023
    extram=0
    getRestrictedLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

    ! extram = 0
    ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

    ! if( t.le. 2*dt )then
    !   write(*,'("dirichlet CBC: Stage II: side,axis=",2i3," m1a,m1b,m2a,m2b,m3a,m3b=",6i3)') side,axis,m1a,m1b,m2a,m2b,m3a,m3b
    ! end if    

    beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
      if( mask(i1,i2,i3).gt.0 )then

        ! --- get the compatibility forcings at order=4 ---
        getDirichletCompatibilityForcing(FORCING,DIM,4,ff,gtt,fLap,ftt,gtttt)

        ! u_tt = c^2*Lap(u) + f 
        ! u_tttt = c^2*Lap(u_tt) + f_tt 
        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
   
        #If #GRIDTYPE eq "rectangular"
          ! uxx43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*dx42(0) 
          uLap = ulaplacian4 ## DIM ## r(i1,i2,i3,0)
          r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
          a11 = c2*16./(12.*dx(axis)**2)                           ! coeff of u(-1) in r1 
          a12 =    -c2/(12.*dx(axis)**2)                           ! coeff of u(-2) in r1
          ! uxxxx = 1 -4 6 -4 1
          ! vLap = Lap^2( u )
          vLap = lap ## DIM ## d2Pow2(i1,i2,i3,0)
          r2 =  c4*vLap + c2*fLap + ftt - gtttt
          a21 =  -c4*4./(dx(axis)**4)                              ! coeff of u(-1) in r2
          a22 =   c4*1./(dx(axis)**4)
        #Else
          ! curvilinear 
          ! uxx42(i1,i2,i3,kd)=(rsxy(i1,i2,i3,0,0)**2)*urr4(i1,i2,i3,kd)+2.*(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,0))*urs4(i1,i2,i3,kd)+(rsxy(i1,i2,i3,1,0)**2)*uss4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,0,0))*ur4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,1,0))*us4(i1,i2,i3,kd)
          uLap = ulaplacian4 ## DIM(i1,i2,i3,0)
          r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
          #If #DIM eq "2"
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
          #Else
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2
          #End
          a11 =  c2*rFactor*16./(12.*dr(axis)**2)                           ! coeff of u(-1) in r1 
          a12 = -c2*rFactor    /(12.*dr(axis)**2)                           ! coeff of u(-2) in r1
          ! vLap = Lap^2( u) to second-order
          ! vLap = vlaplacian22 or vlaplacian23 
          vLap = vlaplacian2 ## DIM(i1,i2,i3,0)
          r2 =  c4*vLap + c2*fLap + ftt - gtttt
          ! Here is the leading order term in a21, a22   ** this may not be good enough for stability but should remain accurate ***
          a21 =  -c4*( rFactor**2*4./(dr(axis)**4) )                             ! coeff of u(-1) in r2
          a22 =   c4*( rFactor**2   /(dr(axis)**4) )         

        #End

      ! if( .false. )then
      !   write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
      ! end if

        ghost =1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost =2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost        
        ! Solve
        !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
        !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
        f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
        f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2

        det = a11*a22 - a21*a12
        uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
        uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det

        ! if( .true. .and. assignTwilightZone.eq.1 )then
        !   ! check the error
        !   #If #DIM == "2" 
        !     call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
        !     call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
        !     write(*,'("D-CBC4: u(",3i3,")=",e10.3," err=",e8.2," u(",3i3,")=",e10.3," err=",e8.2)') j1,j2,j3,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),k1,k2,k3,uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
        !   #End
        ! end if

      end if ! mask .gt. 0

    endLoops3d()

    ! ------ fill in ghost values from uTemp ----

    ! --- Note this loop will restore the original values on the extra end points computed with the 2nd order scheme ---
    !  Note: the original values were stored in uTemp arrays in Stage I    
    extram = numGhost-1 
    getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

    beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)

      if( mask(i1,i2,i3).ne.0 )then
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost 
        u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
        u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 

      ! if( .true. .and. nd.eq.2 )then
      !   ! check the error
      !   call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
      !   write(*,'("(j1,j2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (fill uTemp)")') j1,j2, u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
      !   call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue1 )
      !   write(*,'("(k1,k2)=(",2i3,") u(-2)=",e10.3," err=",e8.2, "  (fill uTemp)")') k1,k2, u(k1,k2,k3,0),abs(u(k1,k2,k3,0)-ue1)
      ! end if

        ! if( j1==7 .and. j2==-1 )then
        !   write(*,'(" BC3: j1,j2=",2i3," set uTemp=",e10.2)') j1,j2,uTemp(j1,j2,j3,0)
        ! end if 

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          ghost = 3
          l1=i1-is1*ghost
          l2=i2-is2*ghost
          l3=i3-is3*ghost           
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if        
       
      else if( mask(i1,i2,i3).lt.0 )then
        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ! This should have already been done

        ! ghost = 1 
        ! j1=i1-is1*ghost
        ! j2=i2-is2*ghost
        ! j3=i3-is3*ghost
        ! u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)

        ! ghost = 2
        ! k1=i1-is1*ghost
        ! k2=i2-is2*ghost
        ! k3=i3-is3*ghost           
        ! u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        ! if( numGhost.gt.2 )then
        !   !  extrap third ghost (UPW)
        !   ghost = 3
        !   l1=i1-is1*ghost
        !   l2=i2-is2*ghost
        !   l3=i3-is3*ghost           
        !   u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        ! end if

      end if    
    endLoops3d()
  #End

#endMacro

! ===================================================================================================
! Macro: Get the TZ solution in 2d or 3d 
! ===================================================================================================
#beginMacro getTZ(DIM,ntd,nxd,nyd,nzd,i1,i2,i3,t,uc,ued)
 #If DIM == 2
    call ogDeriv(ep,ntd,nxd,nyd,nzd,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ued )
 #Elif DIM == 3 
    call ogDeriv(ep,ntd,nxd,nyd,nzd,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ued )
 #Else
  stop 2299
 #End
#endMacro

! ===================================================================================================
! Macro: Evaluate the forcing for the CBCs
! ===================================================================================================
#beginMacro getDirichletCompatibilityForcingOrder6(FORCING,DIM,f1,f2,f3)
  #If #FORCING eq "noForcing"
    ! No forcing, do nothing 
  #Else
    if( assignTwilightZone.eq.1 )then
      ! compute RHS from TZ
      getTZ(DIM,0,2,0,0,i1,i2,i3,t,uc,uexx )
      getTZ(DIM,0,0,2,0,i1,i2,i3,t,uc,ueyy )

      getTZ(DIM,0,4,0,0,i1,i2,i3,t,uc,uexxxx )
      getTZ(DIM,0,2,2,0,i1,i2,i3,t,uc,uexxyy )
      getTZ(DIM,0,0,4,0,i1,i2,i3,t,uc,ueyyyy )

      getTZ(DIM,0,6,0,0,i1,i2,i3,t,uc,uexxxxxx )
      getTZ(DIM,0,4,2,0,i1,i2,i3,t,uc,uexxxxyy )
      getTZ(DIM,0,2,4,0,i1,i2,i3,t,uc,uexxyyyy )      
      getTZ(DIM,0,0,6,0,i1,i2,i3,t,uc,ueyyyyyy )      

      #If DIM == 3 
        getTZ(DIM,0,0,0,2,i1,i2,i3,t,uc,uezz )

        getTZ(DIM,0,2,0,2,i1,i2,i3,t,uc,uexxzz )
        getTZ(DIM,0,0,2,2,i1,i2,i3,t,uc,ueyyzz )
        getTZ(DIM,0,0,0,4,i1,i2,i3,t,uc,uezzzz )

        getTZ(DIM,0,4,0,2,i1,i2,i3,t,uc,uexxxxzz )
        getTZ(DIM,0,2,0,4,i1,i2,i3,t,uc,uexxzzzz )
        getTZ(DIM,0,0,4,2,i1,i2,i3,t,uc,ueyyyyzz )      
        getTZ(DIM,0,0,2,4,i1,i2,i3,t,uc,ueyyzzzz )      
        getTZ(DIM,0,0,0,6,i1,i2,i3,t,uc,uezzzzzz )      
        getTZ(DIM,0,2,2,2,i1,i2,i3,t,uc,uexxyyzz )      
      #End

      #If DIM == 2 
        f1 = -c2*( uexx + ueyy )
        f2 = -c4*( uexxxx + ueyyyy + 2.*uexxyy )
        f3 = -c6*( uexxxxxx + ueyyyyyy + 3.*( uexxxxyy + uexxyyyy ) )
      #Else
        f1 = -c2*( uexx + ueyy + uezz )
        f2 = -c4*( uexxxx + ueyyyy + uezzzz + 2.*(uexxyy + uexxzz + ueyyzz) )
        f3 = -c6*(       uexxxxxx + ueyyyyyy + uezzzzzz \
                  + 3.*( uexxxxyy + uexxyyyy + uexxxxzz + uexxzzzz + ueyyyyzz + ueyyzzzz) \
                  + 6.*( uexxyyzz ) )
      #End

    else
      ! Fix me for standard forcings 
      f1=0.; f2=0.; f3=0.;
    end if
  #End
#endMacro

! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 6 
! FORCING : noForcing, forcing
! ===================================================================================================
#beginMacro assignDirichletGhostCompatibilityOrder6(DIM,ORDER,GRIDTYPE,FORCING)

  ! write(*,*) "START OF ASSIGN GHOST CBC order=ORDER"

  !---------------------------------------------------------------
  ! assign extram points in the tangential directions
  ! extram = numGhost-1 
  ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 

  #If ORDER ne 6
    stop 6666
  #End

  !----------------------------------------------------------------
  ! ------ Fill in three ghost by 6th-order compatibility ---------
  ! ------ Using extrapolated values as initial guesses -----------
  !----------------------------------------------------------------
  
  uc=0
  firstTimeForCBC6 = .true.
  f1=0.; f2=0.; f3=0.; 
  beginLoops3d()
    if( mask(i1,i2,i3).gt.0 )then

      ghost=1
      j1=i1-is1*ghost
      j2=i2-is2*ghost
      j3=i3-is3*ghost
      ghost = 2
      k1=i1-is1*ghost
      k2=i2-is2*ghost
      k3=i3-is3*ghost 
      ghost = 3
      l1=i1-is1*ghost
      l2=i2-is2*ghost
      l3=i3-is3*ghost       

      ! --- get the compatibility forcings at order=4 ---
      ! ** FIX ME ****
      getDirichletCompatibilityForcingOrder6(FORCING,DIM,f1,f2,f3)

      ! u_tt = c^2*Lap(u) + f 
      ! u_tttt = c^2*Lap(u_tt) + f_tt 
      !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
      !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
   
      ! First evaluate the derivatives using the wrong values at the ghost
      !     uxx     : 6th order
      !     uxxxx   : 4th order
      !     uxxxxxx : 2nd order
      #If DIM == 2


        #If #GRIDTYPE eq "rectangular"

          getSixthDerivatives2d(ORDER,GRIDTYPE,noMetrics,i1,i2,i3)

          ! scale equations for better conditioning
          scale1 = dx(axis)**2/c2; 
          scale2 = dx(axis)**4/c4;
          scale3 = dx(axis)**6/c6; 
          ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
          r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
          r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
          r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3

          ! write(*,'("(i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
 
          if( firstTimeForCBC6 )then
            ! first time trhu, create the matrix of coefficients
             firstTimeForCBC6 = .false. 

            ! Order=6: (see MakeGetDerivativesMacro.maple output)
            ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
            a3(0,0) = c2*( (  3./2.)/(dx(axis)**2) )*scale1   ! coeff of u(-1) in c2*( uxx + uyy )*scale
            a3(0,1) = c2*( (-3./20.)/(dx(axis)**2) )*scale1   ! coeff of u(-2) 
            a3(0,2) = c2*( ( 1./90.)/(dx(axis)**2) )*scale1   ! coeff of u(-3)

            ! Order=4:
            ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
            a3(1,0) = c4*( (-13./2.)/(dx(axis)**4) )*scale2
            a3(1,1) = c4*( (     2.)/(dx(axis)**4) )*scale2
            a3(1,2) = c4*( ( -1./6.)/(dx(axis)**4) )*scale2

            ! Order=2
            ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
            a3(2,0) = c6*( (    15.)/(dx(axis)**6) )*scale3
            a3(2,1) = c6*( (    -6.)/(dx(axis)**6) )*scale3
            a3(2,2) = c6*( (     1.)/(dx(axis)**6) )*scale3

            ! Find the inverse -- could be done once for rectangular and saved
            det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + \
                   (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + \
                   (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
            det=1./det;

            a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
            a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
            a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
            a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
            a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
            a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
            a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
            a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
            a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 

          !   ! check inverse
          !   if( .true. )then
          !     do m1=0,2
          !       do m2=0,2
          !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
          !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
          !       end do
          !     end do
          !   end if

          end if ! end if firstTime

        #Else

          ! ----- curvilinear ----
          getSixthDerivatives2d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

           #If #DIM eq "2"
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
          #Else
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2
          #End


          ! Scaling for equations so leading terms are undivided differences
          scale1 = (dr(axis)**2/rFactor)**1/c2; 
          scale2 = (dr(axis)**2/rFactor)**2/c4;
          scale3 = (dr(axis)**2/rFactor)**3/c6; 

          ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
          r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
          r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
          r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3

          ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: uxx,uxxxx,uxxxxxx=",3(1pe9.2,1x))') i1,i2,uxx,uxxxx,uxxxxxx
          ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
 

          ! Order=6: (see MakeGetDerivativesMacro.maple output)
          ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
          a3(0,0) = ( (  3./2.) )   ! coeff of u(-1) in c2*( uxx + uyy )*scale1
          a3(0,1) = ( (-3./20.) )   ! coeff of u(-2) 
          a3(0,2) = ( ( 1./90.) )   ! coeff of u(-3)

          ! Order=4:
          ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
          a3(1,0) = ( (-13./2.) )
          a3(1,1) = ( (     2.) )
          a3(1,2) = ( ( -1./6.) )

          ! Order=2
          ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
          a3(2,0) = ( (    15.) )
          a3(2,1) = ( (    -6.) )
          a3(2,2) = ( (     1.) )

          ! Find the inverse -- We could save these inverses
          det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + \
                 (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + \
                 (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
          det=1./det;

          a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
          a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
          a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
          a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
          a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
          a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
          a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
          a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
          a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 

        !   ! check inverse
        !   if( .true. )then
        !     do m1=0,2
        !       do m2=0,2
        !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
        !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
        !       end do
        !     end do
        !   end if


        #End
      #Else
        ! -- 3D ---
        ! This next seems broken: 
        ! getSixthDerivatives3d(ORDER,GRIDTYPE,OPTION,i1,i2,i3)
        stop 6363
      #End

      f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
      f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
      f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)

      ! if( .true. )then
      !   getTZ(DIM,0,0,0,0,j1,j2,j3,t,uc,ue1 )
      !   getTZ(DIM,0,0,0,0,k1,k2,k3,t,uc,ue2 )
      !   getTZ(DIM,0,0,0,0,l1,l2,l3,t,uc,ue3 )
      !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') \
      !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
      ! end if

      ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
      ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
      ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)

      uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
      uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
      uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      


      ! if( .true. )then
      !   getTZ(DIM,0,0,0,0,j1,j2,j3,t,uc,ue1 )
      !   getTZ(DIM,0,0,0,0,k1,k2,k3,t,uc,ue2 )
      !   getTZ(DIM,0,0,0,0,l1,l2,l3,t,uc,ue3 )
      !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') \
      !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
      ! end if

 
      ! if( numGhost.gt.3 )then
      !   ! extrap an extra ghost for upwinding 
      !   ghost = 4
      !   j1=i1-is1*ghost
      !   j2=i2-is2*ghost
      !   j3=i3-is3*ghost 
      !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
      ! end if

    end if ! mask .gt. 0

  endLoops3d()

    ! ------ fill in ghost values from uTemp ----
  if( .true. )then
    beginLoops3d()
      if( mask(i1,i2,i3).gt.0 )then
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost 
        ghost = 3
        l1=i1-is1*ghost
        l2=i2-is2*ghost
        l3=i3-is3*ghost         
        u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
        u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
        u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 

        if( numGhost.gt.3 )then
          !  extrap 4th ghost (UPW)
          ghost = 4
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost   
          ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 

          ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
          u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            

        end if        
       
      else if( mask(i1,i2,i3).lt.0 )then

        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        u(j1,j2,j3,uc)=extrap7(u,i1,i2,i3,uc,is1,is2,is3)

        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost           
        u(k1,k2,k3,uc)=extrap7(u,j1,j2,j3,uc,is1,is2,is3)

        ghost = 3
        l1=i1-is1*ghost
        l2=i2-is2*ghost
        l3=i3-is3*ghost           
        u(l1,l2,l3,uc)=extrap7(u,k1,k2,k3,uc,is1,is2,is3)            


        if( numGhost.gt.3 )then
          !  extrap 4th ghost (UPW)
          ghost = 4
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost           
          u(j1,j2,j3,uc)=extrap7(u,l1,l2,l3,uc,is1,is2,is3)            
        end if        

      end if    
    endLoops3d()  
  end if
  ! write(*,*) "CBC6 stop here for now"
  ! stop 6666  

#endMacro




! ------------------------------------------------------------------------------------
!  Macro: evaluate the RHS to the Neumann BC
! ------------------------------------------------------------------------------------
#beginMacro getNeumannForcing(ff)
  if( assignTwilightZone.eq.1 )then
    ! compute RHS from TZ
    if( nd.eq.2 )then
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
      call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
      call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
      ff = a0*ue + a1*( an1*uex + an2*uey )
    else
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
      call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
      call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
      call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
      ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
    end if

  else if( assignKnownSolutionAtBoundaries.eq.1 )then

    ! -- we set inhomogeneous Neumann values for some known solutions 
    if( knownSolutionOption.eq.planeWave )then
      ! --- evaluate RHS for the plane wave solution ---
      if( nd.eq.2 )then
        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
        uex   = kxPlaneWave*cosPW
        uey   = kyPlaneWave*cosPw

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
        uex   = kxPlaneWave*cosPW
        uey   = kyPlaneWave*cosPw
        uez   = kzPlaneWave*cosPw

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if 

    else if( knownSolutionOption.eq.gaussianPlaneWave )then
      ! Do nothing for Gaussian plane wave solution for now
      ff = 0.
      
    else if( knownSolutionOption.eq.boxHelmholtz ) then
      ! --- evaluate RHS the boxHelmholtz solution ---
      if( nd.eq.2 )then
        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
        uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if

    else if( knownSolutionOption.eq.polyPeriodic ) then
      ! --- evaluate RHS the polyPeriodic solution ---
      if( nd.eq.2 )then
        ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) ) *coswt
        uex = (      a1PolyPeriodic                                                            ) *coswt
        uey = (                          b1PolyPeriodic                                        ) *coswt

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
        uex = (      a1PolyPeriodic                                                                                            ) *coswt
        uey = (                          b1PolyPeriodic                                                                        ) *coswt
        uez = (                                              c1PolyPeriodic                                                    ) *coswt

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if


    else

      stop 9876

    end if 

  end if
#endMacro 

! ===================================================================================================
! Macro: Assign ghost points on Neumann boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro assignNeumannGhost(ORDER)
   ! BC: a0*T + a1*T.n = 

   ! a0=mixedCoeff(uc,side,axis,grid)
   ! a1=mixedNormalCoeff(uc,side,axis,grid)
   a0=0.
   a1=1.

   ! rectangular case:
   if( gridType.eq.rectangular )then
     ! compute the outward normal (an1,an2,an3)
     an1 = 0.
     an2 = 0.
     an3 = 0.
     if( axis.eq.0 )then
      an1=-is
     else if( axis.eq.1 )then
      an2=-is
     else
      an3=-is
     end if
     dxn=dx(axis)
     b0=-4.*dxn*a0/a1-10./3.
     b1=4.*(dxn/a1)
   end if

   ff=0.
   beginLoops3d()

    ! first ghost pt:
    j1=i1-is1
    j2=i2-is2
    j3=i3-is3
    ! 2nd ghost:
    k1=j1-is1
    k2=j2-is2
    k3=j3-is3
    ! 3rd ghost:
    l1=k1-is1
    l2=k2-is2
    l3=k3-is3    

    if( mask(i1,i2,i3).gt.0 )then
    

      if( gridType.eq.curvilinear )then
        ! compute the outward normal (an1,an2,an3)
        getNormal(i1,i2,i3)
      end if

      getNeumannForcing(ff)


      ! ORDER=4: 
      ! --- assign 2 ghost points using:
      !  (1) Apply Neumann BC to 4th order
      !  (2) Extrap. 2nd ghost to 5th order

      if( gridType.eq.rectangular )then

        ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
        !if( orderOfAccuracy.eq.2 )then
        #If #ORDER eq "2"
          ! --- NEUMANN ORDER=2 rectangular ---
          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
          !  *check me* 
          b0 = -2.*dxn*a0/a1 
          b1 =  2.*dxn/a1 
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          + b1*ff
        #Elif #ORDER eq "4"  
         !  --- NEUMANN ORDER=4 rectangular ---
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.\
                            +b1*ff
        #Else
          stop 777
        #End

      else 
        ! ------ curvilinear grid: -------

        ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
        ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
        ! =>
        !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 

        #If #ORDER eq "2"

          ! ----- NEUMANN ORDER=2 curvilinear ----

          ! ur = ( u(i+1) - u(i-1) )/2*dr
          ! ur = ur0 -> 
          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 

          urv(0) = ur2(i1,i2,i3,uc)
          urv(1) = us2(i1,i2,i3,uc)
          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut2(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

           ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
         end if

         u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0


        #Elif #ORDER eq "4"  

          ! ---- NEUMANN ORDER 4 curvilinear ----
          !       d14(kd) = 1./(12.*dr(kd))
          !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
          !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)

          ! ur = f -> 
          ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
          ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)

          ! A - B = 
          !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 

          urv(0) = ur4(i1,i2,i3,uc)
          urv(1) = us4(i1,i2,i3,uc)

          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut4(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
          end if

          u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                                 +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                                 -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)\
                              -4.*is*dr(axis)*ur0

        #Else
          stop 7878
        #End

      end if ! curvilinear grid 
      
      ! ----- Assign extra ghost ----
      #If #ORDER eq "2"

        if( numGhost.gt.1 )then
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if

      #Elif #ORDER eq "4"  

        ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
        ! extrap second ghost
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      #Else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777        
      #End


    else if( mask(i1,i2,i3).lt.0 )then

      ! ----- extrap ghost outside interp. pts on physical boundaries ------
      #If #ORDER eq "2"

        u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)
        if( numGhost.gt.1 )then
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
        end if

      #Elif #ORDER eq "4"

        u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)
        if( numGhost.gt.2 )then
          !  extrap third ghost 
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      #Else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777        
      #End
       
    end if

   endLoops3d()
#endMacro





! ============================================================================================
! Macro: evaluate the forcings for Neumann CBCs
!    Solving
!        u_tt = c^2 * Delta( u ) + f(x,y,z,t)
!        u.n = g
! For TZ at order=2:
!    gg = g
!  order=4:
!    gg,
!    nDotGradF = n.grad( f ), f = ue_tt - c^2*lap(ue)
!    gtt
! ============================================================================================
#beginMacro getNeumannCompatibilityForcing(FORCING,DIM,ORDER,gg,nDotGradF,gtt )

  ! write(*,'("getNeumannCompatForcing forcing=FORCING dim=DIM order=ORDER assignTwilightZone=",i2)') assignTwilightZone

  #If #FORCING eq "noForcing"
    ! No forcing, do nothing 
    gg=0.;  gtt=0.; nDotGradF=0.; 
  #Else
    if( assignTwilightZone.eq.1 )then
      ! compute RHS from TZ
      #If #DIM eq "2"
        call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex )
        call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
        gg = an1*uex + an2*uey

        #If #ORDER eq "4"
          call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettx )
          call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetty )
          gtt = an1*( uettx ) + an2*( uetty )

          call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxx )
          call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyy )
          call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxy )
          call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyy )

          nDotGradF = an1*( uettx - c2*( uexxx + uexyy ) ) + \
                      an2*( uetty - c2*( uexxy + ueyyy ) )
          ! write(*,'(" nDotGradF=",e10.2," an1,an2=",2e10.2,"x,y=",2e10.2)') nDotGradF,an1,an2,xy(i1,i2,i3,0),xy(i1,i2,i3,1)
        #End

      #Else
        ! ----- 3D  -----
        call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex )
        call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey )
        call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez )
        gg = an1*uex + an2*uey + an3*uez

        #If #ORDER eq "4"
          call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettx )
          call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uetty )
          call ogDeriv(ep,2,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettz )
          gtt = an1*( uettx ) + an2*( uetty ) + an3*( uettz )

          call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxx )
          call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxy )
          call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexyy )
          call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyy )
          call ogDeriv(ep,0,2,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxz )
          call ogDeriv(ep,0,1,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexzz )
          call ogDeriv(ep,0,0,2,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyz )
          call ogDeriv(ep,0,0,1,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyzz )
          call ogDeriv(ep,0,0,0,3,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzz )

          nDotGradF = an1*( uettx - c2*( uexxx + uexyy + uexzz ) ) + \
                      an2*( uetty - c2*( uexxy + ueyyy + ueyzz ) ) + \
                      an3*( uettz - c2*( uexxz + ueyyz + uezzz ) )
        #End      

      #End
    else
      gg=0.;  gtt=0.; nDotGradF=0.; 
    end if
  #End
#endMacro      

!==========================================================================
!  Check the coefficients in the ghost points of the residual equations
! using the discrete delta approach
!==========================================================================
#beginMacro checkCoeffByDiscreteDelta(GRIDTYPE,DIM)
  if( checkCoeff.eq.1 )then
    ! --- Check coefficients a11,a12,... by discrete delta ---
    u1Save = u(j1,j2,j3,0)
    u2Save = u(k1,k2,k3,0)
    u(j1,j2,j3,0)=0.
    u(k1,k2,k3,0)=0.
    getThirdDerivatives ## DIM ## d(2,GRIDTYPE,nothing,i1,i2,i3)
    r1a = resid1(i1,i2,i3)
    r2a = resid2(i1,i2,i3)

    u(j1,j2,j3,0)=1.
    getThirdDerivatives ## DIM ## d(2,GRIDTYPE,nothing,i1,i2,i3)
    r1b =  resid1(i1,i2,i3)
    r2b =  resid2(i1,i2,i3)
    a11c = r1b - r1a
    a21c = r2b - r2a

    u(j1,j2,j3,0)=0.
    u(k1,k2,k3,0)=1.
    getThirdDerivatives ## DIM ## d(2,GRIDTYPE,nothing,i1,i2,i3)
    r1b =  resid1(i1,i2,i3)
    r2b =  resid2(i1,i2,i3)
    a12c = r1b - r1a
    a22c = r2b - r2a

    u(j1,j2,j3,0) = u1Save  
    u(k1,k2,k3,0) = u2Save      

    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))

    ! #If #GRIDTYPE eq "curvilinear"
    ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
    ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
    ! #End
  end if 
#endMacro      

! ===================================================================================================
! Macro: Assign ghost points on Neumann boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 2,4,6,8
! FORCING : noForcing, forcing
! ===================================================================================================
#beginMacro assignNeumannGhostCompatibility(DIM,ORDER,GRIDTYPE,FORCING)


  ! write(*,'("START ASSIGN NEUMANN GHOST COMPATIBILITY dim=[DIM] gridType=[GRIDTYPE] forcing=[FORCING] ======")') 

  ! Mixed BC: a0*u + a1*u.n = 
  a0=0.
  a1=1.

  ! STAGE I always fill in first ghost from 2nd-order scheme 

  ! rectangular case:
  #If #GRIDTYPE eq "rectangular"
    ! compute the outward normal (an1,an2,an3)
    an1 = 0.
    an2 = 0.
    an3 = 0.
    if( axis.eq.0 )then
     an1=-is
    else if( axis.eq.1 )then
     an2=-is
    else
     an3=-is
    end if
    dxn=dx(axis)
  #End

  !---------------------------------------------------------------
  ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
  !---------------------------------------------------------------


! *wdh* Dec 7 : Apply 2nd order conditions for fourth order scheme too 
! *wdh* Dec 7, 2023 #If #ORDER eq "2"
  if( orderOfAccuracy==4 )then
    if( t.le.3*dt )then
      write(*,'("Neumann CBC order=4: Stage I: apply 2nd order conditions first")') 
    end if
  end if

  ! assign extram points in the tangential directions
  extram = numGhost-1 
  getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  gg=0.; nDotGradF=0.; gtt=0.; 
  beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)

    ! first ghost pt:
    j1=i1-is1; j2=i2-is2; j3=i3-is3

    #If #ORDER eq "2"
    if( mask(i1,i2,i3).gt.0 )then
    #Else
    if( mask(i1,i2,i3).ne.0 )then
    #End
    

      #If #GRIDTYPE eq "curvilinear"
        ! compute the outward normal (an1,an2,an3)
        getNormal(i1,i2,i3)
      #End

      getNeumannCompatibilityForcing(FORCING,DIM,2,gg,nDotGradF,gtt)


      #If #ORDER eq "4"
        ! Save original values so we can restore end points that we have filled in with a 2nd order approximation
        ! We really only need to save the end points, but do this for now
        k1=i1-is1*2; k2=i2-is2*2; k3=i3-is3*2;       
        uTemp(j1,j2,j3,0)=u(j1,j2,j3,0)
        uTemp(k1,k2,k3,0)=u(k1,k2,k3,0)
      #End
      #If #GRIDTYPE eq "rectangular"

        ! --- NEUMANN ORDER=2 rectangular ---
        !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*gg 
        !  *check me* 
        b0 = -2.*dxn*a0/a1 
        b1 =  2.*dxn/a1 
        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                       +    u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                       + b1*gg

      #Else

        ! ------ curvilinear grid: -------

        ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
        ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
        ! =>
        !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 

        ! ----- NEUMANN ORDER=2 curvilinear ----

        ! ur = ( u(i+1) - u(i-1) )/2*dr
        ! ur = ur0 -> 
        ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
        ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 

        urv(0) = ur2(i1,i2,i3,uc)
        urv(1) = us2(i1,i2,i3,uc)
        #If #DIM eq "2"
          t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
          t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
          ur0 = (gg - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
        #Else
          urv(2) = ut2(i1,i2,i3,uc)
          t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
          t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
          t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
          ur0 = ( gg - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
        #End
        u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0

        ! write(*,'("neumann CBC j1,j2=",2i4," u=",1pe12.4," gg=",1pe10.2)') j1,j2,u(j1,j2,j3,uc),gg

      #End
      
      #If #ORDER eq "2" 
        ! ----- Assign extra ghost ----
        if( numGhost.gt.1 )then
          ghost =2
          k1=i1-is1*ghost
          k2=i2-is2*ghost
          k3=i3-is3*ghost   
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if
      #End

    else if( mask(i1,i2,i3).lt.0 )then
      #If #ORDER eq "2" 
        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)

        if( numGhost.gt.1 )then
          ! extrap second ghost (UPW)
          ghost = 2
          k1=i1-is1*ghost
          k2=i2-is2*ghost
          k3=i3-is3*ghost              
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
        end if
      #End

    end if

  endLoops3d()
! Dec 7, 2023 #End


  #If #ORDER eq "4"
    ! ------------------- order 4 NEUMANN CBC --------------------
    maxDiff=0. ! for checkCoeff

    gg=0.
    beginLoops3d()

      ghost =1 
      j1=i1-is1*ghost; j2=i2-is2*ghost; j3=i3-is3*ghost
      ghost =2
      k1=i1-is1*ghost; k2=i2-is2*ghost; k3=i3-is3*ghost   

      if( mask(i1,i2,i3).gt.0 )then

        #If #GRIDTYPE eq "curvilinear"
          ! compute the outward normal (an1,an2,an3)
          getNormal(i1,i2,i3)
        #End

        ! --- call get Neumann Compatibility forcing=[FORCING] dim={DIM] ---
        getNeumannCompatibilityForcing(FORCING,DIM,4,gg,nDotGradF,gtt)


        ! ---call getThirdDerivatives gridtype=[GRIDTYPE] dim=[DIM]---
        #If #DIM eq "2"
          getThirdDerivatives2d(2,GRIDTYPE,evalMetrics,i1,i2,i3)
        #Else
          ! evaluate 3rd derivatives : uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 
          getThirdDerivatives3d(2,GRIDTYPE,evalMetrics,i1,i2,i3)
        #End
        #If #GRIDTYPE eq "rectangular"

          ! --- NEUMANN ORDER=4 rectangular ---
          ! u_tt = c^2*Lap(u) + f 
          !   u.n = g
          ! g_tt = c^2 n.grad( Lap(u) ) + n.grad(f)

          ! ux = [ u(-2) - 8*u(-1) + 8*u(1) - u(2) ]/(12*h) 

          ! uxxx = (-u(-1) +2*u(-1) - 2*u(1) + u(2) ]/(2*h^3)
          #If #DIM eq "2"
            ! eval equation with wrong values at ghost: 
            r1 =  an1*ux42r(i1,i2,i3,0) + an2*uy42r(i1,i2,i3,0) - gg

            ! note: an1=-1 on left side and an1=+1 on right side
            ! **CHECK ME**
            a11 =  8./(12.*dx(axis))  ! coeff of u(-1) in r1
            a12 = -1./(12.*dx(axis))  ! coeff of u(-2) in r1

            r2 = c2*( an1*( uxxx + uxyy ) + \
                      an2*( uxxy + uyyy ) ) + nDotGradF - gtt

            ! two terms contribute:
            !  uxxx + uxyy : left/right
            ! *wdh* Dec 7, 2023 turn off: a21 =  -c2*( 2./(2.*dx(axis)**3) +2./(2.*dx(axis)*dx(axisp1)**2) )  ! coeff of u(-1) in r2
            a21 =  -c2*( 2./(2.*dx(axis)**3) )                                  ! coeff of u(-1) in r2
            a22 =   c2*( 1./(2.*dx(axis)**3) )                                  ! coeff of u(-1) in r2         

      ! write(*,'("CBC:N4:i1,i2=",2i3," a11,a12,a21,a22=",4(e10.2,1x)," r1,r2,nDotGradF,gtt=",4(e10.2,1x))') i1,i2,a11,a12,a21,a22,r1,r2,nDotGradF,gtt
      ! write(*,'("CBC:N4:uxxx,uxyy,uxxy,uyyy=",4(e10.2,1x))') uxxx,uxyy,uxxy,uyyy


            ! define the residual functions for the discrete delta method
#defineMacro resid1(i1,i2,i3) ( an1*ux42r(i1,i2,i3,0) + an2*uy42r(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)

          #Else

            ! --- 3D ----
            r1 =  an1*ux43r(i1,i2,i3,0) + an2*uy43r(i1,i2,i3,0) + an3*uz43r(i1,i2,i3,0) - gg

            ! **CHECK ME**
            a11 =  8./(12.*dx(axis))  ! coeff of u(-1)
            a12 = -1./(12.*dx(axis))  ! coeff of u(-2)  

            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + \
                      an2*( uxxy + uyyy + uyzz ) + \
                      an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt

            ! three terms contribute: uxx, uxyy, uxzz
            ! *wdh* Dec 7, 2023 turn off: a21 =  -c2*( 2./(2.*dx(axis)**3) +2./(2.*dx(axis)*dx(axisp1)**2) +2./(2.*dx(axis)*dx(axisp2)**2) )

            a21 =  -c2*( 2./(2.*dx(axis)**3) )
            a22 =   c2*( 1./(2.*dx(axis)**3) )

      ! write(*,'("CBC:N4:i1,i2,i3=",3i3," a11,a12,a21,a22=",4(e10.2,1x)," r1,r2,gg,nDotGradF,gtt=",5(e10.2,1x))') i1,i2,i3,a11,a12,a21,a22,r1,r2,gg,nDotGradF,gtt
      ! write(*,'("CBC:N4:uxxx,uxyy,uxzz,uxxy,uyyy,uyzz,uxxz,uyyz,uzzz=",9(e10.2,1x))') uxxx,uxyy,uxzz,uxxy,uyyy,uyzz,uxxz,uyyz,uzzz

        ! if( .true. .or. abs(uyyz).gt.1e-3 )then
        !   write(*,'(" u(i1,i2-1:i2+1,i3-1)=",3(1pe11.2))') u(i1,i2-1,i3-1,0),u(i1,i2  ,i3-1,0),u(i1,i2+1,i3-1,0)
        !   write(*,'(" u(i1,i2-1:i2+1,i3+0)=",3(1pe11.2))') u(i1,i2-1,i3+0,0),u(i1,i2  ,i3+0,0),u(i1,i2+1,i3+0,0)
        !   write(*,'(" u(i1,i2-1:i2+1,i3+1)=",3(1pe11.2))') u(i1,i2-1,i3+1,0),u(i1,i2  ,i3+1,0),u(i1,i2+1,i3+1,0)
        ! end if

      ! uyyz     = ((-u(i1,i2-1,i3-1,0)+u(i1,i2-1,i3+1,0))/(2.*dr(2))
      !         -2.*(-u(i1,i2  ,i3-1,0)+u(i1,i2  ,i3+1,0))/(2.*dr(2))+
      !             (-u(i1,i2+1,i3-1,0)+u(i1,i2+1,i3+1,0))/(2.*dr(2)))/(dr(1)**2)
      ! uyzz     = (-(u(i1,i2-1,i3-1,0)-2.*u(i1,i2-1,i3,0)+u(i1,i2-1,i3+1,0))/(dr(2)**2)+(u(i1,i2+1,i3-1,0)-2.*u(i1,i2+1,i3,0)+u(i1,i2+1,i3+1,0))/(dr(2)**2))/(2.*dr(1))


            ! define the residual functions for the discrete delta method
#defineMacro resid1(i1,i2,i3) ( an1*ux43r(i1,i2,i3,0) + an2*uy43r(i1,i2,i3,0) + an3*uz43r(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)            

          #End


        #Else

          ! ------ curvilinear grid: -------

          #If #DIM eq "2"
            ! eval equation with wrong values at ghost:
            r1 =  an1*ux42(i1,i2,i3,0) + an2*uy42(i1,i2,i3,0) - gg

            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1)
            ! crv(1) = an1*rsxy(i1,i2,i3,1,0) + an2*rsxy(i1,i2,i3,1,1)

            ! **CHECK ME**
            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)

            r2 = c2*( an1*( uxxx + uxyy ) + \
                      an2*( uxxy + uyyy ) ) + nDotGradF - gtt

! uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
! uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
! uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
! uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us

            ! uxxx = rxi**3*urrr +3.*rxi*rxx*urr + rxxx*ur
            ! uxyy = ryi**2*rxi*urrr +(rxi*ryy+2.*rxy*ryi)*urr+rxyy*ur
            ! uxxy = ryi*rxi**2*urrr +(2.*rxi*rxy+rxx*ryi)*urr+rxxy*ur

            ! Coeff of terms involving urrr (do not include terms involving urr and ur as these used 2nd-order values)
            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) )*( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )

            ! if( axis.eq.0 )then
            !   crv(axis) = (an1*rxi + an2*ryi )*( rxi**2 + ryi**2 )
            !   ! crv(axis) = an1*( rxi**3 + ryi**2*rxi ) + \
            !   !             an2*( ryi**3 + ryi*rxi**2 )
            ! else
            !   crv(axis) = (an1*sxi + an2*syi )*( sxi**2 + syi**2 )
            !   ! crv(axis) = an1*( sxi**3 + syi**2*sxi ) + \
            !   !             an2*( syi**3 + syi*sxi**2 )              
            ! end if
            ! crv(1) = an1*rsxy(i1,i2,i3,1,0)**3 + an2*rsxy(i1,i2,i3,1,1)**3

            ! **CHECK ME**
            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )

#defineMacro resid1(i1,i2,i3) ( an1*ux42(i1,i2,i3,0) + an2*uy42(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)

          #Else
            ! 3D 
            r1 =  an1*ux43(i1,i2,i3,0) + an2*uy43(i1,i2,i3,0) + an3*uz43(i1,i2,i3,0) - gg

            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2)

            ! **CHECK ME**
            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)

            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + \
                      an2*( uxxy + uyyy + uyzz ) + \
                      an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt

            ! crv(axis) = an1*rsxy(i1,i2,i3,axis,0)**3 + an2*rsxy(i1,i2,i3,axis,1)**3 + an3*rsxy(i1,i2,i3,axis,2)**3
            ! Coeff of "urrr" term *check me*
            !2d: crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) )*( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )
            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2) )* \
                        (    rsxy(i1,i2,i3,axis,0)**2  + rsxy(i1,i2,i3,axis,1)**2  + rsxy(i1,i2,i3,axis,2)**2 )

            ! if( axis.eq.0 )then
            !   crv(axis) = ( an1*rxi + an2*ryi + an3*rzi )*( rxi**2 + ryi**2 + rzi**2 ) 
            !   ! crv(axis) = an1*( rxi*( rxi**2 + ryi**2 + rzi**2 ) ) + \
            !   !             an2*( ryi*( rxi**2 + ryi**2 + rzi**2 ) ) + \
            !   !             an3*( rzi*( rxi**2 + ryi**2 + rzi**2 ) ) 
            ! else if( axis.eq.1 )then
            !   crv(axis) = ( an1*sxi + an2*syi + an3*szi )*( sxi**2 + syi**2 + szi**2 ) 
            ! else           
            !   crv(axis) = ( an1*txi + an2*tyi + an3*tzi )*( txi**2 + tyi**2 + tzi**2 ) 
            ! end if

            ! **CHECK ME**
            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )            

            ! define the residual functions for the discrete delta method
#defineMacro resid1(i1,i2,i3) ( an1*ux43(i1,i2,i3,0) + an2*uy43(i1,i2,i3,0) + an3*uz43(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)   

          #End          

        #End

        f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
        f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2

        det = a11*a22 - a21*a12
        uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
        uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det

        ! write(*,'("CBC:Neumann O4: i1,i2=",2i3," a11,a12,a21,a22=",4(e10.2,1x)," det,f1,f2=",3(e10.2,1x))') i1,i2,a11,a12,a21,a22,det,f1,f2

        if( .false. )then
          #If #DIM eq "2"
            call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
            call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
          #Else
            call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),xy(j1,j2,j3,2),t,uc,uex )
            call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),xy(k1,k2,k3,2),t,uc,uey )
          #End
          write(*,'(" (j1,j2,j3)=(",3i3,") u,ue,err=",3(1pe12.4)," (k1,k2,k3)=(",3i3,")  u,ue,err=",3(1pe12.4))') j1,j2,j3,uTemp(j1,j2,j3,0),uex,uTemp(j1,j2,j3,0)-uex,k1,k2,k3,uTemp(k1,k2,k3,0),uey,uTemp(k1,k2,k3,0)-uey

        end if

      else if( mask(i1,i2,i3).lt.0 )then
        ! this case done below 
  
      end if

    endLoops3d()



    ! ------ fill in ghost values from uTemp ----
    
    ! wdh: no need to fill in ghost on adjacent Dirichlet boundaries: Dec 2, 2023
    ! getRestrictedLoopBounds(side,axis,0, m1a,m1b,m2a,m2b,m3a,m3b)

    ! --- Note this loop will restore the original values on the extra end points computed with the 2nd order scheme ---
    !  Note: the original values were stored in uTemp arrays in Stage I
    beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)

      if( mask(i1,i2,i3).ne.0 )then
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost 
        u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
        u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 

        if( .false. )then
          #If #DIM eq "2"
            call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
            call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
          #Else
            call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),xy(j1,j2,j3,2),t,uc,uex )
            call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),xy(k1,k2,k3,2),t,uc,uey )
          #End
          !write(*,'(" (i1,i2,i3)=(",3i3,") u(-1),ue(-1),err=",3(1pe12.4)," u(-2),ue(-2),err=",3(1pe12.4))') i1,i2,i3,u(j1,j2,j3,0),uex,u(j1,j2,j3,0)-uex,uTemp(k1,k2,k3,0),uey,uTemp(k1,k2,k3,0)-uey
          write(*,'(" (j1,j2,j3)=(",3i3,") u,ue,err=",3(1pe12.4)," (k1,k2,k3)=(",3i3,")  u,ue,err=",3(1pe12.4))') j1,j2,j3,u(j1,j2,j3,0),uex,u(j1,j2,j3,0)-uex,k1,k2,k3,u(k1,k2,k3,0),uey,u(k1,k2,k3,0)-uey

        end if
        ! write(*,'("CBC:Neumann O4: j1,j2=",2i3," u=",2(e10.2,1x))') j1,j2,u(j1,j2,j3,0),u(k1,k2,k3,0)

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          ghost = 3
          l1=i1-is1*ghost
          l2=i2-is2*ghost
          l3=i3-is3*ghost           
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if        
       
      else if( mask(i1,i2,i3).lt.0 )then
        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ! This should have already been done

        ! ghost = 1 
        ! j1=i1-is1*ghost
        ! j2=i2-is2*ghost
        ! j3=i3-is3*ghost
        ! u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)

        ! ghost = 2
        ! k1=i1-is1*ghost
        ! k2=i2-is2*ghost
        ! k3=i3-is3*ghost           
        ! u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        ! if( numGhost.gt.2 )then
        !   !  extrap third ghost (UPW)
        !   ghost = 3
        !   l1=i1-is1*ghost
        !   l2=i2-is2*ghost
        !   l3=i3-is3*ghost           
        !   u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        ! end if

      end if    
    endLoops3d()    

    if( checkCoeff.eq.1 )then
      write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," GRIDTYPE ORDER")') t,side,axis,maxDiff
    end if
  #End


#endMacro

! ========================================================================================
!  Apply symmetry conditions for ghost along edges in 3D 
! ========================================================================================
#beginMacro assignSymmetryEdgeGhost(FORCING)

do edgeDirection=0,2 ! direction parallel to the edge
  do sidea=0,1
  do sideb=0,1
    if( edgeDirection.eq.0 )then
      side1=0
      side2=sidea
      side3=sideb
    else if( edgeDirection.eq.1 )then
      side1=sideb 
      side2=0
      side3=sidea
    else
      side1=sidea
      side2=sideb
      side3=0
    end if
    is1=1-2*(side1)
    is2=1-2*(side2)
    is3=1-2*(side3)
    if( edgeDirection.eq.2 )then
     is3=0
     n1a=gridIndexRange(side1,0)
     n1b=gridIndexRange(side1,0)
     n2a=gridIndexRange(side2,1)
     n2b=gridIndexRange(side2,1)
     n3a=gridIndexRange(0,2)-extra
     n3b=gridIndexRange(1,2)+extra
     bc1=boundaryCondition(side1,0)
     bc2=boundaryCondition(side2,1)
    else if( edgeDirection.eq.1 )then
     is2=0
     n1a=gridIndexRange(side1,0)
     n1b=gridIndexRange(side1,0)
     n2a=gridIndexRange(    0,1)-extra
     n2b=gridIndexRange(    1,1)+extra
     n3a=gridIndexRange(side3,2)
     n3b=gridIndexRange(side3,2)
     bc1=boundaryCondition(side1,0)
     bc2=boundaryCondition(side3,2)
    else 
     is1=0  
     n1a=gridIndexRange(    0,0)-extra
     n1b=gridIndexRange(    1,0)+extra
     n2a=gridIndexRange(side2,1)
     n2b=gridIndexRange(side2,1)
     n3a=gridIndexRange(side3,2)
     n3b=gridIndexRange(side3,2)
     bc1=boundaryCondition(side2,1)
     bc2=boundaryCondition(side3,2)
    end if
 
    if( bc1==dirichlet .and. bc2==dirichlet )then
      do i3=n3a,n3b
      do i2=n2a,n2b
      do i1=n1a,n1b
        do m1=1,numberOfGhostPoints
        do m2=1,numberOfGhostPoints  
          j1=is1*m1  
          j2=is2*m2
          j3=is3*m3

          u(j1,j2,j3,0) = u(i1+is1*m1,i2+is2*m2,i3+is3*m2,0)
        end do
        end do     

      end do
      end do
      end do
    end if
 
  end do ! end do sideb
  end do ! end do sidea
end do ! end edgeDirection

#endMacro


! ========================================================================================
!  Apply symmetry conditions in corner ghost for Cartesian grids 
! ========================================================================================
#beginMacro assignSymmetryCornerGhost(FORCING)
  ! ---------------------------------
  ! --- assign corners and edges: ---
  ! ---------------------------------


  if( nd.eq.2 )then

    ! --- TWO DIMENSIONS ----
    do side2=0,1
    do side1=0,1

      if( bc(side1,0).gt.0 .and. \
          bc(side2,1).gt.0 )then

        ! **fix me** for exact BCs

        if( ( bc(side1,0).ne.dirichlet .and. bc(side1,0).ne.neumann ) .or. \
            ( bc(side2,1).ne.dirichlet .and. bc(side2,1).ne.neumann ) )then
          write(*,*) "Un-supported corner bcs =",bc(side1,0),bc(side2,1)
          stop 2222
        end if

        symSign = +1. ! even symmetry for D-D or N-N corners
        if( (bc(side1,0).eq.dirichlet .and. bc(side2,1).eq.neumann   ) .or. \
            (bc(side1,0).eq.neumann   .and. bc(side2,1).eq.dirichlet ) ) then
          symSign=-1.;
        end if
        is1 = 1-2*side1
        is2 = 1-2*side2

        i1 = gridIndexRange(side1,0)
        i2 = gridIndexRange(side2,1)
        i3 = gridIndexRange(    0,2)
        do m2=0,numGhost
        do m1=0,numGhost
          j1 = i1-is1*m1; j2=i2-is2*m2; j3=i3; ! ghost 
          k1 = i1+is1*m1; k2=i2+is2*m2; k3=i3; ! interior point 

          u(j1,j2,j3,0) = symSign*u(k1,k2,k3,0)

          #If #FORCING eq "forcing"
            if( assignTwilightZone.eq.1 )then
              getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
              getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
              u(j1,j2,j3,0) = u(j1,j2,j3,0) + ue1 - symSign*ue2 
            else
              ! finish me 
            end if
          #End

        end do
        end do

      end if 
    end do
    end do

  else
    ! --- THREE DIMENSIONS ----

    assignSymmetryEdgeGhost(FORCING)


    write(*,*) "symmetry corners -- finish me in 3D"
    stop 9999

    do side3=0,1
    do side2=0,1
    do side1=0,1

    end do
    end do
    end do
  end if

#endMacro





! ===================================================================================
! Utility macro to call different versions of assignDirichletGhostCompatibility
! for a given ORDER
! ===================================================================================
#beginMacro callDirichletGhostCompatibility(ORDER)
  #If ORDER ne 6 
    if( forcingOption.eq.noForcing )then
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,rectangular,noForcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,rectangular,noForcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,curvilinear,noForcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,curvilinear,noForcing)
        end if
      end if 
    else
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,rectangular,forcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,rectangular,forcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,curvilinear,forcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,curvilinear,forcing)
        end if
      end if     
    end if
  #Else
    if( forcingOption.eq.noForcing )then
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,rectangular,noForcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,rectangular,noForcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,curvilinear,noForcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,curvilinear,noForcing)
        end if
      end if 
    else
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,rectangular,forcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,rectangular,forcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,curvilinear,forcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,curvilinear,forcing)
        end if
      end if     
    end if    
  #End
#endMacro 

! ===================================================================================
! Utility macro to call different versions of assignNeumannGhostCompatibility
! for a given ORDER
! ===================================================================================
#beginMacro callNeumannGhostCompatibility(ORDER)
  if( forcingOption.eq.noForcing )then
    if( gridType.eq.rectangular )then
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,rectangular,noForcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,rectangular,noForcing)
      end if
    else
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,curvilinear,noForcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,curvilinear,noForcing)
      end if
    end if 
  else
    if( gridType.eq.rectangular )then
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,rectangular,forcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,rectangular,forcing)
      end if
    else
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,curvilinear,forcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,curvilinear,forcing)
      end if
    end if     
  end if
#endMacro 


! =========================================================================
! Macro: 
!   Assign the RHS for implicit boundary conditions
!
! =========================================================================
#beginMacro assignImplicitBoundaryConditions()

  ! -------- IMPLICIT BoundaryConditions --------
  ! 
  !   assignBCForImplicit = 1 : BCs for implicit time stepping
  !   assignBCForImplicit = 2 : BCs for direct Helmholtz solve

  ! if( .true. )then
  !   write(*,'("bcOptWave: fill BCs into RHS for implicit solver")')
  ! end if

  ! write(*,'("FINISH ME")')
  ! stop 6789

  an3=0.
  beginLoopOverSides(numGhost,numGhost)

    if( bc(side,axis) == dirichlet )then

       ! ============== IMPLICIT DIRICHLET =============

      ff=0.
      if( bcApproach.eq.useOneSidedBoundaryConditions .or. orderOfAccuracy.eq.2 )then
        beginLoops3d()
          if( mask(i1,i2,i3).ne.0 )then

            getDirichletForcing(ff,i1,i2,i3)
            ! fill in boundary value: 
            u(i1,i2,i3,uc)=ff

            ! -- Set ghost to zero (RHS to extrapolation conditions) ---
            ! Is this necessary ?
            do ghost=1,numGhost
              j1=i1-is1*ghost
              j2=i2-is2*ghost
              j3=i3-is3*ghost

              u(j1,j2,j3,uc) = 0.

            end do  

          end if 
        endLoops3d()
        
      else if( bcApproach.eq.useCompatibilityBoundaryConditions )then

        ! if( t.le.5*dt )then
        !   write(*,'("bcOpt: implicit: finish me for CBC ***")') 
        ! end if

        ! assert orderOfAccuracy==4 ************************************
        if( orderOfAccuracy.ne.4 )then
          write(*,'("bcOpt:ERROR:Dirichlet: implicit, CBC, but orderOfAccuracy=",i4)') orderOfAccuracy
          stop 1234
        end if

        ! At a Dirichlet-Dirichlet Corner we cannot use a CBCs on both sides since this is a duplicate
        !         |
        !   E--C--+
        !         |
        !   D--D--X--+--+--+--
        !         |  |  |
        !         D  C  C
        !         |  |  |
        !         D  E  E
        ! D = use dirichlet BC on extended ghost line(s)
        ! C = use CBC
        ! E = extrap

        ! Assign extended boundary 
        m1a=n1a-numberOfGhostPoints; m1b=n1b+numberOfGhostPoints; 
        m2a=n2a-numberOfGhostPoints; m2b=n2b+numberOfGhostPoints; 
        m3a=n3a-numberOfGhostPoints; m3b=n3b+numberOfGhostPoints; 
        if( nd.eq.2 )then
          m3a=n3a; m3b=n3b;
        end if
        if( axis.eq.0 )then
          m1a=n1a; m1b=n1b;
        else if( axis.eq.1 )then
          m2a=n2a; m2b=n2b;
        else
          m3a=n3a; m3b=n3b;
        end if

        ! write(*,'("bcOpt:Imp:Dirichlet:RHS side,axis=",2i3," m1a,m1b,m2a,m2b,m3a,m3b=",6i5)') side,axis,m1a,m1b,m2a,m2b,m3a,m3b

        beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
          if( mask(i1,i2,i3).ne.0 )then

            getDirichletForcing(ff,i1,i2,i3)
            ! fill in boundary value: 
            u(i1,i2,i3,uc)=ff

            ! write(*,'("IMP-RHS CBC: i1,i2=",2i4," u=",e10.2)') i1,i2,ff 

          end if
        endLoops()


        ! --- Adjust loops for CBC RHS at Dirichlet-Dirichlet corners ---

        iab(0,0)=n1a; iab(1,0)=n1b; 
        iab(0,1)=n2a; iab(1,1)=n2b; 
        iab(0,2)=n3a; iab(1,2)=n3b;

        do sidea=0,1  ! adjacent side
          if( bc(sidea,axisp1) == dirichlet )then
            iab(sidea,axisp1)=iab(sidea,axisp1) + 1-2*sidea  ! avoid end-point
          end if 
        end do
        if( nd.eq.3 )then
          do sidea=0,1  ! adjacent side
            if( bc(sidea,axisp2) == dirichlet )then
              iab(sidea,axisp2)=iab(sidea,axisp2) + 1-2*sidea  ! avoid end-point
            end if 
          end do          
        endif

        m1a=iab(0,0); m1b=iab(1,0); 
        m2a=iab(0,1); m2b=iab(1,1); 
        m3a=iab(0,2); m3b=iab(1,2);

        ! write(*,'("bcOpt:Imp:Dirichlet:CBC2:RHS side,axis=",2i3," m1a,m1b,m2a,m2b,m3a,m3b=",6i5)') side,axis,m1a,m1b,m2a,m2b,m3a,m3b

        ! -- assign RHS to CBC and extrapolation --
        beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
          if( mask(i1,i2,i3).ne.0 )then

            ! getDirichletForcing(ff,i1,i2,i3)
            ! ! fill in boundary value: 
            ! u(i1,i2,i3,uc)=ff

            j1=i1-is1
            j2=i2-is2
            j3=i3-is3 

            if( assignTwilightZone.eq.1 )then
              ! compute RHS from TZ
              if( nd.eq.2 )then
                call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
                call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
                ueLap = uexx + ueyy                  
              else
               call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
               call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
               call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
               ueLap = uexx + ueyy + uezz                  
              end if 

              ! write(*,'("IMP-RHS CBC: j1,j2=",2i4," ueLap=",e10.2)') j1,j2,ueLap 
              u(j1,j2,j3,uc)=c2*ueLap

              do ghost=2,numGhost
                j1=i1-is1*ghost
                j2=i2-is2*ghost
                j3=i3-is3*ghost
                u(j1,j2,j3,uc) = 0.
              end do                 

            else

              ! -- FIX ME FOR PLANE WAVE ETC ---
              ! Is this necessary ?
              do ghost=1,numGhost
                j1=i1-is1*ghost
                j2=i2-is2*ghost
                j3=i3-is3*ghost

                u(j1,j2,j3,uc) = 0.

              end do 
            end if 

          end if 
        endLoops3d()
      else
        write(*,'("bcOpt: implicit: unexpected bcApproach=",i6)') bcApproach
        stop 1111
      end if


    else if( bc(side,axis) == exactBC )then

      ! ------------------------------------------------------------------------
      ! NOTE: KnownSolution values are assigned in **applyBoundaryConditions**
      ! ------------------------------------------------------------------------


      if( assignTwilightZone==1 )then
        if( t.le.3*dt )then
          write(*,'("bcOptWave: Assign IMP EXACT BC : Twilightzone grid,side,axis=",3i3)') grid,side,axis 
        end if        

        ! --- Assign extended boundary AND ghost points ----
        m1a=n1a-numberOfGhostPoints; m1b=n1b+numberOfGhostPoints; 
        m2a=n2a-numberOfGhostPoints; m2b=n2b+numberOfGhostPoints; 
        m3a=n3a-numberOfGhostPoints; m3b=n3b+numberOfGhostPoints; 
        if( nd.eq.2 )then
          m3a=n3a; m3b=n3b;
        end if
        if( axis.eq.0 )then
          if( side==0 )then
            m1a=n1a-numberOfGhostPoints 
            m1b=n1a
          else
            m1a=n1b
            m1b=n1b+numberOfGhostPoints
          end if
        else if( axis.eq.1 )then
         if( side==0 )then
            m2a=n2a-numberOfGhostPoints 
            m2b=n2a
          else
            m2a=n2b
            m2b=n2b+numberOfGhostPoints
          end if          
        else
         if( side==0 )then
            m3a=n3a-numberOfGhostPoints 
            m3b=n3a
          else
            m3a=n3b
            m3b=n3b+numberOfGhostPoints
          end if          
        end if

        beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
          if( mask(i1,i2,i3).ne.0 )then

            getDirichletForcing(ff,i1,i2,i3)
            ! fill in boundary value: 
            u(i1,i2,i3,uc)=ff

            ! write(*,'("IMP-RHS CBC: i1,i2=",2i4," u=",e10.2)') i1,i2,ff 

          end if
        endLoops()
      end if ! end if assignTwilightZone


    else if( bc(side,axis) == neumann )then

      if( gridType.eq.rectangular )then
        ! compute the outward normal (an1,an2,an3)
        an1 = 0.
        an2 = 0.
        an3 = 0.
        if( axis.eq.0 )then
         an1=-is
        else if( axis.eq.1 )then
         an2=-is
        else
         an3=-is
        end if
      end if        

      ! BC is a0*u + a1*u.n = 
      a0=0.
      a1=1.
      ff=0.

      if( bcApproach==useCompatibilityBoundaryConditions .and. orderOfAccuracy==4 )then
        ! Exclude the ends when adjacent boundaries are dirichlet or exact: *wdh* Dec 4, 2023
        extram=0
        getRestrictedLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
      else
        m1a=n1a; m1b=n1b; m2a=n2a; m2b=n2b; m3a=n3a; m3b=n3b; 
      end if

      ! write(*,'("bcOpt:Imp:Neumann:CBC:RHS side,axis=",2i3," m1a,m1b,m2a,m2b,m3a,m3b=",6i5)') side,axis,m1a,m1b,m2a,m2b,m3a,m3b

      beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
      ! beginLoops3d()
        if( mask(i1,i2,i3).ne.0 )then

          if( gridType.eq.curvilinear )then
            ! compute the outward normal (an1,an2,an3)
            getNormal(i1,i2,i3)
          end if            

          getNeumannForcing(ff)
          ! fill in first ghost:
          j1=i1-is1
          j2=i2-is2
          j3=i3-is3
          u(j1,j2,j3,uc)=ff

          ! write(*,'("IMP-RHS NEUMANN: CBC1: j1,j2,j3=",3i4," an1,an2,an3=",3(1pe10.2)," rhs=",e10.2)') j1,j2,j3,an1,an2,an3,ff        

        end if 
      endLoops3d()  

      if( bcApproach.eq.useCompatibilityBoundaryConditions .and. orderOfAccuracy.ge.4 )then   

        if( orderOfAccuracy.ne.4 )then
          write(*,'("bcOpt:ERROR:Neumann implicit, CBC, but orderOfAccuracy=",i4)') orderOfAccuracy
          stop 3456
        end if      

        ! if( t.le.5*dt )then
        !   write(*,'("bcOpt: implicit:Neumann: Assign RHS for CBC ***")') 
        !   ! stop 8888
        ! end if

        ! -- assign RHS to CBC  --
        !   Neumann:   u.n = g 
        !   CBC        (u_tt).n = g_tt ->   c^2 Delta( u.n ) = g.tt 
        !
        an1 = -is1; an2 = -is2; an3 = -is3; ! outward normal
        ! beginLoops3d()
        beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
          if( mask(i1,i2,i3).ne.0 )then

            j1=i1-2*is1 ! 2nd ghost 
            j2=i2-2*is2
            j3=i3-2*is3 

            if( gridType.eq.curvilinear )then
              ! compute the outward normal (an1,an2,an3)
              getNormal(i1,i2,i3)
            end if                    

            if( assignTwilightZone.eq.1 )then
              ! compute RHS from TZ
              if( nd.eq.2 )then
                call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxx )
                call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyy )
                call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxy )
                call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyy )
                rhs = an1*(uexxx + uexyy) + an2*(uexxy + ueyyy)
                ! test: rhs = an1*(uexxx) + an2*(ueyyy)
              else
                call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxx )
                call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexyy )
                call ogDeriv(ep,0,1,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexzz )
                call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxy )
                call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyy )
                call ogDeriv(ep,0,0,1,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyzz )
                call ogDeriv(ep,0,2,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxz )
                call ogDeriv(ep,0,0,2,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyz )
                call ogDeriv(ep,0,0,0,3,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzz )
                rhs = an1*(uexxx+uexyy+uexzz) + an2*(uexxy+ueyyy+ueyzz) + an3*(uexxz+ueyyz+uezzz)
                ! test: rhs = an1*(uexxx) + an2*(ueyyy) + an3*(uezzz)

              end if 

              ! write(*,'("IMP-RHS NEUMANN: CBC2: j1,j2,j3=",3i4," an1,an2,an3=",3(1pe10.2)," rhs=",e10.2)') j1,j2,j3,an1,an2,an3,rhs

              u(j1,j2,j3,uc)=c2*rhs

            else

              ! -- FIX ME FOR PLANE WAVE ETC ---
              u(j1,j2,j3,uc) = 0.
            end if 

          end if 
        endLoops3d()          
  

      end if       

    else if( bc(side,axis) == absorbing .or. bc(side,axis) == abcEM2 )then

      ! if( t<=4.*dt )then
      !   write(*,*) "bcOpt: implicit BC for absorbing/EM2 "
      ! end if
      ! stop 4444

      !  Use adjusted c for the EM2 absorbing BC to account for time-discretization errors
      !    D+t (Dx ) w + A+( ... )
      ! cEM2 = c*tan(frequencyArray(0)*dt/2.)/(frequencyArraySave(0)*dt/2.);

      ca = cEM2;  ! Adjusted c 

      if( gridType.eq.rectangular )then
        beginLoops3d()
          if( mask(i1,i2,i3).ne.0 )then
            j1  = i1-is1; j2  = i2-is2; j3  = i3-is3;     ! ghost 
            i1p = i1+is1; i2p = i2+is2; i3p = i3+is3;     ! first line inside

            ! We need current solution un here
            ! res = -is*(unx-ucx)/dt + (.5*c)*( unxx + ucxx) + (.25*c)*( unyy + ucyy );
            if( assignBCForImplicit.eq.1 )then
              if( axis==0 )then
                u(j1,j2,j3,uc) = (un(j1,j2,j3,uc)-un(i1p,i2p,i3p,uc))/(2.*dx(axis)*dt)                    \
                      - .5*(   ca*(un(i1+1,i2,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1-1,i2,i3,uc))/(dx(0)**2) )   \
                      - .5*(.5*ca*(un(i1,i2+1,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1,i2-1,i3,uc))/(dx(1)**2) ) 
              else
                u(j1,j2,j3,uc) = (un(j1,j2,j3,uc)-un(i1p,i2p,i3p,uc))/(2.*dx(axis)*dt)                     \
                      - .5*( .5*ca*(un(i1+1,i2,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1-1,i2,i3,uc))/(dx(0)**2) )   \
                      - .5*(    ca*(un(i1,i2+1,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1,i2-1,i3,uc))/(dx(1)**2) )                   
              end if 
            else
               ! Bc for direct Helmholtz solve
               u(j1,j2,j3,uc) = 0.
            end if

            do ghost=2,numGhost
              j1=i1-is1*ghost
              j2=i2-is2*ghost
              j3=i3-is3*ghost

              u(j1,j2,j3,uc) = 0.

            end do                
          end if
        endLoops3d();                

      else

       write(*,*) "bcOpt: implicit BC for absorbing/EM2 -- CURVILINEAR : finish me"
        stop 4444          
      end if


    else if( bc(side,axis) > 0 )then

      write(*,'("bcOptWave:fill RHS for direct Helmholtz solver, unexpected boundaryCondition=",i4)') bc(side,axis)

      stop 6666

    else if( bc(side,axis) == 0 )then
      !write(*,'("QQQQ Set ghost outside interp to zero: side,axis,grid,numGhost=",4i4)') side,axis,grid,numGhost
      !write(*,'(" bcOptWave: grid,side,axis=",3i3,", \
      ! loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i6)') grid,side,axis,\
      ! n1a,n1b,n2a,n2b,n3a,n3b        
      beginLoops3d()
       ! -- Set ghost outside interpolation boundaries to zero (for active unused points)
        do ghost=1,numGhost
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost
          u(j1,j2,j3,uc) = 0.
        end do  
      endLoops3d()        
    end if

  endLoopOverSides()   
 
 #endMacro   

! ===============================================================================
! ----------- STAGE I : Assign Dirichlet Conditions -------------
! ===============================================================================
#beginMacro assignDirichletStageI(ORDER)

  ! NOTE: the numGhost args are used in ghost loops
  extraForDirichlet=numGhost
  ff =0. ! default value 
  beginLoopOverSides(extraForDirichlet,numGhost)

    if( bc(side,axis).eq.exactBC )then

      ! ==== Set the boundary and ghost with the exact solution ====

      ! NOTE: known solutions are now done in applyBoundaryCondtions.bC 
      if( assignTwilightZone.eq.1 )then
        assignExactBoundary()
      end if

    else if( bc(side,axis).eq.dirichlet )then

      if( bcApproach.eq.useCompatibilityBoundaryConditions )then
        ! --- Assign values on the boundary for CBCs ---
        if( orderOfAccuracy.eq.2 )then

          #If #ORDER eq "2"
          if( gridType.eq.rectangular )then
           
            assignDirichletBoundary(2,2,rectangular)
          else
            assignDirichletBoundary(2,2,curvilinear)
          end if 
          #Else
            stop 222 
          #End        

        else if( orderOfAccuracy.eq.4 )then

          if( t.le.3*dt .and. debug.gt.1 )then
            write(*,'("APPLY BC order =4 useCompatibilityBoundaryConditions, side,axis=",2i4)') side,axis
          end if

          #If #ORDER eq "4"
          if( gridType.eq.rectangular )then
            assignDirichletBoundary(2,4,rectangular)
          else
            assignDirichletBoundary(2,4,curvilinear)
          end if  
          #Else
            stop 444 
          #End                      

        else if( orderOfAccuracy.eq.6 )then 

          write(*,'("CgWave::bcOpt:ERROR: CBC order=6 turned off, use LCBC")') 
          stop 666

        else if( orderOfAccuracy.eq.8 )then   
          stop 888
        else
          write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
          stop 8888
        end if

      else 
        ! ----- assign boundary and then ghost by extrapolation ----
        ! This was a temporary method until other approaches were implemented
        if( orderOfAccuracy.eq.2 )then
          #If #ORDER eq "2"
            assignDirichletBoundaryAndGhost(2)
          #End
        else if( orderOfAccuracy.eq.4 )then
          #If #ORDER eq "4"
          assignDirichletBoundaryAndGhost(4)
          #End
        else if( orderOfAccuracy.eq.6 )then   
          #If #ORDER eq "6"
          assignDirichletBoundaryAndGhost(6)
          #End
        else if( orderOfAccuracy.eq.8 )then   
          stop 888
        else
          write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
          stop 8888
        end if
      end if

    end if ! end if dirichlet 

  endLoopOverSides()
  #endMacro


! Argument list
#defineMacro ARGLIST() nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                      gridIndexRange, dimRange, isPeriodic, u, un, mask,rsxy, xy, uTemp, v, boundaryCondition, \
                      frequencyArray, pdb, ipar, rpar, ierr

! **********************************************************************************
! Macro BC_WAVE:
!  NAME: name of the subroutine
!  DIM : 2 or 3
!  ORDER : 2 ,4, 6 or 8
! **********************************************************************************
#beginMacro BC_WAVE(NAME,DIM,ORDER)
subroutine NAME( ARGLIST() )

! ===================================================================================
!  Boundary conditions for CgWave
!
!  gridType : 0=rectangular, 1=curvilinear
!
! The forcing for the boundary conditions can be accessed using the statement function:
!         bcf(side,axis,i1,i2,i3,m)
! which is defined below. 
! ===================================================================================

  implicit none

  integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ndb, ierr

  real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
  real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
  real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
  integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*)
  real frequencyArray(0:*)

  ! temp space for CBC order 4 -- fix me : just make a stencil
  real uTemp(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)


  ! ! *** TEMP ARRAYS FOR WORK SPACE --> THIS IS SLOW!!!
  ! #If #ORDER eq "4"
  !   real uTemp(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  !   real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  ! #Else
  ! real v(2,2,2,0:0)
  ! #End

  double precision pdb  ! pointer to data base

  ! integer addBoundaryForcing(0:1,0:2)
  ! integer interfaceType(0:1,0:2,0:*)
  ! integer dim(0:1,0:2,0:1,0:2)

  ! real bcf0(0:*)
  ! integer*8 bcOffset(0:1,0:2)

  ! real bcData(0:ndb-1,0:1,0:nd-1,0:*)

  integer ipar(0:*)
  real rpar(0:*)

  !     --- local variables ----

  integer bc(0:1,0:2) ! local version, normally equal to boundaryCondition
  
  integer uc,numberOfComponents,assignTwilightZone,assignKnownSolutionAtBoundaries,freq
  integer grid,gridType,orderOfAccuracy,useWhereMask,gridIsImplicit,useUpwindDissipation
  integer twilightZone,numberOfProcessors,addForcingBC,assignBCForImplicit
  integer debug,myid,ghost

  integer checkCoeff
  real maxDiff

  integer ok,getInt,getReal
  real omega,cfl,c
  real kx,ky,kz,twoPi

  real t,dt,epsx,REAL_MIN 
  real ep
  real a0,a1,an1,an2,an3,aNormi, t1,t2,t3
  real dx(0:2),dr(0:2),gravity(0:2)
  real r1,r2,r3

  

  real dxn,b0,b1,ue,uex,uey,uez,ff,urv(0:2),ur0,cosPW

  real c2,c4,c6,c8
  real gtt,rFactor,uLap,vLap
  real a11,a12,a21,a22
  real r1a,r2a, r1b,r2b, a11c,a12c,a21c,a22c  
  real u1Save,u2Save  
  real uett,uexx,ueyy,uezz,ueLap
  real ue1,ue2,ue3,ue4,f1,f2,f3,det
  real uettxx,uettyy,uettzz, uexxxx,ueyyyy,uezzzz,uexxyy,uexxzz,ueyyzz
  real uetttt,uettLap,ueLap2,lap3d2Pow2
  real uettx,uetty,uettz
  real uexxx,uexxy,uexxz,uexyy,uexzz,ueyyy,ueyyz,ueyzz,uezzz
  real uexxxxxx,uexxxxyy,uexxxxzz,ueyyyyyy,uexxyyyy,uexxzzzz,ueyyyyzz,ueyyzzzz,uezzzzzz,uexxyyzz
  real fLap,ftt,gtttt
  real gg,nDotGradF,crv(0:3)



  integer side,axis,axisp1,axisp2,i1,i2,i3,is1,is2,is3,j1,j2,j3,js1,js2,js3,k1,k2,k3,ks1,ks2,ks3,is,js
  integer i1p,i2p,i3p
  integer l1,l2,l3

  integer numGhost,numGhost3,numberOfGhostPoints,extraForNeumann,extraForDirichlet,numberOfFrequencies
  integer side1,side2,side3
  integer n1a,n1b,n2a,n2b,n3a,n3b
  integer m1a,m1b,m2a,m2b,m3a,m3b
  integer nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
  integer j1a,j1b,j2a,j2b,ja,j3b
  integer extra1a,extra1b,extra2a,extra2b,extra3a,extra3b,extram
  integer maxExtrapWidth,extrapWidth

  integer cornerBC(0:2,0:2,0:2), iparc(0:10), orderOfExtrapolationForCorners
  real rparc(0:10)

  real ca,cEM2,rhs

  ! boundary conditions parameters and interfaceType values
  ! #Include "bcDefineFortran.h"
  ! These should mauch the values in Parameters.h
  integer dirichletBoundaryCondition,neumannBoundaryCondition,dirichletInterface,neumannInterface,mixedBoundaryCondition
  parameter( dirichletBoundaryCondition=12, neumannBoundaryCondition=18, dirichletInterface=21, neumannInterface=22, mixedBoundaryCondition=30 )

  integer rectangular,curvilinear
  parameter(\
    rectangular=0,\
    curvilinear=1)

  ! Boundary conditions: These must mauch the values in CgWave.h
  ! periodic       =-1,
  ! interpolation  = 0,
  ! dirichlet      = 1,
  ! neumann        = 2,
  ! evenSymmetry   = 3,
  ! radiation      = 4   
  ! exactBC        = 5 
  ! abcEM2         = 6,  // absorbing BC, Engquist-Majda order 2  
  ! characteristic = 7,  // characteristic BC
  ! absorbing      = 8,   // for SuperGrid  

  integer dirichlet,neumann,evenSymmetry,radiation,exactBC,abcEM2,characteristic,absorbing
  parameter( dirichlet=1, neumann=2, evenSymmetry=3, radiation=4, exactBC=5, abcEM2=6, characteristic=7, absorbing=8  )

  ! Corner conditions (from op/fortranDeriv/assignCornersOpt.bf)
  integer doNothingCorner,extrapolateCorner,symmetryCorner,taylor2ndOrder
  integer evenSymmetryCorner,oddSymmetryCorner,taylor2ndOrderEvenCorner,taylor4thOrderEvenCorner,\
          vectorSymmetryAxis1Corner,vectorSymmetryAxis2Corner,vectorSymmetryAxis3Corner

  parameter(doNothingCorner=-1,extrapolateCorner=0,symmetryCorner=1,taylor2ndOrder=2, \
   evenSymmetryCorner=3,oddSymmetryCorner=4,taylor2ndOrderEvenCorner=5,taylor4thOrderEvenCorner=6, \
   vectorSymmetryAxis1Corner=7,vectorSymmetryAxis2Corner=8,vectorSymmetryAxis3Corner=9 )      

  ! known solutions
  integer knownSolutionOption
  integer planeWave, gaussianPlaneWave, boxHelmHoltz, polyPeriodic, otherKnownSolution
  parameter( planeWave=1, gaussianPlaneWave=2, boxHelmHoltz=3, polyPeriodic=4, otherKnownSolution=1000 )

  ! parameters for plane wave known solution
  real ampPlaneWave, kxPlaneWave,kyPlaneWave,kzPlaneWave, omegaPlaneWave, omegaTol
  integer solveHelmholtz, solveForScatteredField

  ! parameters for Gaussian plane wave
  real kxGPW,kyGPW,kzGPW, x0GPW,y0GPW,z0GPW, k0GPW, betaGPW
  real xi

  ! parameters for boxHelmholtz known solution
  real kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz,coswt

  ! parameters for polyPeriodic known solution
  real omegaPolyPeriodic,a0PolyPeriodic, a1PolyPeriodic, b1PolyPeriodic, c1PolyPeriodic

  ! --- forcing options ----
  ! These must match the values in CgWave.h: 
  ! enum ForcingOptionEnum
  ! {
  !   noForcing=0,
  !   twilightZoneForcing,
  !   userForcing,
  !   helmholtzForcing
  ! };  
  integer forcingOption
  integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
  parameter( noForcing=0, twilightZoneForcing=1, userForcing=2, helmholtzForcing=2 )

  ! BC APPROACH -- these must match the values in CgWave.h 
  ! enum BoundaryConditionApproachEnum
  ! {
  !   defaultBoundaryConditionApproach,
  !   useOneSidedBoundaryConditions,
  !   useCompatibilityBoundaryConditions,
  !   useLocalCompatibilityBoundaryConditions
  ! };  
  integer bcApproach
  integer defaultBoundaryConditionApproach
  integer useOneSidedBoundaryConditions
  integer useCompatibilityBoundaryConditions
  integer useLocalCompatibilityBoundaryConditions  
  parameter( defaultBoundaryConditionApproach       =0, \
             useOneSidedBoundaryConditions          =1, \
             useCompatibilityBoundaryConditions     =2, \
             useLocalCompatibilityBoundaryConditions=3 )


  real r3v(0:2),a3(0:2,0:2),a3i(0:2,0:2),f3v(0:2)
  real scale1,scale2,scale3
  integer m1,m2,m3
  integer assignCornerGhostPoints
  logical firstTimeForCBC6
  real symSign

  integer sidea, iab(0:1,0:2)

  !     --- start statement function ----
  real bcf,mixedRHS,mixedCoeff,mixedNormalCoeff
  integer kd,m,n,component
  real uxOneSided,lap2d2Pow2

  ! real uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 

  real rx,ry,rz,sx,sy,sz,tx,ty,tz

  ! define variables for getDerivatives macros
  ! #Include "../maple/declareGetDerivativesMacrosVariables.h"

  declareDifferenceOrder2(u,RX)
  #If #ORDER eq "4"
   declareDifferenceOrder4(u,RX)
  #End

  declareDifferenceOrder2(v,none)


  !  The next macro call will define the difference approximation statement functions
  defineDifferenceOrder2Components1(u,RX)
  #If #ORDER eq "4"
   defineDifferenceOrder4Components1(u,RX)
  #End

  defineDifferenceOrder2Components1(v,none)

! declare variables for getDerivatives macros
!! turned off May 4, 2023
!! #Include "../include/declareGetSixthDerivativesMacrosVariables.h"
! instead: 
#Include "../include/declareGetFourthDerivativesMacrosVariables.h"

 real ux,uy,uz
 real uxxx,uxxy,uxyy,uyyy,uxxz,uxzz,uzzz,uyyz,uyzz,uxyz

  ! 4th-order 1 sided derivative  extrap=(1 5 10 10 5 1)
  uxOneSided(i1,i2,i3,m)=-(10./3.)*u(i1,i2,i3,m)+6.*u(i1+is1,i2+is2,i3+is3,m)-2.*u(i1+2*is1,i2+2*is2,i3+2*is3,m)\
                         +(1./3.)*u(i1+3*is1,i2+3*is2,i3+3*is3,m)

  ! 2D laplacian squared = u.xxxx + 2 u.xxyy + u.yyyy
  lap2d2Pow2(i1,i2,i3,m)= ( 6.*u(i1,i2,i3,m)   \
    - 4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m))    \
        +(u(i1+2,i2,i3,m)+u(i1-2,i2,i3,m)) )/(dx(0)**4) \
    +( 6.*u(i1,i2,i3,m)    \
     -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))    \
        +(u(i1,i2+2,i3,m)+u(i1,i2-2,i3,m)) )/(dx(1)**4)  \
    +( 8.*u(i1,i2,i3,m)     \
     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))   \
     +2.*(u(i1+1,i2+1,i3,m)+u(i1-1,i2+1,i3,m)+u(i1+1,i2-1,i3,m)+u(i1-1,i2-1,i3,m)) )/( (dx(0)*dx(1))**2 )

  ! 3D laplacian squared = u.xxxx + u.yyyy + u.zzzz + 2 (u.xxyy + u.xxzz + u.yyzz )
  lap3d2Pow2(i1,i2,i3,m)= ( 6.*u(i1,i2,i3,m)   \
    - 4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m))    \
        +(u(i1+2,i2,i3,m)+u(i1-2,i2,i3,m)) )/(dx(0)**4) \
   +(  +6.*u(i1,i2,i3,m)    \
     -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))    \
        +(u(i1,i2+2,i3,m)+u(i1,i2-2,i3,m)) )/(dx(1)**4)\
   +(  +6.*u(i1,i2,i3,m)    \
     -4.*(u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))    \
        +(u(i1,i2,i3+2,m)+u(i1,i2,i3-2,m)) )/(dx(2)**4)\
    +(8.*u(i1,i2,i3,m)     \
     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))   \
     +2.*(u(i1+1,i2+1,i3,m)+u(i1-1,i2+1,i3,m)+u(i1+1,i2-1,i3,m)+u(i1-1,i2-1,i3,m)) )/( (dx(0)*dx(1))**2 ) \
    +(8.*u(i1,i2,i3,m)     \
     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))   \
     +2.*(u(i1+1,i2,i3+1,m)+u(i1-1,i2,i3+1,m)+u(i1+1,i2,i3-1,m)+u(i1-1,i2,i3-1,m)) )/( (dx(0)*dx(2))**2 ) \
    +(8.*u(i1,i2,i3,m)     \
     -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m)+u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))   \
     +2.*(u(i1,i2+1,i3+1,m)+u(i1,i2-1,i3+1,m)+u(i1,i2+1,i3-1,m)+u(i1,i2-1,i3-1,m)) )/( (dx(1)*dx(2))**2 ) 
 

  ! ! Here is the the generic boundary condition forcing array. It uses the bcOffset(side,axis) values as an
  ! ! an offset from the bcf0 array to access the bcf10, bcf01, bcf11, ... arrays
  ! bcf(side,axis,i1,i2,i3,m) = bcf0(bcOffset(side,axis) + \
  !     (i1-dim(0,0,side,axis)+(dim(1,0,side,axis)-dim(0,0,side,axis)+1)* \
  !     (i2-dim(0,1,side,axis)+(dim(1,1,side,axis)-dim(0,1,side,axis)+1)* \
  !     (i3-dim(0,2,side,axis)+(dim(1,2,side,axis)-dim(0,2,side,axis)+1)*(m)))))

  ! mixedRHS(component,side,axis,grid) = bcData(component+numberOfComponents*(0),side,axis,grid)
  ! mixedCoeff(component,side,axis,grid) = bcData(component+numberOfComponents*(1),side,axis,grid)
  ! mixedNormalCoeff(component,side,axis,grid) =  bcData(component+numberOfComponents*(2),side,axis,grid)

  !.......statement functions for jacobian
 rx(i1,i2,i3)=rsxy(i1,i2,i3,0,0)
 ry(i1,i2,i3)=rsxy(i1,i2,i3,0,1)
 rz(i1,i2,i3)=rsxy(i1,i2,i3,0,2)
 sx(i1,i2,i3)=rsxy(i1,i2,i3,1,0)
 sy(i1,i2,i3)=rsxy(i1,i2,i3,1,1)
 sz(i1,i2,i3)=rsxy(i1,i2,i3,1,2)
 tx(i1,i2,i3)=rsxy(i1,i2,i3,2,0)
 ty(i1,i2,i3)=rsxy(i1,i2,i3,2,1)
 tz(i1,i2,i3)=rsxy(i1,i2,i3,2,2)


  !............... end statement functions

  ! if( .true. )then ! ********************* TESTING FOR TIMING
  !   return
  ! end if

  checkCoeff=0 ! 1 ! set to 1 to check coefficients in CBCs using discrete delta approach

  ierr=0

  uc                              = ipar( 0)
  numberOfComponents              = ipar( 1)
  grid                            = ipar( 2)
  gridType                        = ipar( 3)
  orderOfAccuracy                 = ipar( 4)
  gridIsImplicit                  = ipar( 5)
  twilightZone                    = ipar( 6)
  numberOfProcessors              = ipar( 7)
  debug                           = ipar( 8)
  myid                            = ipar( 9)
  assignKnownSolutionAtBoundaries = ipar(10)
  knownSolutionOption             = ipar(11)
  addForcingBC                    = ipar(12)
  forcingOption                   = ipar(13)
  useUpwindDissipation            = ipar(14)
  numGhost                        = ipar(15)  
  assignBCForImplicit             = ipar(16)
  bcApproach                      = ipar(17)
  numberOfFrequencies             = ipar(18)
  assignCornerGhostPoints         = ipar(19)
 
  t         = rpar( 0)
  dt        = rpar( 1)
  dx(0)     = rpar( 2)
  dx(1)     = rpar( 3)
  dx(2)     = rpar( 4)
  dr(0)     = rpar( 5)
  dr(1)     = rpar( 6)
  dr(2)     = rpar( 7)
  ep        = rpar( 8) ! pointer for exact solution -- new : 110311 
  REAL_MIN  = rpar( 9)
  c         = rpar(10)
  cEM2      = rpar(11)

  c2 = c**2
  c4 = c**4
  c6 = c**6
  c8 = c**8
  twoPi = atan2(1.,1.)*8.; ! atan2(1,1)=pi/4

  if( gridType.eq.rectangular )then
    ! some macros want dr=dx for rectangular grids
    do axis=0,2
      dr(axis)=dx(axis)
    end do
  end if

  ! numberOfGhostPoints=orderOfAccuracy/2
  numberOfGhostPoints=numGhost ! now passed in 
  numGhost3          =numGhost ! num ghost in 3rd direction (i3)
  if( nd.eq.2 )then
    numGhost3=0
  end if
  
  if( assignCornerGhostPoints.ne.0 .and. assignCornerGhostPoints.ne.1 )then
    write(*,'("bcOptWave: ERROR: assignCornerGhostPoints=",i6," is unexpected")') assignCornerGhostPoints
    stop 4321
  end if

  ! write(*,'(" NAME: dim=DIM, order=ORDER")')

  ! *wdh* Nov 22, 2023 try turning of explicit BC's for implicit time-stepping
  if( .false. .and. gridIsImplicit.ne.0 .and. bcApproach==useCompatibilityBoundaryConditions .and. assignBCForImplicit==0 )then
    write(*,'(" bcOptWave: Skip explicit CBCs for implicit grid=",i4)') grid
    return
  end if

  if( t.le.3*dt .and. debug.gt.1 )then
  ! if( .true. )then

    write(*,'(" bcOptWave: nd=",i2," grid=",i4," gridType=",i2," orderOfAccuracy=",i2," uc=",i3," twilightZone=",i2)') nd,grid,gridType,orderOfAccuracy,uc,twilightZone
    write(*,'("  addForcingBC=",i4," forcingOption=",i4," assignKnownSolutionAtBoundaries=",i4)') addForcingBC, forcingOption, assignKnownSolutionAtBoundaries
    write(*,'("  t=",e10.2," dt=",e10.2," knownSolutionOption=",i4," REAL_MIN=",e10.2)') t,dt,knownSolutionOption,REAL_MIN
    write(*,'("  abcWave: c=",e14.6," cEM2=",e14.6)') c,cEM2
    write(*,'("  useUpwindDissipation=",i2," numGhost=",i2," assignCornerGhostPoints=",i2)') useUpwindDissipation,numGhost,assignCornerGhostPoints
    write(*,'("  assignBCForImplicit=",i4," bcApproach=",i4," gridIsImplicit=",i2)') assignBCForImplicit,bcApproach,gridIsImplicit
    write(*,'("  boundaryCondition=",6i4)') ((boundaryCondition(side,axis),side=0,1),axis=0,2)
  end if
  
  ! if( bcApproach.eq.useCompatibilityBoundaryConditions )then
  !   write(*,'("bcOptWave: ERROR: useCompatibilityBoundaryConditions not implemented yet.")') 
  !   stop 1010
  ! end if

  if( bcApproach.eq.useLocalCompatibilityBoundaryConditions )then
    write(*,'("bcOptWave: ERROR: useLocalCompatibilityBoundaryConditions not implemented yet.")') 
    stop 2020    
  end if

  ! ---- Make a local version of the boundaryCondition array ----
  do side=0,1
    do axis=0,2
      bc(side,axis)=boundaryCondition(side,axis)

      ! if( bc(side,axis).eq.absorbing )then

      !   ! DO THIS FOR NOW : use dirichlet for absorbing boundaries 

      !   bc(side,axis)=dirichlet
      ! end if

    end do
  end do

  if( assignKnownSolutionAtBoundaries.eq.1 ) then

    if( knownSolutionOption.eq.planeWave )then

      ! get parameter values from the C++ data-base
      getRealParameter(ampPlaneWave)
      getRealParameter(kxPlaneWave)
      getRealParameter(kyPlaneWave)
      getRealParameter(kzPlaneWave)
      getRealParameter(omegaPlaneWave)

      getIntParameter(solveForScatteredField)  

      if( solveForScatteredField==1 )then
         ! If we solve for the scattered field then we flip the sign of the plane wave since this has been subtracted out
         ampPlaneWave = -ampPlaneWave

         getIntParameter(solveHelmholtz) 
         if( solveHelmholtz==1 )then 
            ! Get adjusted omega:
            getRealParameter(omega)
            if( t.le.2*dt )then
              write(*,'(" bcOptWave:solveHelmholtz:scattering: Use adjusted omega=",1pe15.8," in place of omegaPlaneWave=",1pe15.8)') omega,omegaPlaneWave
            end if
            omegaPlaneWave = omega
         end if

         ! getIntParameter(solveHelmholtz)  
         ! if( solveHelmholtz==1 )then
         !    ! We are solving a Helmholtz problem : check that omega in the plane wave solution matches the omega for Helmholtz
         !    getRealParameter(omega)

         !    omegaTol = 1e-10  ! **FIX ME** use a multiple for REAL_EPSILON 

         !    if( abs(omega-omegaPlaneWave) .gt. omegaTol * omega )then
         !      write(*,'(" bcOptWave: solveForScatteredField=1, boundary forcing is a plane wave")') 
         !      write(*,'(" bcOptWave: ERROR: omegaPlaneWave=",e18.8," is not equal to omega(Helmholtz)=",e18.8)') omegaPlaneWave,omega
         !      stop 1234
         !    end if
         ! end if

      end if

      if(  t.le.2*dt .and. debug.gt.1  )then
        write(*,'(" bcOptWave:  knownSolutionOption=planeWave: solveForScatteredField=",i2," ampPlaneWave=",e10.2," kxPlaneWave=",e10.2," kyPlaneWave=",e10.2," omegaPlaneWave=",e14.4)') solveForScatteredField, ampPlaneWave,kxPlaneWave,kyPlaneWave,omegaPlaneWave
      end if 
      ! write(*,'(" bcOptWave:  knownSolutionOption=planeWave: solveForScatteredField=",i2," omegaPlaneWave=",e14.4)') solveForScatteredField, omegaPlaneWave
        
    else if( knownSolutionOption.eq.gaussianPlaneWave )then

      ! Get the parameters in the Gaussian plane wave (Set in userDefinedKnownSolution)
      getRealParameter( kxGPW )
      getRealParameter( kyGPW )
      getRealParameter( kzGPW )      
      getRealParameter( x0GPW )
      getRealParameter( y0GPW )
      getRealParameter( z0GPW )      
      getRealParameter( k0GPW )      
      getRealParameter( betaGPW ) 
      if(  t.le.dt .and. debug.ge.0  )then
        write(*,'(" bcOptWave:  knownSolutionOption=gaussianPlaneWave: kx,ky,kz=",3(1pe10.2)," x0,y0,z0=",3(1pe10.2)," k0,beta=",2(1pe10.2))') \
               kxGPW,kyGPW,kzGPW,x0GPW,y0GPW,z0GPW,k0GPW,betaGPW
      end if           

    else if( knownSolutionOption.eq.boxHelmholtz )then

      ! get parameter values from the C++ data-base
      getRealParameter(kxBoxHelmholtz)
      getRealParameter(kyBoxHelmholtz)
      getRealParameter(kzBoxHelmholtz)
      getRealParameter(omegaBoxHelmholtz)
      coswt = cos(omegaBoxHelmholtz*t)
      assignKnownSolutionAtBoundaries=1  ! for inhomogeneous BCs
      if(  t.le.dt .and. debug.ge.1   )then
        
        write(*,'(" bcOptWave:  assignKnownSolutionAtBoundaries=",i4)') assignKnownSolutionAtBoundaries
        write(*,'(" bcOptWave:  numberOfFrequencies=",i4)') numberOfFrequencies
        write(*,'(" bcOptWave:  frequencyArray=",10(1pe12.4,1x))') (frequencyArray(freq),freq=0,numberOfFrequencies-1)
        write(*,'(" bcOptWave:  knownSolutionOption=boxHelmholtz: kx,ky,kz,omega=",4e10.2)') \
                     kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz
      end if

    else if( knownSolutionOption.eq.polyPeriodic )then

      ! get parameter values from the C++ data-base
      getRealParameter(omegaPolyPeriodic)
      getRealParameter(a0PolyPeriodic)
      getRealParameter(a1PolyPeriodic)
      getRealParameter(b1PolyPeriodic)
      getRealParameter(c1PolyPeriodic)

      coswt = cos(omegaPolyPeriodic*t)
      if(  t.le.dt .and. debug.gt.1   )then
        write(*,'(" bcOptWave:  knownSolutionOption=polyPeriodic: a0,a1,b1,c1,omega=",5e10.2)') \
                     a0PolyPeriodic,a1PolyPeriodic,b1PolyPeriodic,c1PolyPeriodic,omegaPolyPeriodic
      end if


    else if( knownSolutionOption.ne.0 .and. knownSolutionOption.ne.otherKnownSolution )then

      write(*,'("bcOptWave:ERROR: unknown knownSolutionOption=",i6)') knownSolutionOption
      stop 1111
    end if 

  end if
      
  ! TEST: 
  ! getRealParameter(omega)
  ! getRealParameter(cfl)
  ! write(*,'(" bcOptWave:  cfl=",e10.2)') cfl

  if( uc.lt.0 .or. uc.ge.numberOfComponents )then
    write(*,'("bcOptWave:ERROR: invalid uc=",i6," but numberOfComponents=",i3)')  uc,numberOfComponents
    stop 1111
  end if
    
  epsx=REAL_MIN*100.  ! for normal

  if( orderOfAccuracy.ne.2 .and. orderOfAccuracy.ne.4 .and. orderOfAccuracy.ne.6 .and. orderOfAccuracy.ne.8 )then
    write(*,'("bcOptWave:ERROR: orderOfAccuracy is not 2, 4 or 6, orderOfAccuracy=",i4)') orderOfAccuracy
    stop 1111
  end if

  ! Now passed in: 
  ! numGhost=orderOfAccuracy/2

  if( assignBCForImplicit.eq.1 .or. assignBCForImplicit.eq.2 )then

    ! -------- IMPLICIT BoundaryConditions --------
    assignImplicitBoundaryConditions()

    if( assignCornerGhostPoints.eq.1 )then

      ! ---- Assign RHS for corner and edge points ----
      call cornersWave( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                        gridIndexRange, dimRange, isPeriodic, u, un, mask,rsxy, xy, uTemp, v, boundaryCondition, \
                        frequencyArray, pdb, ipar, rpar, ierr )
    end if

    ! ---------------- RETURN ---------------
    return

  end if


  ! if( .true. .and. assignCornerGhostPoints.eq.1 )then  ! ************************** TESTING **************

  !   ! call new routine: nov 28, 2024 -- 
  !   call cornersWave( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
  !                     gridIndexRange, dimRange, isPeriodic, u, un, mask,rsxy, xy, uTemp, v, boundaryCondition, \
  !                     frequencyArray, pdb, ipar, rpar, ierr )
  ! end if

  ! ---------------------------------------------------------------
  ! ----------- STAGE I : Assign Dirichlet Conditions -------------
  ! ---------------------------------------------------------------

  assignDirichletStageI(ORDER)

  if( .false. ) then

   n1a=gridIndexRange(0,0)
   n1b=gridIndexRange(1,0)
   n2a=gridIndexRange(0,1)
   n2b=gridIndexRange(1,1)
   n3a=gridIndexRange(0,2)
   n3b=gridIndexRange(1,2)    
    write(*,'(/,"bcOpt: After dirichlet BC, n1a,n1b,n2a,n2b,n3a,n3b=",6i5, " numGhost3=",i3)') n1a,n1b,n2a,n2b,n3a,n3b,numGhost3
    do i3=n3a-numGhost3,n3b+numGhost3
      if( nd.eq.3 )then
        write(*,'("i3=",i4)') i3
      end if
      do i2=n2a-numGhost,n2b+numGhost
        write(*,'("i2=",i4,1x,100(1pe10.2))') i2,(u(i1,i2,i3,0),i1=n1a-numGhost,n1b+numGhost)
      end do
    end do

  end if

   ! if( .true. )then
  !   return   ! ************************ TESTING TEMP **********************
  ! end if

  ! --  Extrap values on remaining sides to give initial values 
  !     --> maybe we only need to do this along extended boundaries on
  !         curvilinear grids so we have values for the Neumann BC
  beginLoopOverSides(numGhost,numGhost)

    ! if( ( (bc(side,axis).ne.dirichlet .and. bc(side,axis).ne.exactBC .and. bc(side,axis).ne.absorbing .and. bc(side,axis).ne.abcEM2 ) \
    !      .or. bcApproach.eq.useCompatibilityBoundaryConditions ) \
    !      .and. bc(side,axis).gt.0 )then

    if(  bc(side,axis).gt.0 .and. bc(side,axis).ne.exactBC )then ! *wdh* Dec 2, 2023 -- always do this at least for CBCs

      ! If the grid is too coarse then we can only extrapolate using point from n1a to n1b 
      !         E--+--+--+--+
      !           n1a       n1b

      maxExtrapWidth = gridIndexRange(1,axis)-gridIndexRange(0,axis)+1
      extrapWidth = min(orderOfAccuracy+1,maxExtrapWidth)
      if( extrapWidth .lt. orderOfAccuracy+1)then
        write(*,'("bcOptWave:WARNING: reducing extrapolation width to ",i2," since there are not enough grid points")') extrapWidth
      end if

      if( extrapWidth==2 )then
        extrapolateGhost(2)
      else if( extrapWidth==3 )then
        extrapolateGhost(3)
      #If #ORDER eq "4"  || #ORDER eq "6"  || #ORDER eq "8"  
        else if( extrapWidth==4 )then
          extrapolateGhost(4)
        else if( extrapWidth==5 )then
          extrapolateGhost(5)

        #If #ORDER eq "6"  || #ORDER eq "8"  
          else if( extrapWidth==6 )then
            extrapolateGhost(6)
          else if( extrapWidth==7 )then
            extrapolateGhost(7)
          else if( extrapWidth==8 )then
            extrapolateGhost(8)
          else if( extrapWidth==9 )then
            extrapolateGhost(9)        
        #End
      #End
      else

        write(*,'("CgWave::bcOpt:ERROR: unexpected extrapWidth=",i3," for orderOfAccuracy=",i6)') extrapWidth,orderOfAccuracy
        stop 8888

      end if

    end if

  endLoopOverSides()      

  if( .false.  ) then
    n1a=gridIndexRange(0,0)
    n1b=gridIndexRange(1,0)
    n2a=gridIndexRange(0,1)
    n2b=gridIndexRange(1,1)
    n3a=gridIndexRange(0,2)
    n3b=gridIndexRange(1,2)
    write(*,'(/,"bcOpt: After dirichlet BC and extrapolate ghost, grid=",i3," n1a,n1b,n2a,n2b,n3a,n3b=",6i5)') grid,n1a,n1b,n2a,n2b,n3a,n3b
    do i3=n3a-numGhost3,n3b+numGhost3
      if( nd.eq.3 )then
        write(*,'("i3=",i4)') i3
      else
        write(*,'("i1=[",i4," : ",i4,"]")') n1a-numGhost,n1b+numGhost
      end if
      do i2=n2a-numGhost,n2b+numGhost
        write(*,'("i2=",i4,1x,100(1pe10.2))') i2,(u(i1,i2,i3,0),i1=n1a-numGhost,n1b+numGhost)
      end do
    end do
  end if

  ! if( .true. )then
  !   write(*,'("bcOpt:TEST: return after Stage Ia extrapolate ghost")')
  !   return
  ! end if

  ! TESTING: Is this needed now ?? --> Needed for Dirichlet-Neumann Corners order=4
  if( assignCornerGhostPoints.eq.1 .and. bcApproach.eq.useCompatibilityBoundaryConditions )then

    ! Fill in corners and edges -- this assumes the corners and edges do not need other ghost points!!
    call cornersWave( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                      gridIndexRange, dimRange, isPeriodic, u, un, mask,rsxy, xy, uTemp, v, boundaryCondition, \
                      frequencyArray, pdb, ipar, rpar, ierr )
  end if  

  ! ---------------------------------------------------------------------
  ! ----------- STAGE II : Neumann-like Boundary Conditions -------------
  ! -----------            Ghost values for CBCs            -------------
  ! ---------------------------------------------------------------------

  ! CHECK ME --> numGhost here ??
  extraForNeumann=0 ! only assign Neumann conditions to the adjacent boundaries
  beginLoopOverSides(extraForNeumann,numGhost)

    if( bc(side,axis).eq.dirichlet .and. bcApproach.eq.useCompatibilityBoundaryConditions )then
      ! -- fill ghost using CBCs ----

      if( orderOfAccuracy.eq.2 )then
        #If #ORDER eq "2"
        callDirichletGhostCompatibility(2)
        #End

      else if( orderOfAccuracy.eq.4 )then
        #If #ORDER eq "4"
        callDirichletGhostCompatibility(4)
        #End

      else if( orderOfAccuracy.eq.6 )then  

        ! turned off May 4, 2023
        write(*,'("CgWave::bcOpt:ERROR: CBC order=6 turned off, use LCBC")')
        stop 666
        ! callDirichletGhostCompatibility(6)

      else if( orderOfAccuracy.eq.8 )then   
        stop 888
      else

        write(*,'("CgWave::bcOpt:ERROR:Dirichlet CBC unexpected orderOfAccuracy=",i6)') orderOfAccuracy
        stop 8888

      end if

    else if( bc(side,axis).eq.neumann )then

      ! ------ NEUMANN ----------
      if( bcApproach.eq.useCompatibilityBoundaryConditions )then
        if( orderOfAccuracy.eq.2 )then
          #If #ORDER eq "2"
          callNeumannGhostCompatibility(2)
          #End

        else if( orderOfAccuracy.eq.4 )then
          #If #ORDER eq "4"
          callNeumannGhostCompatibility(4)
          #End

        else if( orderOfAccuracy.eq.6 )then   
          stop 666
        else if( orderOfAccuracy.eq.8 )then   
          stop 888
        else

          write(*,'("CgWave::bcOpt:ERROR:neumann CBC unexpected orderOfAccuracy=",i6)') orderOfAccuracy
         stop 8888
        end if

      else ! one-sided 
        if( orderOfAccuracy.eq.2 )then
          #If #ORDER eq "2"
          assignNeumannGhost(2)
          #End
        else if( orderOfAccuracy.eq.4 )then
          #If #ORDER eq "4"
          assignNeumannGhost(4)
          #End

        else if( orderOfAccuracy.eq.6 )then
          #If #ORDER eq "6"   
          assignNeumannGhost(6)
          #End

        else if( orderOfAccuracy.eq.8 )then   
          #If #ORDER eq "8"
          assignNeumannGhost(8)
          #End
        else

          write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
          stop 8888
        end if
      end if

    else if( bc(side,axis) == absorbing .or. bc(side,axis) == abcEM2 )then

      ! --- ABC's are done elsewhere ---

      ! write(*,'("bcOptWave: bc=absorbing/EM2 called??")')
      ! stop 3434

    else if(  bc(side,axis).eq.dirichlet .or. bc(side,axis).eq.exactBC .or. bc(side,axis).le.0 )then
      ! do nothing

    else
      write(*,'("bcOptWave: unexpected boundaryCondition=",i4)') bc(side,axis)
      stop 5151
    end if 

  endLoopOverSides()

 if( .false.  ) then
    n1a=gridIndexRange(0,0)
    n1b=gridIndexRange(1,0)
    n2a=gridIndexRange(0,1)
    n2b=gridIndexRange(1,1)
    n3a=gridIndexRange(0,2)
    n3b=gridIndexRange(1,2)
    write(*,'(/,"bcOpt: After dirichlet COMPAT, grid=",i3," n1a,n1b,n2a,n2b,n3a,n3b=",6i5)') grid,n1a,n1b,n2a,n2b,n3a,n3b
    do i3=n3a-numGhost3,n3b+numGhost3
      if( nd.eq.3 )then
        write(*,'("i3=",i4)') i3
      else
        write(*,'("i1=[",i4," : ",i4,"]")') n1a-numGhost,n1b+numGhost
      end if
      do i2=n2a-numGhost,n2b+numGhost
        write(*,'("i2=",i4,1x,100(1pe10.2))') i2,(u(i1,i2,i3,0),i1=n1a-numGhost,n1b+numGhost)
      end do
    end do
  end if


  ! **TEST** DEC 2, 2023
  ! Dec 8, 2023 : this should no longer be needed as we now restore the Dirichlet values
  if( .false. .and. nd==3 .and. bcApproach==useCompatibilityBoundaryConditions )then
    if( t.le.2*dt )then
      write(*,'(/,"*** bcOptWave: RE-ASSIGN DIRICHLET BCS ***",/)') 
    end if

    assignDirichletStageI(ORDER)

  end if


  if( assignCornerGhostPoints.eq.1 )then

    ! call new routine: nov 28, 2024 -- 
    ! assignCornerGhostPoints : this variable is set in the calling routine

    call cornersWave( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                      gridIndexRange, dimRange, isPeriodic, u, un, mask,rsxy, xy, uTemp, v, boundaryCondition, \
                      frequencyArray, pdb, ipar, rpar, ierr )
  else

    !  --- Assign ghost points outside corners ---
    if( .false. .and. orderOfAccuracy==4 .and. gridType==rectangular .and. bcApproach==useCompatibilityBoundaryConditions )then 
      ! *wdh* Nov 28, 2023

      if( t.le.3*dt .and. debug.gt.1 )then
        write(*,'("bcOpt: Assign symmetry corner ghost for CBC")')
        stop 1234
      end if

      ! if( forcingOption.eq.noForcing )then
      !   assignSymmetryCornerGhost(noForcing)
      ! else
      !   assignSymmetryCornerGhost(forcing)
      ! end if

    else
      ! This is broken, at least in 3D: May 2, 2023 
      ! 
      if( nd.eq.2 )then
        ! Turn this back on for 2D -- Nov 23, 2023
        if( t.le.3*dt .and. debug.gt.1 )then
          write(*,'("bcOpt: Assign corner ghost")')
        end if
        assignCornerGhostsMacro()
      end if
    end if
  end if

  return
  end

#endMacro



! --- Macro to build the file for each dimension and order ---
#beginMacro buildFile(NAME,DIM,ORDER)
#beginFile NAME.f90
 BC_WAVE(NAME,DIM,ORDER)
#endFile
#endMacro

! ****************************************************************
! --- construct the different files ----
! ****************************************************************

buildFile(bcOptWave2dOrder2,2,2)
! buildFile(bcOptWave3dOrder2,3,2)
! buildFile(bcOptWave2dOrder4,2,4)
! buildFile(bcOptWave3dOrder4,3,4)


! buildFile(bcOptWave2dOrder4,2,6)
! buildFile(bcOptWave3dOrder4,3,6)


subroutine bcOptWave( ARGLIST() ) 
! ===================================================================================
!  Boundary conditions for CgWave
!
!  gridType : 0=rectangular, 1=curvilinear
!
! The forcing for the boundary conditions can be accessed using the statement function:
!         bcf(side,axis,i1,i2,i3,m)
! which is defined below. 
! ===================================================================================

  implicit none

  integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ndb, ierr

  real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
  real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
  real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)

  real uTemp(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)

  integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*)
  real frequencyArray(0:*)

  double precision pdb  ! pointer to data base


  integer ipar(0:*)
  real rpar(0:*)

  integer orderOfAccuracy

  ! extract parameters we need: 
  orderOfAccuracy  = ipar( 4)

  if( nd.eq.2 )then
    if( orderOfAccuracy.eq.2 )then
      call bcOptWave2dOrder2( ARGLIST() )
    elseif( orderOfAccuracy.eq.4 )then
      call bcOptWave2dOrder4( ARGLIST() )
    else
      stop 6666
    end if
  else
    if( orderOfAccuracy.eq.2 )then
      call bcOptWave3dOrder2( ARGLIST() )
    elseif( orderOfAccuracy.eq.4 )then
      call bcOptWave3dOrder4( ARGLIST() )
    else
      stop 7777
    end if    

  end if


  return
  end

