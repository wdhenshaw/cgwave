! ==================================================================================
!
!        Optimized Assign Boundary Conditions for CgWave
!        -----------------------------------------------
!
! ==================================================================================


! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
#Include "defineDiffOrder2f.h"
#Include "defineDiffOrder4f.h"

#Include "knownSolutionMacros.h"

! define macros to evaluate higher derivatives (from maple/makeGetDerivativesMacros.maple)
!! ** June 13, 2023 : TURN OFF ??
!! #Include "../maple/defineGetDerivativesMacros.h"

! NEW VERSION WITH DISTINCTIVE NAMES:
#Include "../maple/defineGetThirdDerivativesMacros.h"


! ! ************ TEMP ********************
! #beginMacro defineParameticDerivativesComponents0(u)
!  #defineMacro u ## Ar2(i1,i2,i3) (-u(i1-1,i2,i3)+u(i1+1,i2,i3))/(2.*dr(0))
!  #defineMacro u ## As2(i1,i2,i3) (-u(i1,i2-1,i3)+u(i1,i2+1,i3))/(2.*dr(1))
!  #defineMacro u ## At2(i1,i2,i3) (-u(i1,i2,i3-1)+u(i1,i2,i3+1))/(2.*dr(2))
!  #defineMacro u ## Arr2(i1,i2,i3) (u(i1-1,i2,i3)-2.*u(i1,i2,i3)+u(i1+1,i2,i3))/(dr(0)**2)
!  #defineMacro u ## Ars2(i1,i2,i3) (-u ## s2(i1-1,i2,i3)+u ## s2(i1+1,i2,i3))/(2.*dr(0))
!  #defineMacro u ## Ass2(i1,i2,i3) (u(i1,i2-1,i3)-2.*u(i1,i2,i3)+u(i1,i2+1,i3))/(dr(1)**2)
!  #defineMacro u ## Art2(i1,i2,i3) (-u ## t2(i1-1,i2,i3)+u ## t2(i1+1,i2,i3))/(2.*dr(0))
!  #defineMacro u ## Ast2(i1,i2,i3) (-u ## t2(i1,i2-1,i3)+u ## t2(i1,i2+1,i3))/(2.*dr(1))
!  #defineMacro u ## Att2(i1,i2,i3) (u(i1,i2,i3-1)-2.*u(i1,i2,i3)+u(i1,i2,i3+1))/(dr(2)**2)
!  #defineMacro u ## Arrr2(i1,i2,i3) (-u(i1-2,i2,i3)+2.*u(i1-1,i2,i3)-2.*u(i1+1,i2,i3)+u(i1+2,i2,i3))/(2.*dr(0)**3)
!  #defineMacro u ## Arrs2(i1,i2,i3) (u ## s2(i1-1,i2,i3)-2.*u ## s2(i1,i2,i3)+u ## s2(i1+1,i2,i3))/(dr(0)**2)
!  #defineMacro u ## Arss2(i1,i2,i3) (-u ## ss2(i1-1,i2,i3)+u ## ss2(i1+1,i2,i3))/(2.*dr(0))
!  #defineMacro u ## Asss2(i1,i2,i3) (-u(i1,i2-2,i3)+2.*u(i1,i2-1,i3)-2.*u(i1,i2+1,i3)+u(i1,i2+2,i3))/(2.*dr(1)**3)
!  #defineMacro u ## Arrt2(i1,i2,i3) (u ## t2(i1-1,i2,i3)-2.*u ## t2(i1,i2,i3)+u ## t2(i1+1,i2,i3))/(dr(0)**2)
!  #defineMacro u ## Arst2(i1,i2,i3) (-u ## st2(i1-1,i2,i3)+u ## st2(i1+1,i2,i3))/(2.*dr(0))
!  #defineMacro u ## Asst2(i1,i2,i3) (u ## t2(i1,i2-1,i3)-2.*u ## t2(i1,i2,i3)+u ## t2(i1,i2+1,i3))/(dr(1)**2)
!  #defineMacro u ## Artt2(i1,i2,i3) (-u ## tt2(i1-1,i2,i3)+u ## tt2(i1+1,i2,i3))/(2.*dr(0))
!  #defineMacro u ## Astt2(i1,i2,i3) (-u ## tt2(i1,i2-1,i3)+u ## tt2(i1,i2+1,i3))/(2.*dr(1))
!  #defineMacro u ## Attt2(i1,i2,i3) (-u(i1,i2,i3-2)+2.*u(i1,i2,i3-1)-2.*u(i1,i2,i3+1)+u(i1,i2,i3+2))/(2.*dr(2)**3)
!  #defineMacro u ## Ar4(i1,i2,i3) (u(i1-2,i2,i3)-8.*u(i1-1,i2,i3)+8.*u(i1+1,i2,i3)-u(i1+2,i2,i3))/(12.*dr(0))
!  #defineMacro u ## As4(i1,i2,i3) (u(i1,i2-2,i3)-8.*u(i1,i2-1,i3)+8.*u(i1,i2+1,i3)-u(i1,i2+2,i3))/(12.*dr(1))
!  #defineMacro u ## At4(i1,i2,i3) (u(i1,i2,i3-2)-8.*u(i1,i2,i3-1)+8.*u(i1,i2,i3+1)-u(i1,i2,i3+2))/(12.*dr(2))
!  #defineMacro u ## Arr4(i1,i2,i3) (-u(i1-2,i2,i3)+16.*u(i1-1,i2,i3)-30.*u(i1,i2,i3)+16.*u(i1+1,i2,i3)-u(i1+2,i2,i3))/(12.*dr(0)**2)
!  #defineMacro u ## Ars4(i1,i2,i3) (u ## s4(i1-2,i2,i3)-8.*u ## s4(i1-1,i2,i3)+8.*u ## s4(i1+1,i2,i3)-u ## s4(i1+2,i2,i3))/(12.*dr(0))
!  #defineMacro u ## Ass4(i1,i2,i3) (-u(i1,i2-2,i3)+16.*u(i1,i2-1,i3)-30.*u(i1,i2,i3)+16.*u(i1,i2+1,i3)-u(i1,i2+2,i3))/(12.*dr(1)**2)
!  #defineMacro u ## Art4(i1,i2,i3) (u ## t4(i1-2,i2,i3)-8.*u ## t4(i1-1,i2,i3)+8.*u ## t4(i1+1,i2,i3)-u ## t4(i1+2,i2,i3))/(12.*dr(0))
!  #defineMacro u ## Ast4(i1,i2,i3) (u ## t4(i1,i2-2,i3)-8.*u ## t4(i1,i2-1,i3)+8.*u ## t4(i1,i2+1,i3)-u ## t4(i1,i2+2,i3))/(12.*dr(1))
!  #defineMacro u ## Att4(i1,i2,i3) (-u(i1,i2,i3-2)+16.*u(i1,i2,i3-1)-30.*u(i1,i2,i3)+16.*u(i1,i2,i3+1)-u(i1,i2,i3+2))/(12.*dr(2)**2)
!  #defineMacro u ## Arrr4(i1,i2,i3) (u(i1-3,i2,i3)-8.*u(i1-2,i2,i3)+13.*u(i1-1,i2,i3)-13.*u(i1+1,i2,i3)+8.*u(i1+2,i2,i3)-u(i1+3,i2,i3))/(8.*dr(0)**3)
!  #defineMacro u ## Arrs4(i1,i2,i3) (-u ## s4(i1-2,i2,i3)+16.*u ## s4(i1-1,i2,i3)-30.*u ## s4(i1,i2,i3)+16.*u ## s4(i1+1,i2,i3)-u ## s4(i1+2,i2,i3))/(12.*dr(0)**2)
!  #defineMacro u ## Arss4(i1,i2,i3) (u ## ss4(i1-2,i2,i3)-8.*u ## ss4(i1-1,i2,i3)+8.*u ## ss4(i1+1,i2,i3)-u ## ss4(i1+2,i2,i3))/(12.*dr(0))
!  #defineMacro u ## Asss4(i1,i2,i3) (u(i1,i2-3,i3)-8.*u(i1,i2-2,i3)+13.*u(i1,i2-1,i3)-13.*u(i1,i2+1,i3)+8.*u(i1,i2+2,i3)-u(i1,i2+3,i3))/(8.*dr(1)**3)
!  #defineMacro u ## Arrt4(i1,i2,i3) (-u ## t4(i1-2,i2,i3)+16.*u ## t4(i1-1,i2,i3)-30.*u ## t4(i1,i2,i3)+16.*u ## t4(i1+1,i2,i3)-u ## t4(i1+2,i2,i3))/(12.*dr(0)**2)
!  #defineMacro u ## Arst4(i1,i2,i3) (u ## st4(i1-2,i2,i3)-8.*u ## st4(i1-1,i2,i3)+8.*u ## st4(i1+1,i2,i3)-u ## st4(i1+2,i2,i3))/(12.*dr(0))
!  #defineMacro u ## Asst4(i1,i2,i3) (-u ## t4(i1,i2-2,i3)+16.*u ## t4(i1,i2-1,i3)-30.*u ## t4(i1,i2,i3)+16.*u ## t4(i1,i2+1,i3)-u ## t4(i1,i2+2,i3))/(12.*dr(1)**2)
!  #defineMacro u ## Artt4(i1,i2,i3) (u ## tt4(i1-2,i2,i3)-8.*u ## tt4(i1-1,i2,i3)+8.*u ## tt4(i1+1,i2,i3)-u ## tt4(i1+2,i2,i3))/(12.*dr(0))
!  #defineMacro u ## Astt4(i1,i2,i3) (u ## tt4(i1,i2-2,i3)-8.*u ## tt4(i1,i2-1,i3)+8.*u ## tt4(i1,i2+1,i3)-u ## tt4(i1,i2+2,i3))/(12.*dr(1))
!  #defineMacro u ## Attt4(i1,i2,i3) (u(i1,i2,i3-3)-8.*u(i1,i2,i3-2)+13.*u(i1,i2,i3-1)-13.*u(i1,i2,i3+1)+8.*u(i1,i2,i3+2)-u(i1,i2,i3+3))/(8.*dr(2)**3)
! #endMacro

! #beginMacro defineParameticDerivativesComponents1(u)
!  #defineMacro u ## Ar2(i1,i2,i3,m) (-u(i1-1,i2,i3,m)+u(i1+1,i2,i3,m))/(2.*dr(0))
!  #defineMacro u ## As2(i1,i2,i3,m) (-u(i1,i2-1,i3,m)+u(i1,i2+1,i3,m))/(2.*dr(1))
!  #defineMacro u ## At2(i1,i2,i3,m) (-u(i1,i2,i3-1,m)+u(i1,i2,i3+1,m))/(2.*dr(2))
!  #defineMacro u ## Arr2(i1,i2,i3,m) (u(i1-1,i2,i3,m)-2.*u(i1,i2,i3,m)+u(i1+1,i2,i3,m))/(dr(0)**2)
!  #defineMacro u ## Ars2(i1,i2,i3,m) (-u ## s2(i1-1,i2,i3,m)+u ## s2(i1+1,i2,i3,m))/(2.*dr(0))
!  #defineMacro u ## Ass2(i1,i2,i3,m) (u(i1,i2-1,i3,m)-2.*u(i1,i2,i3,m)+u(i1,i2+1,i3,m))/(dr(1)**2)
!  #defineMacro u ## Art2(i1,i2,i3,m) (-u ## t2(i1-1,i2,i3,m)+u ## t2(i1+1,i2,i3,m))/(2.*dr(0))
!  #defineMacro u ## Ast2(i1,i2,i3,m) (-u ## t2(i1,i2-1,i3,m)+u ## t2(i1,i2+1,i3,m))/(2.*dr(1))
!  #defineMacro u ## Att2(i1,i2,i3,m) (u(i1,i2,i3-1,m)-2.*u(i1,i2,i3,m)+u(i1,i2,i3+1,m))/(dr(2)**2)
!  #defineMacro u ## Arrr2(i1,i2,i3,m) (-u(i1-2,i2,i3,m)+2.*u(i1-1,i2,i3,m)-2.*u(i1+1,i2,i3,m)+u(i1+2,i2,i3,m))/(2.*dr(0)**3)
!  #defineMacro u ## Arrs2(i1,i2,i3,m) (u ## s2(i1-1,i2,i3,m)-2.*u ## s2(i1,i2,i3,m)+u ## s2(i1+1,i2,i3,m))/(dr(0)**2)
!  #defineMacro u ## Arss2(i1,i2,i3,m) (-u ## ss2(i1-1,i2,i3,m)+u ## ss2(i1+1,i2,i3,m))/(2.*dr(0))
!  #defineMacro u ## Asss2(i1,i2,i3,m) (-u(i1,i2-2,i3,m)+2.*u(i1,i2-1,i3,m)-2.*u(i1,i2+1,i3,m)+u(i1,i2+2,i3,m))/(2.*dr(1)**3)
!  #defineMacro u ## Arrt2(i1,i2,i3,m) (u ## t2(i1-1,i2,i3,m)-2.*u ## t2(i1,i2,i3,m)+u ## t2(i1+1,i2,i3,m))/(dr(0)**2)
!  #defineMacro u ## Arst2(i1,i2,i3,m) (-u ## st2(i1-1,i2,i3,m)+u ## st2(i1+1,i2,i3,m))/(2.*dr(0))
!  #defineMacro u ## Asst2(i1,i2,i3,m) (u ## t2(i1,i2-1,i3,m)-2.*u ## t2(i1,i2,i3,m)+u ## t2(i1,i2+1,i3,m))/(dr(1)**2)
!  #defineMacro u ## Artt2(i1,i2,i3,m) (-u ## tt2(i1-1,i2,i3,m)+u ## tt2(i1+1,i2,i3,m))/(2.*dr(0))
!  #defineMacro u ## Astt2(i1,i2,i3,m) (-u ## tt2(i1,i2-1,i3,m)+u ## tt2(i1,i2+1,i3,m))/(2.*dr(1))
!  #defineMacro u ## Attt2(i1,i2,i3,m) (-u(i1,i2,i3-2,m)+2.*u(i1,i2,i3-1,m)-2.*u(i1,i2,i3+1,m)+u(i1,i2,i3+2,m))/(2.*dr(2)**3)
!  #defineMacro u ## Ar4(i1,i2,i3,m) (u(i1-2,i2,i3,m)-8.*u(i1-1,i2,i3,m)+8.*u(i1+1,i2,i3,m)-u(i1+2,i2,i3,m))/(12.*dr(0))
!  #defineMacro u ## As4(i1,i2,i3,m) (u(i1,i2-2,i3,m)-8.*u(i1,i2-1,i3,m)+8.*u(i1,i2+1,i3,m)-u(i1,i2+2,i3,m))/(12.*dr(1))
!  #defineMacro u ## At4(i1,i2,i3,m) (u(i1,i2,i3-2,m)-8.*u(i1,i2,i3-1,m)+8.*u(i1,i2,i3+1,m)-u(i1,i2,i3+2,m))/(12.*dr(2))
!  #defineMacro u ## Arr4(i1,i2,i3,m) (-u(i1-2,i2,i3,m)+16.*u(i1-1,i2,i3,m)-30.*u(i1,i2,i3,m)+16.*u(i1+1,i2,i3,m)-u(i1+2,i2,i3,m))/(12.*dr(0)**2)
!  #defineMacro u ## Ars4(i1,i2,i3,m) (u ## s4(i1-2,i2,i3,m)-8.*u ## s4(i1-1,i2,i3,m)+8.*u ## s4(i1+1,i2,i3,m)-u ## s4(i1+2,i2,i3,m))/(12.*dr(0))
!  #defineMacro u ## Ass4(i1,i2,i3,m) (-u(i1,i2-2,i3,m)+16.*u(i1,i2-1,i3,m)-30.*u(i1,i2,i3,m)+16.*u(i1,i2+1,i3,m)-u(i1,i2+2,i3,m))/(12.*dr(1)**2)
!  #defineMacro u ## Art4(i1,i2,i3,m) (u ## t4(i1-2,i2,i3,m)-8.*u ## t4(i1-1,i2,i3,m)+8.*u ## t4(i1+1,i2,i3,m)-u ## t4(i1+2,i2,i3,m))/(12.*dr(0))
!  #defineMacro u ## Ast4(i1,i2,i3,m) (u ## t4(i1,i2-2,i3,m)-8.*u ## t4(i1,i2-1,i3,m)+8.*u ## t4(i1,i2+1,i3,m)-u ## t4(i1,i2+2,i3,m))/(12.*dr(1))
!  #defineMacro u ## Att4(i1,i2,i3,m) (-u(i1,i2,i3-2,m)+16.*u(i1,i2,i3-1,m)-30.*u(i1,i2,i3,m)+16.*u(i1,i2,i3+1,m)-u(i1,i2,i3+2,m))/(12.*dr(2)**2)
!  #defineMacro u ## Arrr4(i1,i2,i3,m) (u(i1-3,i2,i3,m)-8.*u(i1-2,i2,i3,m)+13.*u(i1-1,i2,i3,m)-13.*u(i1+1,i2,i3,m)+8.*u(i1+2,i2,i3,m)-u(i1+3,i2,i3,m))/(8.*dr(0)**3)
!  #defineMacro u ## Arrs4(i1,i2,i3,m) (-u ## s4(i1-2,i2,i3,m)+16.*u ## s4(i1-1,i2,i3,m)-30.*u ## s4(i1,i2,i3,m)+16.*u ## s4(i1+1,i2,i3,m)-u ## s4(i1+2,i2,i3,m))/(12.*dr(0)**2)
!  #defineMacro u ## Arss4(i1,i2,i3,m) (u ## ss4(i1-2,i2,i3,m)-8.*u ## ss4(i1-1,i2,i3,m)+8.*u ## ss4(i1+1,i2,i3,m)-u ## ss4(i1+2,i2,i3,m))/(12.*dr(0))
!  #defineMacro u ## Asss4(i1,i2,i3,m) (u(i1,i2-3,i3,m)-8.*u(i1,i2-2,i3,m)+13.*u(i1,i2-1,i3,m)-13.*u(i1,i2+1,i3,m)+8.*u(i1,i2+2,i3,m)-u(i1,i2+3,i3,m))/(8.*dr(1)**3)
!  #defineMacro u ## Arrt4(i1,i2,i3,m) (-u ## t4(i1-2,i2,i3,m)+16.*u ## t4(i1-1,i2,i3,m)-30.*u ## t4(i1,i2,i3,m)+16.*u ## t4(i1+1,i2,i3,m)-u ## t4(i1+2,i2,i3,m))/(12.*dr(0)**2)
!  #defineMacro u ## Arst4(i1,i2,i3,m) (u ## st4(i1-2,i2,i3,m)-8.*u ## st4(i1-1,i2,i3,m)+8.*u ## st4(i1+1,i2,i3,m)-u ## st4(i1+2,i2,i3,m))/(12.*dr(0))
!  #defineMacro u ## Asst4(i1,i2,i3,m) (-u ## t4(i1,i2-2,i3,m)+16.*u ## t4(i1,i2-1,i3,m)-30.*u ## t4(i1,i2,i3,m)+16.*u ## t4(i1,i2+1,i3,m)-u ## t4(i1,i2+2,i3,m))/(12.*dr(1)**2)
!  #defineMacro u ## Artt4(i1,i2,i3,m) (u ## tt4(i1-2,i2,i3,m)-8.*u ## tt4(i1-1,i2,i3,m)+8.*u ## tt4(i1+1,i2,i3,m)-u ## tt4(i1+2,i2,i3,m))/(12.*dr(0))
!  #defineMacro u ## Astt4(i1,i2,i3,m) (u ## tt4(i1,i2-2,i3,m)-8.*u ## tt4(i1,i2-1,i3,m)+8.*u ## tt4(i1,i2+1,i3,m)-u ## tt4(i1,i2+2,i3,m))/(12.*dr(1))
!  #defineMacro u ## Attt4(i1,i2,i3,m) (u(i1,i2,i3-3,m)-8.*u(i1,i2,i3-2,m)+13.*u(i1,i2,i3-1,m)-13.*u(i1,i2,i3+1,m)+8.*u(i1,i2,i3+2,m)-u(i1,i2,i3+3,m))/(8.*dr(2)**3)
! #endMacro


! ! =======================================================
! !  Macro to compute Third derivatives in 2 dimensions 
! !  OPTION : evalMetrics : evaluate the derivatives of the metrics
! !          (metrics need only be evaluated once when using discrete delta to get coeffs)
! ! =======================================================
! #beginMacro getThirdDerivatives2d(ORDER,GRIDTYPE,OPTION,i1,i2,i3)

! #If #GRIDTYPE eq "rectangular" 
! ! ---------- RECTANGULAR  ---------
! uxxx = uxxx22r(i1,i2,i3,0)
! uxxy = uxxy22r(i1,i2,i3,0)
! uxyy = uxyy22r(i1,i2,i3,0)
! uyyy = uyyy22r(i1,i2,i3,0)

! #Else
! ! ---------- START CURVILINEAR  ---------
! defineParameticDerivativesComponents1(u)
! #If #OPTION eq "evalMetrics"
! defineParameticDerivativesComponents0(rx)
! defineParameticDerivativesComponents0(ry)
! defineParameticDerivativesComponents0(sx)
! defineParameticDerivativesComponents0(sy)
! #End

! ! ---------- Parametric derivatives ---------
! ur     = uAr4(i1,i2,i3,0)
! urr    = uArr4(i1,i2,i3,0)
! urrr   = uArrr2(i1,i2,i3,0)
! us     = uAs4(i1,i2,i3,0)
! urs    = uArs4(i1,i2,i3,0)
! urrs   = uArrs2(i1,i2,i3,0)
! uss    = uAss4(i1,i2,i3,0)
! urss   = uArss2(i1,i2,i3,0)
! usss   = uAsss2(i1,i2,i3,0)
! #If #OPTION eq "evalMetrics"
! rxr    = rxAr4(i1,i2,i3)
! rxrr   = rxArr4(i1,i2,i3)
! rxs    = rxAs4(i1,i2,i3)
! rxrs   = rxArs4(i1,i2,i3)
! rxss   = rxAss4(i1,i2,i3)
! ryr    = ryAr4(i1,i2,i3)
! ryrr   = ryArr4(i1,i2,i3)
! rys    = ryAs4(i1,i2,i3)
! ryrs   = ryArs4(i1,i2,i3)
! ryss   = ryAss4(i1,i2,i3)
! sxr    = sxAr4(i1,i2,i3)
! sxrr   = sxArr4(i1,i2,i3)
! sxs    = sxAs4(i1,i2,i3)
! sxrs   = sxArs4(i1,i2,i3)
! sxss   = sxAss4(i1,i2,i3)
! syr    = syAr4(i1,i2,i3)
! syrr   = syArr4(i1,i2,i3)
! sys    = syAs4(i1,i2,i3)
! syrs   = syArs4(i1,i2,i3)
! syss   = syAss4(i1,i2,i3)

! ! ---------- Spatial derivatives of metrics rx, sx, ry, ... ---------
! rxi = rx(i1,i2,i3)
! ryi = ry(i1,i2,i3)
! sxi = sx(i1,i2,i3)
! syi = sy(i1,i2,i3)
! rxx = rxi*rxr+sxi*rxs
! rxxx = rxi**2*rxrr+2.*rxi*sxi*rxrs+sxi**2*rxss+rxx*rxr+sxx*rxs
! rxy = ryi*rxr+syi*rxs
! rxxy = ryi*rxi*rxrr+(rxi*syi+ryi*sxi)*rxrs+syi*sxi*rxss+rxy*rxr+sxy*rxs
! rxyy = ryi**2*rxrr+2.*ryi*syi*rxrs+syi**2*rxss+ryy*rxr+syy*rxs
! ryy = ryi*ryr+syi*rys
! ryyy = ryi**2*ryrr+2.*ryi*syi*ryrs+syi**2*ryss+ryy*ryr+syy*rys
! sxx = rxi*sxr+sxi*sxs
! sxxx = rxi**2*sxrr+2.*rxi*sxi*sxrs+sxi**2*sxss+rxx*sxr+sxx*sxs
! sxy = ryi*sxr+syi*sxs
! sxxy = ryi*rxi*sxrr+(rxi*syi+ryi*sxi)*sxrs+syi*sxi*sxss+rxy*sxr+sxy*sxs
! sxyy = ryi**2*sxrr+2.*ryi*syi*sxrs+syi**2*sxss+ryy*sxr+syy*sxs
! syy = ryi*syr+syi*sys
! syyy = ryi**2*syrr+2.*ryi*syi*syrs+syi**2*syss+ryy*syr+syy*sys
! #End
! ! ---- end OPTION eq evalMetrics ---

! ! ---------- Third spatial derivatives of u ---------
! uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
! uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
! uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
! uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us
! ! ---------- END CURVILINEAR  ---------
! #End
! #endMacro



! define macros to evaluate derivatives for the 6th order method (from maple/makeGetDerivativesMacros.maple)
!! turned off May 4, 2023
!! #Include "../maple/defineGetSixthDerivativesMacros.h"


! From bcOptSmFOS.bf
! DataBase *pdb = &parameters.dbase;
! double precision pdb  ! pointer to data base
! ====================================================================
! Look up an integer parameter from the data base
! ====================================================================
#beginMacro getIntParameter(name)
 ok=getInt(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** bcOptWave:getInt:ERROR: unable to find name")') 
   stop 1122
 end if
#endMacro

! ====================================================================
! Look up a real parameter from the data base
! ====================================================================
#beginMacro getRealParameter(name)
 ok=getReal(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** bcOptWave:getReal:ERROR: unable to find name")') 
   stop 1133
 end if
#endMacro



! General begin loops macro
#beginMacro beginLoops(n1a,n1b,n2a,n2b,n3a,n3b)
do i3=n3a,n3b
do i2=n2a,n2b
do i1=n1a,n1b
#endMacro

#beginMacro endLoops()
end do
end do
end do
#endMacro


#beginMacro beginLoops2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro
#beginMacro endLoops2d()
 end do
 end do
#endMacro

#beginMacro beginLoopsMask2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro
#beginMacro endLoopsMask2d()
 end if
 end do
 end do
#endMacro

#beginMacro beginGhostLoops2d()
 i3=n3a
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

#beginMacro beginLoops3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro

#beginMacro endLoops3d()
 end do
 end do
 end do
#endMacro

#beginMacro beginLoopsMask3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro

#beginMacro endLoopsMask3d()
 end if
 end do
 end do
 end do
#endMacro

#beginMacro beginGhostLoops3d()
 do i3=nn3a,nn3b
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

! ----- define extrapolation formulae ------

#defineMacro extrap2(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   2.*uu(k1,k2,k3,kc)\
                  -uu(k1+  ks1,k2+  ks2,k3+  ks3,kc))

#defineMacro extrap3(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   3.*uu(k1,k2,k3,kc)\
               -3.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
                  +uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc))

#defineMacro extrap4(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   4.*uu(k1,k2,k3,kc)\
               -6.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
               +4.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
                  -uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc))

#defineMacro extrap5(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   5.*uu(k1,k2,k3,kc)\
              -10.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +10.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
               -5.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
                  +uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc))

#defineMacro extrap6(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   6.*uu(k1,k2,k3,kc)\
              -15.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +20.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -15.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
               +6.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
               -   uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc) )

#defineMacro extrap7(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   7.*uu(k1,k2,k3,kc)\
              -21.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +35.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -35.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
              +21.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
               -7.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
                +  uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc) )

#defineMacro extrap8(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   8.*uu(k1,k2,k3,kc)\
              -28.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +56.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -70.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
              +56.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
              -28.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
               +8.*uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc)\
                -  uu(k1+7*ks1,k2+7*ks2,k3+7*ks3,kc) )

#defineMacro extrap9(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   9.*uu(k1,k2,k3,kc)\
              -36.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +84.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
             -126.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
             +126.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
              -84.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
              +36.*uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc)\
               -9.*uu(k1+7*ks1,k2+7*ks2,k3+7*ks3,kc)\
                  +uu(k1+8*ks1,k2+8*ks2,k3+8*ks3,kc) )            



! ************************************************************************************************
!  This macro is used for looping over the faces of a grid to assign booundary conditions
!
! extra: extra points to assign
!          Case 1: extra=numberOfGhostPoints -- for assigning extended boundaries
!          Case 2: extra=-1 -- for assigning ghost points but not including extended boundaries
! numberOfGhostPoints : number of ghost points (1 for 2nd order, 2 for fourth-order ...)
!
!
! Output:
!  n1a,n1b,n2a,n2b,n3a,n3b : from gridIndexRange
!  nn1a,nn1b,nn2a,nn2b,nn3a,nn3b : includes "extra" points
! 
! ***********************************************************************************************
#beginMacro beginLoopOverSides(extra,numberOfGhostPoints)
 extra1a=extra
 extra1b=extra
 extra2a=extra
 extra2b=extra
 if( nd.eq.3 )then
   extra3a=extra
   extra3b=extra
 else
   extra3a=0
   extra3b=0
 end if
 if( bc(0,0).lt.0 )then
   extra1a=max(0,extra1a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( bc(0,0).eq.0 )then
   extra1a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( bc(1,0).lt.0 )then
   extra1b=max(0,extra1b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( bc(1,0).eq.0 )then
   extra1b=numberOfGhostPoints
 end if

 if( bc(0,1).lt.0 )then
   extra2a=max(0,extra2a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( bc(0,1).eq.0 )then
   extra2a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( bc(1,1).lt.0 )then
   extra2b=max(0,extra2b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( bc(1,1).eq.0 )then
   extra2b=numberOfGhostPoints
 end if

 if(  nd.eq.3 )then
  if( bc(0,2).lt.0 )then
    extra3a=max(0,extra3a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
  else if( bc(0,2).eq.0 )then
    extra3a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
  end if
  ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
  if( bc(1,2).lt.0 )then
    extra3b=max(0,extra3b) ! over-ride extra=-1 : assign ends in periodic directions
  else if( bc(1,2).eq.0 )then
    extra3b=numberOfGhostPoints
  end if
 end if

 do axis=0,nd-1
 do side=0,1

   if( .true. .or. bc(side,axis).gt.0 )then ! we may set ghost outside interp for implicit

     ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,bc(side,axis)

     n1a=gridIndexRange(0,0)
     n1b=gridIndexRange(1,0)
     n2a=gridIndexRange(0,1)
     n2b=gridIndexRange(1,1)
     n3a=gridIndexRange(0,2)
     n3b=gridIndexRange(1,2)
     if( axis.eq.0 )then
       n1a=gridIndexRange(side,axis)
       n1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       n2a=gridIndexRange(side,axis)
       n2b=gridIndexRange(side,axis)
     else
       n3a=gridIndexRange(side,axis)
       n3b=gridIndexRange(side,axis)
     end if


     nn1a=gridIndexRange(0,0)-extra1a
     nn1b=gridIndexRange(1,0)+extra1b
     nn2a=gridIndexRange(0,1)-extra2a
     nn2b=gridIndexRange(1,1)+extra2b
     nn3a=gridIndexRange(0,2)-extra3a
     nn3b=gridIndexRange(1,2)+extra3b
     if( axis.eq.0 )then
       nn1a=gridIndexRange(side,axis)
       nn1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       nn2a=gridIndexRange(side,axis)
       nn2b=gridIndexRange(side,axis)
     else
       nn3a=gridIndexRange(side,axis)
       nn3b=gridIndexRange(side,axis)
     end if

     is=1-2*side

     is1=0
     is2=0
     is3=0
     if( axis.eq.0 )then
       is1=1-2*side
     else if( axis.eq.1 )then
       is2=1-2*side
     else if( axis.eq.2 )then
       is3=1-2*side
     else
       stop 5
     end if
     
     axisp1=mod(axis+1,nd)
     axisp2=mod(axis+2,nd)
     
     i3=n3a

     if( debug.gt.7 )then
       write(*,'(" bcOptWave: grid,side,axis=",3i3,", \
         loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,\
         n1a,n1b,n2a,n2b,n3a,n3b

     end if
   end if ! if bc>0 

   assignTwilightZone=twilightZone

#endMacro

#beginMacro endLoopOverSides()
 end do ! end side
 end do ! end axis
#endMacro


#beginMacro getNormal2d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2))
 an1=an1*aNormi
 an2=an2*aNormi
#endMacro

#beginMacro getNormal3d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 an3 = rsxy(i1,i2,i3,axis,2)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2+ an3**2))
 an1=an1*aNormi
 an2=an2*aNormi
 an3=an3*aNormi
#endMacro



! =================================================================================
!   Assign values in the corners in 2D (see bcMaxwellCorners.bf)
!
!  Set the normal component of the solution on the extended boundaries (points N in figure)
!  Set the corner points "C" 
!              |
!              X
!              |
!        N--N--X--X----
!              |
!        C  C  N
!              |
!        C  C  N
!
! ORDER: 2 or 4
! GRIDTYPE: rectangular, curvilinear
! FORCING: none, twilightZone
! =================================================================================
#beginMacro assignCorners2d(ORDER,GRIDTYPE,FORCING)

  axis=0
  axisp1=1

  i3=gridIndexRange(0,2)
  ! numberOfGhostPoints=orderOfAccuracy/2


  do side1=0,1
  do side2=0,1
  if( bc(side1,0).eq.tractionBC .and.\
      bc(side2,1).eq.tractionBC )then

    i1=gridIndexRange(side1,0) ! (i1,i2,i3)=corner point
    i2=gridIndexRange(side2,1)

    ! write(*,'("bcOpt: assign corner side1,side2,i1,i2,i3=",2i2,3i5)') side1,side2,i1,i2,i3

    is1=1-2*side1
    is2=1-2*side2

!   dra=dr(0)*is1
!   dsa=dr(1)*is2

    ! First assign normal component of the displacement:
    ! u.x=u.xxx=0 --> u is even in x
    ! v.y=v.yyy=0 --> v is even in y
    do m=1,numberOfGhostPoints

      js1=is1*m  ! shift to ghost point "m"
      js2=is2*m

      #If #GRIDTYPE == "rectangular"

        u(i1-js1,i2,i3,uc)=u(i1+js1,i2,i3,uc)
        u(i1,i2-js2,i3,vc)=u(i1,i2+js2,i3,vc)

        #If #FORCING == "twilightZone"
          OGF2D(i1-js1,i2,i3,t,um,vm)
          OGF2D(i1+js1,i2,i3,t,up,vp)
          u(i1-js1,i2,i3,uc)=u(i1-js1,i2,i3,uc) + um-up

          OGF2D(i1,i2-js2,i3,t,um,vm)
          OGF2D(i1,i2+js2,i3,t,up,vp)
          u(i1,i2-js2,i3,vc)=u(i1,i2-js2,i3,vc) + vm-vp

        #Elif #FORCING == "none"
        #Else
          stop 6767
        #End

      #Elif #GRIDTYPE == "curvilinear"
        stop 1116
      #Else
        stop 1117
      #End
    end do 

    ! Now assign the tangential components of the displacement 
    alpha=lambda/(lambda+2.*mu)  
    #If #ORDER eq "2" 
      js1=is1
      js2=is2
      #If #GRIDTYPE == "rectangular"
        ! u.yy = alpha*u.xx
        ! v.xx = alpha*v.yy

        u(i1,i2-js2,i3,uc)=2.*u(i1,i2,i3,uc)-u(i1,i2+js2,i3,uc) +dx(1)**2*alpha*uxx22r(i1,i2,i3,uc)
        u(i1-js1,i2,i3,vc)=2.*u(i1,i2,i3,vc)-u(i1+js1,i2,i3,vc) +dx(0)**2*alpha*uyy22r(i1,i2,i3,vc)
      
        #If #FORCING == "twilightZone"

          OGDERIV2D(0,2,0,0,i1,i2,i3,t,uxx0,vxx0)
          OGDERIV2D(0,0,2,0,i1,i2,i3,t,uyy0,vyy0)

          u(i1,i2-js2,i3,uc)=u(i1,i2-js2,i3,uc) +dx(1)**2*( -alpha*uxx0+ uyy0)
          u(i1-js1,i2,i3,vc)=u(i1-js1,i2,i3,vc) +dx(0)**2*( -alpha*vyy0+ vxx0)

          if( debug.gt.0 )then
            OGF2D(i1-js1,i2,i3,t,um,vm)
            OGF2D(i1,i2-js2,i3,t,up,vp)
            write(*,'(" bcOpt:corner: i1,i2=",2i4," uerr,verr=",4e10.2)') i1,i2,\
                  u(i1-js1,i2,i3,uc)-um,u(i1-js1,i2,i3,vc)-vm,\
                  u(i1,i2-js2,i3,uc)-up,u(i1,i2-js2,i3,vc)-vp
            ! '
          end if

        #Elif #FORCING == "none"
        #Else
          stop 6767
        #End
          
      #Elif #GRIDTYPE == "curvilinear"
        stop 1116
      #Else
        stop 1117
      #End

    #Elif #ORDER eq "4" 
      stop 2221
    #Else
    #End


    ! Now do corner (C) points
    ! Taylor series: 
    !   u(-x,-y) = u(x,y) - 2*x*u.x(0,0) - 2*y*u.y(0,0) + O( h^3 )
  ! ** u(i1-is1,i2-is2,i3,uc)=u(i1+is1,i2+is2,i3,uc) -2.*is1*dx(0)*ux22r(i1,i2,i3,uc) -2.*is2*dx(1)*uy22r(i1,i2,i3,uc)
  ! ** u(i1-is1,i2-is2,i3,vc)=u(i1+is1,i2+is2,i3,vc) -2.*is1*dx(0)*ux22r(i1,i2,i3,vc) -2.*is2*dx(1)*uy22r(i1,i2,i3,vc)

    ! This version uses u.xy = - v.xx, v.xy = - u.yy
    u(i1-is1,i2-is2,i3,uc)=2.*u(i1,i2,i3,uc) - u(i1+is1,i2+is2,i3,uc) \
                     +dx(0)**2*uxx22r(i1,i2,i3,uc) - 2.*dx(0)*dx(1)*uxx22r(i1,i2,i3,vc) +dx(1)**2*uyy22r(i1,i2,i3,uc)
    u(i1-is1,i2-is2,i3,vc)=2.*u(i1,i2,i3,vc) - u(i1+is1,i2+is2,i3,vc) \
                     +dx(0)**2*uxx22r(i1,i2,i3,vc) - 2.*dx(0)*dx(1)*uyy22r(i1,i2,i3,uc) +dx(1)**2*uyy22r(i1,i2,i3,vc)

  else if( (bc(side1,0).eq.tractionBC .and. bc(side2,1).eq.displacementBC) .or.\
           (bc(side1,0).eq.displacementBC  .and. bc(side2,1).eq.tractionBC) )then 

    ! displacementBC next to stress free
    stop 2311

  else if( bc(side1,0).eq.displacementBC .and. bc(side2,1).eq.displacementBC )then

    ! displacementBC next to displacementBC
    ! do we need to do anything in this case ? *wdh* 071012
    ! stop 2312

  else if( bc(side1,0).gt.0 .and. bc(side2,1).gt.0 )then

    ! unknown 
    stop 2313

  end if
  end do
  end do

#endMacro


#beginMacro assignCorners3d(ORDER,GRIDTYPE,FORCING)
  ! numberOfGhostPoints=orderOfAccuracy/2


  ! Assign the edges
  assignEdges3d(ORDER,GRIDTYPE,FORCING)



  ! Finally assign points outside the vertices of the unit cube
  g1=0.
  g2=0.
  g3=0.

  do side3=0,1
  do side2=0,1
  do side1=0,1

   ! assign ghost values outside the corner (vertex)
   i1=gridIndexRange(side1,0)
   i2=gridIndexRange(side2,1)
   i3=gridIndexRange(side3,2)
   is1=1-2*side1
   is2=1-2*side2
   is3=1-2*side3

   if( bc(side1,0).eq.perfectElectricalConductor .and.\
       bc(side2,1).eq.perfectElectricalConductor .and.\
       bc(side3,2).eq.perfectElectricalConductor )then

   end if

  end do
  end do
  end do
#endMacro





! =========================================================================
! Compute the normal on a curvilinear grid.
!
! Assumes is=1-2*side is defined. 
! =========================================================================
#beginMacro getNormal(j1,j2,j3)
    an1 = rsxy(j1,j2,j3,axis,0)
    an2 = rsxy(j1,j2,j3,axis,1)
    if( nd.eq.2 )then
     aNormi = (-is)/sqrt(an1**2+an2**2)
     an1=an1*aNormi
     an2=an2*aNormi
    else
     an3 = rsxy(j1,j2,j3,axis,2)
     aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
     an1=an1*aNormi
     an2=an2*aNormi
     an3=an3*aNormi
    end if
#endMacro

! ========================================================================================
!  Assign ghost points outside corners
! ========================================================================================
#beginMacro assignCornerGhostsMacro()
  ! ---------------------------------
  ! --- assign corners and edges: ---
  ! ---------------------------------

 ! From op/src/BoundaryConditionParameters.h
 ! enum CornerBoundaryConditionEnum
 !  {
 !    doNothingCorner=-1,  
 !    extrapolateCorner=0,
 !    symmetryCorner,  // should be replaced by the one of the odd,even below -- keep for compatibility
 !    taylor2ndOrder,  // should be replaced by the taylor2ndOrderOddCorner below -- keep for compatibility
 !    evenSymmetryCorner,
 !    oddSymmetryCorner,
 !    taylor2ndOrderEvenCorner,
 !    taylor4thOrderEvenCorner,
 !    vectorSymmetryAxis1Corner,       // even symmetry on all variables except normal component of the "velocity"
 !    vectorSymmetryAxis2Corner, 
 !    vectorSymmetryAxis3Corner
 !  };

  stop 666
  ! ** FIX ME :
  !   cornerBC(0:2,0:2,0:2) : 2=edge in 3D 
  do side3=0,1
  do side2=0,1
  do side1=0,1
    if( orderOfAccuracy.ge.4. .and. bc(side1,0).eq.neumann .and. \
                                    bc(side2,1).eq.neumann .and. \
                     ( nd.eq.2 .or. bc(side3,2).eq.neumann ) )then
      ! ---- This is a Neumann-Neumann corner ----
      cornerBC(side1,side2,side3)=extrapolateCorner

      ! if( t.le.2*dt  )then
      !   write(*,'("Assign special Neumann corners conditions ")')
      ! end if
      ! cornerBC(side1,side2,side3)=taylor4thOrderEvenCorner
      ! cornerBC(side1,side2,side3)=evenSymmetryCorner
      ! cornerBC(side1,side2,side3)=0 
    else if(            bc(side1,0).eq.exactBC .and. \
                        bc(side2,1).eq.exactBC .and. \
         ( nd.eq.2 .or. bc(side3,2).eq.exactBC ) )then

      ! ---- Do nothing at this exact corner 

      cornerBC(side1,side2,side3)=-1

    else 
      cornerBC(side1,side2,side3)=0         ! extrapolateCorner=0, (BoundaryConditionParameters)
    end if 
  end do
  end do
  end do

  ! orderOfExtrapolationForCorners=5
  orderOfExtrapolationForCorners= orderOfAccuracy+1

  iparc(0)=uc
  iparc(1)=uc
  iparc(2)=0                              ! useWhereMask;
  iparc(3)=orderOfExtrapolationForCorners
  iparc(4)=numGhost                       ! numberOfCornerGhostLinesToAssign
  iparc(5)=0                              ! cornerExtrapolationOption : 0=extrap along diagonals
  iparc(6)=0                              ! vectorSymmetryCornerComponent
  iparc(7)=gridType

  rparc(0)=epsx ! normEps

  ! Note: is it ok to use gridIndexRange instead of indexRange here: ??
  call fixBoundaryCornersOpt( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,0,uc,\
             nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, u,mask,rsxy, gridIndexRange, dimRange, \
             isPeriodic, boundaryCondition, cornerBC, iparc, rparc )
#endMacro




! ===================================================================================================
! Macro: Extrapolate Ghost Points 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro extrapolateGhost(ORDER)

  #If #ORDER eq "2"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap3(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "4"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap5(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "6"
    ! #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap6(u,i1,i2,i3,n,is1,is2,is3)
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap7(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "8"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap9(u,i1,i2,i3,n,is1,is2,is3)
  #Else
     write(*,'("bcOptWave: unexpected order=ORDER")') 
    stop 1010
  #End

  ! ghost-loops will assign extra points in tangential directions
  beginGhostLoops3d()
    if( mask(i1,i2,i3).ne.0 )then
     
      ! -- extrapolate ghost ---
      do ghost=1,numGhost
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost

        u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 

      end do
       
    end if ! mask .ne. 0
  endLoops3d()
#endMacro


! ============================================================================================
! Macro: evaluate the solution on the boundary for Dirichlet BCs
! ============================================================================================
#beginMacro getDirichletForcing(ff,i1,i2,i3)
  if( assignTwilightZone.eq.1 )then
    ! compute RHS from TZ
    if( nd.eq.2 )then
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
    else
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
    end if
    ff = ue
  else if( assignKnownSolutionAtBoundaries.eq.1 )then
    ! -- we set inhomogeneous Dirichlet values for some known solutions 
    if( knownSolutionOption.eq.planeWave )then
      ! --- evaluate the plane wave solution ---
      if( nd.eq.2 )then
        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
      else
        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
      end if 

    else if( knownSolutionOption.eq.gaussianPlaneWave ) then
      ! Eval the Gaussian plane wave solution
      !    u = exp( -beta*(xi^2) )*cos( k0*xi )
      !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
      !  
      if( nd.eq.2 )then
        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
      else
        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
      end if 
      ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      

    else if( knownSolutionOption.eq.boxHelmholtz ) then
      ! --- evaluate the boxHelmholtz solution ---
      ! For multi-freq we add up all the component frequencies
      ff = 0. 
      do freq=0,numberOfFrequencies-1
        ! kx = kxBoxHelmholtz + twoPi*freq
        ! ky = kyBoxHelmholtz + twoPi*freq
        ! kz = kzBoxHelmholtz + twoPi*freq
        ! coswt = cos( frequencyArray(freq)*t )

        getBoxHelmholtzParameters( freq, omega, kx,ky,kz, F90 )
        coswt = cos( omega*t )
        if( nd.eq.2 )then
          ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) *coswt
        else
          ff = ff + sin( kx*xy(i1,i2,i3,0) ) * sin( ky*xy(i1,i2,i3,1) ) * sin( kz*xy(i1,i2,i3,2) ) *coswt
        end if 
      end do

    else if( knownSolutionOption.eq.polyPeriodic ) then
      ! --- evaluate the polyPeriodic solution ---
      if( nd.eq.2 )then
        ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1)                                 ) *coswt
      else
        ff = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
      end if 

    else
      stop 9876
    end if 
  end if
#endMacro      

! ===================================================================================================
! Macro: Assign boundary and ghost points on Dirichlet boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro assignDirichletBoundaryAndGhost(ORDER)

  #If #ORDER eq "2"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap3(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "4"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap5(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "6"
    ! #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap6(u,i1,i2,i3,n,is1,is2,is3)
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap7(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "8"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap9(u,i1,i2,i3,n,is1,is2,is3)
  #Else
     write(*,'("bcOptWave: unexpected order=ORDER")') 
    stop 1010
  #End

  ff=0.
  if( addForcingBC.eq.1 )then  
    beginLoops3d()
      if( mask(i1,i2,i3).ne.0 )then
       
        ! --- get the RHS to the Dirichlet BC ---
        getDirichletForcing(ff,i1,i2,i3)

        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=ff
    
        ! -- extrapolate ghost ---
        do ghost=1,numGhost
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost

          u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 

        end do

      end if ! mask .ne. 0
    endLoops3d()

  else

    ! --- no forcing ----
    if( numGhost.eq.1 )then
      ghost=1
      beginLoops3d()
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=0.
        ! -- extrapolate ghost ---
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost         
        u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
      endLoops3d()      
    else 
      beginLoops3d()
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=0.
        ! -- extrapolate ghost ---
        do ghost=1,numGhost
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost
          u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
        end do
      endLoops3d()
    end if

    if( .false. )then
      ! -- two loops ---
      ! --- no forcing ----
      beginLoops3d()
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=0.
      endLoops3d()

      ! -- extrapolate ghost ---
      do ghost=1,numGhost
        beginLoops3d() 
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost               
          u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 
        endLoops3d()    
      end do
    end if

  endif

#endMacro


! ============================================================================================
! Macro: evaluate the solution on the boundary for Dirichlet BCs
!    Solving
!        u_tt = c^2 * Delta( u ) + f(x,y,z,t)
!        u = g
! For TZ at order=2:
!    ff = ue_tt - c^2*Delta(ue) 
!    gtt = g_tt = uett
!  order=4:
!    fLap 
!    ftt
!    gtttt
! ============================================================================================
#beginMacro getDirichletCompatibilityForcing(FORCING,DIM,ORDER,ff,gtt,fLap,ftt,gtttt)
  #If #FORCING eq "noForcing"
    ! No forcing, do nothing 
  #Else
    if( assignTwilightZone.eq.1 )then
      ! compute RHS from TZ
      #If #DIM eq 2
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
        ueLap = uexx + ueyy
        call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uett )
        #If #ORDER eq "4"
          call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettxx )
          call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettyy )
          uettLap = uettxx + uettyy

          call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx )
          call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
          call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )

          ueLap2 = uexxxx + 2.*uexxyy + ueyyyy ! Lap^2( u )

          call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )

        #End
      #Else
        ! 3D 
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
        call ogDeriv(ep,0,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezz )
        ueLap = uexx + ueyy + uezz
        call ogDeriv(ep,2,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uett )
        #If #ORDER eq "4"
          call ogDeriv(ep,2,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettxx )
          call ogDeriv(ep,2,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettyy )
          call ogDeriv(ep,2,0,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettzz )
          uettLap = uettxx + uettyy + uettzz

          call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxxx )
          call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyyy )
          call ogDeriv(ep,0,0,0,4,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzzz )
          call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxyy )
          call ogDeriv(ep,0,2,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxzz )
          call ogDeriv(ep,0,0,2,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyzz )

          ueLap2 = uexxxx + 2.*( uexxyy + uexxzz + ueyyzz)  + ueyyyy + uezzzz ! Lap^2( u )

          call ogDeriv(ep,4,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetttt )

        #End      

      #End
      ff = uett - c2*ueLap
      gtt = uett

      #If #ORDER eq "4"
        fLap = uettLap - c2*ueLap2 
        ftt  = uetttt - c2*uettLap
        gtttt = uetttt
      #End    


    else
      ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.;
    end if
  #End
#endMacro      


! ===================================================================================================
! Macro: Assign the boundary values on Dirichlet boundaries
!
!  NOTE: DIM AND GRIDTYPE NOT CURRENTLY USED
!  FORCE : USEFORCING or NOFORCING 
! ===================================================================================================
#beginMacro assignDirichletBoundary(DIM,ORDER,GRIDTYPE)

  ff=0.
  if( addForcingBC.eq.1 )then
    beginLoops3d()
      if( mask(i1,i2,i3).ne.0 )then
       
        ! --- get the RHS to the Dirichlet BC ---
        #If #FORCING eq "USEFORCING"
          getDirichletForcing(ff,i1,i2,i3)
        #End
    
        ! --- Dirichlet BC ---
        u(i1,i2,i3,uc)=ff
    
      end if ! mask .ne. 0
    endLoops3d()
  else
    ! Homogenous BCs 
    beginLoops3d()
      u(i1,i2,i3,uc)=0.
    endLoops3d() 

  end if

#endMacro

! ===================================================================================================
! Macro: Assign the boundary values on "exact" boundaries
!
! **NOT USED ANY MORE**
! Exact boundaries are set in applyBoundaryConditions.bC
!
! ===================================================================================================
! #beginMacro assignExactBoundary()

!   ! assign extram points in the tangential directions
!   extram = numGhost 
!   getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

!   ff=0.
!   beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
!     if( mask(i1,i2,i3).ne.0 )then
     
!       do ghost=0,numGhost
!         j1=i1-is1*ghost
!         j2=i2-is2*ghost
!         j3=i3-is3*ghost

!         getDirichletForcing(ff,j1,j2,j3)

!         u(j1,j2,j3,uc) = ff

!       end do
  
!     end if ! mask .ne. 0
!   endLoops3d()

! #endMacro



! ===================================================================================================
! Macro: get loop bounds over boundaries with extram points in tangential directions 
! ===================================================================================================
#beginMacro getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)
  m1a=gridIndexRange(0,0)-extram
  m1b=gridIndexRange(1,0)+extram
  m2a=gridIndexRange(0,1)-extram
  m2b=gridIndexRange(1,1)+extram
  if( nd.eq.2 )then
    m3a=gridIndexRange(0,2)
    m3b=gridIndexRange(1,2)
  else
    m3a=gridIndexRange(0,2)-extram
    m3b=gridIndexRange(1,2)+extram
  end if
  if( axis.eq.0 )then
   m1a=gridIndexRange(side,axis)
   m1b=gridIndexRange(side,axis)
  else if( axis.eq.1 )then
   m2a=gridIndexRange(side,axis)
   m2b=gridIndexRange(side,axis)
  else
   m3a=gridIndexRange(side,axis)
   m3b=gridIndexRange(side,axis)
  end if
#endMacro


! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 2,4,6,8
! FORCING : noForcing, forcing
! ===================================================================================================
#beginMacro assignDirichletGhostCompatibility(DIM,ORDER,GRIDTYPE,FORCING)

  !---------------------------------------------------------------
  ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
  !---------------------------------------------------------------
  ! assign extram points in the tangential directions
  extram = numGhost-1 
  getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 
  beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)

    if( mask(i1,i2,i3).gt.0 )then ! valid discretization point on the boundary 

      ! --- get the compatibility forcings for order=2 ---
      getDirichletCompatibilityForcing(FORCING,DIM,2,ff,gtt,fLap,ftt,gtttt)

      ! u_tt = c^2*Lap(u) + f 
      #If #GRIDTYPE eq "rectangular"
        ! uLap = ulaplacian22r or ulaplacian23r 
        uLap = ulaplacian2 ## DIM ## r(i1,i2,i3,0)
        r1 = uLap + (ff - gtt)/c2            ! residual in equation using current ghost value
        a11 = 1./( dx(axis)**2 )                                  ! coeff of u(-1) in r1 
      #Else
        ! uLap = ulaplacian22 or ulaplacian23 
        uLap = ulaplacian2 ## DIM(i1,i2,i3,0)
        r1 = uLap + (ff - gtt)/c2
        #If #DIM eq "2"
          a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
        #Else
          a11 = ( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2 )/( dr(axis)**2 )  ! coeff of u(-1) in r1 
        #End
      #End

      ghost =1 
      j1=i1-is1*ghost
      j2=i2-is2*ghost
      j3=i3-is3*ghost
      u(j1,j2,j3,0) = u(j1,j2,j3,0) - r1/a11 
      if( .false. )then
        ! check the error
        call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
        write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2, "  (order 2 update)")') i1,i2,u(j1,j2,j3,0),abs(u(j1,j2,j3,0)-ue1)
      end if

      #If #ORDER eq "2" 
        if( numGhost.gt.1 )then
          ghost =2
          k1=i1-is1*ghost
          k2=i2-is2*ghost
          k3=i3-is3*ghost   
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if
      #End

    else if( mask(i1,i2,i3).lt.0 )then ! interpolation point on the boundary 
      ! ----- extrap ghost outside interp. pts on physical boundaries ------
      ghost = 1 
      j1=i1-is1*ghost
      j2=i2-is2*ghost
      j3=i3-is3*ghost
      u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)

      #If #ORDER eq "2" 
        if( numGhost.gt.1 )then
          ! extrap second ghost (UPW)
          ghost = 2
          k1=i1-is1*ghost
          k2=i2-is2*ghost
          k3=i3-is3*ghost              
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
        end if
      #End
    end if ! mask 
  endLoops()


  #If #ORDER eq "4"

    !----------------------------------------------------------------
    ! --- STAGE II fill in first ghost by 4th-order compatibility ---
    !----------------------------------------------------------------

    #If #GRIDTYPE eq "curvilinear"
      ! Compute and save v = Lap(u) at some points near the boundary
      !  for use below to compute Lap^2 (u)
      !          |
      !        +-X-+
      !          |
      !        +-X-+
      !          |
      !        +-X-+
      !          |
      !        +-X-+
      !          |
      !         r=0 

      beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)
        ! eval Lap(u) on ghost, boundary and first line in:
        if( mask(i1,i2,i3).ne.0 )then 
          v(i1-is1,i2-is2,i3-is3,0) = ulaplacian2 ## DIM(i1-is1,i2-is2,i3-is3,0)
          v(i1    ,i2    ,i3    ,0) = ulaplacian2 ## DIM(i1    ,i2    ,i3    ,0)
          v(i1+is1,i2+is2,i3+is3,0) = ulaplacian2 ## DIM(i1+is1,i2+is2,i3+is3,0)
        end if
      endLoops()      

    #End

    ! --- fill in two ghost using 4th- order compatibility ---
    beginLoops3d()
      if( mask(i1,i2,i3).gt.0 )then

        ! --- get the compatibility forcings at order=4 ---
        getDirichletCompatibilityForcing(FORCING,DIM,4,ff,gtt,fLap,ftt,gtttt)

        ! u_tt = c^2*Lap(u) + f 
        ! u_tttt = c^2*Lap(u_tt) + f_tt 
        !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
        !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
   
        #If #GRIDTYPE eq "rectangular"
          ! uxx43r(i1,i2,i3,kd)=( -30.*u(i1,i2,i3,kd)+16.*(u(i1+1,i2,i3,kd)+u(i1-1,i2,i3,kd))-(u(i1+2,i2,i3,kd)+u(i1-2,i2,i3,kd)) )*dx42(0) 
          uLap = ulaplacian4 ## DIM ## r(i1,i2,i3,0)
          r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
          a11 = c2*16./(12.*dx(axis)**2)                           ! coeff of u(-1) in r1 
          a12 =    -c2/(12.*dx(axis)**2)                           ! coeff of u(-2) in r1
          ! uxxxx = 1 -4 6 -4 1
          ! vLap = Lap^2( u )
          vLap = lap ## DIM ## d2Pow2(i1,i2,i3,0)
          r2 =  c4*vLap + c2*fLap + ftt - gtttt
          a21 =  -c4*4./(dx(axis)**4)                              ! coeff of u(-1) in r2
          a22 =   c4*1./(dx(axis)**4)
        #Else
          ! curvilinear 
          ! uxx42(i1,i2,i3,kd)=(rsxy(i1,i2,i3,0,0)**2)*urr4(i1,i2,i3,kd)+2.*(rsxy(i1,i2,i3,0,0)*rsxy(i1,i2,i3,1,0))*urs4(i1,i2,i3,kd)+(rsxy(i1,i2,i3,1,0)**2)*uss4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,0,0))*ur4(i1,i2,i3,kd)+(rsxyx42(i1,i2,i3,1,0))*us4(i1,i2,i3,kd)
          uLap = ulaplacian4 ## DIM(i1,i2,i3,0)
          r1 =  c2*uLap + ff - gtt            ! residual in equation using current ghost value
          #If #DIM eq "2"
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
          #Else
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2
          #End
          a11 =  c2*rFactor*16./(12.*dr(axis)**2)                           ! coeff of u(-1) in r1 
          a12 = -c2*rFactor    /(12.*dr(axis)**2)                           ! coeff of u(-2) in r1
          ! vLap = Lap^2( u) to second-order
          ! vLap = vlaplacian22 or vlaplacian23 
          vLap = vlaplacian2 ## DIM(i1,i2,i3,0)
          r2 =  c4*vLap + c2*fLap + ftt - gtttt
          ! Here is the leading order term in a21, a22   ** this may not be good enough for stability but should remain accurate ***
          a21 =  -c4*( rFactor**2*4./(dr(axis)**4) )                             ! coeff of u(-1) in r2
          a22 =   c4*( rFactor**2   /(dr(axis)**4) )         

        #End

      if( .false. )then
        write(*,'("(i1,i2)=(",2i3,"),  r1,r2,a11,a12,a21,a22,vLap=",7(1pe9.2,1x))') i1,i2,r1,r2,a11,a12,a21,a22,vLap
      end if

        ghost =1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost =2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost        
        ! Solve
        !  [ a11 a12 ][ u(-1)] = [ a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1 ]
        !  [ a21 a22 ][ u(-2)]   [ a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2 ]
        f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
        f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2

        det = a11*a22 - a21*a12
        uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2)/det
        uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1)/det

        if( .false. )then
          ! check the error
          call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,ue1 )
          call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,ue2 )
          write(*,'("(i1,i2)=(",2i3,") u(-1)=",e10.3," err=",e8.2," u(-1)=",e10.3," err=",e8.2)') i1,i2,uTemp(j1,j2,j3,0),abs(uTemp(j1,j2,j3,0)-ue1),uTemp(k1,k2,k3,0),abs(uTemp(k1,k2,k3,0)-ue2)
        end if

      end if ! mask .gt. 0

    endLoops3d()

    ! ------ fill in ghost values from uTemp ----
    beginLoops3d()
      if( mask(i1,i2,i3).gt.0 )then
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost 
        u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
        u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          ghost = 3
          l1=i1-is1*ghost
          l2=i2-is2*ghost
          l3=i3-is3*ghost           
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if        
       
      else if( mask(i1,i2,i3).lt.0 )then
        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)

        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost           
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          ghost = 3
          l1=i1-is1*ghost
          l2=i2-is2*ghost
          l3=i3-is3*ghost           
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      end if    
    endLoops3d()
  #End

#endMacro

! ===================================================================================================
! Macro: Get the TZ solution in 2d or 3d 
! ===================================================================================================
#beginMacro getTZ(DIM,ntd,nxd,nyd,nzd,i1,i2,i3,t,uc,ued)
 #If DIM == 2
    call ogDeriv(ep,ntd,nxd,nyd,nzd,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ued )
 #Elif DIM == 3 
    call ogDeriv(ep,ntd,nxd,nyd,nzd,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ued )
 #Else
  stop 2299
 #End
#endMacro

! ===================================================================================================
! Macro: Evaluate the forcing for the CBCs
! ===================================================================================================
#beginMacro getDirichletCompatibilityForcingOrder6(FORCING,DIM,f1,f2,f3)
  #If #FORCING eq "noForcing"
    ! No forcing, do nothing 
  #Else
    if( assignTwilightZone.eq.1 )then
      ! compute RHS from TZ
      getTZ(DIM,0,2,0,0,i1,i2,i3,t,uc,uexx )
      getTZ(DIM,0,0,2,0,i1,i2,i3,t,uc,ueyy )

      getTZ(DIM,0,4,0,0,i1,i2,i3,t,uc,uexxxx )
      getTZ(DIM,0,2,2,0,i1,i2,i3,t,uc,uexxyy )
      getTZ(DIM,0,0,4,0,i1,i2,i3,t,uc,ueyyyy )

      getTZ(DIM,0,6,0,0,i1,i2,i3,t,uc,uexxxxxx )
      getTZ(DIM,0,4,2,0,i1,i2,i3,t,uc,uexxxxyy )
      getTZ(DIM,0,2,4,0,i1,i2,i3,t,uc,uexxyyyy )      
      getTZ(DIM,0,0,6,0,i1,i2,i3,t,uc,ueyyyyyy )      

      #If DIM == 3 
        getTZ(DIM,0,0,0,2,i1,i2,i3,t,uc,uezz )

        getTZ(DIM,0,2,0,2,i1,i2,i3,t,uc,uexxzz )
        getTZ(DIM,0,0,2,2,i1,i2,i3,t,uc,ueyyzz )
        getTZ(DIM,0,0,0,4,i1,i2,i3,t,uc,uezzzz )

        getTZ(DIM,0,4,0,2,i1,i2,i3,t,uc,uexxxxzz )
        getTZ(DIM,0,2,0,4,i1,i2,i3,t,uc,uexxzzzz )
        getTZ(DIM,0,0,4,2,i1,i2,i3,t,uc,ueyyyyzz )      
        getTZ(DIM,0,0,2,4,i1,i2,i3,t,uc,ueyyzzzz )      
        getTZ(DIM,0,0,0,6,i1,i2,i3,t,uc,uezzzzzz )      
        getTZ(DIM,0,2,2,2,i1,i2,i3,t,uc,uexxyyzz )      
      #End

      #If DIM == 2 
        f1 = -c2*( uexx + ueyy )
        f2 = -c4*( uexxxx + ueyyyy + 2.*uexxyy )
        f3 = -c6*( uexxxxxx + ueyyyyyy + 3.*( uexxxxyy + uexxyyyy ) )
      #Else
        f1 = -c2*( uexx + ueyy + uezz )
        f2 = -c4*( uexxxx + ueyyyy + uezzzz + 2.*(uexxyy + uexxzz + ueyyzz) )
        f3 = -c6*(       uexxxxxx + ueyyyyyy + uezzzzzz \
                  + 3.*( uexxxxyy + uexxyyyy + uexxxxzz + uexxzzzz + ueyyyyzz + ueyyzzzz) \
                  + 6.*( uexxyyzz ) )
      #End

    else
      ! Fix me for standard forcings 
      f1=0.; f2=0.; f3=0.;
    end if
  #End
#endMacro

! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 6 
! FORCING : noForcing, forcing
! ===================================================================================================
#beginMacro assignDirichletGhostCompatibilityOrder6(DIM,ORDER,GRIDTYPE,FORCING)

  ! write(*,*) "START OF ASSIGN GHOST CBC order=ORDER"

  !---------------------------------------------------------------
  ! assign extram points in the tangential directions
  ! extram = numGhost-1 
  ! getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  ! ff=0.; gtt=0.; fLap=0.; ftt=0.; gtttt=0.; 

  #If ORDER ne 6
    stop 6666
  #End

  !----------------------------------------------------------------
  ! ------ Fill in three ghost by 6th-order compatibility ---------
  ! ------ Using extrapolated values as initial guesses -----------
  !----------------------------------------------------------------
  
  uc=0
  firstTimeForCBC6 = .true.
  f1=0.; f2=0.; f3=0.; 
  beginLoops3d()
    if( mask(i1,i2,i3).gt.0 )then

      ghost=1
      j1=i1-is1*ghost
      j2=i2-is2*ghost
      j3=i3-is3*ghost
      ghost = 2
      k1=i1-is1*ghost
      k2=i2-is2*ghost
      k3=i3-is3*ghost 
      ghost = 3
      l1=i1-is1*ghost
      l2=i2-is2*ghost
      l3=i3-is3*ghost       

      ! --- get the compatibility forcings at order=4 ---
      ! ** FIX ME ****
      getDirichletCompatibilityForcingOrder6(FORCING,DIM,f1,f2,f3)

      ! u_tt = c^2*Lap(u) + f 
      ! u_tttt = c^2*Lap(u_tt) + f_tt 
      !        = c^2*Lap( c^2*Lap(u) + f ) + f_tt 
      !        = c^4*Lap^2(u) + c^2*Lap(f) ) + f_tt 
   
      ! First evaluate the derivatives using the wrong values at the ghost
      !     uxx     : 6th order
      !     uxxxx   : 4th order
      !     uxxxxxx : 2nd order
      #If DIM == 2


        #If #GRIDTYPE eq "rectangular"

          getSixthDerivatives2d(ORDER,GRIDTYPE,noMetrics,i1,i2,i3)

          ! scale equations for better conditioning
          scale1 = dx(axis)**2/c2; 
          scale2 = dx(axis)**4/c4;
          scale3 = dx(axis)**6/c6; 
          ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
          r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
          r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
          r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3

          ! write(*,'("(i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
 
          if( firstTimeForCBC6 )then
            ! first time trhu, create the matrix of coefficients
             firstTimeForCBC6 = .false. 

            ! Order=6: (see MakeGetDerivativesMacro.maple output)
            ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
            a3(0,0) = c2*( (  3./2.)/(dx(axis)**2) )*scale1   ! coeff of u(-1) in c2*( uxx + uyy )*scale
            a3(0,1) = c2*( (-3./20.)/(dx(axis)**2) )*scale1   ! coeff of u(-2) 
            a3(0,2) = c2*( ( 1./90.)/(dx(axis)**2) )*scale1   ! coeff of u(-3)

            ! Order=4:
            ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
            a3(1,0) = c4*( (-13./2.)/(dx(axis)**4) )*scale2
            a3(1,1) = c4*( (     2.)/(dx(axis)**4) )*scale2
            a3(1,2) = c4*( ( -1./6.)/(dx(axis)**4) )*scale2

            ! Order=2
            ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
            a3(2,0) = c6*( (    15.)/(dx(axis)**6) )*scale3
            a3(2,1) = c6*( (    -6.)/(dx(axis)**6) )*scale3
            a3(2,2) = c6*( (     1.)/(dx(axis)**6) )*scale3

            ! Find the inverse -- could be done once for rectangular and saved
            det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + \
                   (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + \
                   (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
            det=1./det;

            a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
            a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
            a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
            a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
            a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
            a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
            a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
            a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
            a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 

          !   ! check inverse
          !   if( .true. )then
          !     do m1=0,2
          !       do m2=0,2
          !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
          !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
          !       end do
          !     end do
          !   end if

          end if ! end if firstTime

        #Else

          ! ----- curvilinear ----
          getSixthDerivatives2d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

           #If #DIM eq "2"
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2
          #Else
            rFactor = rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 + rsxy(i1,i2,i3,axis,2)**2
          #End


          ! Scaling for equations so leading terms are undivided differences
          scale1 = (dr(axis)**2/rFactor)**1/c2; 
          scale2 = (dr(axis)**2/rFactor)**2/c4;
          scale3 = (dr(axis)**2/rFactor)**3/c6; 

          ! Here are the residuals in the compatibility conditions using the wrong values at ghost: 
          r3v(0) = ( c2*( uxx + uyy )                                    + f1 )*scale1 
          r3v(1) = ( c4*( uxxxx + 2.*uxxyy + uyyyy )                     + f2 )*scale2
          r3v(2) = ( c6*( uxxxxxx + uyyyyyy + 3.*( uxxxxyy + uxxyyyy ) ) + f3 )*scale3

          ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: uxx,uxxxx,uxxxxxx=",3(1pe9.2,1x))') i1,i2,uxx,uxxxx,uxxxxxx
          ! write(*,'("CBC6c (i1,i2)=(",2i3,"), BEFORE: residuals r3v=",3(1pe9.2,1x))') i1,i2,r3v(0),r3v(1),r3v(2)
 

          ! Order=6: (see MakeGetDerivativesMacro.maple output)
          ! Derivative 2 [-3:3]: 1/90, -3/20, 3/2, -49/18, 3/2, -3/20, 1/90,
          a3(0,0) = ( (  3./2.) )   ! coeff of u(-1) in c2*( uxx + uyy )*scale1
          a3(0,1) = ( (-3./20.) )   ! coeff of u(-2) 
          a3(0,2) = ( ( 1./90.) )   ! coeff of u(-3)

          ! Order=4:
          ! Derivative 4 [-3:3]: -1/6, 2, -13/2, 28/3, -13/2, 2, -1/6, 
          a3(1,0) = ( (-13./2.) )
          a3(1,1) = ( (     2.) )
          a3(1,2) = ( ( -1./6.) )

          ! Order=2
          ! Derivative 6 [-3:3]: 1, -6, 15, -20, 15, -6, 1, 
          a3(2,0) = ( (    15.) )
          a3(2,1) = ( (    -6.) )
          a3(2,2) = ( (     1.) )

          ! Find the inverse -- We could save these inverses
          det =( (a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*a3(2,2) + \
                 (a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*a3(2,0) + \
                 (a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*a3(2,1) );
          det=1./det;

          a3i(0,0)=(a3(1,1)*a3(2,2)-a3(1,2)*a3(2,1))*det;
          a3i(1,0)=(a3(1,2)*a3(2,0)-a3(1,0)*a3(2,2))*det;
          a3i(2,0)=(a3(1,0)*a3(2,1)-a3(1,1)*a3(2,0))*det;
          a3i(0,1)=(a3(2,1)*a3(0,2)-a3(2,2)*a3(0,1))*det;
          a3i(1,1)=(a3(2,2)*a3(0,0)-a3(2,0)*a3(0,2))*det;
          a3i(2,1)=(a3(2,0)*a3(0,1)-a3(2,1)*a3(0,0))*det;
          a3i(0,2)=(a3(0,1)*a3(1,2)-a3(0,2)*a3(1,1))*det;
          a3i(1,2)=(a3(0,2)*a3(1,0)-a3(0,0)*a3(1,2))*det;
          a3i(2,2)=(a3(0,0)*a3(1,1)-a3(0,1)*a3(1,0))*det; 

        !   ! check inverse
        !   if( .true. )then
        !     do m1=0,2
        !       do m2=0,2
        !         r1 = a3(m1,0)*a3i(0,m2) + a3(m1,1)*a3i(1,m2) + a3(m1,2)*a3i(2,m2)
        !         write(*,'(" A3*A3^(-1) : (m1,m2)=",2i3," val=",(1pe9.2,1x))') m1,m2,r1
        !       end do
        !     end do
        !   end if


        #End
      #Else
        ! -- 3D ---
        ! This next seems broken: 
        ! getSixthDerivatives3d(ORDER,GRIDTYPE,OPTION,i1,i2,i3)
        stop 6363
      #End

      f3v(0) = a3(0,0)*u(j1,j2,j3,0) + a3(0,1)*u(k1,k2,k3,0) + a3(0,2)*u(l1,l2,l3,0) - r3v(0)
      f3v(1) = a3(1,0)*u(j1,j2,j3,0) + a3(1,1)*u(k1,k2,k3,0) + a3(1,2)*u(l1,l2,l3,0) - r3v(1)
      f3v(2) = a3(2,0)*u(j1,j2,j3,0) + a3(2,1)*u(k1,k2,k3,0) + a3(2,2)*u(l1,l2,l3,0) - r3v(2)

      ! if( .true. )then
      !   getTZ(DIM,0,0,0,0,j1,j2,j3,t,uc,ue1 )
      !   getTZ(DIM,0,0,0,0,k1,k2,k3,t,uc,ue2 )
      !   getTZ(DIM,0,0,0,0,l1,l2,l3,t,uc,ue3 )
      !   write(*,'("(i1,i2)=(",2i3,"), BEFORE u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') \
      !        i1,i2,u(j1,j2,j3,0),u(k1,k2,k3,0),u(l1,l2,l3,0),abs(u(j1,j2,j3,0)-ue1),abs(u(k1,k2,k3,0)-ue2),abs(u(l1,l2,l3,0)-ue3)
      ! end if

      ! u(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
      ! u(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
      ! u(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)

      uTemp(j1,j2,j3,0) = a3i(0,0)*f3v(0) + a3i(0,1)*f3v(1) + a3i(0,2)*f3v(2)
      uTemp(k1,k2,k3,0) = a3i(1,0)*f3v(0) + a3i(1,1)*f3v(1) + a3i(1,2)*f3v(2)
      uTemp(l1,l2,l3,0) = a3i(2,0)*f3v(0) + a3i(2,1)*f3v(1) + a3i(2,2)*f3v(2)      


      ! if( .true. )then
      !   getTZ(DIM,0,0,0,0,j1,j2,j3,t,uc,ue1 )
      !   getTZ(DIM,0,0,0,0,k1,k2,k3,t,uc,ue2 )
      !   getTZ(DIM,0,0,0,0,l1,l2,l3,t,uc,ue3 )
      !   write(*,'("(i1,i2)=(",2i3,"),  u(-1),u(-2),u(-3)=",3(1pe11.4,1x)," err=",3(1pe9.2,1x))') \
      !        i1,i2,uTemp(j1,j2,j3,0),uTemp(k1,k2,k3,0),uTemp(l1,l2,l3,0),abs(uTemp(j1,j2,j3,0)-ue1),abs(uTemp(k1,k2,k3,0)-ue2),abs(uTemp(l1,l2,l3,0)-ue3)
      ! end if

 
      ! if( numGhost.gt.3 )then
      !   ! extrap an extra ghost for upwinding 
      !   ghost = 4
      !   j1=i1-is1*ghost
      !   j2=i2-is2*ghost
      !   j3=i3-is3*ghost 
      !   u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
      ! end if

    end if ! mask .gt. 0

  endLoops3d()

    ! ------ fill in ghost values from uTemp ----
  if( .true. )then
    beginLoops3d()
      if( mask(i1,i2,i3).gt.0 )then
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost 
        ghost = 3
        l1=i1-is1*ghost
        l2=i2-is2*ghost
        l3=i3-is3*ghost         
        u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
        u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 
        u(l1,l2,l3,0) = uTemp(l1,l2,l3,0) 

        if( numGhost.gt.3 )then
          !  extrap 4th ghost (UPW)
          ghost = 4
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost   
          ! u(j1,j2,j3,uc) = extrap6(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 

          ! u(j1,j2,j3,uc) = extrap8(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            
          u(j1,j2,j3,uc) = extrap7(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3)            

        end if        
       
      else if( mask(i1,i2,i3).lt.0 )then

        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        u(j1,j2,j3,uc)=extrap7(u,i1,i2,i3,uc,is1,is2,is3)

        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost           
        u(k1,k2,k3,uc)=extrap7(u,j1,j2,j3,uc,is1,is2,is3)

        ghost = 3
        l1=i1-is1*ghost
        l2=i2-is2*ghost
        l3=i3-is3*ghost           
        u(l1,l2,l3,uc)=extrap7(u,k1,k2,k3,uc,is1,is2,is3)            


        if( numGhost.gt.3 )then
          !  extrap 4th ghost (UPW)
          ghost = 4
          j1=i1-is1*ghost
          j2=i2-is2*ghost
          j3=i3-is3*ghost           
          u(j1,j2,j3,uc)=extrap7(u,l1,l2,l3,uc,is1,is2,is3)            
        end if        

      end if    
    endLoops3d()  
  end if
  ! write(*,*) "CBC6 stop here for now"
  ! stop 6666  

#endMacro




! ------------------------------------------------------------------------------------
!  Macro: evaluate the RHS to the Neumann BC
! ------------------------------------------------------------------------------------
#beginMacro getNeumannForcing(ff)
  if( assignTwilightZone.eq.1 )then
    ! compute RHS from TZ
    if( nd.eq.2 )then
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
      call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
      call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
      ff = a0*ue + a1*( an1*uex + an2*uey )
    else
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
      call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
      call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
      call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
      ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
    end if

  else if( assignKnownSolutionAtBoundaries.eq.1 )then

    ! -- we set inhomogeneous Neumann values for some known solutions 
    if( knownSolutionOption.eq.planeWave )then
      ! --- evaluate RHS for the plane wave solution ---
      if( nd.eq.2 )then
        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
        uex   = kxPlaneWave*cosPW
        uey   = kyPlaneWave*cosPw

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
        uex   = kxPlaneWave*cosPW
        uey   = kyPlaneWave*cosPw
        uez   = kzPlaneWave*cosPw

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if 

    else if( knownSolutionOption.eq.gaussianPlaneWave )then
      ! Do nothing for Gaussian plane wave solution for now
      ff = 0.
      
    else if( knownSolutionOption.eq.boxHelmholtz ) then
      ! --- evaluate RHS the boxHelmholtz solution ---
      if( nd.eq.2 )then
        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
        uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if

    else if( knownSolutionOption.eq.polyPeriodic ) then
      ! --- evaluate RHS the polyPeriodic solution ---
      if( nd.eq.2 )then
        ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) ) *coswt
        uex = (      a1PolyPeriodic                                                            ) *coswt
        uey = (                          b1PolyPeriodic                                        ) *coswt

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue  = ( a0PolyPeriodic + a1PolyPeriodic*xy(i1,i2,i3,0) + b1PolyPeriodic*xy(i1,i2,i3,1) + c1PolyPeriodic*xy(i1,i2,i3,2) ) *coswt
        uex = (      a1PolyPeriodic                                                                                            ) *coswt
        uey = (                          b1PolyPeriodic                                                                        ) *coswt
        uez = (                                              c1PolyPeriodic                                                    ) *coswt

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if


    else

      stop 9876

    end if 

  end if
#endMacro 

! ===================================================================================================
! Macro: Assign ghost points on Neumann boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro assignNeumannGhost(ORDER)
   ! BC: a0*T + a1*T.n = 

   ! a0=mixedCoeff(uc,side,axis,grid)
   ! a1=mixedNormalCoeff(uc,side,axis,grid)
   a0=0.
   a1=1.

   ! rectangular case:
   if( gridType.eq.rectangular )then
     ! compute the outward normal (an1,an2,an3)
     an1 = 0.
     an2 = 0.
     an3 = 0.
     if( axis.eq.0 )then
      an1=-is
     else if( axis.eq.1 )then
      an2=-is
     else
      an3=-is
     end if
     dxn=dx(axis)
     b0=-4.*dxn*a0/a1-10./3.
     b1=4.*(dxn/a1)
   end if

   ff=0.
   beginLoops3d()

    ! first ghost pt:
    j1=i1-is1
    j2=i2-is2
    j3=i3-is3
    ! 2nd ghost:
    k1=j1-is1
    k2=j2-is2
    k3=j3-is3
    ! 3rd ghost:
    l1=k1-is1
    l2=k2-is2
    l3=k3-is3    

    if( mask(i1,i2,i3).gt.0 )then
    

      if( gridType.eq.curvilinear )then
        ! compute the outward normal (an1,an2,an3)
        getNormal(i1,i2,i3)
      end if

      getNeumannForcing(ff)


      ! ORDER=4: 
      ! --- assign 2 ghost points using:
      !  (1) Apply Neumann BC to 4th order
      !  (2) Extrap. 2nd ghost to 5th order

      if( gridType.eq.rectangular )then

        ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
        !if( orderOfAccuracy.eq.2 )then
        #If #ORDER eq "2"
          ! --- NEUMANN ORDER=2 rectangular ---
          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
          !  *check me* 
          b0 = -2.*dxn*a0/a1 
          b1 =  2.*dxn/a1 
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          + b1*ff
        #Elif #ORDER eq "4"  
         !  --- NEUMANN ORDER=4 rectangular ---
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.\
                            +b1*ff
        #Else
          stop 777
        #End

      else 
        ! ------ curvilinear grid: -------

        ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
        ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
        ! =>
        !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 

        #If #ORDER eq "2"

          ! ----- NEUMANN ORDER=2 curvilinear ----

          ! ur = ( u(i+1) - u(i-1) )/2*dr
          ! ur = ur0 -> 
          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 

          urv(0) = ur2(i1,i2,i3,uc)
          urv(1) = us2(i1,i2,i3,uc)
          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut2(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

           ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
         end if

         u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0


        #Elif #ORDER eq "4"  

          ! ---- NEUMANN ORDER 4 curvilinear ----
          !       d14(kd) = 1./(12.*dr(kd))
          !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
          !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)

          ! ur = f -> 
          ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
          ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)

          ! A - B = 
          !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 

          urv(0) = ur4(i1,i2,i3,uc)
          urv(1) = us4(i1,i2,i3,uc)

          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut4(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
          end if

          u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                                 +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                                 -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)\
                              -4.*is*dr(axis)*ur0

        #Else
          stop 7878
        #End

      end if ! curvilinear grid 
      
      ! ----- Assign extra ghost ----
      #If #ORDER eq "2"

        if( numGhost.gt.1 )then
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if

      #Elif #ORDER eq "4"  

        ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
        ! extrap second ghost
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      #Else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777        
      #End


    else if( mask(i1,i2,i3).lt.0 )then

      ! ----- extrap ghost outside interp. pts on physical boundaries ------
      #If #ORDER eq "2"

        u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)
        if( numGhost.gt.1 )then
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
        end if

      #Elif #ORDER eq "4"

        u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)
        if( numGhost.gt.2 )then
          !  extrap third ghost 
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      #Else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777        
      #End
       
    end if

   endLoops3d()
#endMacro


! ===================================================================================================
! Macro: Assign ghost points on Neumann boundaries
!          *** COMPATIBILITY BOUNDARY CONDITIONS **** 
! ORDER : 2,4,6,8
! ===================================================================================================
! *** OLD VERSION ****
#beginMacro assignNeumannGhostCompatibilityOld(ORDER)
   ! BC: a0*T + a1*T.n = 

   ! a0=mixedCoeff(uc,side,axis,grid)
   ! a1=mixedNormalCoeff(uc,side,axis,grid)

  if( bcApproach.eq.useCompatibilityBoundaryConditions )then
    write(*,'("bcOptWave: ERROR: useCompatibilityBoundaryConditions not implemented yet.")') 
    stop 1010
  end if

   a0=0.
   a1=1.

   ! rectangular case:
   if( gridType.eq.rectangular )then
     ! compute the outward normal (an1,an2,an3)
     an1 = 0.
     an2 = 0.
     an3 = 0.
     if( axis.eq.0 )then
      an1=-is
     else if( axis.eq.1 )then
      an2=-is
     else
      an3=-is
     end if
     dxn=dx(axis)
     b0=-4.*dxn*a0/a1-10./3.
     b1=4.*(dxn/a1)
   end if

   ff=0.
   beginLoops3d()

    ! first ghost pt:
    j1=i1-is1
    j2=i2-is2
    j3=i3-is3
    ! 2nd ghost:
    k1=j1-is1
    k2=j2-is2
    k3=j3-is3
    ! 3rd ghost:
    l1=k1-is1
    l2=k2-is2
    l3=k3-is3    

    if( mask(i1,i2,i3).gt.0 )then
    

      if( gridType.eq.curvilinear )then
        ! compute the outward normal (an1,an2,an3)
        getNormal(i1,i2,i3)
      end if

      getNeumannForcing(ff)


      ! ORDER=4: 
      ! --- assign 2 ghost points using:
      !  (1) Apply Neumann BC to 4th order
      !  (2) Extrap. 2nd ghost to 5th order

      if( gridType.eq.rectangular )then

        ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
        if( orderOfAccuracy.eq.2 )then
          ! --- NEUMANN ORDER=2 rectangular ---
          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
          !  *check me* 
          b0 = -2.*dxn*a0/a1 
          b1 =  2.*dxn/a1 
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          + b1*ff
        else 
         !  --- NEUMANN ORDER=4 rectangular ---
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.\
                            +b1*ff
        end if

      else 
        ! ------ curvilinear grid: -------

        ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
        ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
        ! =>
        !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 

        if( orderOfAccuracy.eq.2 )then

          ! ----- NEUMANN ORDER=2 curvilinear ----

          ! ur = ( u(i+1) - u(i-1) )/2*dr
          ! ur = ur0 -> 
          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 

          urv(0) = ur2(i1,i2,i3,uc)
          urv(1) = us2(i1,i2,i3,uc)
          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut2(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

           ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
         end if

         u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0


        else

          ! ---- NEUMANN ORDER 4 curvilinear ----
          !       d14(kd) = 1./(12.*dr(kd))
          !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
          !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)

          ! ur = f -> 
          ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
          ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)

          ! A - B = 
          !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 

          urv(0) = ur4(i1,i2,i3,uc)
          urv(1) = us4(i1,i2,i3,uc)

          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut4(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
          end if

          u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                                 +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                                 -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)\
                              -4.*is*dr(axis)*ur0

        end if ! order =4 
      end if ! curvilinear grid 
      
      ! ----- Assign extra ghost ----
      if( orderOfAccuracy.eq.2) then

        if( numGhost.gt.1 )then
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if

      else if( orderOfAccuracy.eq.4 )then

        ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
        ! extrap second ghost
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777        
      end if


    else if( mask(i1,i2,i3).lt.0 )then

      ! ----- extrap ghost outside interp. pts on physical boundaries ------
      if( orderOfAccuracy.eq.2 )then
        u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)
        if( numGhost.gt.1 )then
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
        end if

      else if( orderOfAccuracy.eq.4 )then
        u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)
        if( numGhost.gt.2 )then
          !  extrap third ghost 
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777
      end if
       
    end if

   endLoops3d()
#endMacro


! ============================================================================================
! Macro: evaluate the forcings for Neumann CBCs
!    Solving
!        u_tt = c^2 * Delta( u ) + f(x,y,z,t)
!        u.n = g
! For TZ at order=2:
!    gg = g
!  order=4:
!    gg,
!    nDotGradF = n.grad( f ), f = ue_tt - c^2*lap(ue)
!    gtt
! ============================================================================================
#beginMacro getNeumannCompatibilityForcing(FORCING,DIM,ORDER,gg,nDotGradF,gtt )
  #If #FORCING eq "noForcing"
    ! No forcing, do nothing 
  #Else
    if( assignTwilightZone.eq.1 )then
      ! compute RHS from TZ
      #If #DIM eq 2
        call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex )
        call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
        gg = an1*uex + an2*uey

        #If #ORDER eq "4"
          call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uettx )
          call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uetty )
          gtt = an1*( uettx ) + an2*( uetty )

          call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxx )
          call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyy )
          call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxy )
          call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyy )

          nDotGradF = an1*( uettx - c2*( uexxx + uexyy ) ) + \
                      an2*( uetty - c2*( uexxy + ueyyy ) )

        #End

      #Else
        ! ----- 3D  -----
        call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex )
        call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey )
        call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez )
        gg = an1*uex + an2*uey + an3*uez

        #If #ORDER eq "4"
          call ogDeriv(ep,2,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettx )
          call ogDeriv(ep,2,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uetty )
          call ogDeriv(ep,2,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uettz )
          gtt = an1*( uettx ) + an2*( uetty ) + an3*( uettz )

          call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxx )
          call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxy )
          call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexyy )
          call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyy )
          call ogDeriv(ep,0,2,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexxz )
          call ogDeriv(ep,0,1,0,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexzz )
          call ogDeriv(ep,0,0,2,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyyz )
          call ogDeriv(ep,0,0,1,2,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyzz )
          call ogDeriv(ep,0,0,0,3,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uezzz )

          nDotGradF = an1*( uettx - c2*( uexxx + uexyy + uexzz ) ) + \
                      an2*( uetty - c2*( uexxy + ueyyy + ueyzz ) ) + \
                      an3*( uettz - c2*( uexxz + ueyyz + uezzz ) )
        #End      

      #End
    else
      gg=0.;  gtt=0.; nDotGradF=0.; 
    end if
  #End
#endMacro      

!==========================================================================
!  Check the coefficients in the ghost points of the residual equations
! using the discrete delta approach
!==========================================================================
#beginMacro checkCoeffByDiscreteDelta(GRIDTYPE,DIM)
  if( checkCoeff.eq.1 )then
    ! --- Check coefficients a11,a12,... by discrete delta ---
    u1Save = u(j1,j2,j3,0)
    u2Save = u(k1,k2,k3,0)
    u(j1,j2,j3,0)=0.
    u(k1,k2,k3,0)=0.
    getThirdDerivatives ## DIM ## d(2,GRIDTYPE,nothing,i1,i2,i3)
    r1a = resid1(i1,i2,i3)
    r2a = resid2(i1,i2,i3)

    u(j1,j2,j3,0)=1.
    getThirdDerivatives ## DIM ## d(2,GRIDTYPE,nothing,i1,i2,i3)
    r1b =  resid1(i1,i2,i3)
    r2b =  resid2(i1,i2,i3)
    a11c = r1b - r1a
    a21c = r2b - r2a

    u(j1,j2,j3,0)=0.
    u(k1,k2,k3,0)=1.
    getThirdDerivatives ## DIM ## d(2,GRIDTYPE,nothing,i1,i2,i3)
    r1b =  resid1(i1,i2,i3)
    r2b =  resid2(i1,i2,i3)
    a12c = r1b - r1a
    a22c = r2b - r2a

    u(j1,j2,j3,0) = u1Save  
    u(k1,k2,k3,0) = u2Save      

    maxDiff=max(maxDiff,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c),abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c))

    ! #If #GRIDTYPE eq "curvilinear"
    ! write(*,'("++ i1,i2=",2i4," a11,a11c=",2(1pe12.4)," a12,a12c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a11,a11c,a12,a12c,abs(a11-a11c)/abs(a11c),abs(a12-a12c)/abs(a12c)
    ! write(*,'("++ i1,i2=",2i4," a21,a21c=",2(1pe12.4)," a22,a22c=",2(1pe12.4)," rel-diff=",2(e9.2))') i1,i2,a21,a21c,a22,a22c,abs(a21-a21c)/abs(a21c),abs(a22-a22c)/abs(a22c)
    ! #End
  end if 
#endMacro      

! ===================================================================================================
! Macro: Assign ghost points on Dirichlet boundaries using: 
!          *** COMPATIBILITY BOUNDARY CONDITIONS ****
! ORDER : 2,4,6,8
! FORCING : noForcing, forcing
! ===================================================================================================
#beginMacro assignNeumannGhostCompatibility(DIM,ORDER,GRIDTYPE,FORCING)



  ! Mixed BC: a0*u + a1*u.n = 
  a0=0.
  a1=1.

  ! STAGE I always fill in first ghost from 2nd-order scheme 

  ! rectangular case:
  #If #GRIDTYPE eq "rectangular"
    ! compute the outward normal (an1,an2,an3)
    an1 = 0.
    an2 = 0.
    an3 = 0.
    if( axis.eq.0 )then
     an1=-is
    else if( axis.eq.1 )then
     an2=-is
    else
     an3=-is
    end if
    dxn=dx(axis)
  #End

  !---------------------------------------------------------------
  ! --- STAGE I fill in first ghost by 2nd-order compatibility ---
  !---------------------------------------------------------------
  ! assign extram points in the tangential directions
  extram = numGhost-1 
#If #ORDER eq "2"
  getLoopBounds(side,axis,extram, m1a,m1b,m2a,m2b,m3a,m3b)

  gg=0.; nDotGradF=0.; gtt=0.; 
  beginLoops(m1a,m1b,m2a,m2b,m3a,m3b)

    ! first ghost pt:
    j1=i1-is1
    j2=i2-is2
    j3=i3-is3

    if( mask(i1,i2,i3).gt.0 )then
    

      #If #GRIDTYPE eq "curvilinear"
        ! compute the outward normal (an1,an2,an3)
        getNormal(i1,i2,i3)
      #End

      getNeumannCompatibilityForcing(FORCING,DIM,2,gg,nDotGradF,gtt)


      #If #GRIDTYPE eq "rectangular"

        ! --- NEUMANN ORDER=2 rectangular ---
        !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*gg 
        !  *check me* 
        b0 = -2.*dxn*a0/a1 
        b1 =  2.*dxn/a1 
        u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                       +    u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                       + b1*gg
      #Else

        ! ------ curvilinear grid: -------

        ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
        ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
        ! =>
        !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 

        ! ----- NEUMANN ORDER=2 curvilinear ----

        ! ur = ( u(i+1) - u(i-1) )/2*dr
        ! ur = ur0 -> 
        ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
        ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 

        urv(0) = ur2(i1,i2,i3,uc)
        urv(1) = us2(i1,i2,i3,uc)
        #If #DIM eq "2"
          t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
          t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 
          ur0 = (gg - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
        #Else
          urv(2) = ut2(i1,i2,i3,uc)
          t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
          t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
          t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )
         ur0 = ( gg - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
        #End
        u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0

      #End
      
      #If #ORDER eq "2" 
        ! ----- Assign extra ghost ----
        if( numGhost.gt.1 )then
          ghost =2
          k1=i1-is1*ghost
          k2=i2-is2*ghost
          k3=i3-is3*ghost   
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if
      #End

    else if( mask(i1,i2,i3).lt.0 )then
      #If #ORDER eq "2" 
        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)

        if( numGhost.gt.1 )then
          ! extrap second ghost (UPW)
          ghost = 2
          k1=i1-is1*ghost
          k2=i2-is2*ghost
          k3=i3-is3*ghost              
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
        end if
      #End

    end if

  endLoops3d()
#End


  #If #ORDER eq "4"
    ! ------------------- ORDER 4 NEUMANN CBC --------------------
    maxDiff=0. ! for checkCoeff

    gg=0.
    beginLoops3d()

      ghost =1 
      j1=i1-is1*ghost
      j2=i2-is2*ghost
      j3=i3-is3*ghost
      ghost =2
      k1=i1-is1*ghost
      k2=i2-is2*ghost
      k3=i3-is3*ghost   

      if( mask(i1,i2,i3).gt.0 )then
    

        #If #GRIDTYPE eq "curvilinear"
          ! compute the outward normal (an1,an2,an3)
          getNormal(i1,i2,i3)
        #End

        getNeumannCompatibilityForcing(FORCING,DIM,4,gg,nDotGradF,gtt)


        #If #DIM eq "2"
          getThirdDerivatives2d(2,GRIDTYPE,evalMetrics,i1,i2,i3)
        #Else
          ! evaluate 3rd derivatives : uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 
          getThirdDerivatives3d(2,GRIDTYPE,evalMetrics,i1,i2,i3)
        #End
        #If #GRIDTYPE eq "rectangular"

          ! --- NEUMANN ORDER=4 rectangular ---
          ! u_tt = c^2*Lap(u) + f 
          !   u.n = g
          ! g_tt = c^2 n.grad( Lap(u) ) + n.grad(f)

          ! ux = [ u(-2) - 8*u(-1) + 8*u(1) - u(2) ]/(12*h) 

          ! uxxx = (-u(-1) +2*u(-1) - 2*u(1) + u(2) ]/(2*h^3)
          #If #DIM eq "2"
            ! eval equation with wrong values at ghost: 
            r1 =  an1*ux42r(i1,i2,i3,0) + an2*uy42r(i1,i2,i3,0) - gg

            ! note: an1=-1 on left side ans an1=+1 on right side
            ! **CHECK ME**
            a11 =  8./(12.*dx(axis))  ! coeff of u(-1)
            a12 = -1./(12.*dx(axis))  ! coeff of u(-2)

            r2 = c2*( an1*( uxxx + uxyy ) + \
                      an2*( uxxy + uyyy ) ) + nDotGradF - gtt
            ! **CHECK ME**
            a21 = -c2*( 2./(2.*dx(axis)**3) )
            a22 =  c2*( 1./(2.*dx(axis)**3) )

            ! define the residual functions for the discrete delta method
#defineMacro resid1(i1,i2,i3) ( an1*ux42r(i1,i2,i3,0) + an2*uy42r(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)

          #Else
            ! 3D 
            r1 =  an1*ux43r(i1,i2,i3,0) + an2*uy43r(i1,i2,i3,0) + an3*uz43r(i1,i2,i3,0) - gg

            ! **CHECK ME**
            a11 =  8./(12.*dx(axis))  ! coeff of u(-1)
            a12 = -1./(12.*dx(axis))  ! coeff of u(-2)  

            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + \
                      an2*( uxxy + uyyy + uyzz ) + \
                      an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt
            ! **CHECK ME**
            a21 = -c2*( 2./(2.*dx(axis)**3) )
            a22 =  c2*( 1./(2.*dx(axis)**3) )

            ! define the residual functions for the discrete delta method
#defineMacro resid1(i1,i2,i3) ( an1*ux43r(i1,i2,i3,0) + an2*uy43r(i1,i2,i3,0) + an3*uz43r(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)            

          #End


        #Else

          ! ------ curvilinear grid: -------

          #If #DIM eq "2"
            ! eval equation with wrong values at ghost:
            r1 =  an1*ux42(i1,i2,i3,0) + an2*uy42(i1,i2,i3,0) - gg

            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1)
            ! crv(1) = an1*rsxy(i1,i2,i3,1,0) + an2*rsxy(i1,i2,i3,1,1)

            ! **CHECK ME**
            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)

            r2 = c2*( an1*( uxxx + uxyy ) + \
                      an2*( uxxy + uyyy ) ) + nDotGradF - gtt

! uxxx = rxi**3*urrr+3.*rxi**2*sxi*urrs+3.*rxi*sxi**2*urss+sxi**3*usss+3.*rxi*rxx*urr+(3.*rxi*sxx+3.*rxx*sxi)*urs+3.*sxx*sxi*uss+rxxx*ur+sxxx*us
! uxyy = ryi**2*rxi*urrr+(syi*ryi*rxi+ryi*(rxi*syi+ryi*sxi))*urrs+(ryi*syi*sxi+syi*(rxi*syi+ryi*sxi))*urss+syi**2*sxi*usss+(rxi*ryy+2.*rxy*ryi)*urr+(rxi*syy+2.*rxy*syi+2.*ryi*sxy+ryy*sxi)*urs+(sxi*syy+2.*sxy*syi)*uss+rxyy*ur+sxyy*us
! uxxy = ryi*rxi**2*urrr+(rxi**2*syi+2.*rxi*ryi*sxi)*urrs+(2.*rxi*sxi*syi+ryi*sxi**2)*urss+syi*sxi**2*usss+(2.*rxi*rxy+rxx*ryi)*urr+(2.*rxi*sxy+rxx*syi+2.*rxy*sxi+ryi*sxx)*urs+(2.*sxi*sxy+sxx*syi)*uss+rxxy*ur+sxxy*us
! uyyy = ryi**3*urrr+3.*ryi**2*syi*urrs+3.*ryi*syi**2*urss+syi**3*usss+3.*ryi*ryy*urr+(3.*ryi*syy+3.*ryy*syi)*urs+3.*syy*syi*uss+ryyy*ur+syyy*us

            ! uxxx = rxi**3*urrr +3.*rxi*rxx*urr + rxxx*ur
            ! uxyy = ryi**2*rxi*urrr +(rxi*ryy+2.*rxy*ryi)*urr+rxyy*ur
            ! uxxy = ryi*rxi**2*urrr +(2.*rxi*rxy+rxx*ryi)*urr+rxxy*ur

            ! Coeff of terms involving urrr (do not include terms involving urr and ur as these used 2nd-order values)
            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) )*( rsxy(i1,i2,i3,axis,0)**2 + rsxy(i1,i2,i3,axis,1)**2 )

            ! if( axis.eq.0 )then
            !   crv(axis) = (an1*rxi + an2*ryi )*( rxi**2 + ryi**2 )
            !   ! crv(axis) = an1*( rxi**3 + ryi**2*rxi ) + \
            !   !             an2*( ryi**3 + ryi*rxi**2 )
            ! else
            !   crv(axis) = (an1*sxi + an2*syi )*( sxi**2 + syi**2 )
            !   ! crv(axis) = an1*( sxi**3 + syi**2*sxi ) + \
            !   !             an2*( syi**3 + syi*sxi**2 )              
            ! end if
            ! crv(1) = an1*rsxy(i1,i2,i3,1,0)**3 + an2*rsxy(i1,i2,i3,1,1)**3

            ! **CHECK ME**
            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )

#defineMacro resid1(i1,i2,i3) ( an1*ux42(i1,i2,i3,0) + an2*uy42(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy ) + an2*( uxxy + uyyy ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)

          #Else
            ! 3D 
            r1 =  an1*ux43(i1,i2,i3,0) + an2*uy43(i1,i2,i3,0) + an3*uz43(i1,i2,i3,0) - gg

            crv(axis) = an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2)

            ! **CHECK ME**
            a11 = -is*( crv(axis)*8./(12.*dr(axis)) )  ! coeff of u(-1)
            a12 =  is*( crv(axis)*1./(12.*dr(axis)) )  ! coeff of u(-2)

            r2 = c2*( an1*( uxxx + uxyy + uxzz ) + \
                      an2*( uxxy + uyyy + uyzz ) + \
                      an3*( uxxz + uyyz + uzzz ) ) + nDotGradF - gtt

            ! crv(axis) = an1*rsxy(i1,i2,i3,axis,0)**3 + an2*rsxy(i1,i2,i3,axis,1)**3 + an3*rsxy(i1,i2,i3,axis,2)**3
            ! Coeff of "urrr" term *check me*
            crv(axis) = (an1*rsxy(i1,i2,i3,axis,0) + an2*rsxy(i1,i2,i3,axis,1) + an3*rsxy(i1,i2,i3,axis,2) )* \
                        (    rsxy(i1,i2,i3,axis,0)**2  + rsxy(i1,i2,i3,axis,1)**2  + rsxy(i1,i2,i3,axis,2)**2 )

            ! if( axis.eq.0 )then
            !   crv(axis) = ( an1*rxi + an2*ryi + an3*rzi )*( rxi**2 + ryi**2 + rzi**2 ) 
            !   ! crv(axis) = an1*( rxi*( rxi**2 + ryi**2 + rzi**2 ) ) + \
            !   !             an2*( ryi*( rxi**2 + ryi**2 + rzi**2 ) ) + \
            !   !             an3*( rzi*( rxi**2 + ryi**2 + rzi**2 ) ) 
            ! else if( axis.eq.1 )then
            !   crv(axis) = ( an1*sxi + an2*syi + an3*szi )*( sxi**2 + syi**2 + szi**2 ) 
            ! else           
            !   crv(axis) = ( an1*txi + an2*tyi + an3*tzi )*( txi**2 + tyi**2 + tzi**2 ) 
            ! end if

            ! **CHECK ME**
            a21 =  is*c2*( 2.*crv(axis)/(2.*dr(axis)**3) )
            a22 = -is*c2*( 1.*crv(axis)/(2.*dr(axis)**3) )            

            ! define the residual functions for the discrete delta method
#defineMacro resid1(i1,i2,i3) ( an1*ux43(i1,i2,i3,0) + an2*uy43(i1,i2,i3,0) + an3*uz43(i1,i2,i3,0) )
#defineMacro resid2(i1,i2,i3) ( c2*( an1*( uxxx + uxyy + uxzz ) + an2*( uxxy + uyyy + uyzz ) + an3*( uxxz + uyyz + uzzz ) ) )
            checkCoeffByDiscreteDelta(GRIDTYPE,DIM)   

          #End          

        #End

        f1 = a11*u(j1,j2,j3,0) + a12*u(k1,k2,k3,0) - r1
        f2 = a21*u(j1,j2,j3,0) + a22*u(k1,k2,k3,0) - r2

        det = a11*a22 - a21*a12
        uTemp(j1,j2,j3,0) = ( a22*f1 - a12*f2 )/det
        uTemp(k1,k2,k3,0) = ( a11*f2 - a21*f1 )/det
        if( .false. )then
          call ogDeriv(ep,0,0,0,0,xy(j1,j2,j3,0),xy(j1,j2,j3,1),0.,t,uc,uex )
          call ogDeriv(ep,0,0,0,0,xy(k1,k2,k3,0),xy(k1,k2,k3,1),0.,t,uc,uey )
          write(*,'(" (i1,i2)=(",2i3,") u(-1),ue(-1)=",2(1pe12.4)," u(-2),ue(-2)=",2(1pe12.4))') i1,i2,uTemp(j1,j2,j3,0),uex,uTemp(k1,k2,k3,0),uey

        end if

      else if( mask(i1,i2,i3).lt.0 )then
        ! this case done below 
  
      end if

    endLoops3d()



    ! ------ fill in ghost values from uTemp ----
    beginLoops3d()
      if( mask(i1,i2,i3).gt.0 )then
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost 
        u(j1,j2,j3,0) = uTemp(j1,j2,j3,0)
        u(k1,k2,k3,0) = uTemp(k1,k2,k3,0) 

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          ghost = 3
          l1=i1-is1*ghost
          l2=i2-is2*ghost
          l3=i3-is3*ghost           
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if        
       
      else if( mask(i1,i2,i3).lt.0 )then
        ! ----- extrap ghost outside interp. pts on physical boundaries ------
        ghost = 1 
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost
        u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)

        ghost = 2
        k1=i1-is1*ghost
        k2=i2-is2*ghost
        k3=i3-is3*ghost           
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          ghost = 3
          l1=i1-is1*ghost
          l2=i2-is2*ghost
          l3=i3-is3*ghost           
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      end if    
    endLoops3d()    

    if( checkCoeff.eq.1 )then
      write(*,'("bcOptWave: t=",e12.3," checkCoeff: (side,axis)=(",2i2,") rel-maxDiff=",e9.2," GRIDTYPE ORDER")') t,side,axis,maxDiff
    end if
  #End


#endMacro


! ========================================================================================
!  Apply symmetry conditions in corner ghost for Cartesian grids 
! ========================================================================================
#beginMacro assignSymmetryCornerGhost(FORCING)
  ! ---------------------------------
  ! --- assign corners and edges: ---
  ! ---------------------------------


  if( nd.eq.2 )then

    ! --- TWO DIMENSIONS ----
    do side2=0,1
    do side1=0,1

      if( bc(side1,0).gt.0 .and. \
          bc(side2,1).gt.0 )then

        ! **fix me** for exact BCs

        if( ( bc(side1,0).ne.dirichlet .and. bc(side1,0).ne.neumann ) .or. \
            ( bc(side2,1).ne.dirichlet .and. bc(side2,1).ne.neumann ) )then
          write(*,*) "Un-supported corner bcs =",bc(side1,0),bc(side2,1)
          stop 2222
        end if

        symSign = +1. ! even symmetry for D-D or N-N corners
        if( (bc(side1,0).eq.dirichlet .and. bc(side2,1).eq.neumann   ) .or. \
            (bc(side1,0).eq.neumann   .and. bc(side2,1).eq.dirichlet ) ) then
          symSign=-1.;
        end if
        is1 = 1-2*side1
        is2 = 1-2*side2

        i1 = gridIndexRange(side1,0)
        i2 = gridIndexRange(side2,1)
        i3 = gridIndexRange(    0,2)
        do m2=0,numGhost
        do m1=0,numGhost
          j1 = i1-is1*m1; j2=i2-is2*m2; j3=i3; ! ghost 
          k1 = i1+is1*m1; k2=i2+is2*m2; k3=i3; ! interior point 

          u(j1,j2,j3,0) = symSign*u(k1,k2,k3,0)

          #If #FORCING eq "forcing"
            if( assignTwilightZone.eq.1 )then
              getTZ(2,0,0,0,0,j1,j2,j3,t,uc,ue1 )
              getTZ(2,0,0,0,0,k1,k2,k3,t,uc,ue2 )
              u(j1,j2,j3,0) = u(j1,j2,j3,0) + ue1 - symSign*ue2 
            else
              ! finish me 
            end if
          #End

        end do
        end do

      end if 
    end do
    end do

  else
    ! --- THREE DIMENSIONS ----
    write(*,*) "symmetry corners -- finish me in 3D"
    stop 9999
    do side3=0,1
    do side2=0,1
    do side1=0,1

    end do
    end do
    end do
  end if

#endMacro





! ===================================================================================
! Utility macro to call different versions of assignDirichletGhostCompatibility
! for a given ORDER
! ===================================================================================
#beginMacro callDirichletGhostCompatibility(ORDER)
  #If ORDER ne 6 
    if( forcingOption.eq.noForcing )then
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,rectangular,noForcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,rectangular,noForcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,curvilinear,noForcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,curvilinear,noForcing)
        end if
      end if 
    else
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,rectangular,forcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,rectangular,forcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibility(2,ORDER,curvilinear,forcing)
        else
          assignDirichletGhostCompatibility(3,ORDER,curvilinear,forcing)
        end if
      end if     
    end if
  #Else
    if( forcingOption.eq.noForcing )then
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,rectangular,noForcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,rectangular,noForcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,curvilinear,noForcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,curvilinear,noForcing)
        end if
      end if 
    else
      if( gridType.eq.rectangular )then
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,rectangular,forcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,rectangular,forcing)
        end if
      else
        if( nd.eq.2 )then
          assignDirichletGhostCompatibilityOrder6(2,ORDER,curvilinear,forcing)
        else
          assignDirichletGhostCompatibilityOrder6(3,ORDER,curvilinear,forcing)
        end if
      end if     
    end if    
  #End
#endMacro 

! ===================================================================================
! Utility macro to call different versions of assignNeumannGhostCompatibility
! for a given ORDER
! ===================================================================================
#beginMacro callNeumannGhostCompatibility(ORDER)
  if( forcingOption.eq.noForcing )then
    if( gridType.eq.rectangular )then
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,rectangular,noForcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,rectangular,noForcing)
      end if
    else
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,curvilinear,noForcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,curvilinear,noForcing)
      end if
    end if 
  else
    if( gridType.eq.rectangular )then
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,rectangular,forcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,rectangular,forcing)
      end if
    else
      if( nd.eq.2 )then
        assignNeumannGhostCompatibility(2,ORDER,curvilinear,forcing)
      else
        assignNeumannGhostCompatibility(3,ORDER,curvilinear,forcing)
      end if
    end if     
  end if
#endMacro 



! Argument list
#defineMacro ARGLIST() nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                      gridIndexRange, dimRange, isPeriodic, u, un, mask,rsxy, xy, uTemp, v, boundaryCondition, \
                      frequencyArray, pdb, ipar, rpar, ierr

! **********************************************************************************
! Macro BC_WAVE:
!  NAME: name of the subroutine
!  DIM : 2 or 3
!  ORDER : 2 ,4, 6 or 8
! **********************************************************************************
#beginMacro BC_WAVE(NAME,DIM,ORDER)
subroutine NAME( ARGLIST() )

! ===================================================================================
!  Boundary conditions for CgWave
!
!  gridType : 0=rectangular, 1=curvilinear
!
! The forcing for the boundary conditions can be accessed using the statement function:
!         bcf(side,axis,i1,i2,i3,m)
! which is defined below. 
! ===================================================================================

  implicit none

  integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ndb, ierr

  real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
  real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
  real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
  integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*)
  real frequencyArray(0:*)

  ! temp space for CBC order 4 -- fix me : just make a stencil
  real uTemp(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)


  ! ! *** TEMP ARRAYS FOR WORK SPACE --> THIS IS SLOW!!!
  ! #If #ORDER eq "4"
  !   real uTemp(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  !   real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  ! #Else
  ! real v(2,2,2,0:0)
  ! #End

  double precision pdb  ! pointer to data base

  ! integer addBoundaryForcing(0:1,0:2)
  ! integer interfaceType(0:1,0:2,0:*)
  ! integer dim(0:1,0:2,0:1,0:2)

  ! real bcf0(0:*)
  ! integer*8 bcOffset(0:1,0:2)

  ! real bcData(0:ndb-1,0:1,0:nd-1,0:*)

  integer ipar(0:*)
  real rpar(0:*)

  !     --- local variables ----

  integer bc(0:1,0:2) ! local version, normally equal to boundaryCondition
  
  integer uc,numberOfComponents,assignTwilightZone,assignKnownSolutionAtBoundaries,freq
  integer grid,gridType,orderOfAccuracy,useWhereMask,gridIsImplicit,useUpwindDissipation
  integer twilightZone,numberOfProcessors,addForcingBC,assignBCForImplicit
  integer debug,myid,ghost

  integer checkCoeff
  real maxDiff

  integer ok,getInt,getReal
  real omega,cfl,c
  real kx,ky,kz,twoPi

  real t,dt,epsx,REAL_MIN 
  real ep
  real a0,a1,an1,an2,an3,aNormi, t1,t2,t3
  real dx(0:2),dr(0:2),gravity(0:2)
  real r1,r2,r3

  

  real dxn,b0,b1,ue,uex,uey,uez,ff,urv(0:2),ur0,cosPW

  real c2,c4,c6,c8
  real gtt,rFactor,uLap,vLap
  real a11,a12,a21,a22
  real r1a,r2a, r1b,r2b, a11c,a12c,a21c,a22c  
  real u1Save,u2Save  
  real uett,uexx,ueyy,uezz,ueLap
  real ue1,ue2,ue3,ue4,f1,f2,f3,det
  real uettxx,uettyy,uettzz, uexxxx,ueyyyy,uezzzz,uexxyy,uexxzz,ueyyzz
  real uetttt,uettLap,ueLap2,lap3d2Pow2
  real uettx,uetty,uettz
  real uexxx,uexxy,uexxz,uexyy,uexzz,ueyyy,ueyyz,ueyzz,uezzz
  real uexxxxxx,uexxxxyy,uexxxxzz,ueyyyyyy,uexxyyyy,uexxzzzz,ueyyyyzz,ueyyzzzz,uezzzzzz,uexxyyzz
  real fLap,ftt,gtttt
  real gg,nDotGradF,crv(0:3)



  integer side,axis,axisp1,axisp2,i1,i2,i3,is1,is2,is3,j1,j2,j3,js1,js2,js3,k1,k2,k3,ks1,ks2,ks3,is,js
  integer i1p,i2p,i3p
  integer l1,l2,l3

  integer numGhost,numberOfGhostPoints,extraForNeumann,extraForDirichlet,numberOfFrequencies
  integer side1,side2,side3
  integer n1a,n1b,n2a,n2b,n3a,n3b
  integer m1a,m1b,m2a,m2b,m3a,m3b
  integer nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
  integer j1a,j1b,j2a,j2b,ja,j3b
  integer extra1a,extra1b,extra2a,extra2b,extra3a,extra3b,extram

  integer cornerBC(0:2,0:2,0:2), iparc(0:10), orderOfExtrapolationForCorners
  real rparc(0:10)

  real ca,cEM2

  ! boundary conditions parameters and interfaceType values
  ! #Include "bcDefineFortran.h"
  ! These should mauch the values in Parameters.h
  integer dirichletBoundaryCondition,neumannBoundaryCondition,dirichletInterface,neumannInterface,mixedBoundaryCondition
  parameter( dirichletBoundaryCondition=12, neumannBoundaryCondition=18, dirichletInterface=21, neumannInterface=22, mixedBoundaryCondition=30 )

  integer rectangular,curvilinear
  parameter(\
    rectangular=0,\
    curvilinear=1)

  ! Boundary conditions: These must mauch the values in CgWave.h
  ! periodic       =-1,
  ! interpolation  = 0,
  ! dirichlet      = 1,
  ! neumann        = 2,
  ! evenSymmetry   = 3,
  ! radiation      = 4   
  ! exactBC        = 5 
  ! abcEM2         = 6,  // absorbing BC, Engquist-Majda order 2  
  ! characteristic = 7,  // characteristic BC
  ! absorbing      = 8,   // for SuperGrid  

  integer dirichlet,neumann,evenSymmetry,radiation,exactBC,abcEM2,characteristic,absorbing
  parameter( dirichlet=1, neumann=2, evenSymmetry=3, radiation=4, exactBC=5, abcEM2=6, characteristic=7, absorbing=8  )

  ! Corner conditions (from op/fortranDeriv/assignCornersOpt.bf)
  integer doNothingCorner,extrapolateCorner,symmetryCorner,taylor2ndOrder
  integer evenSymmetryCorner,oddSymmetryCorner,taylor2ndOrderEvenCorner,taylor4thOrderEvenCorner,\
          vectorSymmetryAxis1Corner,vectorSymmetryAxis2Corner,vectorSymmetryAxis3Corner

  parameter(doNothingCorner=-1,extrapolateCorner=0,symmetryCorner=1,taylor2ndOrder=2, \
   evenSymmetryCorner=3,oddSymmetryCorner=4,taylor2ndOrderEvenCorner=5,taylor4thOrderEvenCorner=6, \
   vectorSymmetryAxis1Corner=7,vectorSymmetryAxis2Corner=8,vectorSymmetryAxis3Corner=9 )      

  ! known solutions
  integer knownSolutionOption
  integer planeWave, gaussianPlaneWave, boxHelmHoltz, polyPeriodic, otherKnownSolution
  parameter( planeWave=1, gaussianPlaneWave=2, boxHelmHoltz=3, polyPeriodic=4, otherKnownSolution=1000 )

  ! parameters for plane wave known solution
  real ampPlaneWave, kxPlaneWave,kyPlaneWave,kzPlaneWave, omegaPlaneWave

  ! parameters for Gaussian plane wave
  real kxGPW,kyGPW,kzGPW, x0GPW,y0GPW,z0GPW, k0GPW, betaGPW
  real xi

  ! parameters for boxHelmholtz known solution
  real kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz,coswt

  ! parameters for polyPeriodic known solution
  real omegaPolyPeriodic,a0PolyPeriodic, a1PolyPeriodic, b1PolyPeriodic, c1PolyPeriodic

  ! --- forcing options ----
  ! These must match the values in CgWave.h: 
  ! enum ForcingOptionEnum
  ! {
  !   noForcing=0,
  !   twilightZoneForcing,
  !   userForcing,
  !   helmholtzForcing
  ! };  
  integer forcingOption
  integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
  parameter( noForcing=0, twilightZoneForcing=1, userForcing=2, helmholtzForcing=2 )

  ! BC APPROACH -- these must match the values in CgWave.h 
  ! enum BoundaryConditionApproachEnum
  ! {
  !   defaultBoundaryConditionApproach,
  !   useOneSidedBoundaryConditions,
  !   useCompatibilityBoundaryConditions,
  !   useLocalCompatibilityBoundaryConditions
  ! };  
  integer bcApproach
  integer defaultBoundaryConditionApproach
  integer useOneSidedBoundaryConditions
  integer useCompatibilityBoundaryConditions
  integer useLocalCompatibilityBoundaryConditions  
  parameter( defaultBoundaryConditionApproach       =0, \
             useOneSidedBoundaryConditions          =1, \
             useCompatibilityBoundaryConditions     =2, \
             useLocalCompatibilityBoundaryConditions=3 )


  real r3v(0:2),a3(0:2,0:2),a3i(0:2,0:2),f3v(0:2)
  real scale1,scale2,scale3
  integer m1,m2,m3
  logical firstTimeForCBC6
  real symSign


  !     --- start statement function ----
  real bcf,mixedRHS,mixedCoeff,mixedNormalCoeff
  integer kd,m,n,component
  real uxOneSided,lap2d2Pow2

  ! real uxxx,uxxy,uxxz,uxyy,uxzz, uyyy,uyyz,uyzz, uzzz 

  real rx,ry,rz,sx,sy,sz,tx,ty,tz

  ! define variables for getDerivatives macros
  ! #Include "../maple/declareGetDerivativesMacrosVariables.h"

  declareDifferenceOrder2(u,RX)
  #If #ORDER eq "4"
   declareDifferenceOrder4(u,RX)
  #End

  declareDifferenceOrder2(v,none)


  !  The next macro call will define the difference approximation statement functions
  defineDifferenceOrder2Components1(u,RX)
  #If #ORDER eq "4"
   defineDifferenceOrder4Components1(u,RX)
  #End

  defineDifferenceOrder2Components1(v,none)

! declare variables for getDerivatives macros
!! turned off May 4, 2023
!! #Include "../include/declareGetSixthDerivativesMacrosVariables.h"
! instead: 
#Include "../include/declareGetFourthDerivativesMacrosVariables.h"

 real uxxx,uxxy,uxyy,uyyy,uxxz,uxzz,uzzz,uyyz,uyzz,uxyz

  ! 4th-order 1 sided derivative  extrap=(1 5 10 10 5 1)
  uxOneSided(i1,i2,i3,m)=-(10./3.)*u(i1,i2,i3,m)+6.*u(i1+is1,i2+is2,i3+is3,m)-2.*u(i1+2*is1,i2+2*is2,i3+2*is3,m)\
                         +(1./3.)*u(i1+3*is1,i2+3*is2,i3+3*is3,m)

  ! 2D laplacian squared = u.xxxx + 2 u.xxyy + u.yyyy
  lap2d2Pow2(i1,i2,i3,m)= ( 6.*u(i1,i2,i3,m)   \
    - 4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m))    \
        +(u(i1+2,i2,i3,m)+u(i1-2,i2,i3,m)) )/(dx(0)**4) \
    +( 6.*u(i1,i2,i3,m)    \
     -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))    \
        +(u(i1,i2+2,i3,m)+u(i1,i2-2,i3,m)) )/(dx(1)**4)  \
    +( 8.*u(i1,i2,i3,m)     \
     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))   \
     +2.*(u(i1+1,i2+1,i3,m)+u(i1-1,i2+1,i3,m)+u(i1+1,i2-1,i3,m)+u(i1-1,i2-1,i3,m)) )/( (dx(0)*dx(1))**2 )

  ! 3D laplacian squared = u.xxxx + u.yyyy + u.zzzz + 2 (u.xxyy + u.xxzz + u.yyzz )
  lap3d2Pow2(i1,i2,i3,m)= ( 6.*u(i1,i2,i3,m)   \
    - 4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m))    \
        +(u(i1+2,i2,i3,m)+u(i1-2,i2,i3,m)) )/(dx(0)**4) \
   +(  +6.*u(i1,i2,i3,m)    \
     -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))    \
        +(u(i1,i2+2,i3,m)+u(i1,i2-2,i3,m)) )/(dx(1)**4)\
   +(  +6.*u(i1,i2,i3,m)    \
     -4.*(u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))    \
        +(u(i1,i2,i3+2,m)+u(i1,i2,i3-2,m)) )/(dx(2)**4)\
    +(8.*u(i1,i2,i3,m)     \
     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m))   \
     +2.*(u(i1+1,i2+1,i3,m)+u(i1-1,i2+1,i3,m)+u(i1+1,i2-1,i3,m)+u(i1-1,i2-1,i3,m)) )/( (dx(0)*dx(1))**2 ) \
    +(8.*u(i1,i2,i3,m)     \
     -4.*(u(i1+1,i2,i3,m)+u(i1-1,i2,i3,m)+u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))   \
     +2.*(u(i1+1,i2,i3+1,m)+u(i1-1,i2,i3+1,m)+u(i1+1,i2,i3-1,m)+u(i1-1,i2,i3-1,m)) )/( (dx(0)*dx(2))**2 ) \
    +(8.*u(i1,i2,i3,m)     \
     -4.*(u(i1,i2+1,i3,m)+u(i1,i2-1,i3,m)+u(i1,i2,i3+1,m)+u(i1,i2,i3-1,m))   \
     +2.*(u(i1,i2+1,i3+1,m)+u(i1,i2-1,i3+1,m)+u(i1,i2+1,i3-1,m)+u(i1,i2-1,i3-1,m)) )/( (dx(1)*dx(2))**2 ) 
 

  ! ! Here is the the generic boundary condition forcing array. It uses the bcOffset(side,axis) values as an
  ! ! an offset from the bcf0 array to access the bcf10, bcf01, bcf11, ... arrays
  ! bcf(side,axis,i1,i2,i3,m) = bcf0(bcOffset(side,axis) + \
  !     (i1-dim(0,0,side,axis)+(dim(1,0,side,axis)-dim(0,0,side,axis)+1)* \
  !     (i2-dim(0,1,side,axis)+(dim(1,1,side,axis)-dim(0,1,side,axis)+1)* \
  !     (i3-dim(0,2,side,axis)+(dim(1,2,side,axis)-dim(0,2,side,axis)+1)*(m)))))

  ! mixedRHS(component,side,axis,grid) = bcData(component+numberOfComponents*(0),side,axis,grid)
  ! mixedCoeff(component,side,axis,grid) = bcData(component+numberOfComponents*(1),side,axis,grid)
  ! mixedNormalCoeff(component,side,axis,grid) =  bcData(component+numberOfComponents*(2),side,axis,grid)

  !.......statement functions for jacobian
 rx(i1,i2,i3)=rsxy(i1,i2,i3,0,0)
 ry(i1,i2,i3)=rsxy(i1,i2,i3,0,1)
 rz(i1,i2,i3)=rsxy(i1,i2,i3,0,2)
 sx(i1,i2,i3)=rsxy(i1,i2,i3,1,0)
 sy(i1,i2,i3)=rsxy(i1,i2,i3,1,1)
 sz(i1,i2,i3)=rsxy(i1,i2,i3,1,2)
 tx(i1,i2,i3)=rsxy(i1,i2,i3,2,0)
 ty(i1,i2,i3)=rsxy(i1,i2,i3,2,1)
 tz(i1,i2,i3)=rsxy(i1,i2,i3,2,2)


  !............... end statement functions

  ! if( .true. )then ! ********************* TESTING FOR TIMING
  !   return
  ! end if

  checkCoeff=0 ! set to 1 to check coefficients in CBCs using discrete delta approach

  ierr=0

  uc                              = ipar( 0)
  numberOfComponents              = ipar( 1)
  grid                            = ipar( 2)
  gridType                        = ipar( 3)
  orderOfAccuracy                 = ipar( 4)
  gridIsImplicit                  = ipar( 5)
  twilightZone                    = ipar( 6)
  numberOfProcessors              = ipar( 7)
  debug                           = ipar( 8)
  myid                            = ipar( 9)
  assignKnownSolutionAtBoundaries = ipar(10)
  knownSolutionOption             = ipar(11)
  addForcingBC                    = ipar(12)
  forcingOption                   = ipar(13)
  useUpwindDissipation            = ipar(14)
  numGhost                        = ipar(15)  
  assignBCForImplicit             = ipar(16)
  bcApproach                      = ipar(17)
  numberOfFrequencies             = ipar(18)
 
  t         = rpar( 0)
  dt        = rpar( 1)
  dx(0)     = rpar( 2)
  dx(1)     = rpar( 3)
  dx(2)     = rpar( 4)
  dr(0)     = rpar( 5)
  dr(1)     = rpar( 6)
  dr(2)     = rpar( 7)
  ep        = rpar( 8) ! pointer for exact solution -- new : 110311 
  REAL_MIN  = rpar( 9)
  c         = rpar(10)
  cEM2      = rpar(11)

  c2 = c**2
  c4 = c**4
  c6 = c**6
  c8 = c**8
  twoPi = atan2(1.,1.)*8.; ! atan2(1,1)=pi/4

  ! numberOfGhostPoints=orderOfAccuracy/2
  numberOfGhostPoints=numGhost ! now passed in 

  ! write(*,'(" NAME: dim=DIM, order=ORDER")')

  if( t.le.3*dt .and. debug.gt.1 )then
  ! if( .true. )then

    write(*,'(" bcOptWave: grid=",i4," gridType=",i2," orderOfAccuracy=",i2," uc=",i3," twilightZone=",i2)') grid,gridType,orderOfAccuracy,uc,twilightZone
    write(*,'("  addForcingBC=",i4," forcingOption=",i4," assignKnownSolutionAtBoundaries=",i4)') addForcingBC, forcingOption, assignKnownSolutionAtBoundaries
    write(*,'("  t=",e10.2," dt=",e10.2," knownSolutionOption=",i4," REAL_MIN=",e10.2)') t,dt,knownSolutionOption,REAL_MIN
    write(*,'("abcWave: c=",e14.6," cEM2=",e14.6)') c,cEM2
    write(*,'("  useUpwindDissipation=",i2," numGhost=",i2)') useUpwindDissipation,numGhost
    write(*,'("  assignBCForImplicit=",i4," bcApproach=",i4)') assignBCForImplicit,bcApproach
    write(*,'("  boundaryCondition=",6i4)') ((boundaryCondition(side,axis),side=0,1),axis=0,2)
  end if
  
  ! if( bcApproach.eq.useCompatibilityBoundaryConditions )then
  !   write(*,'("bcOptWave: ERROR: useCompatibilityBoundaryConditions not implemented yet.")') 
  !   stop 1010
  ! end if

  if( bcApproach.eq.useLocalCompatibilityBoundaryConditions )then
    write(*,'("bcOptWave: ERROR: useLocalCompatibilityBoundaryConditions not implemented yet.")') 
    stop 2020    
  end if

  ! ---- Make a local version of the boundaryCondition array ----
  do side=0,1
    do axis=0,2
      bc(side,axis)=boundaryCondition(side,axis)

      ! if( bc(side,axis).eq.absorbing )then

      !   ! DO THIS FOR NOW : use dirichlet for absorbing boundaries 

      !   bc(side,axis)=dirichlet
      ! end if

    end do
  end do

  if( .true. ) then
    if( knownSolutionOption.eq.planeWave )then

      ! get parameter values from the C++ data-base
      getRealParameter(ampPlaneWave)
      getRealParameter(kxPlaneWave)
      getRealParameter(kyPlaneWave)
      getRealParameter(kzPlaneWave)
      getRealParameter(omegaPlaneWave)

      if(  t.le.dt .and. debug.gt.1  )then
        write(*,'(" bcOptWave:  knownSolutionOption=planeWave: ampPlaneWave=",e10.2," kxPlaneWave=",e10.2," kyPlaneWave=",e10.2)') ampPlaneWave,kxPlaneWave,kyPlaneWave
      end if 
        
    else if( knownSolutionOption.eq.gaussianPlaneWave )then

      ! Get the parameters in the Gaussian plane wave (Set in userDefinedKnownSolution)
      getRealParameter( kxGPW )
      getRealParameter( kyGPW )
      getRealParameter( kzGPW )      
      getRealParameter( x0GPW )
      getRealParameter( y0GPW )
      getRealParameter( z0GPW )      
      getRealParameter( k0GPW )      
      getRealParameter( betaGPW ) 
      if(  t.le.dt .and. debug.ge.0  )then
        write(*,'(" bcOptWave:  knownSolutionOption=gaussianPlaneWave: kx,ky,kz=",3(1pe10.2)," x0,y0,z0=",3(1pe10.2)," k0,beta=",2(1pe10.2))') \
               kxGPW,kyGPW,kzGPW,x0GPW,y0GPW,z0GPW,k0GPW,betaGPW
      end if           

    else if( knownSolutionOption.eq.boxHelmholtz )then

      ! get parameter values from the C++ data-base
      getRealParameter(kxBoxHelmholtz)
      getRealParameter(kyBoxHelmholtz)
      getRealParameter(kzBoxHelmholtz)
      getRealParameter(omegaBoxHelmholtz)
      coswt = cos(omegaBoxHelmholtz*t)
      assignKnownSolutionAtBoundaries=1  ! for inhomogeneous BCs
      if(  t.le.dt .and. debug.ge.1   )then
        
        write(*,'(" bcOptWave:  assignKnownSolutionAtBoundaries=",i4)') assignKnownSolutionAtBoundaries
        write(*,'(" bcOptWave:  numberOfFrequencies=",i4)') numberOfFrequencies
        write(*,'(" bcOptWave:  frequencyArray=",10(1pe12.4,1x))') (frequencyArray(freq),freq=0,numberOfFrequencies-1)
        write(*,'(" bcOptWave:  knownSolutionOption=boxHelmholtz: kx,ky,kz,omega=",4e10.2)') \
                     kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz
      end if

    else if( knownSolutionOption.eq.polyPeriodic )then

      ! get parameter values from the C++ data-base
      getRealParameter(omegaPolyPeriodic)
      getRealParameter(a0PolyPeriodic)
      getRealParameter(a1PolyPeriodic)
      getRealParameter(b1PolyPeriodic)
      getRealParameter(c1PolyPeriodic)

      coswt = cos(omegaPolyPeriodic*t)
      if(  t.le.dt .and. debug.gt.1   )then
        write(*,'(" bcOptWave:  knownSolutionOption=polyPeriodic: a0,a1,b1,c1,omega=",5e10.2)') \
                     a0PolyPeriodic,a1PolyPeriodic,b1PolyPeriodic,c1PolyPeriodic,omegaPolyPeriodic
      end if


    else if( knownSolutionOption.ne.0 .and. knownSolutionOption.ne.otherKnownSolution )then

      write(*,'("bcOptWave:ERROR: unknown knownSolutionOption=",i6)') knownSolutionOption
      stop 1111
    end if 

  end if
      
  ! TEST: 
  ! getRealParameter(omega)
  ! getRealParameter(cfl)
  ! write(*,'(" bcOptWave:  cfl=",e10.2)') cfl

  if( uc.lt.0 .or. uc.ge.numberOfComponents )then
    write(*,'("bcOptWave:ERROR: invalid uc=",i6," but numberOfComponents=",i3)')  uc,numberOfComponents
    stop 1111
  end if
    
  epsx=REAL_MIN*100.  ! for normal

  if( orderOfAccuracy.ne.2 .and. orderOfAccuracy.ne.4 .and. orderOfAccuracy.ne.6 .and. orderOfAccuracy.ne.8 )then
    write(*,'("bcOptWave:ERROR: orderOfAccuracy is not 2, 4 or 6, orderOfAccuracy=",i4)') orderOfAccuracy
    stop 1111
  end if

  ! Now passed in: 
  ! numGhost=orderOfAccuracy/2

  if( assignBCForImplicit.eq.1 .or. assignBCForImplicit.eq.2 )then

    ! -------- IMPLICIT BoundaryConditions --------
    ! 
    !   assignBCForImplicit = 1 : BCs for implicit time stepping
    !   assignBCForImplicit = 2 : BCs for direct Helmholtz solve

    ! if( .true. )then
    !   write(*,'("bcOptWave: fill BCs into RHS for implicit solver")')
    ! end if

    ! write(*,'("FINISH ME")')
    ! stop 6789

    beginLoopOverSides(numGhost,numGhost)

      if( bc(side,axis) == dirichlet )then

        ff=0.
        if( bcApproach.eq.useOneSidedBoundaryConditions )then
          beginLoops3d()
            if( mask(i1,i2,i3).ne.0 )then

              getDirichletForcing(ff,i1,i2,i3)
              ! fill in boundary value: 
              u(i1,i2,i3,uc)=ff

              ! -- Set ghost to zero (RHS to extrapolation conditions) ---
              ! Is this necessary ?
              do ghost=1,numGhost
                j1=i1-is1*ghost
                j2=i2-is2*ghost
                j3=i3-is3*ghost

                u(j1,j2,j3,uc) = 0.

              end do  

            end if 
          endLoops3d()
          
        else if( bcApproach.eq.useCompatibilityBoundaryConditions )then

          if( t.le.5*dt )then
            write(*,'("bcOpt: implicit: finish me for CBC")') 
          end if

          beginLoops3d()
            if( mask(i1,i2,i3).ne.0 )then

              getDirichletForcing(ff,i1,i2,i3)
              ! fill in boundary value: 
              u(i1,i2,i3,uc)=ff

              ! -- Set ghost to zero (RHS to extrapolation conditions) ---
              ! Is this necessary ?
              do ghost=1,numGhost
                j1=i1-is1*ghost
                j2=i2-is2*ghost
                j3=i3-is3*ghost

                u(j1,j2,j3,uc) = 0.

              end do  

            end if 
          endLoops3d()
        else
          write(*,'("bcOpt: implicit: unexpected bcApproach=",i6)') bcApproach
          stop 1111
        end if


      else if( bc(side,axis) == exactBC )then

        ! These atre now assigned in **takeImplicitStep** 

        ! write(*,*) "bcOpt: implicit BC for exactBc -- finish me"
        ! stop 4444


      else if( bc(side,axis) == neumann )then

        if( gridType.eq.rectangular )then
          ! compute the outward normal (an1,an2,an3)
          an1 = 0.
          an2 = 0.
          an3 = 0.
          if( axis.eq.0 )then
           an1=-is
          else if( axis.eq.1 )then
           an2=-is
          else
           an3=-is
          end if
        end if        

        ! BC is a0*u + a1*u.n = 
        a0=0.
        a1=1.
        ff=0.
        beginLoops3d()
          if( mask(i1,i2,i3).ne.0 )then

            if( gridType.eq.curvilinear )then
              ! compute the outward normal (an1,an2,an3)
              getNormal(i1,i2,i3)
            end if            

            getNeumannForcing(ff)
            ! fill in first ghost:
            j1=i1-is1
            j2=i2-is2
            j3=i3-is3
            u(j1,j2,j3,uc)=ff

          end if 
        endLoops3d()    

      else if( bc(side,axis) == absorbing .or. bc(side,axis) == abcEM2 )then

        ! if( t<=4.*dt )then
        !   write(*,*) "bcOpt: implicit BC for absorbing/EM2 "
        ! end if
        ! stop 4444

        !  Use adjusted c for the EM2 absorbing BC to account for time-discretization errors
        !    D+t (Dx ) w + A+( ... )
        ! cEM2 = c*tan(frequencyArray(0)*dt/2.)/(frequencyArraySave(0)*dt/2.);

        ca = cEM2;  ! Adjusted c 

        if( gridType.eq.rectangular )then
          beginLoops3d()
            if( mask(i1,i2,i3).ne.0 )then
              j1  = i1-is1; j2  = i2-is2; j3  = i3-is3;     ! ghost 
              i1p = i1+is1; i2p = i2+is2; i3p = i3+is3;     ! first line inside

              ! We need current solution un here
              ! res = -is*(unx-ucx)/dt + (.5*c)*( unxx + ucxx) + (.25*c)*( unyy + ucyy );
              if( assignBCForImplicit.eq.1 )then
                if( axis==0 )then
                  u(j1,j2,j3,uc) = (un(j1,j2,j3,uc)-un(i1p,i2p,i3p,uc))/(2.*dx(axis)*dt)                    \
                        - .5*(   ca*(un(i1+1,i2,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1-1,i2,i3,uc))/(dx(0)**2) )   \
                        - .5*(.5*ca*(un(i1,i2+1,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1,i2-1,i3,uc))/(dx(1)**2) ) 
                else
                  u(j1,j2,j3,uc) = (un(j1,j2,j3,uc)-un(i1p,i2p,i3p,uc))/(2.*dx(axis)*dt)                     \
                        - .5*( .5*ca*(un(i1+1,i2,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1-1,i2,i3,uc))/(dx(0)**2) )   \
                        - .5*(    ca*(un(i1,i2+1,i3,uc)-2.*un(i1,i2,i3,uc)+un(i1,i2-1,i3,uc))/(dx(1)**2) )                   
                end if 
              else
                 ! Bc for direct Helmholtz solve
                 u(j1,j2,j3,uc) = 0.
              end if

              do ghost=2,numGhost
                j1=i1-is1*ghost
                j2=i2-is2*ghost
                j3=i3-is3*ghost

                u(j1,j2,j3,uc) = 0.

              end do                
            end if
          endLoops3d();                

        else

         write(*,*) "bcOpt: implicit BC for absorbing/EM2 -- CURVILINEAR : finish me"
          stop 4444          
        end if


      else if( bc(side,axis) > 0 )then

        write(*,'("bcOptWave:fill RHS for direct Helmholtz solver, unexpected boundaryCondition=",i4)') bc(side,axis)

        stop 6666

      else if( bc(side,axis) == 0 )then
        !write(*,'("QQQQ Set ghost outside interp to zero: side,axis,grid,numGhost=",4i4)') side,axis,grid,numGhost
        !write(*,'(" bcOptWave: grid,side,axis=",3i3,", \
        ! loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i6)') grid,side,axis,\
        ! n1a,n1b,n2a,n2b,n3a,n3b        
        beginLoops3d()
         ! -- Set ghost outside interpolation boundaries to zero (for active unused points)
          do ghost=1,numGhost
            j1=i1-is1*ghost
            j2=i2-is2*ghost
            j3=i3-is3*ghost
            u(j1,j2,j3,uc) = 0.
          end do  
        endLoops3d()        
      end if

    endLoopOverSides()   
    
    ! ---------------- RETURN ---------------
    return

  end if



  ! ---------------------------------------------------------------
  ! ----------- STAGE I : Assign Dirichlet Conditions -------------
  ! ---------------------------------------------------------------

  ! NOTE: the numGhost args are used in ghost loops
  extraForDirichlet=numGhost
  ff =0. ! default value 
  beginLoopOverSides(extraForDirichlet,numGhost)

    if( bc(side,axis).eq.exactBC )then

      ! ==== Set the boundary and ghost with the exact solution ====

      ! *wdh* June 13, 2023 

      ! ***** this case is now done in applyBoundaryCondtions.bC *******
      !! assignExactBoundary()

    else if( bc(side,axis).eq.dirichlet )then

      if( bcApproach.eq.useCompatibilityBoundaryConditions )then
        ! --- Assign values on the boundary for CBCs ---
        if( orderOfAccuracy.eq.2 )then

          #If #ORDER eq "2"
          if( gridType.eq.rectangular )then
           
            assignDirichletBoundary(2,2,rectangular)
          else
            assignDirichletBoundary(2,2,curvilinear)
          end if 
          #Else
            stop 222 
          #End        

        else if( orderOfAccuracy.eq.4 )then

          #If #ORDER eq "4"
          if( gridType.eq.rectangular )then
            assignDirichletBoundary(2,4,rectangular)
          else
            assignDirichletBoundary(2,4,curvilinear)
          end if  
          #Else
            stop 444 
          #End                      

        else if( orderOfAccuracy.eq.6 )then 

          write(*,'("CgWave::bcOpt:ERROR: CBC order=6 turned off, use LCBC")') 
          stop 666

        else if( orderOfAccuracy.eq.8 )then   
          stop 888
        else
          write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
          stop 8888
        end if

      else 
        ! ----- assign boundary and then ghost by extrapolation ----
        ! This was a temporary method until other approaches were implemented
        if( orderOfAccuracy.eq.2 )then
          #If #ORDER eq "2"
            assignDirichletBoundaryAndGhost(2)
          #End
        else if( orderOfAccuracy.eq.4 )then
          #If #ORDER eq "4"
          assignDirichletBoundaryAndGhost(4)
          #End
        else if( orderOfAccuracy.eq.6 )then   
          #If #ORDER eq "6"
          assignDirichletBoundaryAndGhost(6)
          #End
        else if( orderOfAccuracy.eq.8 )then   
          stop 888
        else
          write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
          stop 8888
        end if
      end if

    end if ! end if dirichlet 

  endLoopOverSides()

  ! if( .true. )then
  !   return   ! ************************ TESTING TEMP **********************
  ! end if

  ! --  Extrap values on remaining sides to give initial values 
  !     --> maybe we only need to do this along extended boundaries on
  !         curvilinear grids so we have values for the Neumann BC
  beginLoopOverSides(numGhost,numGhost)

    if( ( (bc(side,axis).ne.dirichlet .and. bc(side,axis).ne.exactBC .and. bc(side,axis).ne.absorbing .and. bc(side,axis).ne.abcEM2 ) \
         .or. bcApproach.eq.useCompatibilityBoundaryConditions ) \
         .and. bc(side,axis).gt.0 )then

      if( orderOfAccuracy.eq.2 )then
        #If #ORDER eq "2"
        extrapolateGhost(2)
        #End
      else if( orderOfAccuracy.eq.4 )then
        #If #ORDER eq "4"
        extrapolateGhost(4)
        #End
      else if( orderOfAccuracy.eq.6 )then   
        #If #ORDER eq "6"
        extrapolateGhost(6)
        #End
      else if( orderOfAccuracy.eq.8 )then   
        #If #ORDER eq "8"
        extrapolateGhost(8)
        #End

      else

        write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
        stop 8888

      end if

    end if

  endLoopOverSides()      

  !  --- Assign ghost points outside corners ---
  ! assignCornerGhostsMacro()

  ! Try this for order==6
  ! if( .false. .and. orderOfAccuracy.eq.6 .and. nd.eq.2 .and. gridType.eq.rectangular )then
  !   if( forcingOption.eq.noForcing )then
  !     assignSymmetryCornerGhost(noForcing)
  !   else
  !     assignSymmetryCornerGhost(forcing)
  !   end if
  ! end if

  ! ---------------------------------------------------------------------
  ! ----------- STAGE II : Neumann-like Boundary Conditions -------------
  ! -----------            Ghost values for CBCs            -------------
  ! ---------------------------------------------------------------------

  ! CHECK ME --> numGhost here ??
  extraForNeumann=0 ! only assign Neumann conditions to the boundary
  beginLoopOverSides(extraForNeumann,numGhost)

    if( bc(side,axis).eq.dirichlet .and. bcApproach.eq.useCompatibilityBoundaryConditions )then
      ! -- fill ghost using CBCs ----

      if( orderOfAccuracy.eq.2 )then
        #If #ORDER eq "2"
        callDirichletGhostCompatibility(2)
        #End

      else if( orderOfAccuracy.eq.4 )then
        #If #ORDER eq "4"
        callDirichletGhostCompatibility(4)
        #End

      else if( orderOfAccuracy.eq.6 )then  

        ! turned off May 4, 2023
        write(*,'("CgWave::bcOpt:ERROR: CBC order=6 turned off, use LCBC")')
        stop 666
        ! callDirichletGhostCompatibility(6)

      else if( orderOfAccuracy.eq.8 )then   
        stop 888
      else

        write(*,'("CgWave::bcOpt:ERROR:Dirichlet CBC unexpected orderOfAccuracy=",i6)') orderOfAccuracy
        stop 8888

      end if

    else if( bc(side,axis).eq.neumann )then

      ! ------ NEUMANN ----------
      if( bcApproach.eq.useCompatibilityBoundaryConditions )then
        if( orderOfAccuracy.eq.2 )then
          #If #ORDER eq "2"
          callNeumannGhostCompatibility(2)
          #End

        else if( orderOfAccuracy.eq.4 )then
          #If #ORDER eq "4"
          callNeumannGhostCompatibility(4)
          #End

        else if( orderOfAccuracy.eq.6 )then   
          stop 666
        else if( orderOfAccuracy.eq.8 )then   
          stop 888
        else

          write(*,'("CgWave::bcOpt:ERROR:neumann CBC unexpected orderOfAccuracy=",i6)') orderOfAccuracy
         stop 8888
        end if

      else ! one-sided 
        if( orderOfAccuracy.eq.2 )then
          #If #ORDER eq "2"
          assignNeumannGhost(2)
          #End
        else if( orderOfAccuracy.eq.4 )then
          #If #ORDER eq "4"
          assignNeumannGhost(4)
          #End

        else if( orderOfAccuracy.eq.6 )then
          #If #ORDER eq "6"   
          assignNeumannGhost(6)
          #End

        else if( orderOfAccuracy.eq.8 )then   
          #If #ORDER eq "8"
          assignNeumannGhost(8)
          #End
        else

          write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
          stop 8888
        end if
      end if

    else if( bc(side,axis) == absorbing .or. bc(side,axis) == abcEM2 )then

      ! --- ABC's are done elsewhere ---

      ! write(*,'("bcOptWave: bc=absorbing/EM2 called??")')
      ! stop 3434

    else if(  bc(side,axis).eq.dirichlet .or. bc(side,axis).eq.exactBC .or. bc(side,axis).le.0 )then
      ! do nothing

    else
      write(*,'("bcOptWave: unexpected boundaryCondition=",i4)') bc(side,axis)
      stop 5151
    end if 

  endLoopOverSides()

  !  --- Assign ghost points outside corners ---
  if( .false. .and. orderOfAccuracy.eq.6 .and. nd.eq.2 .and. gridType.eq.rectangular )then
    if( forcingOption.eq.noForcing )then
      assignSymmetryCornerGhost(noForcing)
    else
      assignSymmetryCornerGhost(forcing)
    end if
  else
    ! This is broken, at least in 3D: May 2, 2023 
    ! 
    ! assignCornerGhostsMacro()
  end if

  return
  end

#endMacro

! --- Macro to build the file for each dimension and order ---
#beginMacro buildFile(NAME,DIM,ORDER)
#beginFile NAME.f90
 BC_WAVE(NAME,DIM,ORDER)
#endFile
#endMacro

! --- construct the different files ----

buildFile(bcOptWave2dOrder2,2,2)
buildFile(bcOptWave3dOrder2,3,2)
! buildFile(bcOptWave2dOrder4,2,4)
! buildFile(bcOptWave3dOrder4,3,4)


! buildFile(bcOptWave2dOrder4,2,6)
! buildFile(bcOptWave3dOrder4,3,6)




subroutine bcOptWave( ARGLIST() ) 
! ===================================================================================
!  Boundary conditions for CgWave
!
!  gridType : 0=rectangular, 1=curvilinear
!
! The forcing for the boundary conditions can be accessed using the statement function:
!         bcf(side,axis,i1,i2,i3,m)
! which is defined below. 
! ===================================================================================

  implicit none

  integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ndb, ierr

  real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
  real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
  real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)

  real uTemp(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)
  real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:0)

  integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*)
  real frequencyArray(0:*)

  double precision pdb  ! pointer to data base


  integer ipar(0:*)
  real rpar(0:*)

  integer orderOfAccuracy

  ! extract parameters we need: 
  orderOfAccuracy  = ipar( 4)

  if( nd.eq.2 )then
    if( orderOfAccuracy.eq.2 )then
      call bcOptWave2dOrder2( ARGLIST() )
    elseif( orderOfAccuracy.eq.4 )then
      call bcOptWave2dOrder4( ARGLIST() )
    else
      stop 6666
    end if
  else
    if( orderOfAccuracy.eq.2 )then
      call bcOptWave2dOrder2( ARGLIST() )
    elseif( orderOfAccuracy.eq.4 )then
      call bcOptWave2dOrder4( ARGLIST() )
    else
      stop 7777
    end if    

  end if

  return
  end

