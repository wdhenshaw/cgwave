! ==================================================================================
!
!        Optimized Assign Boundary Conditions for CgWave
!        -----------------------------------------------
!
! ==================================================================================


! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
#Include "defineDiffNewerOrder2f.h"
#Include "defineDiffNewerOrder4f.h"


! From bcOptSmFOS.bf
! DataBase *pdb = &parameters.dbase;
! double precision pdb  ! pointer to data base
! ====================================================================
! Look up an integer parameter from the data base
! ====================================================================
#beginMacro getIntParameter(name)
 ok=getInt(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** bcOptWave:getInt:ERROR: unable to find name")') 
   stop 1122
 end if
#endMacro

! ====================================================================
! Look up a real parameter from the data base
! ====================================================================
#beginMacro getRealParameter(name)
 ok=getReal(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** bcOptWave:getReal:ERROR: unable to find name")') 
   stop 1133
 end if
#endMacro




#beginMacro beginLoops(n1a,n1b,n2a,n2b,n3a,n3b,na,nb)
do i3=n3a,n3b
do i2=n2a,n2b
do i1=n1a,n1b
do n=na,nb
  ! write(*,'(" periodic i1,i2,i3,n=",4i4)') i1,i2,i3,n
#endMacro

#beginMacro endLoops()
end do
end do
end do
end do
#endMacro


#beginMacro beginLoops2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro
#beginMacro endLoops2d()
 end do
 end do
#endMacro

#beginMacro beginLoopsMask2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro
#beginMacro endLoopsMask2d()
 end if
 end do
 end do
#endMacro

#beginMacro beginGhostLoops2d()
 i3=n3a
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

#beginMacro beginLoops3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro

#beginMacro endLoops3d()
 end do
 end do
 end do
#endMacro

#beginMacro beginLoopsMask3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro

#beginMacro endLoopsMask3d()
 end if
 end do
 end do
 end do
#endMacro

#beginMacro beginGhostLoops3d()
 do i3=nn3a,nn3b
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

! ----- define extrapolation formulae ------

#defineMacro extrap2(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   2.*uu(k1,k2,k3,kc)\
                  -uu(k1+  ks1,k2+  ks2,k3+  ks3,kc))

#defineMacro extrap3(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   3.*uu(k1,k2,k3,kc)\
               -3.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
                  +uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc))

#defineMacro extrap4(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   4.*uu(k1,k2,k3,kc)\
               -6.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
               +4.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
                  -uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc))

#defineMacro extrap5(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   5.*uu(k1,k2,k3,kc)\
              -10.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +10.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
               -5.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
                  +uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc))

#defineMacro extrap7(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   7.*uu(k1,k2,k3,kc)\
              -21.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +35.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
              -35.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
              +21.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
               -7.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
                +  uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc) )

#defineMacro extrap9(uu,k1,k2,k3,kc,ks1,ks2,ks3) \
            (   9.*uu(k1,k2,k3,kc)\
              -36.*uu(k1+  ks1,k2+  ks2,k3+  ks3,kc)\
              +84.*uu(k1+2*ks1,k2+2*ks2,k3+2*ks3,kc)\
             -126.*uu(k1+3*ks1,k2+3*ks2,k3+3*ks3,kc)\
             +126.*uu(k1+4*ks1,k2+4*ks2,k3+4*ks3,kc)\
              -84.*uu(k1+5*ks1,k2+5*ks2,k3+5*ks3,kc)\
              +36.*uu(k1+6*ks1,k2+6*ks2,k3+6*ks3,kc)\
               -9.*uu(k1+7*ks1,k2+7*ks2,k3+7*ks3,kc)\
                  +uu(k1+8*ks1,k2+8*ks2,k3+8*ks3,kc) )            



! ************************************************************************************************
!  This macro is used for looping over the faces of a grid to assign booundary conditions
!
! extra: extra points to assign
!          Case 1: extra=numberOfGhostPoints -- for assigning extended boundaries
!          Case 2: extra=-1 -- for assigning ghost points but not including extended boundaries
! numberOfGhostPoints : number of ghost points (1 for 2nd order, 2 for fourth-order ...)
!
!
! Output:
!  n1a,n1b,n2a,n2b,n3a,n3b : from gridIndexRange
!  nn1a,nn1b,nn2a,nn2b,nn3a,nn3b : includes "extra" points
! 
! ***********************************************************************************************
#beginMacro beginLoopOverSides(extra,numberOfGhostPoints)
 extra1a=extra
 extra1b=extra
 extra2a=extra
 extra2b=extra
 if( nd.eq.3 )then
   extra3a=extra
   extra3b=extra
 else
   extra3a=0
   extra3b=0
 end if
 if( boundaryCondition(0,0).lt.0 )then
   extra1a=max(0,extra1a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( boundaryCondition(0,0).eq.0 )then
   extra1a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( boundaryCondition(1,0).lt.0 )then
   extra1b=max(0,extra1b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( boundaryCondition(1,0).eq.0 )then
   extra1b=numberOfGhostPoints
 end if

 if( boundaryCondition(0,1).lt.0 )then
   extra2a=max(0,extra2a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
 else if( boundaryCondition(0,1).eq.0 )then
   extra2a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
 end if
 ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
 if( boundaryCondition(1,1).lt.0 )then
   extra2b=max(0,extra2b) ! over-ride extra=-1 : assign ends in periodic directions
 else if( boundaryCondition(1,1).eq.0 )then
   extra2b=numberOfGhostPoints
 end if

 if(  nd.eq.3 )then
  if( boundaryCondition(0,2).lt.0 )then
    extra3a=max(0,extra3a) ! over-ride extra=-1 : assign ends in periodic directions (or internal parallel boundaries)
  else if( boundaryCondition(0,2).eq.0 )then
    extra3a=numberOfGhostPoints  ! include interpolation points since we assign ghost points outside these
  end if
  ! **NOTE** the bc on the right may be negative even it is not on the left (for parallel)
  if( boundaryCondition(1,2).lt.0 )then
    extra3b=max(0,extra3b) ! over-ride extra=-1 : assign ends in periodic directions
  else if( boundaryCondition(1,2).eq.0 )then
    extra3b=numberOfGhostPoints
  end if
 end if

 do axis=0,nd-1
 do side=0,1

   if( boundaryCondition(side,axis).gt.0 )then

     ! write(*,'(" bcOpt: side,axis,bc=",3i2)') side,axis,boundaryCondition(side,axis)

     n1a=gridIndexRange(0,0)
     n1b=gridIndexRange(1,0)
     n2a=gridIndexRange(0,1)
     n2b=gridIndexRange(1,1)
     n3a=gridIndexRange(0,2)
     n3b=gridIndexRange(1,2)
     if( axis.eq.0 )then
       n1a=gridIndexRange(side,axis)
       n1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       n2a=gridIndexRange(side,axis)
       n2b=gridIndexRange(side,axis)
     else
       n3a=gridIndexRange(side,axis)
       n3b=gridIndexRange(side,axis)
     end if


     nn1a=gridIndexRange(0,0)-extra1a
     nn1b=gridIndexRange(1,0)+extra1b
     nn2a=gridIndexRange(0,1)-extra2a
     nn2b=gridIndexRange(1,1)+extra2b
     nn3a=gridIndexRange(0,2)-extra3a
     nn3b=gridIndexRange(1,2)+extra3b
     if( axis.eq.0 )then
       nn1a=gridIndexRange(side,axis)
       nn1b=gridIndexRange(side,axis)
     else if( axis.eq.1 )then
       nn2a=gridIndexRange(side,axis)
       nn2b=gridIndexRange(side,axis)
     else
       nn3a=gridIndexRange(side,axis)
       nn3b=gridIndexRange(side,axis)
     end if

     is=1-2*side

     is1=0
     is2=0
     is3=0
     if( axis.eq.0 )then
       is1=1-2*side
     else if( axis.eq.1 )then
       is2=1-2*side
     else if( axis.eq.2 )then
       is3=1-2*side
     else
       stop 5
     end if
     
     axisp1=mod(axis+1,nd)
     axisp2=mod(axis+2,nd)
     
     i3=n3a

     if( debug.gt.7 )then
       write(*,'(" bcOptWave: grid,side,axis=",3i3,", \
         loop bounds: n1a,n1b,n2a,n2b,n3a,n3b=",6i3)') grid,side,axis,\
         n1a,n1b,n2a,n2b,n3a,n3b

     end if
   end if ! if bc>0 

   assignTwilightZone=twilightZone

#endMacro

#beginMacro endLoopOverSides()
 end do ! end side
 end do ! end axis
#endMacro


#beginMacro getNormal2d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2))
 an1=an1*aNormi
 an2=an2*aNormi
#endMacro

#beginMacro getNormal3d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 an3 = rsxy(i1,i2,i3,axis,2)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2+ an3**2))
 an1=an1*aNormi
 an2=an2*aNormi
 an3=an3*aNormi
#endMacro



! =================================================================================
!   Assign values in the corners in 2D (see bcMaxwellCorners.bf)
!
!  Set the normal component of the solution on the extended boundaries (points N in figure)
!  Set the corner points "C" 
!              |
!              X
!              |
!        N--N--X--X----
!              |
!        C  C  N
!              |
!        C  C  N
!
! ORDER: 2 or 4
! GRIDTYPE: rectangular, curvilinear
! FORCING: none, twilightZone
! =================================================================================
#beginMacro assignCorners2d(ORDER,GRIDTYPE,FORCING)

  axis=0
  axisp1=1

  i3=gridIndexRange(0,2)
  numberOfGhostPoints=orderOfAccuracy/2


  do side1=0,1
  do side2=0,1
  if( boundaryCondition(side1,0).eq.tractionBC .and.\
      boundaryCondition(side2,1).eq.tractionBC )then

    i1=gridIndexRange(side1,0) ! (i1,i2,i3)=corner point
    i2=gridIndexRange(side2,1)

    ! write(*,'("bcOpt: assign corner side1,side2,i1,i2,i3=",2i2,3i5)') side1,side2,i1,i2,i3

    is1=1-2*side1
    is2=1-2*side2

!   dra=dr(0)*is1
!   dsa=dr(1)*is2

    ! First assign normal component of the displacement:
    ! u.x=u.xxx=0 --> u is even in x
    ! v.y=v.yyy=0 --> v is even in y
    do m=1,numberOfGhostPoints

      js1=is1*m  ! shift to ghost point "m"
      js2=is2*m

      #If #GRIDTYPE == "rectangular"

        u(i1-js1,i2,i3,uc)=u(i1+js1,i2,i3,uc)
        u(i1,i2-js2,i3,vc)=u(i1,i2+js2,i3,vc)

        #If #FORCING == "twilightZone"
          OGF2D(i1-js1,i2,i3,t,um,vm)
          OGF2D(i1+js1,i2,i3,t,up,vp)
          u(i1-js1,i2,i3,uc)=u(i1-js1,i2,i3,uc) + um-up

          OGF2D(i1,i2-js2,i3,t,um,vm)
          OGF2D(i1,i2+js2,i3,t,up,vp)
          u(i1,i2-js2,i3,vc)=u(i1,i2-js2,i3,vc) + vm-vp

        #Elif #FORCING == "none"
        #Else
          stop 6767
        #End

      #Elif #GRIDTYPE == "curvlinear"
        stop 1116
      #Else
        stop 1117
      #End
    end do 

    ! Now assign the tangential components of the displacement 
    alpha=lambda/(lambda+2.*mu)  
    #If #ORDER eq "2" 
      js1=is1
      js2=is2
      #If #GRIDTYPE == "rectangular"
        ! u.yy = alpha*u.xx
        ! v.xx = alpha*v.yy

        u(i1,i2-js2,i3,uc)=2.*u(i1,i2,i3,uc)-u(i1,i2+js2,i3,uc) +dx(1)**2*alpha*uxx22r(i1,i2,i3,uc)
        u(i1-js1,i2,i3,vc)=2.*u(i1,i2,i3,vc)-u(i1+js1,i2,i3,vc) +dx(0)**2*alpha*uyy22r(i1,i2,i3,vc)
      
        #If #FORCING == "twilightZone"

          OGDERIV2D(0,2,0,0,i1,i2,i3,t,uxx0,vxx0)
          OGDERIV2D(0,0,2,0,i1,i2,i3,t,uyy0,vyy0)

          u(i1,i2-js2,i3,uc)=u(i1,i2-js2,i3,uc) +dx(1)**2*( -alpha*uxx0+ uyy0)
          u(i1-js1,i2,i3,vc)=u(i1-js1,i2,i3,vc) +dx(0)**2*( -alpha*vyy0+ vxx0)

          if( debug.gt.0 )then
            OGF2D(i1-js1,i2,i3,t,um,vm)
            OGF2D(i1,i2-js2,i3,t,up,vp)
            write(*,'(" bcOpt:corner: i1,i2=",2i4," uerr,verr=",4e10.2)') i1,i2,\
                  u(i1-js1,i2,i3,uc)-um,u(i1-js1,i2,i3,vc)-vm,\
                  u(i1,i2-js2,i3,uc)-up,u(i1,i2-js2,i3,vc)-vp
            ! '
          end if

        #Elif #FORCING == "none"
        #Else
          stop 6767
        #End
          
      #Elif #GRIDTYPE == "curvlinear"
        stop 1116
      #Else
        stop 1117
      #End

    #Elif #ORDER eq "4" 
      stop 2221
    #Else
    #End


    ! Now do corner (C) points
    ! Taylor series: 
    !   u(-x,-y) = u(x,y) - 2*x*u.x(0,0) - 2*y*u.y(0,0) + O( h^3 )
  ! ** u(i1-is1,i2-is2,i3,uc)=u(i1+is1,i2+is2,i3,uc) -2.*is1*dx(0)*ux22r(i1,i2,i3,uc) -2.*is2*dx(1)*uy22r(i1,i2,i3,uc)
  ! ** u(i1-is1,i2-is2,i3,vc)=u(i1+is1,i2+is2,i3,vc) -2.*is1*dx(0)*ux22r(i1,i2,i3,vc) -2.*is2*dx(1)*uy22r(i1,i2,i3,vc)

    ! This version uses u.xy = - v.xx, v.xy = - u.yy
    u(i1-is1,i2-is2,i3,uc)=2.*u(i1,i2,i3,uc) - u(i1+is1,i2+is2,i3,uc) \
                     +dx(0)**2*uxx22r(i1,i2,i3,uc) - 2.*dx(0)*dx(1)*uxx22r(i1,i2,i3,vc) +dx(1)**2*uyy22r(i1,i2,i3,uc)
    u(i1-is1,i2-is2,i3,vc)=2.*u(i1,i2,i3,vc) - u(i1+is1,i2+is2,i3,vc) \
                     +dx(0)**2*uxx22r(i1,i2,i3,vc) - 2.*dx(0)*dx(1)*uyy22r(i1,i2,i3,uc) +dx(1)**2*uyy22r(i1,i2,i3,vc)

  else if( (boundaryCondition(side1,0).eq.tractionBC .and. boundaryCondition(side2,1).eq.displacementBC) .or.\
           (boundaryCondition(side1,0).eq.displacementBC  .and. boundaryCondition(side2,1).eq.tractionBC) )then 

    ! displacementBC next to stress free
    stop 2311

  else if( boundaryCondition(side1,0).eq.displacementBC .and. boundaryCondition(side2,1).eq.displacementBC )then

    ! displacementBC next to displacementBC
    ! do we need to do anything in this case ? *wdh* 071012
    ! stop 2312

  else if( boundaryCondition(side1,0).gt.0 .and. boundaryCondition(side2,1).gt.0 )then

    ! unknown 
    stop 2313

  end if
  end do
  end do

#endMacro


#beginMacro assignCorners3d(ORDER,GRIDTYPE,FORCING)
  numberOfGhostPoints=orderOfAccuracy/2


  ! Assign the edges
  assignEdges3d(ORDER,GRIDTYPE,FORCING)



  ! Finally assign points outside the vertices of the unit cube
  g1=0.
  g2=0.
  g3=0.

  do side3=0,1
  do side2=0,1
  do side1=0,1

   ! assign ghost values outside the corner (vertex)
   i1=gridIndexRange(side1,0)
   i2=gridIndexRange(side2,1)
   i3=gridIndexRange(side3,2)
   is1=1-2*side1
   is2=1-2*side2
   is3=1-2*side3

   if( boundaryCondition(side1,0).eq.perfectElectricalConductor .and.\
       boundaryCondition(side2,1).eq.perfectElectricalConductor .and.\
       boundaryCondition(side3,2).eq.perfectElectricalConductor )then

   end if

  end do
  end do
  end do
#endMacro





! =========================================================================
! Compute the normal on a curvilinear grid.
!
! Assumes is=1-2*side is defined. 
! =========================================================================
#beginMacro getNormal(j1,j2,j3)
    an1 = rsxy(j1,j2,j3,axis,0)
    an2 = rsxy(j1,j2,j3,axis,1)
    if( nd.eq.2 )then
     aNormi = (-is)/sqrt(an1**2+an2**2)
     an1=an1*aNormi
     an2=an2*aNormi
    else
     an3 = rsxy(j1,j2,j3,axis,2)
     aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
     an1=an1*aNormi
     an2=an2*aNormi
     an3=an3*aNormi
    end if
#endMacro

! ========================================================================================
!  Assign ghost points outside corners
! ========================================================================================
#beginMacro assignCornerGhostsMacro()
  ! ---------------------------------
  ! --- assign corners and edges: ---
  ! ---------------------------------

  do side3=0,2
  do side2=0,2
  do side1=0,2
    if( orderOfAccuracy.eq.4. .and. boundaryCondition(side1,0).eq.neumann .and. \
                                    boundaryCondition(side2,1).eq.neumann .and. \
                     ( nd.eq.2 .or. boundaryCondition(side3,2).eq.neumann ) )then
      ! ---- This is a Neumann-Neumann corner ----
      cornerBC(side1,side2,side3)=extrapolateCorner

      ! if( t.le.2*dt  )then
      !   write(*,'("Assign special Neumann corners conditions ")')
      ! end if
      ! cornerBC(side1,side2,side3)=taylor4thOrderEvenCorner
      ! cornerBC(side1,side2,side3)=evenSymmetryCorner
      ! cornerBC(side1,side2,side3)=0 
    else 
      cornerBC(side1,side2,side3)=0         ! extrapolateCorner=0, (BoundaryConditionParameters)
    end if 
  end do
  end do
  end do

  ! orderOfExtrapolationForCorners=5
  orderOfExtrapolationForCorners= orderOfAccuracy+1

  iparc(0)=uc
  iparc(1)=uc
  iparc(2)=0                              ! useWhereMask;
  iparc(3)=orderOfExtrapolationForCorners
  iparc(4)=numGhost                       ! numberOfCornerGhostLinesToAssign
  iparc(5)=0                              ! cornerExtrapolationOption : 0=extrap along diagonals
  iparc(6)=0                              ! vectorSymmetryCornerComponent
  iparc(7)=gridType

  rparc(0)=epsx ! normEps

  ! Note: is it ok to use gridIndexRange instead of indexRange here: ??
  call fixBoundaryCornersOpt( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,0,uc,\
             nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, u,mask,rsxy, gridIndexRange, dimRange, \
             isPeriodic, boundaryCondition, cornerBC, iparc, rparc )
#endMacro


! ===================================================================================================
! Macro: Extrapolate Ghost Points 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro extrapolateGhost(ORDER)

  #If #ORDER eq "2"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap3(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "4"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap5(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "6"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap7(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "8"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap9(u,i1,i2,i3,n,is1,is2,is3)
  #Else
     write(*,'("bcOptWave: unexpected order=ORDER")') 
    stop 1010
  #End

  beginLoops3d()
    if( mask(i1,i2,i3).ne.0 )then
     
      ! -- extrapolate ghost ---
      do ghost=1,numGhost
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost

        u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 

      end do
       
    end if ! mask .ne. 0
  endLoops3d()
#endMacro


! ============================================================================================
! Macro: evaluate the solution on the boundary for Dirichlet BCs
! ============================================================================================
#beginMacro getDirichletForcing(ff)
  if( assignTwilightZone.eq.1 )then
    ! compute RHS from TZ
    if( nd.eq.2 )then
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
    else
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
    end if
    ff = ue
  else if( assignKnownSolutionAtBoundaries.eq.1 )then
    ! -- we set inhomogeneous Dirichlet values for some known solutions 
    if( knownSolutionOption.eq.planeWave )then
      ! --- evaluate the plane wave solution ---
      if( nd.eq.2 )then
        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
      else
        ff = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
      end if 

    else if( knownSolutionOption.eq.gaussianPlaneWave ) then
      ! Eval the Gaussian plane wave solution
      !    u = exp( -beta*(xi^2) )*cos( k0*xi )
      !    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t       
      !  
      if( nd.eq.2 )then
        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) - c*t
      else
        xi = kxGPW*(xy(i1,i2,i3,0)-x0GPW) + kyGPW*(xy(i1,i2,i3,1)-y0GPW) + kzGPW*(xy(i1,i2,i3,2)-z0GPW) - c*t
      end if 
      ff = exp( -betaGPW*xi**2 ) * cos( k0GPW*xi )      

    else if( knownSolutionOption.eq.boxHelmholtz ) then
      ! --- evaluate the boxHelmholtz solution ---
      if( nd.eq.2 )then
        ff = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
      else
        ff = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
      end if 
    else
      stop 9876
    end if 
  end if
#endMacro      

! ===================================================================================================
! Macro: Assign boundary and ghost points on Dirichlet boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro assignDirichletBoundaryAndGhost(ORDER)

  #If #ORDER eq "2"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap3(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "4"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap5(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "6"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap7(u,i1,i2,i3,n,is1,is2,is3)
  #Elif #ORDER eq "8"
    #defineMacro EXTRAP(u,i1,i2,i3,n,is1,is2,is3) extrap9(u,i1,i2,i3,n,is1,is2,is3)
  #Else
     write(*,'("bcOptWave: unexpected order=ORDER")') 
    stop 1010
  #End

  ff=0.
  beginLoops3d()
    if( mask(i1,i2,i3).ne.0 )then
     
      ! --- get the RHS to the Dirichlet BC ---
      getDirichletForcing(ff)

      ! --- Dirichlet BC ---
      u(i1,i2,i3,uc)=ff
  
      ! -- extrapolate ghost ---
      do ghost=1,numGhost
        j1=i1-is1*ghost
        j2=i2-is2*ghost
        j3=i3-is3*ghost

        u(j1,j2,j3,uc) = EXTRAP(u,j1+is1,j2+is2,j3+is3,uc,is1,is2,is3) 

      end do

    end if ! mask .ne. 0
  endLoops3d()
#endMacro


! ------------------------------------------------------------------------------------
!  Macro: evaluate the RHS to the Neumann BC
! ------------------------------------------------------------------------------------
#beginMacro getNeumannForcing(ff)
  if( assignTwilightZone.eq.1 )then
    ! compute RHS from TZ
    if( nd.eq.2 )then
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ue )
      call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex)
      call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey)
      ff = a0*ue + a1*( an1*uex + an2*uey )
    else
      call ogDeriv(ep,0,0,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ue )
      call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex)
      call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey)
      call ogDeriv(ep,0,0,0,1,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uez)
      ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
    end if

  else if( assignKnownSolutionAtBoundaries.eq.1 )then

    ! -- we set inhomogeneous Neumann values for some known solutions 
    if( knownSolutionOption.eq.planeWave )then
      ! --- evaluate RHS for the plane wave solution ---
      if( nd.eq.2 )then
        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) - omegaPlaneWave*t )
        uex   = kxPlaneWave*cosPW
        uey   = kyPlaneWave*cosPw

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue    = ampPlaneWave*sin( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
        cosPW = ampPlaneWave*cos( kxPlaneWave*xy(i1,i2,i3,0) + kyPlaneWave*xy(i1,i2,i3,1) + kzPlaneWave*xy(i1,i2,i3,2) - omegaPlaneWave*t )
        uex   = kxPlaneWave*cosPW
        uey   = kyPlaneWave*cosPw
        uez   = kzPlaneWave*cosPw

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if 

    else if( knownSolutionOption.eq.gaussianPlaneWave )then
      ! Do nothing for Gaussian plane wave solution for now
      ff = 0.
      
    else if( knownSolutionOption.eq.boxHelmholtz ) then
      ! --- evaluate RHS the boxHelmholtz solution ---
      if( nd.eq.2 )then
        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt
        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kxBoxHelmholtz
        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) * cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) *coswt * kyBoxHelmholtz

        ff = a0*ue + a1*( an1*uex + an2*uey )
      else
        ue  = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt
        uex = cos( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kxBoxHelmholtz
        uey = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *cos( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * sin( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kyBoxHelmholtz
        uez = sin( kxBoxHelmholtz*xy(i1,i2,i3,0) ) *sin( kyBoxHelmholtz*xy(i1,i2,i3,1) ) * cos( kzBoxHelmholtz*xy(i1,i2,i3,2) ) *coswt * kzBoxHelmholtz

        ff = a0*ue + a1*( an1*uex + an2*uey + an3*uez )
      end if 
    else
      stop 8765
    end if 

  end if
#endMacro 

! ===================================================================================================
! Macro: Assign ghost points on Neumann boundaries 
! ORDER : 2,4,6,8
! ===================================================================================================
#beginMacro assignNeumannGhost(ORDER)
   ! BC: a0*T + a1*T.n = 

   ! a0=mixedCoeff(uc,side,axis,grid)
   ! a1=mixedNormalCoeff(uc,side,axis,grid)
   a0=0.
   a1=1.

   ! rectangular case:
   if( gridType.eq.rectangular )then
     ! compute the outward normal (an1,an2,an3)
     an1 = 0.
     an2 = 0.
     an3 = 0.
     if( axis.eq.0 )then
      an1=-is
     else if( axis.eq.1 )then
      an2=-is
     else
      an3=-is
     end if
     dxn=dx(axis)
     b0=-4.*dxn*a0/a1-10./3.
     b1=4.*(dxn/a1)
   end if

   ff=0.
   beginLoops3d()

    ! first ghost pt:
    j1=i1-is1
    j2=i2-is2
    j3=i3-is3
    ! 2nd ghost:
    k1=j1-is1
    k2=j2-is2
    k3=j3-is3
    ! 3rd ghost:
    l1=k1-is1
    l2=k2-is2
    l3=k3-is3    

    if( mask(i1,i2,i3).gt.0 )then
    

      if( gridType.eq.curvilinear )then
        ! compute the outward normal (an1,an2,an3)
        getNormal(i1,i2,i3)
      end if

      getNeumannForcing(ff)


      ! ORDER=4: 
      ! --- assign 2 ghost points using:
      !  (1) Apply Neumann BC to 4th order
      !  (2) Extrap. 2nd ghost to 5th order

      if( gridType.eq.rectangular )then

        ! write(*,'(" TBC: j1,j2=",2i3," u,ff=",2e12.2)') j1,j2,ff,u(j1,j2,j3,uc)
        if( orderOfAccuracy.eq.2 )then
          ! --- NEUMANN ORDER=2 RECTANGULAR ---
          !    (+/-)*a1*[-u(i-1)  + u(i+1)] + 2*dxn*a0*u(i) = 2*dxn*ff 
          !  *check me* 
          b0 = -2.*dxn*a0/a1 
          b1 =  2.*dxn/a1 
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +   u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          + b1*ff
        else 
         !  --- NEUMANN ORDER=4 RECTANGULAR ---
          u(j1,j2,j3,uc)=  b0*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                          +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                          -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +u(j1+4*is1,j2+4*is2,j3+4*is3,uc)/3.\
                            +b1*ff
        end if

      else 
        ! ------ curvilinear grid: -------

        ! a1*( n1*ux + n2*ux + n3*uz ) + a0*u = f 
        ! a1*( (n1*rx+n2*ry+n3*rz)*ur + (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ) + a0*u = f 
        ! =>
        !  ur = [ f - (n1*sx+n2*sy+n3*sz)*us + (n1*tx+n2*ty+n3*st)*ut ]/( a1*( (n1*rx+n2*ry+n3*rz) ) 

        if( orderOfAccuracy.eq.2 )then

          ! ----- NEUMANN ORDER=2 CURVILINEAR ----

          ! ur = ( u(i+1) - u(i-1) )/2*dr
          ! ur = ur0 -> 
          ! u(i-1) = u(i+1) - 2*dr*( ur0 )   (left)
          ! u(i+1) = u(i-1) + 2*dr*( ur0 )   (right) 

          urv(0) = ur2(i1,i2,i3,uc)
          urv(1) = us2(i1,i2,i3,uc)
          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) ) 

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut2(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

           ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
         end if

         u(j1,j2,j3,uc) =  u(j1+2*is1,j2+2*is2,j3+2*is3,uc) -2.*is*dr(axis)*ur0


        else

          ! ---- NEUMANN ORDER 4 CURVILINEAR ----
          !       d14(kd) = 1./(12.*dr(kd))
          !       ur4(i1,i2,i3,kd)=(8.*(u(i1+1,i2,i3,kd)-u(i1-1,i2,i3,kd))-(u(i1+2,
          !        & i2,i3,kd)-u(i1-2,i2,i3,kd)))*d14(0)

          ! ur = f -> 
          ! u(-2) -8*u(-1) =            -8*u(1)   + u(2)        + 12*dr( f )    --- (A)
          ! u(-2) -5*u(-1) = -10*u(0) + 10*u(1) - 5*u(2) + u(3)                 --- (B)

          ! A - B = 
          !       -3*u(-1) =  10*u(0) - 18*u(1) + 6*u(2) - u(3) + 12*dr*( f ) 

          urv(0) = ur4(i1,i2,i3,uc)
          urv(1) = us4(i1,i2,i3,uc)

          if( nd.eq.2 )then
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1) )

            ur0 = (ff - ( t2*urv(axisp1) + a0*u(i1,i2,i3,uc) ) )/t1
          else
            urv(2) = ut4(i1,i2,i3,uc)
            t1=a1*( an1*rsxy(i1,i2,i3,axis  ,0)+an2*rsxy(i1,i2,i3,axis  ,1)+an3*rsxy(i1,i2,i3,axis  ,2) )
            t2=a1*( an1*rsxy(i1,i2,i3,axisp1,0)+an2*rsxy(i1,i2,i3,axisp1,1)+an3*rsxy(i1,i2,i3,axisp1,2) )
            t3=a1*( an1*rsxy(i1,i2,i3,axisp2,0)+an2*rsxy(i1,i2,i3,axisp2,1)+an3*rsxy(i1,i2,i3,axisp2,2) )

            ur0 = ( ff - ( t2*urv(axisp1) + t3*urv(axisp2) + a0*u(i1,i2,i3,uc) ) )/t1
          end if

          u(j1,j2,j3,uc) = (-10./3.)*u(j1+  is1,j2+  is2,j3+  is3,uc)\
                                 +6.*u(j1+2*is1,j2+2*is2,j3+2*is3,uc)\
                                 -2.*u(j1+3*is1,j2+3*is2,j3+3*is3,uc)\
                             +(1./3)*u(j1+4*is1,j2+4*is2,j3+4*is3,uc)\
                              -4.*is*dr(axis)*ur0

        end if ! order =4 
      end if ! curvilinear grid 
      
      ! ----- Assign extra ghost ----
      if( orderOfAccuracy.eq.2) then

        if( numGhost.gt.1 )then
          ! extrap second ghost (UPW)
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)          
        end if

      else if( orderOfAccuracy.eq.4 )then

        ! For Neumann BC's it IS necessary to extrap to order 5 for fourth order. 
        ! extrap second ghost
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)

        if( numGhost.gt.2 )then
          !  extrap third ghost (UPW)
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777        
      end if


    else if( mask(i1,i2,i3).lt.0 )then

      ! ----- extrap ghost outside interp. pts on physical boundaries ------
      if( orderOfAccuracy.eq.2 )then
        u(j1,j2,j3,uc)=extrap3(u,i1,i2,i3,uc,is1,is2,is3)
        if( numGhost.gt.1 )then
          u(k1,k2,k3,uc)=extrap3(u,j1,j2,j3,uc,is1,is2,is3)
        end if

      else if( orderOfAccuracy.eq.4 )then
        u(j1,j2,j3,uc)=extrap5(u,i1,i2,i3,uc,is1,is2,is3)
        u(k1,k2,k3,uc)=extrap5(u,j1,j2,j3,uc,is1,is2,is3)
        if( numGhost.gt.2 )then
          !  extrap third ghost 
          u(l1,l2,l3,uc)=extrap5(u,k1,k2,k3,uc,is1,is2,is3)            
        end if

      else
        write(*,'("bcOptWave: orderOfAccuracy=",i4," is not implemented (Neumann)")') orderOfAccuracy
        stop 7777
      end if
       
    end if

   endLoops3d()
#endMacro


subroutine bcOptWave( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                      gridIndexRange, dimRange, isPeriodic, u, mask,rsxy, xy, boundaryCondition, \
                      pdb, ipar, rpar, ierr )
! ===================================================================================
!  Boundary conditions for CgWave
!
!  gridType : 0=rectangular, 1=curvilinear
!
! The forcing for the boundary conditions can be accessed using the statement function:
!         bcf(side,axis,i1,i2,i3,m)
! which is defined below. 
! ===================================================================================

  implicit none

  integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ndb, ierr

  real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
  real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
  real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
  integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*)

  double precision pdb  ! pointer to data base

  ! integer addBoundaryForcing(0:1,0:2)
  ! integer interfaceType(0:1,0:2,0:*)
  ! integer dim(0:1,0:2,0:1,0:2)

  ! real bcf0(0:*)
  ! integer*8 bcOffset(0:1,0:2)

  ! real bcData(0:ndb-1,0:1,0:nd-1,0:*)

  integer ipar(0:*)
  real rpar(0:*)

  !     --- local variables ----
  
  integer uc,numberOfComponents,assignTwilightZone,assignKnownSolutionAtBoundaries
  integer grid,gridType,orderOfAccuracy,useWhereMask,gridIsImplicit,useUpwindDissipation
  integer twilightZone,numberOfProcessors,addForcing,assignBCForImplicitForImplicit
  integer debug,myid,ghost

  integer ok,getInt,getReal
  real omega,cfl,c

  real t,dt,epsx,REAL_MIN 
  real ep
  real a0,a1,an1,an2,an3,aNormi, t1,t2,t3
  real dx(0:2),dr(0:2),gravity(0:2)

  real dxn,b0,b1,ue,uex,uey,uez,ff,urv(0:2),ur0,cosPW



  integer side,axis,axisp1,axisp2,i1,i2,i3,is1,is2,is3,j1,j2,j3,js1,js2,js3,k1,k2,k3,ks1,ks2,ks3,is,js
  integer l1,l2,l3

  integer numGhost,numberOfGhostPoints,extraForNeumann,extraForDirichlet
  integer side1,side2,side3
  integer n1a,n1b,n2a,n2b,n3a,n3b
  integer nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
  integer extra1a,extra1b,extra2a,extra2b,extra3a,extra3b

  integer cornerBC(0:2,0:2,0:2), iparc(0:10), orderOfExtrapolationForCorners
  real rparc(0:10)

  ! boundary conditions parameters and interfaceType values
  ! #Include "bcDefineFortran.h"
  ! These should mauch the values in Parameters.h
  integer dirichletBoundaryCondition,neumannBoundaryCondition,dirichletInterface,neumannInterface,mixedBoundaryCondition
  parameter( dirichletBoundaryCondition=12, neumannBoundaryCondition=18, dirichletInterface=21, neumannInterface=22, mixedBoundaryCondition=30 )

  integer rectangular,curvilinear
  parameter(\
    rectangular=0,\
    curvilinear=1)

  ! Boundary conditions: These must mauch the values in CgWave.h
  ! periodic      =-1,
  ! interpolation = 0,
  ! dirichlet     = 1,
  ! neumann       = 2,
  ! evenSymmetry  = 3,
  ! radiation     = 4   

  integer dirichlet,neumann,evenSymmetry,radiation
  parameter( dirichlet=1, neumann=2, evenSymmetry=3, radiation=4  )

  ! Corner conditions (from op/fortranDeriv/assignCornersOpt.bf)
  integer doNothingCorner,extrapolateCorner,symmetryCorner,taylor2ndOrder
  integer evenSymmetryCorner,oddSymmetryCorner,taylor2ndOrderEvenCorner,taylor4thOrderEvenCorner,\
          vectorSymmetryAxis1Corner,vectorSymmetryAxis2Corner,vectorSymmetryAxis3Corner

  parameter(doNothingCorner=-1,extrapolateCorner=0,symmetryCorner=1,taylor2ndOrder=2, \
   evenSymmetryCorner=3,oddSymmetryCorner=4,taylor2ndOrderEvenCorner=5,taylor4thOrderEvenCorner=6, \
   vectorSymmetryAxis1Corner=7,vectorSymmetryAxis2Corner=8,vectorSymmetryAxis3Corner=9 )      

  ! known solutions
  integer knownSolutionOption
  integer planeWave, gaussianPlaneWave, boxHelmHoltz
  parameter( planeWave=1, gaussianPlaneWave=2, boxHelmHoltz=3 )

  ! parameters for plane wave known solution
  real ampPlaneWave, kxPlaneWave,kyPlaneWave,kzPlaneWave, omegaPlaneWave

  ! parameters for Gaussian plane wave
  real kxGPW,kyGPW,kzGPW, x0GPW,y0GPW,z0GPW, k0GPW, betaGPW
  real xi

  ! parameters for boxHelmholtz known solution
  real kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz,coswt

  ! --- forcing options ----
  ! These must match the values in CgWave.h: 
  ! enum ForcingOptionEnum
  ! {
  !   noForcing=0,
  !   twilightZoneForcing,
  !   userForcing,
  !   helmholtzForcing
  ! };  
  integer forcingOption
  integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
  parameter( noForcing=0, twilightZoneForcing=1, userForcing=2, helmholtzForcing=2 )

  ! BC APPROACH -- these must match the values in CgWave.h 
  ! enum BoundaryConditionApproachEnum
  ! {
  !   defaultBoundaryConditionApproach,
  !   useOneSidedBoundaryConditions,
  !   useCompatibilityBoundaryConditions,
  !   useLocalCompatibilityBoundaryConditions
  ! };  
  integer bcApproach
  integer defaultBoundaryConditionApproach
  integer useOneSidedBoundaryConditions
  integer useCompatibilityBoundaryConditions
  integer useLocalCompatibilityBoundaryConditions  
  parameter( defaultBoundaryConditionApproach       =0, \
             useOneSidedBoundaryConditions          =1, \
             useCompatibilityBoundaryConditions     =2, \
             useLocalCompatibilityBoundaryConditions=3 )

  !     --- start statement function ----
  real bcf,mixedRHS,mixedCoeff,mixedNormalCoeff
  integer kd,m,n,component
  real uxOneSided

  declareDifferenceNewOrder2(u,rsxy,dr,dx,RX)

  declareDifferenceNewOrder4(u,rsxy,dr,dx,RX)

  !     The next macro call will define the difference approximation statement functions
  defineDifferenceNewOrder2Components1(u,rsxy,dr,dx,RX)

  defineDifferenceNewOrder4Components1(u,rsxy,dr,dx,RX)

  ! 4th-order 1 sided derivative  extrap=(1 5 10 10 5 1)
  uxOneSided(i1,i2,i3,m)=-(10./3.)*u(i1,i2,i3,m)+6.*u(i1+is1,i2+is2,i3+is3,m)-2.*u(i1+2*is1,i2+2*is2,i3+2*is3,m)\
                         +(1./3.)*u(i1+3*is1,i2+3*is2,i3+3*is3,m)

  ! ! Here is the the generic boundary condition forcing array. It uses the bcOffset(side,axis) values as an
  ! ! an offset from the bcf0 array to access the bcf10, bcf01, bcf11, ... arrays
  ! bcf(side,axis,i1,i2,i3,m) = bcf0(bcOffset(side,axis) + \
  !     (i1-dim(0,0,side,axis)+(dim(1,0,side,axis)-dim(0,0,side,axis)+1)* \
  !     (i2-dim(0,1,side,axis)+(dim(1,1,side,axis)-dim(0,1,side,axis)+1)* \
  !     (i3-dim(0,2,side,axis)+(dim(1,2,side,axis)-dim(0,2,side,axis)+1)*(m)))))

  ! mixedRHS(component,side,axis,grid) = bcData(component+numberOfComponents*(0),side,axis,grid)
  ! mixedCoeff(component,side,axis,grid) = bcData(component+numberOfComponents*(1),side,axis,grid)
  ! mixedNormalCoeff(component,side,axis,grid) =  bcData(component+numberOfComponents*(2),side,axis,grid)

  !............... end statement functions

  ierr=0


  uc                              = ipar( 0)
  numberOfComponents              = ipar( 1)
  grid                            = ipar( 2)
  gridType                        = ipar( 3)
  orderOfAccuracy                 = ipar( 4)
  gridIsImplicit                  = ipar( 5)
  twilightZone                    = ipar( 6)
  numberOfProcessors              = ipar( 7)
  debug                           = ipar( 8)
  myid                            = ipar( 9)
  assignKnownSolutionAtBoundaries = ipar(10)
  knownSolutionOption             = ipar(11)
  addForcing                      = ipar(12)
  forcingOption                   = ipar(13)
  useUpwindDissipation            = ipar(14)
  numGhost                        = ipar(15)  
  assignBCForImplicitForImplicit  = ipar(16)
  bcApproach                      = ipar(17)
 
  t         = rpar( 0)
  dt        = rpar( 1)
  dx(0)     = rpar( 2)
  dx(1)     = rpar( 3)
  dx(2)     = rpar( 4)
  dr(0)     = rpar( 5)
  dr(1)     = rpar( 6)
  dr(2)     = rpar( 7)
  ep        = rpar( 8) ! pointer for exact solution -- new : 110311 
  REAL_MIN  = rpar( 9)
  c         = rpar(10)



  if( t.le.dt .and. (.false. .or. debug.gt.1) )then

    write(*,'(" bcOptWave: grid=",i4," gridType=",i2," orderOfAccuracy=",i2," uc=",i3," twilightZone=",i2)') grid,gridType,orderOfAccuracy,uc,twilightZone
    write(*,'("  addForcing=",i4," forcingOption=",i4," assignKnownSolutionAtBoundaries=",i4)') addForcing, forcingOption, assignKnownSolutionAtBoundaries
    write(*,'("  t=",e10.2," dt=",e10.2," knownSolutionOption=",i4," REAL_MIN=",e10.2)') t,dt,knownSolutionOption,REAL_MIN
    write(*,'("  useUpwindDissipation=",i2," numGhost=",i2)') useUpwindDissipation,numGhost
    write(*,'("  assignBCForImplicitForImplicit=",i4," bcApproach=",i4)') assignBCForImplicitForImplicit,bcApproach
    write(*,'("  bc=",6i4)') ((boundaryCondition(side,axis),side=0,1),axis=0,2)
  end if
  
  if( bcApproach.eq.useCompatibilityBoundaryConditions )then
    write(*,'("bcOptWave: ERROR: useCompatibilityBoundaryConditions not implemented yet.")') 
    stop 1010
  end if
  if( bcApproach.eq.useLocalCompatibilityBoundaryConditions )then
    write(*,'("bcOptWave: ERROR: useLocalCompatibilityBoundaryConditions not implemented yet.")') 
    stop 2020    
  end if

  if( .true. ) then
    if( knownSolutionOption.eq.planeWave )then

      ! get parameter values from the C++ data-base
      getRealParameter(ampPlaneWave)
      getRealParameter(kxPlaneWave)
      getRealParameter(kyPlaneWave)
      getRealParameter(kzPlaneWave)
      getRealParameter(omegaPlaneWave)

      if(  t.le.dt .and. debug.gt.1  )then
        write(*,'(" bcOptWave:  knownSolutionOption=planeWave: ampPlaneWave=",e10.2," kxPlaneWave=",e10.2," kyPlaneWave=",e10.2)') ampPlaneWave,kxPlaneWave,kyPlaneWave
      end if 
        
    else if( knownSolutionOption.eq.gaussianPlaneWave )then

      ! Get the parameters in the Gaussian plane wave (Set in userDefinedKnownSolution)
      getRealParameter( kxGPW )
      getRealParameter( kyGPW )
      getRealParameter( kzGPW )      
      getRealParameter( x0GPW )
      getRealParameter( y0GPW )
      getRealParameter( z0GPW )      
      getRealParameter( k0GPW )      
      getRealParameter( betaGPW ) 
      if(  t.le.dt .and. debug.ge.0  )then
        write(*,'(" bcOptWave:  knownSolutionOption=gaussianPlaneWave: kx,ky,kz=",3(1pe10.2)," x0,y0,z0=",3(1pe10.2)," k0,beta=",2(1pe10.2))') \
               kxGPW,kyGPW,kzGPW,x0GPW,y0GPW,z0GPW,k0GPW,betaGPW
      end if           

    else if( knownSolutionOption.eq.boxHelmholtz )then

      ! get parameter values from the C++ data-base
      getRealParameter(kxBoxHelmholtz)
      getRealParameter(kyBoxHelmholtz)
      getRealParameter(kzBoxHelmholtz)
      getRealParameter(omegaBoxHelmholtz)
      coswt = cos(omegaBoxHelmholtz*t)
      if(  t.le.dt .and. debug.gt.1   )then
        write(*,'(" bcOptWave:  knownSolutionOption=boxHelmholtz: kx,ky,kz,omega=",4e10.2)') \
                     kxBoxHelmholtz,kyBoxHelmholtz,kzBoxHelmholtz,omegaBoxHelmholtz
      end if

    else if( knownSolutionOption.ne.0 )then

      write(*,'("bcOptWave:ERROR: unknown knownSolutionOption=",i6)') knownSolutionOption
      stop 1111
    end if 

  end if
      
  ! TEST: 
  ! getRealParameter(omega)
  ! getRealParameter(cfl)
  ! write(*,'(" bcOptWave:  cfl=",e10.2)') cfl

  if( uc.lt.0 .or. uc.ge.numberOfComponents )then
    write(*,'("bcOptWave:ERROR: invalid uc=",i6," but numberOfComponents=",i3)')  uc,numberOfComponents
    stop 1111
  end if
    
  epsx=REAL_MIN*100.  ! for normal

  if( orderOfAccuracy.ne.2 .and. orderOfAccuracy.ne.4 .and. orderOfAccuracy.ne.6 .and. orderOfAccuracy.ne.8 )then
    write(*,'("bcOptWave:ERROR: orderOfAccuracy is not 2, 4 or 6, orderOfAccuracy=",i4)') orderOfAccuracy
    stop 1111
  end if

  ! Now passed in: 
  ! numGhost=orderOfAccuracy/2

  if( assignBCForImplicitForImplicit.eq.1 )then

    ! -------- IMPLICIT BooundaryConditions --------

    ! write(*,'("bcOptWave: fill BCs into RHS for direct Helmholtz solver")')
    ! write(*,'("FINISH ME")')
    ! stop 6789

    beginLoopOverSides(numGhost,numGhost)

      if( boundaryCondition(side,axis) == dirichlet )then

        ff=0.
        beginLoops3d()
          if( mask(i1,i2,i3).ne.0 )then

            getDirichletForcing(ff)
            ! fill in boundary value: 
            u(i1,i2,i3,uc)=ff

            ! -- Set ghost to zero (RHS to extrapolation conditions) ---
            ! Is this necessary ?
            do ghost=1,numGhost
              j1=i1-is1*ghost
              j2=i2-is2*ghost
              j3=i3-is3*ghost

              u(j1,j2,j3,uc) = 0.

            end do  

          end if 
        endLoops3d()

      else if( boundaryCondition(side,axis) == neumann )then

        if( gridType.eq.rectangular )then
          ! compute the outward normal (an1,an2,an3)
          an1 = 0.
          an2 = 0.
          an3 = 0.
          if( axis.eq.0 )then
           an1=-is
          else if( axis.eq.1 )then
           an2=-is
          else
           an3=-is
          end if
        end if        

        ! BC is a0*u + a1*u.n = 
        a0=0.
        a1=1.
        ff=0.
        beginLoops3d()
          if( mask(i1,i2,i3).ne.0 )then

            if( gridType.eq.curvilinear )then
              ! compute the outward normal (an1,an2,an3)
              getNormal(i1,i2,i3)
            end if            

            getNeumannForcing(ff)
            ! fill in first ghost:
            j1=i1-is1
            j2=i2-is2
            j3=i3-is3
            u(j1,j2,j3,uc)=ff

          end if 
        endLoops3d()    

      else if( boundaryCondition(side,axis) > 0 )then

        write(*,'("bcOptWave:fill RHS for direct Helmholtz solver, unexpected boundaryCondition=",i4)') boundaryCondition(side,axis)

        stop 6666
      end if

    endLoopOverSides()   
    
    ! ---------------- RETURN ---------------
    return

  end if



  ! ---------------------------------------------------------------
  ! ----------- STAGE I : Assign Dirichlet Conditions -------------
  ! ---------------------------------------------------------------

  ! NOTE: the numGhost args are used in ghost loops
  extraForDirichlet=numGhost
  ff =0. ! default value 
  beginLoopOverSides(extraForDirichlet,numGhost)

    if( boundaryCondition(side,axis).eq.dirichlet )then

      if( orderOfAccuracy.eq.2 )then

        assignDirichletBoundaryAndGhost(2)

      else if( orderOfAccuracy.eq.4 )then

        assignDirichletBoundaryAndGhost(4)

      else if( orderOfAccuracy.eq.6 )then   

        assignDirichletBoundaryAndGhost(6)

      else if( orderOfAccuracy.eq.8 )then   

        assignDirichletBoundaryAndGhost(8)

      else

        write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
        stop 8888

      end if

    end if ! end if dirichlet 

  endLoopOverSides()

  ! --  Extrap values on remaining sides to give initial values 
  !     --> really we only need to do this along extended boundaries on
  !         curvilinear grids so we have values for the Neumann BC
  beginLoopOverSides(numGhost,numGhost)

    if( boundaryCondition(side,axis).ne.dirichlet .and. boundaryCondition(side,axis).gt.0 )then

      if( orderOfAccuracy.eq.2 )then

        extrapolateGhost(2)

      else if( orderOfAccuracy.eq.4 )then

        extrapolateGhost(4)

      else if( orderOfAccuracy.eq.6 )then   

        extrapolateGhost(6)

      else if( orderOfAccuracy.eq.8 )then   

        extrapolateGhost(8)

      else

        write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
        stop 8888

      end if

    end if

  endLoopOverSides()      

  !  Assign ghost points outside corners
  ! do this for 4th-order neumann-Neumann corners *wdh* April 20, 2021
  ! assignCornerGhostsMacro()

  ! ---------------------------------------------------------------------
  ! ----------- STAGE II : Neumann-like Boundary Conditions -------------
  ! ---------------------------------------------------------------------

  ! CHECK ME --> numGhost here ??
  extraForNeumann=0 ! only assign Neumann conditions to the boundary
  beginLoopOverSides(extraForNeumann,numGhost)

    if( boundaryCondition(side,axis).eq.neumann )then

      ! ------ NEUMANN ----------

      if( orderOfAccuracy.eq.2 )then

        assignNeumannGhost(2)

      else if( orderOfAccuracy.eq.4 )then

        assignNeumannGhost(4)

      else if( orderOfAccuracy.eq.6 )then   

        assignNeumannGhost(6)

      else if( orderOfAccuracy.eq.8 )then   

        assignNeumannGhost(8)

      else

        write(*,'("CgWave::bcOpt:ERROR: unexpected orderOfAccuracy=",i6)') orderOfAccuracy
        stop 8888

      end if


    else if(  boundaryCondition(side,axis).eq.dirichlet .or. boundaryCondition(side,axis).le.0 )then
      ! do nothing

    else
      write(*,'("bcOptWave: unexpected boundaryCondition=",i4)') boundaryCondition(side,axis)
      stop 5151
    end if 

  endLoopOverSides()

  !  --- Assign ghost points outside corners ---
  assignCornerGhostsMacro()


  return
  end

