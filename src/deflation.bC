// ==============================================
//    Deflation Routines for WaveHoltz 
// ==============================================

#include "CgWave.h"
//#include "CompositeGridOperators.h";    
#include "PlotStuff.h"
#include "display.h"
#include "ParallelUtility.h"
//#include "LoadBalancer.h"
#include "gridFunctionNorms.h"
//#include "OGPolyFunction.h"
//#include "ProcessorInfo.h"
#include "ShowFileReader.h"
// #include "InterpolatePointsOnAGrid.h"

#include "Integrate.h"
#Include "GridStatistics.h"
#include "InterpolatePointsOnAGrid.h"



#define FOR_3(i1,i2,i3,I1,I2,I3) for( i3=I3.getBase(); i3<=I3.getBound(); i3++ )  for( i2=I2.getBase(); i2<=I2.getBound(); i2++ )  for( i1=I1.getBase(); i1<=I1.getBound(); i1++ )  
#define FOR_3D(i1,i2,i3,I1,I2,I3) for( int i3=I3.getBase(); i3<=I3.getBound(); i3++ )  for( int i2=I2.getBase(); i2<=I2.getBound(); i2++ )  for( int i1=I1.getBase(); i1<=I1.getBound(); i1++ )


// ======================================================================
// Macro: Normalize an eigenvector 
// ======================================================================
#beginMacro normalizeEigenvectorMacro(i)        
  for( int grid=0; grid<cgev.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cgev[grid];
    getIndex(mg.dimension(),I1,I2,I3);
    OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
    OV_GET_SERIAL_ARRAY(real,u[grid],uLocal);

    bool ok=ParallelUtility::getLocalArrayBounds(u[grid],uLocal,I1,I2,I3);
    if( ok )
      uLocal(I1,I2,I3) = uevLocal(I1,I2,I3,i)*uevLocal(I1,I2,I3,i);
  }


  Real eNorm = sqrt( integrate.volumeIntegral(u) );

  for( int grid=0; grid<cgev.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cgev[grid];
    getIndex(mg.dimension(),I1,I2,I3);
    OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
    bool ok=ParallelUtility::getLocalArrayBounds(uev[grid],uevLocal,I1,I2,I3);
    if( ok )
      uevLocal(I1,I2,I3,i) *= (1./eNorm);
  }
#endMacro 

// ======================================================================
// Macro: Compute the inner product of ui and uj
// ======================================================================
#beginMacro innerProductor(i,j,dotProduct)   
  for( int grid=0; grid<cgev.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cgev[grid];
    getIndex(mg.gridIndexRange(),I1,I2,I3);
    OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
    OV_GET_SERIAL_ARRAY(real,u[grid],uLocal);
    bool ok=ParallelUtility::getLocalArrayBounds(u[grid],uLocal,I1,I2,I3);
    if( ok )
      uLocal(I1,I2,I3) = uevLocal(I1,I2,I3,i)*uevLocal(I1,I2,I3,j);
  }

  dotProduct = integrate.volumeIntegral(u);
#endMacro



// ==============================================================================================
/// \brief Initialize Deflation for WaveHoltz 
// ==============================================================================================
int CgWave::initializeDeflation()
{
  bool & deflationInitialized = dbase.get<bool>("deflationInitialized"); //  set too true if deflation has been initialized
  if( deflationInitialized )
    return 0;

  deflationInitialized=true;

  
  const int & orderOfAccuracy             = dbase.get<int>("orderOfAccuracy");
  const int & solveHelmholtz              = dbase.get<int>("solveHelmholtz");
  const int & computeTimeIntegral         = dbase.get<int>("computeTimeIntegral");
  const int & adjustOmega                 = dbase.get<int>("adjustOmega");  // 1 : choose omega from the symbol of D+t D-t 
  const int & adjustHelmholtzForUpwinding = dbase.get<int>("adjustHelmholtzForUpwinding");
  const int & deflateWaveHoltz            = dbase.get<int>("deflateWaveHoltz");
  int & numToDeflate                      = dbase.get<int>("numToDeflate");
  const aString & eigenVectorFile         = dbase.get<aString>("eigenVectorFile"); //  name of file holding eigs and eigenvectors for deflation
  const int & computeEigenmodes           = dbase.get<int>("computeEigenmodes");
  const int & numberOfFrequencies         = dbase.get<int>("numberOfFrequencies");
  const RealArray & frequencyArray        = dbase.get<RealArray>("frequencyArray");

  printF("\n ==== INITIALIZE DEFLATION =====\n");
  printF("  deflateWaveHoltz=%d, numToDeflate=%d, computeEigenmodes=%d, eigenVectorFile=[%s]\n",deflateWaveHoltz,numToDeflate,computeEigenmodes,(const char*)eigenVectorFile);


  if( !dbase.has_key("uev") )
  {
    dbase.put<realCompositeGridFunction>("uev");
    dbase.put<RealArray>("eig");

    dbase.put<IntegerArray>("eigenVectorIsNormalized");
    dbase.put<IntegerArray>("eigMultiplicity");
    dbase.put<IntegerArray>("eigNumbersToDeflate");

    // dbase.put<RealArray>("eigenVectorMaxNorm");

  }

  realCompositeGridFunction & uev        = dbase.get<realCompositeGridFunction>("uev");
  IntegerArray & eigenVectorIsNormalized = dbase.get<IntegerArray>("eigenVectorIsNormalized");
  IntegerArray & eigMultiplicity         = dbase.get<IntegerArray>("eigMultiplicity");
  IntegerArray & eigNumbersToDeflate     = dbase.get<IntegerArray>("eigNumbersToDeflate");
  const Real eigTol                      = dbase.get<Real>("eigenValueTolForMultiplicity"); 
  // RealArray    & eigenVectorMaxNorm      = dbase.get<RealArray>("eigenVectorMaxNorm");


  int numberOfEigenvectors=-1; 
  RealArray & eig = dbase.get<RealArray>("eig");

  // Integrate integrate;

  // ---- Read show file with eigenvectors and process -----
  // readEigenvectors=true;

  // CompositeGrid & cgev = cg;  // ASSUME THIS FOR NOW -- NEED TO CHECK

  // -- this didn't seem to work: seg fault in cgwh when taking a maxNorm of uev ??
  if( !dbase.has_key("cgev") )
    dbase.put<CompositeGrid>("cgev"); // do this for now, save cgev in case we need the eigenvectors later for computing errors

  CompositeGrid & cgev = dbase.get<CompositeGrid>("cgev");

  printF("---- Read show file=[%s] with eigenvectors and process -----\n",(const char*)eigenVectorFile);
  ShowFileReader showFileReader;
  showFileReader.open(eigenVectorFile);

  int numFrames = showFileReader.getNumberOfFrames();
  const int numberOfSolutions = showFileReader.getNumberOfSolutions();
  printF("There are %d solutions and %d frames\n",numberOfSolutions,numFrames);
      

  // int solutionNumber=1;
  // showFileReader.getASolution(solutionNumber,cgev,uev);        // read in a grid and solution

  int solutionNumber=1; // Frame 1 has some extra data 
  HDF_DataBase & db = *(showFileReader.getFrame(solutionNumber));
  db.get(eig,"eig"); 


  // -- genEigs now can orthogonalize the eigenvectors -- 
  //  *new* Sept 5, 2024 :

  bool eigenVectorsAreOrthogonal=false;

  IntegerArray eigStartIndex;
  int rt = db.get(eigMultiplicity,"eigMultiplicity");
  if( rt==0 )
  {
    eigenVectorsAreOrthogonal=true;
    printF("initDeflation: Eigenvectors in the show file have been orthogonalized and have L2-norm 1.\n");
    db.get(eigStartIndex,"eigStartIndex"); // currently not used : index of first of a multiple eigenvalue

  }
  else
  {
    printF("initDeflation: Eigenvectors in the show file have NOT been orthogonalized : this must be an old file. Regenerate with genEigs and orthogonalize to avoid doing this here.\n");
  }

  if( !dbase.has_key("integrate") )
  {
    Integrate & integrate = dbase.put<Integrate>("integrate");
    // Integrate integrate(cg); // ************** TEST *****************

    printF("\n ###### CgWave::initDeflation: reading Integrate object from the show file with precomputed integration weights...\n");

    integrate.updateToMatchGrid(cg);  // This is correct -- see Overture/otherStuff/testIntegrate.C
    rt = integrate.get(db,"integrate");

    if( true )
    {
      Real volume;
      volume = integrate.volume();
      printf("initializeDeflation: computed volume of the domain = %9.2e\n\n",volume);
    }

    // if( rt==0 )
    //   printF("\n ###### CgWave::initDeflation: Integrate object WAS found in the show file.\n\n");
    // else
    //   printF("\n ###### CgWave::initDeflation: Integrate object was NOT found in the show file.\n\n");
  }
  // // ---- start OLD: 
  // IntegerArray multiplicity, multIndex;
  // int rt = db.get(multiplicity,"multiplicity");
  // if( rt!=0 )
  //   printF("Array multiplicity Not found in EV file: returnCode==%d\n",rt);
  // else
  //   ::display(multiplicity,"multiplicity","%2i");
  // rt = db.get(multiplicity,"multIndex");
  // if( rt!=0 )
  //   printF("Array multIndex Not found in EV file: returnCode==%d\n",rt);
  // // end OLD ------  

  // int solutionNumber=1;
  bool gridsMatch=true; // set to false if the grid in the eigenvector file does not match cg 
  if( numberOfSolutions>1 )
  {
    // *new way* May 9, 2023
    // Eigenvectors are stored as time-steps (in different frames)

    realCompositeGridFunction q;
    InterpolatePointsOnAGrid interp; // for interpolating from a grid with a different resolution
    for( int ie=0; ie<numberOfSolutions; ie++ )
    {
      // --- read in each EV and save in uev ---
      solutionNumber= ie+1; 
      showFileReader.getASolution(solutionNumber,cgev,q);
      if( ie==0 )
      {
        Range all;
        // uev.updateToMatchGrid(cgev,all,all,all,numberOfSolutions);
        uev.updateToMatchGrid(cg,all,all,all,numberOfSolutions);

        gridsMatch = CgWave::compositeGridsMatch( cg, cgev );
        if( gridsMatch )
          printF("CgWaveHoltz::initializeDeflation: read eigenvectors from a file: Grid in eigenvector file grid seems to match with current grid\n");
        else
          printF("CgWaveHoltz::initializeDeflation: read eigenvectors from a file: Grid in eigenvector file grid DOES NOT match with current grid... will interpolate...\n");        
      } 

      Index I1,I2,I3;
      if( gridsMatch )
      {
        // --- just copy grid function from EV file ---
        for( int grid=0; grid<cgev.numberOfComponentGrids(); grid++ )
        {
          MappedGrid & mg = cgev[grid];
          getIndex(mg.dimension(),I1,I2,I3);
          OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
          OV_GET_SERIAL_ARRAY(real,q[grid],qLocal);        
          bool ok=ParallelUtility::getLocalArrayBounds(q[grid],qLocal,I1,I2,I3);
          if( ok )
            uevLocal(I1,I2,I3,ie) = qLocal(I1,I2,I3);
        } 
      }
      else
      {
        // --- Interpolate solution from the EV file : this could be a coarser grid version used for deflation with augmented GMRES
        printF("CgWaveHoltz::initializeDeflation: interpolate the eigenvector ie=%d to the current grid ...\n",ie);
        CompositeGrid & cgev = *q.getCompositeGrid();
        cgev.update(MappedGrid::THEmask );

        interp.setAssignAllPoints(true);  // assign all points -- extrap if necessary
        int width = orderOfAccuracy+1;
        interp.setInterpolationWidth( width ); // set interp width 
        Range C(0,0);
        interp.interpolateAllPoints( q,uev, C, Range(ie,ie) );  // interpolate v from q
      }     
    }
  }
  else
  {
    // *old way* EVs stored as multiple components 
    showFileReader.getASolution(solutionNumber,cgev,uev);        // read in a grid and solution
  }

  numberOfEigenvectors = uev.getComponentBound(0) - uev.getComponentBase(0) + 1;
  printF(">> There are %d eigenvectors\n",numberOfEigenvectors);

  if( numToDeflate > numberOfEigenvectors )
  {
    printF("CgWave::initializeDeflation::ERROR: Requesting %d eigenvectors to deflate but only %d eigenvectors are in the show file.\n",numToDeflate,numberOfEigenvectors);
    OV_ABORT("ERROR");
  }

  // eigenvectorsAreTrueEigenvectors : used by AugmentedGmres 
  int & eigenvectorsAreTrueEigenvectors = dbase.get<int>("eigenvectorsAreTrueEigenvectors");
  if( gridsMatch )
    eigenvectorsAreTrueEigenvectors=true;
  else
    eigenvectorsAreTrueEigenvectors=false;

  
  cgev.update(MappedGrid::THEmask ); // *wdh* March 28, 2023

  if( false )
  {
    // turn this off now that we can interpolate 
    int numPoints=0;
    GridStatistics::getNumberOfPoints(cg, numPoints );

    int numPointsEV=0;
    GridStatistics::getNumberOfPoints(cgev, numPointsEV );
    if( numPoints !=numPointsEV )
    {
      printF("CgWave::initializeDeflation::ERROR: numPoints(cg)=%d is NOT equal to numPointsEV=%d from eigenvector show file\n",numPoints,numPointsEV);
      OV_ABORT("error");
    }
  }


  // --------- Eigenvalues for WaveHoltz are the square root of the input eigenvalues -----
  for( int i=0; i<numberOfEigenvectors; i++ )
  {
    if( fabs(eig(1,i)) < REAL_EPSILON*100*fabs(eig(0,i)) )
    {
      // Eigenvalue is real
      Real lambda = sqrt(eig(0,i));  // Take square root
      eig(0,i)=lambda; 
      if( debug>2 )
        printF("Eigenvalue %3d : k=%16.10f (after square root)\n",i,eig(0,i)); 
    }
    else
    {
      Real lambda = sqrt(eig(0,i));  // Take square root
      eig(0,i)=lambda; 
      printF("Eigenvalue %3d : k=%16.10f (after square root)\n",i,eig(0,i)); 

      printF("WARNING: Eigenvalue %3d : k=%16.10f + (%g) I, has IMAGINARY PART (IGNORING)\n",i,eig(0,i),eig(1,i));    
      // OV_ABORT("STOP HERE FOR NOW");    
    }
  }

  // ----- Find the range of eigenvalues in the show file and check that omega is contained in that range ----
  Range all;
  const Real lambdaMin = min( eig(0,all) );
  const Real lambdaMax = max( eig(0,all) );
  printF("CgWave::initializeDeflation:: Eigenvalues from showfile: lambdaMin=%9.2e, lambdaMax=%9.2e, omega=%9.2e\n",lambdaMin,lambdaMax,frequencyArray(0));
  if( frequencyArray(0) < lambdaMin || frequencyArray(0) > lambdaMax )
  {
    printF("CgWave::initializeDeflation::ERROR omega=%10.2e is outside the range of eigenvalues [%9.2e,%9.2e].\n"
           "                                   Deflation will not work very well. Stopping here for now.\n"
           ,frequencyArray(0),lambdaMin,lambdaMax);
    OV_ABORT("ERROR");
  }


  if( !eigenVectorsAreOrthogonal )
  {
    // ***** OLD STUFF -- this should be done in genEigs now ****
    // ---- compute multiplicities ---

    eigenVectorIsNormalized.redim(numberOfEigenvectors); eigenVectorIsNormalized=0;
    eigMultiplicity.redim(numberOfEigenvectors);         eigMultiplicity=1;
    // eigenVectorMaxNorm.redim(numberOfEigenvectors);      eigenVectorMaxNorm=-1.;  // -1 means max-norm 

    // ---- WE COULD HAVE genEigs save the multiplicity ****** FIX ME ****
    for( int i=0; i<numberOfEigenvectors; i++ )
    {  

      // bool doubleEig=false;
      // const Real eigTol = 1.e-4; // ** FIX ME 
      int ie=i; // first eig of multiple set 
      int je=i; // last eig of multiple set
      const int maxMultiplicity=10; 
      int multiplicity=1; 
      for( int m=0; m<maxMultiplicity; m++ )
      {
        bool matchFound=false;

        // if( ie>0 )
        //   printF("ie=%d, eig(0,ie-1)=%.4g\n",ie, eig(0,ie-1));

        if( ie>0 && fabs(eig(0,ie-1)-eig(0,i))< eigTol*(1.+fabs(eig(0,i))) ) 
        {
          multiplicity++;
          // printF("MATCH FOUND: multiplicity=%d\n",multiplicity);
          ie--; 
          matchFound=true;
        }
        // if( je<numberOfEigenvectors-1)
        //   printF("je=%d, eig(0,je+1)=%.4g\n",je, eig(0,je+1));

        if( (je<numberOfEigenvectors-1) && fabs(eig(0,je+1)-eig(0,i)) < eigTol*(1.+fabs(eig(0,i))) )
        {
          multiplicity++;
          // printF("MATCH FOUND: multiplicity=%d\n",multiplicity);
          je++; 
          matchFound=true;
          // doubleEig=true;
          // j=i+1; 
        }
        if( !matchFound ) break;
      }
      eigMultiplicity(i) = multiplicity;
      if( debug>2 )
        printF(" i=%3d : eig=%14.6e, multiplicity=%d (eigTol=%9.2e)\n",i,eig(0,i),eigMultiplicity(i),eigTol);


      if( false )
      {
        Real evNorm = maxNorm( uev,i);
        printF("maxNorm( uev[%d] ) = %9.2e\n",i,evNorm);
      }

    }
  }

  // ::display(eigMultiplicity,"eigMultiplicity","%2d ");
  // OV_ABORT("stop here for now");

  showFileReader.close();

  if( eigenVectorsAreOrthogonal )
  {
    // **NEW WAY** eigenvectors are orthonormal  Sept 5, 2024

    // ---- MAKE A LIST OF EIGENVECTORS TO USE FOR DEFLATION -----
    const int & numberOfFrequencies         = dbase.get<int>("numberOfFrequencies");
    const RealArray & frequencyArray        = dbase.get<RealArray>("frequencyArray");
    const RealArray & frequencyArraySave    = dbase.get<RealArray>("frequencyArraySave");
    const RealArray & periodArray           = dbase.get<RealArray>("periodArray");  

    eigenVectorIsNormalized.redim(numberOfEigenvectors);   
    eigenVectorIsNormalized=1; 

    eigNumbersToDeflate.redim(numToDeflate*2+10);

    RealArray beta(numberOfEigenvectors);
    IntegerArray iperm(numberOfEigenvectors); // for sorting 

    if( !computeEigenmodes )
    {
      // **** Choose eigenvalues to deflate based on the theoretical convergence rate ****

      RealArray lamv(numberOfEigenvectors);
      for( int i=0; i<numberOfEigenvectors; i++ )
      {
        lamv(i) = eig(0,i);
      }

      // -----------------------------------------------------------------------------------------------
      // Evaluate the "beta" or "mu" function that determines the convergence of the WaveHoltz iteration
      // -----------------------------------------------------------------------------------------------
      getWaveHoltzIterationEigenvalue( lamv, beta );

      RealArray betaSave; // save for below
      betaSave= beta;

      for( int i=0; i<numberOfEigenvectors; i++ )
      {
        Real lambda = lamv(i);
        iperm(i)=i; // for sorting 

        beta(i) = fabs( beta(i) );  // NOTE ABSOLUTE VALUE 

        if( debug>2 )
          printF(" WaveHoltz filter values: i=%4d: lambda=%12.4e, |beta|=%12.4e\n",i,lambda,beta(i));
      }
      // -- bubble sort ---
      for( int i=0; i<numberOfEigenvectors-1; i++ )
      {
        bool changed=false;
        for( int j=0; j<numberOfEigenvectors-1; j++ )
        {
          if( beta(j) < beta(j+1) )
          {
            changed=true;
            Real temp=beta(j);   beta(j)= beta(j+1);  beta(j+1)=temp;
            int itemp=iperm(j); iperm(j)=iperm(j+1); iperm(j+1)=itemp;
          }
        }
        if( !changed ) break;
      }

      if( debug>2 )
        printF("\n ---- SORTED by beta: freq(0)=%12.4e\n",frequencyArray(0));
      for( int j=0; j<numberOfEigenvectors; j++ )
      {
        int i = iperm(j);  // original ordering 
        Real lambda = eig(0,i);
        if( debug>2 )
          printF(" i=%4d: lambda=%12.4e, |beta|=%12.4e\n",i,lambda,beta(j));
      }

      if( debug>2 )
        printF("\n ---- CHOOSE EIGENVALUES TO DEFLATE: (freq(0)=%12.4e) \n",frequencyArray(0));

      int ied = 0; // counts eigenvectors to deflate
      int j=0; 
      for( j=0; j<numToDeflate && j<numberOfEigenvectors-1; j++ )
      {
        int eigNumber = iperm(j);  // original ordering 
        eigNumbersToDeflate(ied)=eigNumber;  ied++;


        Real lambda = eig(0,eigNumber);
        
        if( true || debug>2 )
          printF("deflate ied=%3d eigeNumber=%d: lambda=%12.4e, (multiplicity=%d) beta=%12.4e\n",ied,eigNumber,lambda,eigMultiplicity(eigNumber),beta(j));       

        // normalizeEigenvector( eigNumber );

        if( eigMultiplicity(eigNumber)>1 && j<numberOfEigenvectors-1 )
        {
          // Include the multiple eigenvalue 
          // assert( eigMultiplicity(eigNumber) );
          int eigMult = eigMultiplicity(eigNumber);
          for( int k=1; k<eigMult && j<numberOfEigenvectors-1 ; k++ )
          {
            j++; numToDeflate++;
            eigNumber = iperm(j);  // original ordering 
            eigNumbersToDeflate(ied)=eigNumber;  ied++;

            Real lambda2 =  eig(0,eigNumber);
            if( debug>2 )
              printF("deflate ied=%3d eigNumber=%d: lambda=%12.4e, (multiplicity=%d) *** duplicate ***\n",ied,eigNumber,lambda2,eigMultiplicity(eigNumber)); 

          }

        }

      } // end for j
      int numToDeflateNew =min(j,numberOfEigenvectors);

      printF("ACTUAL numToDeflate=%d, numberOfEigenvectors=%d .. using numToDeflate=%d\n",numToDeflate,numberOfEigenvectors,numToDeflateNew);
      numToDeflate=numToDeflateNew;

      // --- Save beta eigenvalues for augmented GMRES ----
      RealArray & betaDeflate = dbase.get<RealArray>("betaDeflate"); 
      betaDeflate.redim(numToDeflate);
      for( int ied=0; ied<numToDeflate; ied++ )
      {
        // if( eigNumbersToDeflate(ied)>=numToDeflate )
        //   printF("ERROR: Setting betaDeflate but ied=%d, eigNumbersToDeflate(ied)=%d, numberOfEigenvectors=%d\n",ied,eigNumbersToDeflate(ied),numberOfEigenvectors);

        betaDeflate(ied) = betaSave(eigNumbersToDeflate(ied)); // check me 
      }


      Real & waveHoltzAsymptoticConvergenceRate = dbase.get<real>("waveHoltzAsymptoticConvergenceRate");
      waveHoltzAsymptoticConvergenceRate = beta(numToDeflate);

      // numToDeflate=ied;
      printF(">>> number of eigenvectors to deflate (including multiplicities) = %d\n",numToDeflate);
      printF(">>> Estimated asymptotic convergence rate=%6.2f\n",waveHoltzAsymptoticConvergenceRate);

    }


  }
  else 
  {
     // *** OLD WAY ***

    if( !dbase.has_key("integrate") )
    {
      dbase.put<Integrate>("integrate");
    }
    Integrate & integrate = dbase.get<Integrate>("integrate");;

    printF("==== INITIALIZE DEFLATION : compute integration weights...\n");
    integrate.updateToMatchGrid(cg);

    if( numToDeflate>0 )
    {
      Real volume;
      volume = integrate.volume();
      printf("initializeDeflation: computed volume of the domain = %9.2e\n",volume);
    }

    // uDeflate : holds intermediate results for deflation:
    if( !dbase.has_key("uDeflate") )
    {
      realCompositeGridFunction & u = dbase.put<realCompositeGridFunction>("uDeflate");
      u.updateToMatchGrid(cg);
    }

    // ---- MAKE A LIST OF EIGENVECTORS TO USE FOR DEFLATION -----
    const int & numberOfFrequencies         = dbase.get<int>("numberOfFrequencies");
    const RealArray & frequencyArray        = dbase.get<RealArray>("frequencyArray");
    const RealArray & frequencyArraySave    = dbase.get<RealArray>("frequencyArraySave");
    const RealArray & periodArray           = dbase.get<RealArray>("periodArray");  

    eigNumbersToDeflate.redim(numToDeflate*2+10);

    RealArray beta(numberOfEigenvectors);
    IntegerArray iperm(numberOfEigenvectors); // for sorting 

    if( !computeEigenmodes )
    {
      // **** Choose eigenvalues to deflate based on the theoretical convergence rate ****

      RealArray lamv(numberOfEigenvectors);
      for( int i=0; i<numberOfEigenvectors; i++ )
      {
        lamv(i) = eig(0,i);
      }

      // Evaluate the "beta" or "mu" function that determines the convergence of the WaveHoltz iteration
      getWaveHoltzIterationEigenvalue( lamv, beta );

      for( int i=0; i<numberOfEigenvectors; i++ )
      {
        Real lambda = lamv(i);
        iperm(i)=i; // for sorting 
        beta(i) = fabs( beta(i) );
        if( debug>2 )
          printF(" WaveHoltz filter values: i=%4d: lambda=%12.4e, |beta|=%12.4e\n",i,lambda,beta(i));
      }
      // -- bubble sort ---
      for( int i=0; i<numberOfEigenvectors-1; i++ )
      {
        bool changed=false;
        for( int j=0; j<numberOfEigenvectors-1; j++ )
        {
          if( beta(j) < beta(j+1) )
          {
            changed=true;
            Real temp=beta(j);   beta(j)= beta(j+1);  beta(j+1)=temp;
            int itemp=iperm(j); iperm(j)=iperm(j+1); iperm(j+1)=itemp;
          }
        }
        if( !changed ) break;
      }
      if( debug>2 )
        printF("\n ---- SORTED by beta: freq(0)=%12.4e\n",frequencyArray(0));
      for( int j=0; j<numberOfEigenvectors; j++ )
      {
        int i = iperm(j);  // original ordering 
        Real lambda = eig(0,i);
        if( debug>2 )
          printF(" i=%4d: lambda=%12.4e, |beta|=%12.4e\n",i,lambda,beta(j));
      }

      if( true || debug>2 )
        printF("\n ---- CHOOSE EIGENVALUES TO DEFLATE: (freq(0)=%12.4e) \n",frequencyArray(0));
      int ied = 0; // counts eigenvectors to deflate
      for( int j=0; j<numToDeflate; j++ )
      {
        int eigNumber = iperm(j);  // original ordering 
        eigNumbersToDeflate(ied)=eigNumber;  ied++;

        Real lambda = eig(0,eigNumber);
        
        if( debug>2 )
          printF("deflate eig=%d: lambda=%12.4e, (multiplicity=%d)\n",eigNumber,lambda,eigMultiplicity(eigNumber));       

        normalizeEigenvector( eigNumber );

        if( eigMultiplicity(eigNumber)>1 )
        {
         // Include the multiple eigenvalue 
         assert( eigMultiplicity(eigNumber) );
         j++; numToDeflate++;
         eigNumber = iperm(j);  // original ordering 
         eigNumbersToDeflate(ied)=eigNumber;  ied++;
         Real lambda2 =  eig(0,eigNumber);
         const Real lamTol=1.e-3; // ** FIX ME **
         if( fabs(lambda-lambda2)/(1.+abs(lambda)) >= lamTol ) 
         {
          printF("WARNING: Checking for duplicate eigenvalue *but* fabs(lambda-lambda2)/(1.+abs(lambda)) = %9.2e >= lamTol=%9.2e\n",
              fabs(lambda-lambda2)/(1.+abs(lambda)) , lamTol );
         }
         if( debug>2 )
           printF("deflate eig=%d: lambda=%12.4e, (multiplicity=%d) *** duplicate ***\n",eigNumber,lambda2,eigMultiplicity(eigNumber));   
        }
      }



      Real & waveHoltzAsymptoticConvergenceRate = dbase.get<real>("waveHoltzAsymptoticConvergenceRate");
      waveHoltzAsymptoticConvergenceRate = beta(numToDeflate);

      // numToDeflate=ied;
      printF(">>> number of eigenvectors to deflate (including multiplicities) = %d\n",numToDeflate);
      printF(">>> Estimated asymptotic convergence rate=%6.2f\n",waveHoltzAsymptoticConvergenceRate);


    }
  } // end old way

 

  return 0;
}

// ==============================================================================================
/// \brief Make various checks for deflation
// ==============================================================================================
int CgWave::
checkDeflation()
{
  const int & solveHelmholtz              = dbase.get<int>("solveHelmholtz");
  const int & computeTimeIntegral         = dbase.get<int>("computeTimeIntegral");
  const int & adjustOmega                 = dbase.get<int>("adjustOmega");  // 1 : choose omega from the symbol of D+t D-t 
  const int & adjustHelmholtzForUpwinding = dbase.get<int>("adjustHelmholtzForUpwinding");
  const int & deflateWaveHoltz            = dbase.get<int>("deflateWaveHoltz");
  const int & numToDeflate                = dbase.get<int>("numToDeflate");
  const aString & eigenVectorFile         = dbase.get<aString>("eigenVectorFile"); //  name of file holding eigs and eigenvectors for deflation
  const Real eigTol                       = dbase.get<Real>("eigenValueTolForMultiplicity");
  printF("\n ==== CHECK DEFLATION =====\n");
  printF("  deflateWaveHoltz=%d, numToDeflate=%d, eigenVectorFile=[%s]\n",deflateWaveHoltz,numToDeflate,(const char*)eigenVectorFile);

  if( !dbase.has_key("uev") )
  {
    initializeDeflation();
  }

  realCompositeGridFunction & uev = dbase.get<realCompositeGridFunction>("uev");
  RealArray & eig = dbase.get<RealArray>("eig");
  int numberOfEigenvectors = uev.getComponentBound(0) - uev.getComponentBase(0) + 1; 

  CompositeGrid & cgev = cg;


  Integrate & integrate = dbase.get<Integrate>("integrate");

  // -- holds intermediate results: 
  realCompositeGridFunction & u = dbase.get<realCompositeGridFunction>("uDeflate");
  u=0.; 

  // u=1.;
  // Real volume;
  // volume = integrate.volumeIntegral(u);
  // printf("Volume of domain = %9.2e\n",volume);


  Real dotProduct;
  Index I1,I2,I3;


  // ***DO THIS FOR NOW***

  // -- normalize and orthogonalize eigenvectors ----

  for( int i=0; i<numberOfEigenvectors; i++ )
  {
    normalizeEigenvectorMacro(i); 

    if( i>0 )
    {
      // --- Look for multiple eigenvalues ---
      int j=i-1; 
      const Real delta = fabs(eig(0,i)-eig(0,j))/fabs(eig(0,i));

      if( i<100 )
        printF(" i=%d: eig(i)=%9.3e eig(i-1)=%9.3e, delta=%9.3e\n",i,eig(0,i),eig(0,j),delta);

      // const Real eigTol = 1.e-4; // ** FIX ME 
      if( delta < eigTol )
      {
        // --- We have a mutiple eigenvalue -----
        // --- Orthogonalize the eigenvectors ----

        if( i<100 )
          printF(" >>> Multiple eigenvalue found: i=%d, eig=%10.3e, will orthogonalize eigenvectors...\n",i,eig(0,i));

        innerProductor( i,j,dotProduct );  

        if( i<100 )
          printF(" Inner product: (u%d,u%d) = %9.3e\n",i,j,dotProduct);

        // -- Gram-Schmidt --
        //   ui = ui - (ui,uj)*uj 
        for( int grid=0; grid<cgev.numberOfComponentGrids(); grid++ )
        {
          MappedGrid & mg = cgev[grid];
          getIndex(mg.dimension(),I1,I2,I3);
          OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
          bool ok=ParallelUtility::getLocalArrayBounds(uev[grid],uevLocal,I1,I2,I3);
          if( ok )
            uevLocal(I1,I2,I3,i) -= dotProduct*uevLocal(I1,I2,I3,j);
        }

        // re-normalize

        normalizeEigenvectorMacro(i);             
      }
    }


  }

  // OV_ABORT("checkDeflation: stop here for now");
  return 0;
}


// ==============================================================================================
/// \brief Normalize eigenvector number "eigNumber". Orthogonalize any eigenvectors corresponding to
///      multiple eigenvalues.
/// \return value: multipilicity of the eigenvector: 1=simple, 2=double, ...
// ==============================================================================================
int CgWave::
normalizeEigenvector( int eigNumber )
{
  const int & debug                       = dbase.get<int>("debug");
  const int & solveHelmholtz              = dbase.get<int>("solveHelmholtz");
  const int & computeTimeIntegral         = dbase.get<int>("computeTimeIntegral");
  const int & adjustOmega                 = dbase.get<int>("adjustOmega");  // 1 : choose omega from the symbol of D+t D-t 
  const int & adjustHelmholtzForUpwinding = dbase.get<int>("adjustHelmholtzForUpwinding");
  const int & deflateWaveHoltz            = dbase.get<int>("deflateWaveHoltz");
  const int & numToDeflate                = dbase.get<int>("numToDeflate");
  const aString & eigenVectorFile         = dbase.get<aString>("eigenVectorFile"); //  name of file holding eigs and eigenvectors for deflation

  IntegerArray & eigenVectorIsNormalized = dbase.get<IntegerArray>("eigenVectorIsNormalized");
  IntegerArray & eigMultiplicity         = dbase.get<IntegerArray>("eigMultiplicity");
  const Real eigTol                      = dbase.get<Real>("eigenValueTolForMultiplicity");


  if(  eigenVectorIsNormalized(eigNumber)  )
  {
    printF(">> normalizeEigenvector: INFO: eigenvector=%d already normalized\n",eigNumber);
    return eigMultiplicity(eigNumber);
  }
  int multiplicity=1; 

  if( debug>2 )
  {
    printF("\n ==== NORMALIZE EIGENVECTOR eigNumber=%d =====\n",eigNumber);
    printF("  deflateWaveHoltz=%d, numToDeflate=%d, eigenVectorFile=[%s]\n",deflateWaveHoltz,numToDeflate,(const char*)eigenVectorFile);
  }

  if( !dbase.has_key("uev") )
  {
    initializeDeflation();
  }

  realCompositeGridFunction & uev = dbase.get<realCompositeGridFunction>("uev");
  RealArray & eig = dbase.get<RealArray>("eig");
  int numberOfEigenvectors = uev.getComponentBound(0) - uev.getComponentBase(0) + 1; 

  CompositeGrid & cgev = cg;


  Integrate & integrate = dbase.get<Integrate>("integrate");

  // -- holds intermediate results: 
  realCompositeGridFunction & u = dbase.get<realCompositeGridFunction>("uDeflate");

  Real dotProduct;
  Index I1,I2,I3;


  // ***DO THIS FOR NOW***

  // -- normalize and orthogonalize eigenvectors ----

  int i = eigNumber;

  normalizeEigenvectorMacro(i); 

  eigenVectorIsNormalized(i)=1;

  if( eigMultiplicity(i) > 1 )
  {
    // ---  multiple eigenvalue ----
    multiplicity = eigMultiplicity(i);

    printF(" >>> Multiple eigenvalue found: i=%d, eig=%12.5e, eigMultiplicity(i)=%d will orthogonalize eigenvectors...\n",i,eig(0,i),eigMultiplicity(i));

    int j=i;
  
    i=j+1; // check for duplicate eig here
    Real delta = fabs(eig(0,i)-eig(0,j))/fabs(eig(0,i));
    // Real eigTol = 1.e-4; // ** FIX ME 
    if( delta> eigTol && i>0 )
    {
      i=j-1;
      delta = fabs(eig(0,i)-eig(0,j))/fabs(eig(0,i));
    }

    assert( eigMultiplicity(i) > 1 );
    if( eigenVectorIsNormalized(i) != 0 )
    {
      printF(">>> ERROR: eigenVectorIsNormalized(i)=%d, expecting zero. i=%d, j=%d, eigMultiplicity(i)=%d\n",eigenVectorIsNormalized(i),i,j,eigMultiplicity(i));
      OV_ABORT("error");
    }

    // Real delta = fabs(eig(0,i)-eig(0,j))/fabs(eig(0,i));
    // Real eigTol = 1.e-3; // ** FIX ME 
    // assert( delta < eigTol );

    // --- Orthogonalize the eigenvectors ----

    innerProductor( i,j,dotProduct );  

    if( i<100 )
      printF(" Inner product: (u%d,u%d) = %9.3e\n",i,j,dotProduct);

    // -- Gram-Schmidt --
    //   ui = ui - (ui,uj)*uj 
    for( int grid=0; grid<cgev.numberOfComponentGrids(); grid++ )
    {
      MappedGrid & mg = cgev[grid];
      getIndex(mg.dimension(),I1,I2,I3);
      OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
      bool ok=ParallelUtility::getLocalArrayBounds(uev[grid],uevLocal,I1,I2,I3);
      if( ok )
        uevLocal(I1,I2,I3,i) -= dotProduct*uevLocal(I1,I2,I3,j);
    }

    // re-normalize
    

    normalizeEigenvectorMacro(i); 
    eigenVectorIsNormalized(i)=1;    

    printF("Eigenvector %d is now orthonormal to eigenvector %d.\n",i,j);

  }

  // if( i>0 )
  // {
  //   // --- Look for multiple eigenvalues ---
  //   int j=i-1; 
  //   const Real delta = fabs(eig(0,i)-eig(0,j))/fabs(eig(0,i));

  //   if( i<100 )
  //     printF(" i=%d: eig(i)=%9.3e eig(i-1)=%9.3e, delta=%9.3e\n",i,eig(0,i),eig(0,j),delta);

  //   const Real eigTol = 1.e-3; // ** FIX ME 
  //   if( delta < eigTol )
  //   {
  //     // --- We have a mutiple eigenvalue -----
  //     // --- Orthogonalize the eigenvectors ----

  //     multiplicity=2;

  //     if( i<100 )
  //       printF(" >>> Multiple eigenvalue found: i=%d, eig=%10.3e, will orthogonalize eigenvectors...\n",i,eig(0,i));

  //     innerProductor( i,j,dotProduct );  

  //     if( i<100 )
  //       printF(" Inner product: (u%d,u%d) = %9.3e\n",i,j,dotProduct);

  //     // -- Gram-Schmidt --
  //     //   ui = ui - (ui,uj)*uj 
  //     for( int grid=0; grid<cgev.numberOfComponentGrids(); grid++ )
  //     {
  //       MappedGrid & mg = cgev[grid];
  //       getIndex(mg.dimension(),I1,I2,I3);
  //       OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);

  //       uevLocal(I1,I2,I3,i) -= dotProduct*uevLocal(I1,I2,I3,j);
  //     }

  //     // re-normalize

  //     normalizeEigenvectorMacro(i);             
  //   }
  // }

  return multiplicity;
}


// ==============================================================================================
/// \brief Deflate the current WaveHoltz solution by subtracting out the components along the
///    selected eigenvectors.
// ==============================================================================================
int CgWave::
deflateSolution()
{
  bool & deflationInitialized = dbase.get<bool>("deflationInitialized");
  const int & debug           = dbase.get<int>("debug"); 
  if( !deflationInitialized )
  {
    initializeDeflation();
    // checkDeflation();   // This will normalized eigenvectors ****** FIX ME *******
  }


 

  const int & numberOfFrequencies          = dbase.get<int>("numberOfFrequencies");
  const int & deflateWaveHoltz             = dbase.get<int>("deflateWaveHoltz");
  const int & numToDeflate                 = dbase.get<int>("numToDeflate");
  const IntegerArray & eigNumbersToDeflate = dbase.get<IntegerArray>("eigNumbersToDeflate");

  if( deflateWaveHoltz==0 || numToDeflate<=0 )
    return 0;

  // -- holds intermediate results: 
  // uDeflate : holds intermediate results for deflation:
  if( !dbase.has_key("uDeflate") )
  {
    realCompositeGridFunction & u = dbase.put<realCompositeGridFunction>("uDeflate");
    u.updateToMatchGrid(cg);
  }  
  realCompositeGridFunction & u = dbase.get<realCompositeGridFunction>("uDeflate");

  // -- eigenvectors:
  realCompositeGridFunction & uev = dbase.get<realCompositeGridFunction>("uev");

  // WaveHoltz solution:
  realCompositeGridFunction & v = dbase.get<realCompositeGridFunction>("v");

  if( !dbase.has_key("integrate") )
  {
    printF("==== CgWave::deflateSolution: compute integration weights...\n");
    Integrate & integrate = dbase.put<Integrate>("integrate");
    integrate.updateToMatchGrid(cg);    
  }
  Integrate & integrate = dbase.get<Integrate>("integrate");


  // int freq=0;      // adjust this frequency **FIX ME**

  Index I1,I2,I3;
  for( int freq=0; freq<numberOfFrequencies; freq++ )
  {
    for( int ied=0; ied<numToDeflate; ied++ )
    {
      int eigNumber = eigNumbersToDeflate(ied); // deflate this eigenvector 
      if( debug>1  )
        printF("deflateSolution: freq=%d : deflate eigenvector %d (numToDeflate=%d)\n",freq,eigNumber,numToDeflate);

      // --- Compute the inner product (phi,v)_h ----
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        getIndex(mg.dimension(),I1,I2,I3);
        OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
        OV_GET_SERIAL_ARRAY(real,u[grid],uLocal);
        OV_GET_SERIAL_ARRAY(real,v[grid],vLocal);
        bool ok=ParallelUtility::getLocalArrayBounds(uev[grid],uevLocal,I1,I2,I3);
        if( ok )
          uLocal(I1,I2,I3) = uevLocal(I1,I2,I3,eigNumber)*vLocal(I1,I2,I3,freq);
      }

      Real phiDotv = integrate.volumeIntegral(u);

      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        getIndex(mg.dimension(),I1,I2,I3);
        OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
        OV_GET_SERIAL_ARRAY(real,v[grid],vLocal);
        bool ok=ParallelUtility::getLocalArrayBounds(uev[grid],uevLocal,I1,I2,I3);
        if( ok )
          vLocal(I1,I2,I3,freq) -= phiDotv*uevLocal(I1,I2,I3,eigNumber);
      }

    }
  }

  return 0;
}


// ==============================================================================================
/// \brief Inflate the WaveHoltz solution by adding in the solution along the
///    selected eigenvectors.
// ==============================================================================================
int CgWave::
inflateSolution()
{

  const int & deflateWaveHoltz             = dbase.get<int>("deflateWaveHoltz");
  const int & numToDeflate                 = dbase.get<int>("numToDeflate");
  const IntegerArray & eigNumbersToDeflate = dbase.get<IntegerArray>("eigNumbersToDeflate");
  const int & debug                        = dbase.get<int>("debug");

  if( deflateWaveHoltz==0 || numToDeflate<=0 )
    return 0;

  const int & numberOfFrequencies         = dbase.get<int>("numberOfFrequencies");
  const RealArray & frequencyArray        = dbase.get<RealArray>("frequencyArray");
  const RealArray & periodArray           = dbase.get<RealArray>("periodArray");  


  // -- holds intermediate results: 
  realCompositeGridFunction & u = dbase.get<realCompositeGridFunction>("uDeflate");

  // -- eigenvectors:
  realCompositeGridFunction & uev = dbase.get<realCompositeGridFunction>("uev");

  // WaveHoltz solution:
  realCompositeGridFunction & v = dbase.get<realCompositeGridFunction>("v");

  Integrate & integrate = dbase.get<Integrate>("integrate");

  RealArray & eig = dbase.get<RealArray>("eig");
  int numberOfEigenvectors = uev.getComponentBound(0) - uev.getComponentBase(0) + 1;


  // int freq=0;      // adjust this frequency **FIX ME**
  
  // Forcing: 
  realCompositeGridFunction f(cg); 
  getHelmholtzForcing( f );

  Index I1,I2,I3;
  for( int freq=0; freq<numberOfFrequencies; freq++ )
  {
    for( int ied=0; ied<numToDeflate; ied++ )
    {
      int eigNumber=eigNumbersToDeflate(ied);

      // --- Compute the inner product (phi,f)_h ----
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        getIndex(mg.dimension(),I1,I2,I3);
        OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
        OV_GET_SERIAL_ARRAY(real,u[grid],uLocal);
        OV_GET_SERIAL_ARRAY(real,f[grid],fLocal);
        bool ok=ParallelUtility::getLocalArrayBounds(uev[grid],uevLocal,I1,I2,I3);
        if( ok )
          uLocal(I1,I2,I3) = uevLocal(I1,I2,I3,eigNumber)*fLocal(I1,I2,I3,freq);
      }

      Real phiDotF = integrate.volumeIntegral(u);  // compute discrete inner product 

      Real lambda = eig(0,eigNumber);
      Real omega = frequencyArray(freq);      // this should be unadjusted value --- *** CHECK ME ***

      const Real factor = phiDotF/( omega*omega - lambda*lambda );

      if( debug>1 )
        printF("inflateSolution: freq=%d: inflate eigenvector %d, lambda=%12.4e, omega=%12.4e\n",freq,eigNumber,lambda,omega);

      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        getIndex(mg.dimension(),I1,I2,I3);
        OV_GET_SERIAL_ARRAY(real,uev[grid],uevLocal);
        OV_GET_SERIAL_ARRAY(real,v[grid],vLocal);
        bool ok=ParallelUtility::getLocalArrayBounds(uev[grid],uevLocal,I1,I2,I3);
        if( ok )
          vLocal(I1,I2,I3,freq) += factor*uevLocal(I1,I2,I3,eigNumber);
      }
    }
  }

  return 0;
}
