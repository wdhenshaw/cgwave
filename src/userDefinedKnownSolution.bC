#include "CgWave.h"
#include "GenericGraphicsInterface.h"
#include "ParallelUtility.h"

#Include "knownSolutionMacros.h"

#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)

typedef ::real LocalReal;

// Macro to get the vertex array
#define GET_VERTEX_ARRAY(x)                                     \
mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);       \
OV_GET_SERIAL_ARRAY_CONST(real,mg.vertex(),x);       

// ==========================================================================================
/// \brief  Evaluate a user defined known solution.
///
/// \param numberOfTimeDerivatives (input) : evaluate this many time-derivatives of the solution.
///     Normally  numberOfTimeDerivatives=0, but it can be 1 when the known solution is used
//      to define boundary conditions 
// ==========================================================================================
int CgWave::
getUserDefinedKnownSolution(real t,  int grid, 
                            realArray & ua, const Index & I1a, const Index &I2a, const Index &I3a, 
                            int numberOfTimeDerivatives /* = 0 */ )
{
  const real & c= dbase.get<real>("c");
  const real & dt= dbase.get<real>("dt");

  const int & numberOfFrequencies   = dbase.get<int>("numberOfFrequencies");
  const RealArray & frequencyArray  = dbase.get<RealArray>("frequencyArray");

  if( false && t<= 2.*dt )
    printF("--CgWave-- getUserDefinedKnownSolution at t=%9.3e \n",t);

  MappedGrid & mg = cg[grid];
  const int numberOfDimensions = cg.numberOfDimensions();

  
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
  {
    printF("--MX-- getUserDefinedKnownSolution:ERROR: sub-directory `userDefinedKnownSolutionData' not found!\n");
    OV_ABORT("error");
  }
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  const aString & userKnownSolution = db.get<aString>("userKnownSolution");

  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");
  
  OV_GET_SERIAL_ARRAY(real,ua,uLocal);

  Index I1=I1a, I2=I2a, I3=I3a;
  bool ok = ParallelUtility::getLocalArrayBounds(ua,uLocal,I1,I2,I3,1);   
  if( !ok ) return 0;  // no points on this processor (NOTE: no communication should be done after this point)

  // -- we optimize for Cartesian grids (we can avoid creating the vertex array)
  const bool isRectangular=mg.isRectangular();
  if( !isRectangular )
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);
  OV_GET_SERIAL_ARRAY_CONDITIONAL(real,mg.center(),xLocal,!isRectangular );

  real dvx[3]={1.,1.,1.}, xab[2][3]={{0.,0.,0.},{0.,0.,0.}};
  int iv0[3]={0,0,0}; //
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];  // NOTE: iv[0]==i1, iv[1]==i2, iv[2]==i3
  real xv[3]={0.,0.,0.};
  if( isRectangular )
  {
    mg.getRectangularGridParameters( dvx, xab );
    for( int dir=0; dir<mg.numberOfDimensions(); dir++ )
    {
      iv0[dir]=mg.gridIndexRange(0,dir);
      if( mg.isAllCellCentered() )
        xab[0][dir]+=.5*dvx[dir];  // offset for cell centered
    }
  }
  // This macro defines the grid points for rectangular grids:
#undef XC
#define XC(iv,axis) (xab[0][axis]+dvx[axis]*(iv[axis]-iv0[axis]))

  
  if( userKnownSolution=="planeWave" )
  {

    assert( numberOfTimeDerivatives<=1 ); 

    const real amp = rpar[0];
    real kx  = rpar[1]*twoPi;
    real ky  = rpar[2]*twoPi;
    real kz  = rpar[3]*twoPi;

    real k;
    if( numberOfDimensions==2 )
      k = sqrt( kx*kx + ky*ky );
    else      
      k = sqrt( kx*kx + ky*ky +kz*kz );
      
    const real omega = c*k;
    
    real x,y,z;
    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
        }
        if( numberOfTimeDerivatives==0 )
          uLocal(i1,i2,i3,0) = amp*sin( kx*x+ky*y - omega*t );
        else
          uLocal(i1,i2,i3,0) = (-omega*amp)*cos( kx*x+ky*y - omega*t );
      }
    }
    else
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
          z= xLocal(i1,i2,i3,2);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
          z=XC(iv,2);
        }
        if( numberOfTimeDerivatives==0 )
          uLocal(i1,i2,i3,0) = amp*sin( kx*x+ky*y+kz*z - omega*t );
        else
          uLocal(i1,i2,i3,0) = (-omega*amp)*cos( kx*x+ky*y+kz*z - omega*t );

      }
    }
    
  }
  else if( userKnownSolution=="gaussianPlaneWave" )
  {
    // Gaussian plane wave (possibly modulated at frequency k0)
    //    u = exp( -beta*(xi^2) )*cos( k0*xi )
    //    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t 

    assert( numberOfTimeDerivatives<=1 );  

    // For now create the vertex array -- could avoid this
    mg.update( MappedGrid::THEvertex | MappedGrid::THEcenter );
    OV_GET_SERIAL_ARRAY(real,mg.vertex(),xLocal );

    const Real *kv    = db.get<real[3]>("kv");
    const Real *x0v   = db.get<real[3]>("x0v");
    const Real & beta = db.get<Real>("beta");
    const Real & k0   = db.get<Real>("k0");

    // Normalize (kx,ky,kz) to the unit vector (so we have a true solution)
    const Real kNorm = max( REAL_MIN*100., sqrt(SQR(kv[0]) + SQR(kv[1]) + SQR(kv[2])) );
    const Real kx=kv[0]/kNorm, ky=kv[1]/kNorm, kz=kv[2]/kNorm;

    if( true && t<= 2.*dt )
      printF("CgWave::userDefinedKS -- GaussianPlaneWave, t=%9.3e, (kx,ky,kz)=(%g,%g,%g), (x0,y0,z0)=(%g,%g,%g),"
             " k0=(%g)*2*pi, beta=%g, c=%g numberOfTimeDerivatives=%d\n",
           t,kv[0],kv[1],kv[2],x0v[0],x0v[1],x0v[2],k0,beta,c,numberOfTimeDerivatives);    

    RealArray xei(I1,I2,I3);
    if( numberOfDimensions==2 )
      xei = kx*(xLocal(I1,I2,I3,0)-x0v[0]) + ky*(xLocal(I1,I2,I3,1)-x0v[1]) -c*t;
    else
      xei = kx*(xLocal(I1,I2,I3,0)-x0v[0]) + ky*(xLocal(I1,I2,I3,1)-x0v[1]) + kz*(xLocal(I1,I2,I3,2)-x0v[2]) - c*t;
    if( k0 != 0. )
    {
      // modulated GPW:
      if( numberOfTimeDerivatives==0 )
      {
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) ) * cos( (twoPi*k0)*xei );
      }
      else
      { // one time derivative: 
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) ) * 
              ( cos( (twoPi*k0)*xei )* (2.*c*beta)*xei - sin((twoPi*k0)*xei )*( (-c*twoPi*k0) ) );
      }

    }
    else
    {
      if( numberOfTimeDerivatives==0 )
      { 
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) );
      }
      else
      { // one time derivative:
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) ) * (2.*c*beta)*xei;
      }
    }
  }

  else if( userKnownSolution=="modulatedGaussian" )
  {
    // Modulated Gaussian Initial Condition
    assert( numberOfTimeDerivatives<=1 ); 

    // For now create the vertex array -- could avoid this
    mg.update( MappedGrid::THEvertex | MappedGrid::THEcenter );
    OV_GET_SERIAL_ARRAY(real,mg.vertex(),xLocal );

    const Real *x0v   = db.get<real[3]>("x0v");
    const Real & beta = db.get<Real>("beta");
    const Real & k0   = db.get<Real>("k0");

    if( true && t<= 2.*dt )
      printF("--CgWave-- Modulated Gaussian Initial Condition, t=%9.3e, (x0,y0,z0)=(%g,%g,%g), k0=(%g)*2*pi,"
             " beta=%g, c=%g, numberOfTimeDerivatives=%d\n",
             t,x0v[0],x0v[1],x0v[2],k0,beta,c,numberOfTimeDerivatives);    

    if( numberOfTimeDerivatives==0 )
    {
      RealArray radSq(I1,I2,I3);
      if( numberOfDimensions==2 )
        radSq = SQR(xLocal(I1,I2,I3,0)-x0v[0]) + SQR(xLocal(I1,I2,I3,1)-x0v[1]);
      else
        radSq = SQR(xLocal(I1,I2,I3,0)-x0v[0]) + SQR(xLocal(I1,I2,I3,1)-x0v[1]) + SQR(xLocal(I1,I2,I3,2)-x0v[2]);
      if( k0 != 0. )
      {
        // modulated 
        uLocal(I1,I2,I3,0) = exp( -beta*radSq ) * cos( (twoPi*k0)*sqrt(radSq) );
      }
      else
      {
        uLocal(I1,I2,I3,0) = exp( -beta*radSq );
      }      
    }
    else
    {  // set first time derivative to zero 
       uLocal(I1,I2,I3,0) = 0.; // ut(0) = 0 
    }

  }

  else if( userKnownSolution=="boxHelmholtz" )
  {

    // printF(" I1=[%i,%i] I2=[%i,%i] I3=[%i,%i]\n",I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound());
    // printF(" uLocal=[%i,%i][%i,%i][%i,%i]\n",
    //     uLocal.getBase(0),uLocal.getBound(0),
    //     uLocal.getBase(1),uLocal.getBound(1),
    //     uLocal.getBase(2),uLocal.getBound(2));

    if( false )
      printF("userDefinedKnownSolution: eval boxHelmholtz: numberOfFrequencies=%d, t=%9.3e, numberOfTimeDerivatives=%d\n",
        numberOfFrequencies,t,numberOfTimeDerivatives);

    assert( numberOfTimeDerivatives<=1 ); 

    const real amp=1.;

    Real x,y,z;

    for( int freq=0; freq<numberOfFrequencies; freq++ )
    {
      // const real omega = rpar[0];
      // const Real omega = frequencyArray(freq);
      // // These next lines must match between userDefinedKnownSolution, userDefinedForcing and bcOptWave.bf90: 
      // const Real kx  = (rpar[1]+freq)*twoPi;
      // const Real ky  = (rpar[2]+freq)*twoPi;
      // const Real kz  = (rpar[3]+freq)*twoPi;

      Real omega,kx,ky,kz; 
      getBoxHelmholtzParameters( freq, omega, kx,ky,kz, C );

      if( false &&  t<= 2.*dt )
        printF("userDefinedKnownSolution: eval boxHelmholtz: freq=%d, omega=%g, kx=%g, ky=%g, kz=%g at t=%9.3e\n",
               freq,omega,kx,ky,kz,t);

      // const real coswt = cos(omega*t);
      Real coswt;
      if( numberOfTimeDerivatives==0 )
        coswt = cos(frequencyArray(freq)*t);
      else
        coswt = -frequencyArray(freq)*sin(frequencyArray(freq)*t);

      if( numberOfDimensions==2 )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          if( !isRectangular )
          {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
          }
          else
          {
            x=XC(iv,0);
            y=XC(iv,1);
          }
          uLocal(i1,i2,i3,freq) = amp*sin( kx*x )*sin( ky*y )*coswt;
        }
      }
      else
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          if( !isRectangular )
          {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
            z= xLocal(i1,i2,i3,2);
          }
          else
          {
            x=XC(iv,0);
            y=XC(iv,1);
            z=XC(iv,2);
          }
          uLocal(i1,i2,i3,freq) = amp*sin( kx*x )*sin( ky*y )*sin( kz*z )*coswt;

        }
      }
    }
  }
  else if( userKnownSolution=="computedHelmholtz" )
  {
    // known solution is determined from the computed Helmholtz solution


    assert( numberOfTimeDerivatives<=1 ); 

    if( !dbase.has_key("uHelmholtz") )
    {
      printF("CgWave:userDefinedKnownSolution: ERROR: uHelmholtz not found.\n");
      printF("This grid function is current computed in cgwh.C\n");
      // OV_ABORT("ERROR");
      uLocal(I1,I2,I2,0) = 0.; // do this for now 
    }
    else
    {
      printF("UDKS: evaluate computedHelmholtz solution at t=%9.3e\n",t);
      realCompositeGridFunction & uHelmholtz = dbase.get<realCompositeGridFunction>("uHelmholtz"); // holds Helmholtz solution from direct solver
  
      const real & omega  = dbase.get<real>("omega");
      // const real coswt = cos(omega*t);
      Real coswt;
      if( numberOfTimeDerivatives==0 )
        coswt = cos(omega*t);
      else
        coswt = -omega*sin(omega*t);      

      OV_GET_SERIAL_ARRAY(real,uHelmholtz[grid],uHelmholtzLocal);
  
      uLocal(I1,I2,I3,0) = uHelmholtzLocal(I1,I2,I3)*coswt;
    }

  }

  else if( userKnownSolution=="polyPeriodic" )
  {
    // ----------------- polynomial in space and periodic in time -----------------

    assert( numberOfTimeDerivatives <= 1 ); 

    const real & omega        = dbase.get<Real>("omegaPolyPeriodic");
    const int & degreeInSpace = dbase.get<int>("degreeInSpacePolyPeriodic");
    const real & a0           = dbase.get<Real>("a0PolyPeriodic");
    const real & a1           = dbase.get<Real>("a1PolyPeriodic");
    const real & b1           = dbase.get<Real>("b1PolyPeriodic");
    const real & c1           = dbase.get<Real>("c1PolyPeriodic");


    if( true || t<= 2.*dt )
      printF("userDefinedKnownSolution: eval polyPeriodic omega=%g, a0=%g, a1=%g, b1=%g, c1=%g at t=%9.3e\n",omega,a0,a1,b1,c1,t);

    // const real coswt = cos(omega*t);
    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else
      coswt = -omega*sin(omega*t);         
      
    real x,y,z;
    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
        }
        uLocal(i1,i2,i3,0) = ( a0 + a1*x + b1*y )*coswt;
      }
    }
    else
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
          z= xLocal(i1,i2,i3,2);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
          z=XC(iv,2);
        }
        uLocal(i1,i2,i3,0) = ( a0 + a1*x + b1*y + c1*z )*coswt;

      }
    }

  }

  else if( userKnownSolution=="diskEigenfunction" )
  {
    // --- Eigenfunction for the wave equation in a disk ---

    // --- we could avoid building the vertex array on Cartesian grids ---
    GET_VERTEX_ARRAY(x);

    const int n     = ipar[0];  // angular number, n=0,1,... --> Jn(omega*r)
    const int m     = ipar[1];  // radial number m=0,... 
    const int bcOpt = ipar[2];

    const Real a   = rpar[0];  // radius of disk
    const Real amp = rpar[1];  // amplitude 

    Real lambda; 
    if( bcOpt==0 )
    {
      // DIRICHLET BC (this next file came from mx/src)
      #include "src/besselZeros.h"    
      assert( m<mdbz && n<ndbz );
      const Real jzmn = besselZeros[n][m];  // m'th zero of Jn
      lambda=jzmn/a;
    }
    else
    {
      // Neumann BC
      #include "src/besselPrimeZeros.h"    
      assert( m<mdbpz && n<ndbpz );
      const Real jzmn = besselPrimeZeros[n][m];  // m'th zero of Jn' (excluding r=0 for J0)
      lambda=jzmn/a;
    }
     

    if( t<=3.*dt )
      printF("Disk: Bessel function solution: a=%g, n=%i, m=%i, lambda=%e, bcOpt=%d \n",a,n,m,lambda,bcOpt);

    const Real omega = c*lambda;  
    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else
      coswt = -omega*sin(omega*t);       

    FOR_3D(i1,i2,i3,I1,I2,I3)
    { 
      const Real xd = x(i1,i2,i3,0), yd = x(i1,i2,i3,1);
      const Real theta = atan2(yd,xd);
      const Real r = sqrt( xd*xd + yd*yd );

      uLocal(i1,i2,i3,0) = jn(n,lambda*r)*cos(n*theta)*coswt;
    }

  }

  else if( userKnownSolution=="annulusEigenfunction" )
  {
    // --- Eigenfunction for the heat equation in an annulus ---

    // We can NOT check the boundaryCondition array since it may not be set yet !
   //  bool dirichlet = (mg.boundaryCondition(0,1)==AdParameters::dirichletBoundaryCondition &&
   //                    mg.boundaryCondition(1,1)==AdParameters::dirichletBoundaryCondition );
   //  bool neumann   = (mg.boundaryCondition(0,1)==AdParameters::neumannBoundaryCondition &&
   //                    mg.boundaryCondition(1,1)==AdParameters::neumannBoundaryCondition );

   // dirichlet=true;

   // assert( dirichlet || neumann );

    // --- we could avoid building the vertex array on Cartesian grids ---
    GET_VERTEX_ARRAY(x);

    const int n     = ipar[0];  // angular number, n=0,1,... --> Jn(lambda*r), Yn(lambda*r)
    const int m     = ipar[1];  // radial number m=0,... 
    const int bcOpt = ipar[2];

    const Real amp  = rpar[0];  // amplitude 

    Real lambda, cJ,cY;
    if( bcOpt==0 )
    {
      // Dirichlet boundary conditions:
      //     det(lambda) =  Jn(lambda*a)*Yn(lambda*b) - Jn(lambda*b)*Yn(lambda*a) = 0 
      // This solution assumes ra=.5 and rb=1 (set in the next file) 
      // This file came from ad/codes: 
      #include "src/annulusEigenvaluesHeatEquationDirichlet.h" 
      lambda = annulusEigs[n][m];  // m'th zero of the determinant condition)  
      assert( m<numRoot && n<numBesselOrder );
      // Here is the eignevctor [cJ,cY] 
      cJ = yn(n,lambda*ra);
      cY =-jn(n,lambda*ra);
    } 
    else 
    {
      // Neumann boundary conditions:
      //     det(lambda) =  Jn'(lambda*a)*Yn'(lambda*b) - Jn'(lambda*b)*Yn'(lambda*a) = 0 
      // This solution assumes ra=.5 and rb=1 (set in the next file)
      // This file came from ad/codes: 
      #include "src/annulusEigenvaluesHeatEquationNeumann.h"   
      lambda = annulusEigs[n][m];  // m'th zero of the detreminant condition)
      assert( m<numRoot && n<numBesselOrder );

      // Here is the eigenvector [cJ,cY] 
      // Use Jn'(z) = (n/z)Jn - J_{n+1}
      const Real z = lambda*ra;
      cJ = ( (n/z)*yn(n,z) - yn(n+1,z) );    //  Yn'(lambda*a)
      cY =-( (n/z)*jn(n,z) - jn(n+1,z) );    // -Jn'(lambda*a)
    }

    // scale eigenvector so solution is of size amp
    Real cNorm = sqrt( cJ*cJ + cY*cY );
    cJ *= amp/cNorm; 
    cY *= amp/cNorm;

    if( t<=3.*dt )
      printF("Annulus: Bessel function solution: amp=%g, n=%i, m=%i, lambda=%e, bcOpt=%d\n", amp,n,m,lambda,bcOpt);

    const Real omega = c*lambda;  
    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else
      coswt = -omega*sin(omega*t);       

    FOR_3D(i1,i2,i3,I1,I2,I3)
    { 
      const Real xd = x(i1,i2,i3,0), yd = x(i1,i2,i3,1);
      const Real theta = atan2(yd,xd);
      const Real r = sqrt( xd*xd + yd*yd );

      uLocal(i1,i2,i3,0) = ( cJ*jn(n,lambda*r) + cY*yn(n,lambda*r) )*cos(n*theta)*coswt;
    }

  }


  else
  {
    printF("getUserDefinedKnownSolution:ERROR: unknown value for userDefinedKnownSolution=%s\n",
           (const char*)userKnownSolution);
    OV_ABORT("ERROR");
  }
  
  return 0;
}


int CgWave::
updateUserDefinedKnownSolution()
// ==========================================================================================
/// \brief This function is called to set the user defined known solution.
/// 
// ==========================================================================================
{
  // Make  dbase.get<real >("a") sub-directory in the data-base to store variables used here
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
     dbase.put<DataBase>("userDefinedKnownSolutionData");
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  if( !db.has_key("userKnownSolution") )
  {
    db.put<aString>("userKnownSolution");
    db.get<aString>("userKnownSolution")="unknownSolution";
    
    // wave numbers (kx,ky,kz) for plane wave and Gaussian plane wave , will be scaled by 2*Pi
    real *kv = db.put<real[3]>("kv");
    kv[0]=1.;
    kv[1]=1.;
    kv[2]=1.;

    // Offset (x0,y0,z0) for Gaussian plane wave 
    real *x0v = db.put<real[3]>("x0v");
    x0v[0]=0.;
    x0v[1]=0.;
    x0v[2]=0.; 

    // Exponential factor "beta" for Gaussian plane wave 
    db.put<Real>("beta")=20.;

    // Modulation wave-number for Gaussian plane wave 
    db.put<Real>("k0")=0.;


    db.put<real[20]>("rpar");
    db.put<int[20]>("ipar");
  }
  real *kv    = db.get<real[3]>("kv");
  real *x0v   = db.get<real[3]>("x0v");
  Real & beta = db.get<Real>("beta");
  Real & k0   = db.get<Real>("k0");

  aString & userKnownSolution = db.get<aString>("userKnownSolution");
  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");


  // Build a dialog menu for changing parameters
  GUIState gui;
  DialogData & dialog=gui;

  dialog.setWindowTitle("Known Solutions");
  dialog.setExitCommand("exit", "exit");

  // -------- PUSH BUTTONS ---------
  aString pbLabels[] = {
                        "no known solution",
                        "plane wave",
                        "gaussian plane wave",
                        "box Helmholtz",
                        "poly periodic",
                        "computed Helmholtz",
                        "modulated Gaussian",
                        "disk eigenfunction",
                        "annulus eigenfunction",
                        "done",    
                        ""};
  int numRows=3;
  dialog.setPushButtons( pbLabels, pbLabels, numRows ); 

 // ----- Text boxes ------
  const int numberOfTextStrings=10;            // max number of text boxes 
  aString textCommands[numberOfTextStrings];
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];
  int nt=0; 
  textCommands[nt] = "wave numbers:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g, %g, %g (kx,ky,kz)",kv[0],kv[1],kv[2]);     nt++; 

  textCommands[nt] = "offset:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g, %g, %g (x0,y0,z0)",x0v[0],x0v[1],x0v[2]);  nt++;  

  textCommands[nt] = "beta:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g",beta);                                    nt++; 

  textCommands[nt] = "k0:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g",k0);                                      nt++; 
 
   // null strings terminal list
  textCommands[nt]="";   textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
  dialog.setTextBoxes(textCommands, textLabels, textStrings);

  // const aString menu[]=
  //   {
  //     "no known solution",
  //     "plane wave",
  //     "box helmholtz",
  //     "done",
  //     ""
  //   }; 

  gi.pushGUI(gui);

  gi.appendToTheDefaultPrompt("userDefinedKnownSolution>");
  aString answer;
  int len;
  for( ;; ) 
  {

    // int response=gi.getMenuItem(menu,answer,"Choose a known solution");
    
    gi.getAnswer(answer,""); 

    if( answer=="done" || answer=="exit" )
    {
      break;
    }
    else if( answer=="no known solution" )
    {
      userKnownSolution="unknownSolution";
    }
    else if( answer=="plane wave" ) 
    {
      userKnownSolution="planeWave";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      gi.inputString(answer,"Enter amp,kx,ky,kz");
      sScanF(answer,"%e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3]);
      printF(" Setting amp=%g, [kx,ky,kz]=[%g,%g,%g]\n",rpar[0],rpar[1],rpar[2],rpar[3]);



      // Save parameters in dbase so we can look them up in bcOptWave
      const Real amp=rpar[0], kx=rpar[1]*twoPi, ky=rpar[2]*twoPi, kz=rpar[3]*twoPi; 
      const Real & c= dbase.get<real>("c");
      real k;
      if( cg.numberOfDimensions()==2 )
        k = sqrt( kx*kx + ky*ky );
      else      
        k = sqrt( kx*kx + ky*ky +kz*kz );
      const real omega = c*k;      

      dbase.put<Real>("ampPlaneWave")   = amp;
      dbase.put<Real>("kxPlaneWave")    = kx;
      dbase.put<Real>("kyPlaneWave")    = ky;
      dbase.put<Real>("kzPlaneWave")    = kz;
      dbase.put<Real>("omegaPlaneWave") = omega;

      
    }
    else if( answer=="gaussian plane wave")
    {
      printF("--- Gaussian plane wave (possibly modulated at frequency k0)--- \n"
             "    u(x,y,z,t) = exp( -beta*(xi^2) )*cos( k0*xi ) \n"
             " where \n"
             "    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t \n"
             "    k0 : most energy will be at this wave-number. \n"
             "    (kx,ky,kz) will be normalized to a unit vector. \n"
             " Set parameters (kx,ky,kz) (x0,y0,z0), beta and k0 in the text boxes.\n");

      userKnownSolution="gaussianPlaneWave";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time

      // Save parameters in dbase so we can look them up in bcOptWave
      // These are updated below (in case the user has changed kx,ky,kz, etc.)
      if( !dbase.has_key("kxGPW") )
      {
        const Real kNorm  = max( REAL_MIN*1000., sqrt( SQR(kv[0]) + SQR(kv[1]) + SQR(kv[2] ) ) ); 
        dbase.put<Real>("kxGPW")   = kv[0]/kNorm;
        dbase.put<Real>("kyGPW")   = kv[1]/kNorm;
        dbase.put<Real>("kzGPW")   = kv[2]/kNorm; 
    
        dbase.put<Real>("x0GPW")   = x0v[0];
        dbase.put<Real>("y0GPW")   = x0v[1];
        dbase.put<Real>("z0GPW")   = x0v[2];
  
        dbase.put<Real>("betaGPW") = beta;
        dbase.put<Real>("k0GPW")   = k0;
      }

    }
    else if( answer=="box Helmholtz" ) 
    {
      printF("----------------- box helmholtz -----------------\n"
             " Define a time-periodic solution for a square or box that depends on a forcing term.\n");
      printF("   We solve :   utt = c^2 * Delta(u) - f(x)*cos(omega*t) \n");
      printF("                u=0 on the boundary                    ) \n");
      printF("The solution is of the form: cos(omega*t)*sin(kx*2*pi*x)*sin(ky*2*pi*y)\n");
      
      userKnownSolution="boxHelmholtz";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      gi.inputString(answer,"Enter omega,kx,ky,kz");
      sScanF(answer,"%e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3]);
      printF(" Setting omega=%g, [kx,ky,kz]=[%g,%g,%g]\n",rpar[0],rpar[1],rpar[2],rpar[3]);

      Real & omega = dbase.get<real>("omega");
      omega = rpar[0]; // define the Helmholtz omega for advance 

      // do this for now: 
      const RealArray & frequencyArray  = dbase.get<RealArray>("frequencyArray");
      frequencyArray(0) = omega;

      // Save parameters in dbase so we can look them up in bcOptWave
      const Real kx=rpar[1]*twoPi, ky=rpar[2]*twoPi, kz=rpar[3]*twoPi; 
      dbase.put<Real>("omegaBoxHelmholtz") = omega;
      dbase.put<Real>("kxBoxHelmholtz")    = kx;
      dbase.put<Real>("kyBoxHelmholtz")    = ky;
      dbase.put<Real>("kzBoxHelmholtz")    = kz;
      
    }
    else if( answer=="poly periodic" ) 
    {
      printF("----------------- polynomial in space and periodic in time -----------------\n");
      printF("   We solve :   utt = c^2 * Delta(u) - f(x)*cos(omega*t) \n");
      printF("The solution is of the form: (a0 + a1*x + a2*x^2 + ... b1*y + b2*y^2 + ... + c1*z + c2*z^2 + ...)*cos(omega*t)\n");
      
      userKnownSolution="polyPeriodic";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time

      // Save parameters in dbase so we can look them up in bcOptWave
      real & omega        = dbase.put<Real>("omegaPolyPeriodic");
      int & degreeInSpace = dbase.put<int>("degreeInSpacePolyPeriodic");
      real & a0           = dbase.put<Real>("a0PolyPeriodic");
      real & a1           = dbase.put<Real>("a1PolyPeriodic");
      real & b1           = dbase.put<Real>("b1PolyPeriodic");
      real & c1           = dbase.put<Real>("c1PolyPeriodic");

      omega=1.; degreeInSpace=1; 
      a0=1.; a1=1.; b1=1.; c1=1.;

      gi.inputString(answer,"Enter omega,degreeInSpace");
      sScanF(answer,"%e %i",&omega,&degreeInSpace);
      printF(" Setting omega=%g, degreeInSpace=%d\n",omega,degreeInSpace);

      if( degreeInSpace==0 )
      {
        a1=0.; b1=0; c1=0; 
      }


    }
    else if( answer=="computed Helmholtz" )
    {
      printF("Known solution will be found from the discrete solution to the Helmholtz problem.\n");
      printF("     u(x,t) = uHelmholtz(x) * cos(omega*t) \n");
      printF("NOTE: uHelmholtz(x) is current computed by cgwh.\n");

      userKnownSolution="computedHelmholtz";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time

      // --- do this for now : only works with boxHelmholtz solution 
      gi.inputString(answer,"Enter omega,kx,ky,kz");
      sScanF(answer,"%e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3]);
      printF(" Setting omega=%g, [kx,ky,kz]=[%g,%g,%g]\n",rpar[0],rpar[1],rpar[2],rpar[3]);

      dbase.get<real>("omega") = rpar[0]; // define the Helmholtz omega for advance 

      // Save parameters in dbase so we can look them up in bcOptWave
      const Real omega=rpar[0], kx=rpar[1]*twoPi, ky=rpar[2]*twoPi, kz=rpar[3]*twoPi; 
      dbase.put<Real>("omegaBoxHelmholtz") = omega;
      dbase.put<Real>("kxBoxHelmholtz")    = kx;
      dbase.put<Real>("kyBoxHelmholtz")    = ky;
      dbase.put<Real>("kzBoxHelmholtz")    = kz;

    }
    else if( answer=="modulated Gaussian")
    {
      printF("--- Modulated Gaussian Initial Condition --- \n"
             "    u(x,y,z,t) = exp( -beta*( r^2 ) )*cos( 2*pi*k0*r ) \n"
             " where \n"
             "    r = sqrt( (x-x0)^2 + (y-y0)^2 + (z-z0)^2 ) \n"
             "    k0 : most energy will be at this wave-number. \n"
             "    (kx,ky,kz) will be normalized to a unit vector. \n"
             " Set parameters (x0,y0,z0), beta and k0 in the text boxes.\n");

      userKnownSolution="modulatedGaussian";
      dbase.get<bool>("knownSolutionIsTimeDependent")=false;  // this is not a known solution

      // Save parameters in dbase so we can look them up in bcOptWave
      // These are updated below (in case the user has changed x0,y0,z0, etc.)
      if( !dbase.has_key("kxGPW") )
      {
        dbase.put<Real>("x0GPW")   = x0v[0];
        dbase.put<Real>("y0GPW")   = x0v[1];
        dbase.put<Real>("z0GPW")   = x0v[2];
  
        dbase.put<Real>("betaGPW") = beta;
        dbase.put<Real>("k0GPW")   = k0;
      }

    }
    else if( answer=="disk eigenfunction" )
    {
      userKnownSolution="diskEigenfunction";

      int & n     = ipar[0];
      int & m     = ipar[1];
      int & bcOpt = ipar[2];      

      Real & a   = rpar[0];
      Real & amp = rpar[1];

      m=0; n=0; amp=1.; a=1.;
      
      printF("--- Eigenfunction for the Wave Equation in the unit disk ---\n"
             "    u = cos( c*lambda_{m,n} *t ) * Jn(lambda_m*r) * cos(n*theta)  [2D, Dirichlet BCs]\n"
             "    n = angular number, n=0,1,2,\n"
             "    m = radial number (m'th zero of Bessel Jn(lambda*a)=0 \n"
             "    a = radius of the disk\n"
             "    amp = amplitude\n"
             "    bcOpt : 0=Dirichlet, 1=Neumann BCs on the annulus.\n"             
        );
      
      gi.inputString(answer,"Enter n,m,a,amp,bcOpt for the exact solution");
      sScanF(answer,"%i %i %e %e %i",&n,&m,&a,&amp,&bcOpt);

      printF("Disk eigenfuncton: n=%i, m=%i, a=%g, amp=%g, bcOpt=%d\n",n,m,a,amp,bcOpt);

      dbase.get<bool>("knownSolutionIsTimeDependent")= true;  // known solution is time dependent

    }  

    else if( answer=="annulus eigenfunction" )
    {
      userKnownSolution="annulusEigenfunction";

      int & n     = ipar[0];
      int & m     = ipar[1];
      int & bcOpt = ipar[2];

      Real & amp = rpar[0];

      m=0; n=0; amp=1.; bcOpt=0;
      
      printF("--- Eigenfunction for the Wave Equation in an annulus---\n"
             "    u = cos( c*lambda_{m,n} *t ) * uHat(r) * cos(n*theta),\n"
             "    uHat(r) = c1*Jn(lambda*r) + c2*Yn(lambda*r),\n"
             "    Annulus: ra=.5, rb=1.\n"
             "    n = angular number, n=0,1,2,\n"
             "    m = radial number (m'th zero of determinant condition). \n"
             "    amp = amplitude.\n"
             "    bcOpt : 0=Dirichlet, 1=Neumann BCs on the annulus.\n"
        );
      
      gi.inputString(answer,"Enter n,m,amp,bcOpt for the exact solution");
      sScanF(answer,"%i %i %e %i",&n,&m,&amp,&bcOpt);

      printF("Annulus eigenfuncton: n=%i, m=%i, amp=%g, bcOpt=%d\n",n,m,amp,bcOpt);

      dbase.get<bool>("knownSolutionIsTimeDependent")= true;  // known solution is time dependent

    } 


    else if( dialog.getTextValue(answer,"beta:","%e",beta) )
    {
      printF("UDKS: Setting beta=%g (exponential factor in Gaussian plane wave)\n",beta);
    }
    else if( dialog.getTextValue(answer,"k0:","%e",k0) )
    {
      printF("UDKS: Setting k0=%g : modulation wave-number in Gaussian plane wave, will be scaled by 2*pi.\n",k0);
    }

    else if( len=answer.matches("wave numbers:") )
    {
      sScanF(answer(len,answer.length()-1),"%e %e %e",&kv[0],&kv[1],&kv[2]);
      printF("UDKS: Setting wave numbers: kx=%g, ky=%g, kz=%g (may be normalized or scaled by 2*pi)\n",kv[0],kv[1],kv[2]);
    }
    else if( len=answer.matches("offset:") )
    {
      sScanF(answer(len,answer.length()-1),"%e %e %e",&x0v[0],&x0v[1],&x0v[2]);
      printF("UDKS: Setting offset (x0,y0,z0)=(%g,%g,%g) (for Gaussian plane-wave)\n",x0v[0],x0v[1],x0v[2]);
    }


    else
    {
      printF("unknown response=[%s]\n",(const char*)answer);
      gi.stopReadingCommandFile();
    }
    
  }
  if( userKnownSolution == "gaussianPlaneWave" )
  {
    // Save parameters in dbase so we can look them up in bcOptWave
    const Real kNorm  = max( REAL_MIN*1000., sqrt( SQR(kv[0]) + SQR(kv[1]) + SQR(kv[2] ) ) ); 
    dbase.get<Real>("kxGPW")   = kv[0]/kNorm;
    dbase.get<Real>("kyGPW")   = kv[1]/kNorm;
    dbase.get<Real>("kzGPW")   = kv[2]/kNorm; 
    dbase.get<Real>("x0GPW")   = x0v[0];
    dbase.get<Real>("y0GPW")   = x0v[1];
    dbase.get<Real>("z0GPW")   = x0v[2];
    dbase.get<Real>("betaGPW") = beta;
    dbase.get<Real>("k0GPW")   = k0;

  }
  gi.unAppendTheDefaultPrompt();

  gi.popGUI();  // pop dialog

  bool knownSolutionChosen = userKnownSolution!="unknownSolution";
  return knownSolutionChosen;
}


