#include "CgWave.h"
#include "GenericGraphicsInterface.h"
#include "ParallelUtility.h"
// #include <cmath>

#Include "knownSolutionMacros.h"

#define rjbesl EXTERN_C_NAME(rjbesl)
extern "C"
{
  void rjbesl( const real & ka, const real & alpha, const int & nb, real & jnka, int & ncalc);
}


#define FOR_3D(i1,i2,i3,I1,I2,I3)                                       \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase(); \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++)                                       \
  for(i2=I2Base; i2<=I2Bound; i2++)                                     \
    for(i1=I1Base; i1<=I1Bound; i1++)

typedef ::real LocalReal;

// --------------------------------------------------------------------
// Macro to evaluate the spherical Bessel function near the origin
// Input: nn,x
// Output : R 
// -------------------------------------------------------------------
#beginMacro evalSphericalBesselTaylor( nn,x, R )
  if( nn == 0 )
  {
    R = 1.0 - (1.0/6.0)*(x*x) + (1.0/120.0)*(x*x*x*x);
  }
  else if( nn == 1 )
  {
    R = (1.0/3.0)*x - (1.0/30.0)*(x*x*x) + (1.0/840.0)*(x*x*x*x*x);
  }
  else if( nn == 2 )
  {
    R = (1.0/15.0)*(x*x) - (1.0/210.0)*(x*x*x*x);
  }
  else if( nn == 3 )
  {
    R = (1.0/105.0)*(x*x*x) - (1.0/1890.0)*(x*x*x*x*x);
  }
  else
  {
    printF("sphericalBesselFunctions ERROR: nn > 4 is not defined\n");
    OV_ABORT("ERROR");
  }
#endMacro

// --------------------------------------------------------------------
// Macro to evaluate the associated Legendre function
//  n = mPhi   : degree
//  k = mTheta : order 
// -------------------------------------------------------------------
#beginMacro evalAssociatedLegendreFunction( mPhi, mTheta,  x, Pnk )
  if( mPhi == 1 && mTheta == 0 )
  {
    Pnk = x;
  }
  else if( mPhi == 2 && mTheta == 0 )
  {
    Pnk = (3.0*x*x - 1.0)/2.0;
  }
  else if( mPhi == 2 && mTheta == 1 )
  {
    Pnk = 3.0*x*sqrt(1 - x*x);
  }
  else if( mPhi == 3 && mTheta == 0 )
  {
    Pnk = (5.0*x*x*x - 3.0*x)/2.0;
  }
  else if( mPhi == 3 && mTheta == 1 )
  {
    Pnk = sqrt(1 - x*x)*(15.0*x*x-3)/2.0;
  }
  else if( mPhi == 3 && mTheta == 2 )
  {
    Pnk = 15.0*x*(1.0-x*x);
  }
  else
  {
    printF("associatedLegendreFunctions ERROR: mPhi=%d, mTheta=%d no supported.\n",mPhi,mTheta);
    OV_ABORT("ERROR");
  }
#endMacro


// Macro to get the vertex array
#define GET_VERTEX_ARRAY(x)                                     \
mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);       \
OV_GET_SERIAL_ARRAY_CONST(real,mg.vertex(),x);       

// ==========================================================================================
/// \brief  Evaluate a user defined known solution.
///
/// \param t (input) : time to eval solution
/// \param grid (input) : grid number
/// \param ua (output) : save solution here
/// \param I1a,I2a,I3a (input) : eval solution at these points
/// \param numberOfTimeDerivatives (input) : evaluate this many time-derivatives of the solution.
///     Normally  numberOfTimeDerivatives=0, but it can be 1 when the known solution is used
//      to define boundary conditions 
// ==========================================================================================
int CgWave::
getUserDefinedKnownSolution(real t,  int grid, 
                            realArray & ua, const Index & I1a, const Index &I2a, const Index &I3a, 
                            int numberOfTimeDerivatives /* = 0 */ )
{
  Real cpu0 = getCPU();

  const real & c= dbase.get<real>("c");
  const real & dt= dbase.get<real>("dt");

  const int & numberOfFrequencies   = dbase.get<int>("numberOfFrequencies");
  const RealArray & frequencyArray  = dbase.get<RealArray>("frequencyArray");

  if( false && t<= 2.*dt )
    printF("--CgWave-- getUserDefinedKnownSolution at t=%9.3e \n",t);

  MappedGrid & mg = cg[grid];
  const int numberOfDimensions = cg.numberOfDimensions();

  
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
  {
    printF("--MX-- getUserDefinedKnownSolution:ERROR: sub-directory `userDefinedKnownSolutionData' not found!\n");
    OV_ABORT("error");
  }
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  const aString & userKnownSolution = db.get<aString>("userKnownSolution");

  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");
  
  OV_GET_SERIAL_ARRAY(real,ua,uLocal);

  Index I1=I1a, I2=I2a, I3=I3a;
  bool ok = ParallelUtility::getLocalArrayBounds(ua,uLocal,I1,I2,I3,1);   
  if( !ok ) return 0;  // no points on this processor (NOTE: no communication should be done after this point)

  // -- we optimize for Cartesian grids (we can avoid creating the vertex array)
  const bool isRectangular=mg.isRectangular();
  if( !isRectangular )
    mg.update(MappedGrid::THEvertex | MappedGrid::THEcenter);
  OV_GET_SERIAL_ARRAY_CONDITIONAL(real,mg.center(),xLocal,!isRectangular );

  real dvx[3]={1.,1.,1.}, xab[2][3]={{0.,0.,0.},{0.,0.,0.}};
  int iv0[3]={0,0,0}; //
  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];  // NOTE: iv[0]==i1, iv[1]==i2, iv[2]==i3
  real xv[3]={0.,0.,0.};
  if( isRectangular )
  {
    mg.getRectangularGridParameters( dvx, xab );
    for( int dir=0; dir<mg.numberOfDimensions(); dir++ )
    {
      iv0[dir]=mg.gridIndexRange(0,dir);
      if( mg.isAllCellCentered() )
        xab[0][dir]+=.5*dvx[dir];  // offset for cell centered
    }
  }
  // This macro defines the grid points for rectangular grids:
#undef XC
#define XC(iv,axis) (xab[0][axis]+dvx[axis]*(iv[axis]-iv0[axis]))

  
  if( userKnownSolution=="planeWave" )
  {

    assert( numberOfTimeDerivatives<=1 ); 

    const real amp = rpar[0];
    real kx  = rpar[1]*twoPi;
    real ky  = rpar[2]*twoPi;
    real kz  = rpar[3]*twoPi;

    real k;
    if( numberOfDimensions==2 )
      k = sqrt( kx*kx + ky*ky );
    else      
      k = sqrt( kx*kx + ky*ky +kz*kz );
      
    const real omega = c*k;
    
    real x,y,z;
    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
        }
        if( numberOfTimeDerivatives==0 )
          uLocal(i1,i2,i3,0) = amp*sin( kx*x+ky*y - omega*t );
        else
          uLocal(i1,i2,i3,0) = (-omega*amp)*cos( kx*x+ky*y - omega*t );
      }
    }
    else
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
          z= xLocal(i1,i2,i3,2);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
          z=XC(iv,2);
        }
        if( numberOfTimeDerivatives==0 )
          uLocal(i1,i2,i3,0) = amp*sin( kx*x+ky*y+kz*z - omega*t );
        else
          uLocal(i1,i2,i3,0) = (-omega*amp)*cos( kx*x+ky*y+kz*z - omega*t );

      }
    }
    
  }
  else if( userKnownSolution=="gaussianPlaneWave" )
  {
    // Gaussian plane wave (possibly modulated at frequency k0)
    //    u = exp( -beta*(xi^2) )*cos( k0*xi )
    //    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t 

    assert( numberOfTimeDerivatives<=1 );  

    // For now create the vertex array -- could avoid this
    mg.update( MappedGrid::THEvertex | MappedGrid::THEcenter );
    OV_GET_SERIAL_ARRAY(real,mg.vertex(),xLocal );

    const Real *kv    = db.get<real[3]>("kv");
    const Real *x0v   = db.get<real[3]>("x0v");
    const Real & beta = db.get<Real>("beta");
    const Real & k0   = db.get<Real>("k0");

    // Normalize (kx,ky,kz) to the unit vector (so we have a true solution)
    const Real kNorm = max( REAL_MIN*100., sqrt(SQR(kv[0]) + SQR(kv[1]) + SQR(kv[2])) );
    const Real kx=kv[0]/kNorm, ky=kv[1]/kNorm, kz=kv[2]/kNorm;

    if( true && t<= 2.*dt && grid<5 )
      printF("CgWave::userDefinedKS -- GaussianPlaneWave, grid=%d, t=%9.3e, (kx,ky,kz)=(%g,%g,%g), (x0,y0,z0)=(%g,%g,%g),"
             " k0=(%g)*2*pi, beta=%g, c=%g numberOfTimeDerivatives=%d\n",
           grid,t,kv[0],kv[1],kv[2],x0v[0],x0v[1],x0v[2],k0,beta,c,numberOfTimeDerivatives);    

    RealArray xei(I1,I2,I3);
    if( numberOfDimensions==2 )
      xei = kx*(xLocal(I1,I2,I3,0)-x0v[0]) + ky*(xLocal(I1,I2,I3,1)-x0v[1]) -c*t;
    else
      xei = kx*(xLocal(I1,I2,I3,0)-x0v[0]) + ky*(xLocal(I1,I2,I3,1)-x0v[1]) + kz*(xLocal(I1,I2,I3,2)-x0v[2]) - c*t;
    if( k0 != 0. )
    {
      // modulated GPW:
      if( numberOfTimeDerivatives==0 )
      {
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) ) * cos( (twoPi*k0)*xei );
      }
      else
      { // one time derivative: 
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) ) * 
              ( cos( (twoPi*k0)*xei )* (2.*c*beta)*xei - sin((twoPi*k0)*xei )*( (-c*twoPi*k0) ) );
      }

    }
    else
    {
      if( numberOfTimeDerivatives==0 )
      { 
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) );
      }
      else
      { // one time derivative:
        uLocal(I1,I2,I3,0) = exp( -beta*((xei)*(xei)) ) * (2.*c*beta)*xei;
      }
    }
  }

  else if( userKnownSolution=="modulatedGaussian" )
  {
    // Modulated Gaussian Initial Condition
    assert( numberOfTimeDerivatives<=1 ); 

    // For now create the vertex array -- could avoid this
    mg.update( MappedGrid::THEvertex | MappedGrid::THEcenter );
    OV_GET_SERIAL_ARRAY(real,mg.vertex(),xLocal );

    const Real *x0v   = db.get<real[3]>("x0v");
    const Real & beta = db.get<Real>("beta");
    const Real & k0   = db.get<Real>("k0");

    if( true && t<= 2.*dt )
      printF("--CgWave-- Modulated Gaussian Initial Condition, t=%9.3e, (x0,y0,z0)=(%g,%g,%g), k0=(%g)*2*pi,"
             " beta=%g, c=%g, numberOfTimeDerivatives=%d\n",
             t,x0v[0],x0v[1],x0v[2],k0,beta,c,numberOfTimeDerivatives);    

    if( numberOfTimeDerivatives==0 )
    {
      RealArray radSq(I1,I2,I3);
      if( numberOfDimensions==2 )
        radSq = SQR(xLocal(I1,I2,I3,0)-x0v[0]) + SQR(xLocal(I1,I2,I3,1)-x0v[1]);
      else
        radSq = SQR(xLocal(I1,I2,I3,0)-x0v[0]) + SQR(xLocal(I1,I2,I3,1)-x0v[1]) + SQR(xLocal(I1,I2,I3,2)-x0v[2]);
      if( k0 != 0. )
      {
        // modulated 
        uLocal(I1,I2,I3,0) = exp( -beta*radSq ) * cos( (twoPi*k0)*sqrt(radSq) );
      }
      else
      {
        uLocal(I1,I2,I3,0) = exp( -beta*radSq );
      }      
    }
    else
    {  // set first time derivative to zero 
       uLocal(I1,I2,I3,0) = 0.; // ut(0) = 0 
    }

  }

  else if( userKnownSolution=="boxHelmholtz" )
  {

    // printF(" I1=[%i,%i] I2=[%i,%i] I3=[%i,%i]\n",I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound());
    // printF(" uLocal=[%i,%i][%i,%i][%i,%i]\n",
    //     uLocal.getBase(0),uLocal.getBound(0),
    //     uLocal.getBase(1),uLocal.getBound(1),
    //     uLocal.getBase(2),uLocal.getBound(2));

    if( false )
      printF("userDefinedKnownSolution: eval boxHelmholtz: numberOfFrequencies=%d, t=%9.3e, numberOfTimeDerivatives=%d\n",
        numberOfFrequencies,t,numberOfTimeDerivatives);

    assert( numberOfTimeDerivatives<=1 ); 

    const real amp=1.;

    Real x,y,z;

    for( int freq=0; freq<numberOfFrequencies; freq++ )
    {
      // const real omega = rpar[0];
      // const Real omega = frequencyArray(freq);
      // // These next lines must match between userDefinedKnownSolution, userDefinedForcing and bcOptWave.bf90: 
      // const Real kx  = (rpar[1]+freq)*twoPi;
      // const Real ky  = (rpar[2]+freq)*twoPi;
      // const Real kz  = (rpar[3]+freq)*twoPi;

      Real omega,kx,ky,kz; 
      getBoxHelmholtzParameters( freq, omega, kx,ky,kz, C );

      if( false &&  t<= 2.*dt )
        printF("userDefinedKnownSolution: eval boxHelmholtz: freq=%d, omega=%g, kx=%g, ky=%g, kz=%g at t=%9.3e\n",
               freq,omega,kx,ky,kz,t);

      // const real coswt = cos(omega*t);
      Real coswt;
      if( numberOfTimeDerivatives==0 )
        coswt = cos(frequencyArray(freq)*t);
      else
        coswt = -frequencyArray(freq)*sin(frequencyArray(freq)*t);

      if( numberOfDimensions==2 )
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          if( !isRectangular )
          {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
          }
          else
          {
            x=XC(iv,0);
            y=XC(iv,1);
          }
          uLocal(i1,i2,i3,freq) = amp*sin( kx*x )*sin( ky*y )*coswt;
        }
      }
      else
      {
        FOR_3D(i1,i2,i3,I1,I2,I3)
        {
          if( !isRectangular )
          {
            x= xLocal(i1,i2,i3,0);
            y= xLocal(i1,i2,i3,1);
            z= xLocal(i1,i2,i3,2);
          }
          else
          {
            x=XC(iv,0);
            y=XC(iv,1);
            z=XC(iv,2);
          }
          uLocal(i1,i2,i3,freq) = amp*sin( kx*x )*sin( ky*y )*sin( kz*z )*coswt;

        }
      }
    }
  }
  else if( userKnownSolution=="computedHelmholtz" )
  {
    // known solution is determined from the computed Helmholtz solution


    assert( numberOfTimeDerivatives<=1 ); 

    if( !dbase.has_key("uHelmholtz") )
    {
      printF("CgWave:userDefinedKnownSolution: ERROR: uHelmholtz not found.\n");
      printF("This grid function is current computed in cgwh.C\n");
      // OV_ABORT("ERROR");
      uLocal(I1,I2,I2,0) = 0.; // do this for now 
    }
    else
    {
      printF("UDKS: evaluate computedHelmholtz solution at t=%9.3e\n",t);
      realCompositeGridFunction & uHelmholtz = dbase.get<realCompositeGridFunction>("uHelmholtz"); // holds Helmholtz solution from direct solver
  
      const real & omega  = dbase.get<real>("omega");
      // const real coswt = cos(omega*t);
      Real coswt;
      if( numberOfTimeDerivatives==0 )
        coswt = cos(omega*t);
      else
        coswt = -omega*sin(omega*t);      

      OV_GET_SERIAL_ARRAY(real,uHelmholtz[grid],uHelmholtzLocal);
  
      uLocal(I1,I2,I3,0) = uHelmholtzLocal(I1,I2,I3)*coswt;
    }

  }

  else if( userKnownSolution=="polyPeriodic" )
  {
    // ----------------- polynomial in space and periodic in time -----------------

    assert( numberOfTimeDerivatives <= 1 ); 

    const real & omega        = dbase.get<Real>("omegaPolyPeriodic");
    const int & degreeInSpace = dbase.get<int>("degreeInSpacePolyPeriodic");
    const real & a0           = dbase.get<Real>("a0PolyPeriodic");
    const real & a1           = dbase.get<Real>("a1PolyPeriodic");
    const real & b1           = dbase.get<Real>("b1PolyPeriodic");
    const real & c1           = dbase.get<Real>("c1PolyPeriodic");


    if( true || t<= 2.*dt )
      printF("userDefinedKnownSolution: eval polyPeriodic omega=%g, a0=%g, a1=%g, b1=%g, c1=%g at t=%9.3e\n",omega,a0,a1,b1,c1,t);

    // const real coswt = cos(omega*t);
    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else
      coswt = -omega*sin(omega*t);         
      
    real x,y,z;
    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
        }
        uLocal(i1,i2,i3,0) = ( a0 + a1*x + b1*y )*coswt;
      }
    }
    else
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
          z= xLocal(i1,i2,i3,2);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
          z=XC(iv,2);
        }
        uLocal(i1,i2,i3,0) = ( a0 + a1*x + b1*y + c1*z )*coswt;

      }
    }

  }

  else if( userKnownSolution=="squareEigenfunction" )
  {
    const int bcOpt = ipar[0]; 
    const Real kx   = rpar[0]*twoPi;
    const Real ky   = rpar[1]*twoPi;
    const Real kz   = rpar[2]*twoPi;

    Real omega;
    if( numberOfDimensions==2 )
      omega = c*sqrt( kx*kx + ky*ky );
    else      
      omega = c*sqrt( kx*kx + ky*ky +kz*kz );

    if( t<=2*dt )
    {
      printf("Eval square eigenfuction: t=%12.3e, [kx,ky,kz]=[%g,%g,%g], bcOpt=%d\n",t,rpar[0],rpar[1],rpar[2],bcOpt);
    }

    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else if( numberOfTimeDerivatives==1 )
      coswt = -omega*sin(omega*t);
    else
    {
      OV_ABORT("UDKS: numberOfTimeDerivatives");
    }      
    real x,y,z;
    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
        }
        if( bcOpt==0 )
          uLocal(i1,i2,i3,0) = sin( kx*x )*sin( ky*y )*coswt;
        else
          uLocal(i1,i2,i3,0) = cos( kx*x )*cos( ky*y )*coswt;  

      }
    }
    else
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        if( !isRectangular )
        {
          x= xLocal(i1,i2,i3,0);
          y= xLocal(i1,i2,i3,1);
          z= xLocal(i1,i2,i3,2);
        }
        else
        {
          x=XC(iv,0);
          y=XC(iv,1);
          z=XC(iv,2);
        }
        if( bcOpt==0 )
          uLocal(i1,i2,i3,0) = sin( kx*x )*sin( ky*y )*sin( kz*z )*coswt;
        else        
          uLocal(i1,i2,i3,0) = cos( kx*x )*cos( ky*y )*cos( kz*z )*coswt;        


      }
    }
    
  }

  else if( userKnownSolution=="diskEigenfunction" )
  {
    // --- Eigenfunction for the wave equation in a disk or 3D cylinder  ---

    // --- we could avoid building the vertex array on Cartesian grids ---
    GET_VERTEX_ARRAY(x);

    const int n      = ipar[0];  // angular number, n=0,1,... --> Jn(omega*r)
    const int m      = ipar[1];  // radial number m=0,... 
    const int bcOpt  = ipar[2];
    const int & mz   = ipar[3];  // axial number 

    const Real a     = rpar[0];  // radius of disk
    const Real amp   = rpar[1];  // amplitude 
    const Real & za  = rpar[2];
    const Real & zb  = rpar[3];

    Real lambda; 
    if( bcOpt==0 )
    {
      // DIRICHLET BC (this next file came from mx/src)
      #include "src/besselZeros.h"    
      assert( m<mdbz && n<ndbz );
      const Real jzmn = besselZeros[n][m];  // m'th zero of Jn
      lambda=jzmn/a;
    }
    else
    {
      // Neumann BC
      // #include "src/besselPrimeZeros.h"    
      // Next file from Allison Carson:
      #include "src/besselPrimeZeros99.h"    
      assert( m<mdbpz && n<ndbpz );
      const Real jzmn = besselPrimeZeros[n][m];  // m'th zero of Jn' (excluding r=0 for J0)
      lambda=jzmn/a;
    }
     
    if( t<=3.*dt )
      printF("Disk: Bessel function solution: a=%g, n=%i, m=%i, lambda=%16.8e, bcOpt=%d, mz=%d, za=%g, zb=%g \n",a,n,m,lambda,bcOpt,mz,za,zb);

    const Real Lz=zb-za;
    const Real kz = .5*twoPi*mz/Lz; 

    Real omega = c*lambda; 
    if( numberOfDimensions==3 )  
    {
      omega = c * sqrt( SQR(lambda) + SQR(kz) );  // ***check me**
    }

    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else
      coswt = -omega*sin(omega*t);       

    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,I1,I2,I3)
      { 
        const Real xd = x(i1,i2,i3,0), yd = x(i1,i2,i3,1);
        const Real theta = atan2(yd,xd);
        const Real r = sqrt( xd*xd + yd*yd );

        uLocal(i1,i2,i3,0) = jn(n,lambda*r)*cos(n*theta)*coswt;
      }
    }
    else
    {
      // --- 3D Cylinder ----

      FOR_3D(i1,i2,i3,I1,I2,I3)
      { 
        const Real xd = x(i1,i2,i3,0), yd = x(i1,i2,i3,1), zd = x(i1,i2,i3,2);
        const Real theta = atan2(yd,xd);
        const Real r = sqrt( xd*xd + yd*yd );

        Real csz = bcOpt==0 ? sin( kz*(zd-za) ) : cos( kz*(zd-za) );

        uLocal(i1,i2,i3,0) = jn(n,lambda*r)*cos( n*theta )* csz *coswt;
      }
    }    

  }

  else if( userKnownSolution=="annulusEigenfunction" )
  {
    // --- Eigenfunction for the heat equation in an annulus ---

    // We can NOT check the boundaryCondition array since it may not be set yet !
   //  bool dirichlet = (mg.boundaryCondition(0,1)==AdParameters::dirichletBoundaryCondition &&
   //                    mg.boundaryCondition(1,1)==AdParameters::dirichletBoundaryCondition );
   //  bool neumann   = (mg.boundaryCondition(0,1)==AdParameters::neumannBoundaryCondition &&
   //                    mg.boundaryCondition(1,1)==AdParameters::neumannBoundaryCondition );

   // dirichlet=true;

   // assert( dirichlet || neumann );

    // --- we could avoid building the vertex array on Cartesian grids ---
    GET_VERTEX_ARRAY(x);

    const int n     = ipar[0];  // angular number, n=0,1,... --> Jn(lambda*r), Yn(lambda*r)
    const int m     = ipar[1];  // radial number m=0,... 
    const int bcOpt = ipar[2];

    const Real amp  = rpar[0];  // amplitude 

    Real lambda, cJ,cY;
    if( bcOpt==0 )
    {
      // Dirichlet boundary conditions:
      //     det(lambda) =  Jn(lambda*a)*Yn(lambda*b) - Jn(lambda*b)*Yn(lambda*a) = 0 
      // This solution assumes ra=.5 and rb=1 (set in the next file) 
      // This file came from ad/codes: 
      #include "src/annulusEigenvaluesHeatEquationDirichlet.h" 
      lambda = annulusEigs[n][m];  // m'th zero of the determinant condition)  
      assert( m<numRoot && n<numBesselOrder );
      // Here is the eignevctor [cJ,cY] 
      cJ = yn(n,lambda*ra);
      cY =-jn(n,lambda*ra);
    } 
    else 
    {
      // Neumann boundary conditions:
      //     det(lambda) =  Jn'(lambda*a)*Yn'(lambda*b) - Jn'(lambda*b)*Yn'(lambda*a) = 0 
      // This solution assumes ra=.5 and rb=1 (set in the next file)
      // This file came from ad/codes: 
      #include "src/annulusEigenvaluesHeatEquationNeumann.h"   
      lambda = annulusEigs[n][m];  // m'th zero of the detreminant condition)
      assert( m<numRoot && n<numBesselOrder );

      // Here is the eigenvector [cJ,cY] 
      // Use Jn'(z) = (n/z)Jn - J_{n+1}
      const Real z = lambda*ra;
      cJ = ( (n/z)*yn(n,z) - yn(n+1,z) );    //  Yn'(lambda*a)
      cY =-( (n/z)*jn(n,z) - jn(n+1,z) );    // -Jn'(lambda*a)
    }

    // scale eigenvector so solution is of size amp
    Real cNorm = sqrt( cJ*cJ + cY*cY );
    cJ *= amp/cNorm; 
    cY *= amp/cNorm;

    if( t<=3.*dt )
      printF("Annulus: Bessel function solution: amp=%g, n=%i, m=%i, lambda=%e, bcOpt=%d\n", amp,n,m,lambda,bcOpt);

    const Real omega = c*lambda;  
    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else
      coswt = -omega*sin(omega*t);       

    FOR_3D(i1,i2,i3,I1,I2,I3)
    { 
      const Real xd = x(i1,i2,i3,0), yd = x(i1,i2,i3,1);
      const Real theta = atan2(yd,xd);
      const Real r = sqrt( xd*xd + yd*yd );

      uLocal(i1,i2,i3,0) = ( cJ*jn(n,lambda*r) + cY*yn(n,lambda*r) )*cos(n*theta)*coswt;
    }

  }


  else if( userKnownSolution=="sphereEigenfunction" )
  {
    
    // --- Eigen function for the wave equation in a SOLID SPHERE ---

    // --- we could avoid building the vertex array on Cartesian grids ---
    GET_VERTEX_ARRAY(x);

    const int & mTheta  = ipar[0];
    const int & mPhi    = ipar[1];
    const int & mr      = ipar[2];
    const int & bcOpt   = ipar[3];      

    const Real & a   = rpar[0];
    const Real & amp = rpar[1];

    const int maxBesselOrder=10;
    assert( mPhi<maxBesselOrder );
    Real jnka[maxBesselOrder]; 
 

    Real lambda; 
    if( bcOpt==0 )
    {
      // DIRICHLET BC
      // #include "src/sphereEigenvalueDirichletRoots.h"    

      // do this for now 
      const int mPhiMax =4, mThetaMax=4, mrMax=4;
      // n = mPhi, m=mr 
      Real omegaArray[]={
          // n=0, m=1,2,..,4
          3.1415926535897932e+00, 6.2831853071795865e+00, 9.4247779607693797e+00, 1.2566370614359173e+01,
          // n=1, m=1,2,..,4
          4.4934094579090642e+00, 7.7252518369377072e+00, 1.0904121659428900e+01, 1.4066193912831473e+01,
          // n=2, m=1,2,..,4
          5.7634591968945498e+00, 9.0950113304763552e+00, 1.2322940970566582e+01, 1.5514603010886748e+01,
          // n=3, m=1,2,..,4
          6.9879320005005200e+00, 1.0417118547379365e+01, 1.3698023153249249e+01, 1.6923621285213840e+01,
      };
      #define omegaRoot(n,m) omegaArray[(m-1)+4*(n-0)]

      assert( mPhi<mPhiMax &&  mr<mrMax );

      lambda= omegaRoot(mPhi,mr)/a;

      if( false && t<=0 )
      {
        // Check the Dirichlet BC:
        Real mSB = mPhi+.5; 
        Real ua = jn(mSB,lambda*a); // jn  DOES NOT WORK !  MAYBE REQUIRES INTEGER ARGUMENT

        int nb = mPhi+1; // nterm+1  ! eval J0, J1, ... J(nb)  -- compute one extra 
        Real ka=lambda*a; 
        Real alpha=0.5;    // fractional part of Bessel order
        int ncalc; 
        rjbesl(ka, alpha, nb, jnka[0], ncalc);

        // Real ub = std::sph_bessel(mPhi,lambda*a);

        
        printF("UDKS: sphere: mPhi=%d, mr=%d, a=%g, lambda=%12.4e, jn(r=a)=%12.4e, jnka=%12.4e (=0?)\n",mPhi,mr,a,lambda,ua,jnka[mPhi]);
        ka=0.;
        rjbesl(ka, alpha, nb, jnka[0], ncalc);
        printF(" -> origin:  jn(0)=%12.4e\n",jnka[mPhi]);
      }
    }
    else
    {
      printF("UDKS: sphereEig: mPhi=%d, mTheta=%d, mr=%d, a=%g\n",mPhi,mTheta,mr);
      printF("UDKS: sphereEig: ERROR: bcOpt=%d not implemented. Only bcopt=0 (Dirichlet) is currently implemented\n",bcOpt);
       OV_ABORT("finish me");
    }
     

    if( t<=3.*dt )
      printF("UDKS: Sphere solution: a=%g, mPhi=%i, mTheta=%i, mr=%d, lambda=%e, bcOpt=%d \n",a,mPhi,mTheta,mr,lambda,bcOpt);

    const Real omega = c*lambda;  
    Real coswt;
    if( numberOfTimeDerivatives==0 )
      coswt = cos(omega*t);
    else if( numberOfTimeDerivatives==1 )
      coswt = -omega*sin(omega*t); 
    else  
    {
      OV_ABORT("UDKS: sphere: unexpected numberOfTimeDerivatives");
    }    

    const Real rTol = 1e-3; 
    const Real phiTol= REAL_EPSILON*1000.; // what should this be ?
    const Real epsx= REAL_EPSILON*100.;
    const int nb = mPhi+1; // nterm+1  ! eval J0, J1, ... J(nb)  -- 
    const Real alpha=0.5;    // fractional part of Bessel order
    int ncalc;         // output flag
    Real sphericalBessel; 

    FOR_3D(i1,i2,i3,I1,I2,I3)
    { 
 
      Real xd = x(i1,i2,i3,0), yd = x(i1,i2,i3,1), zd = x(i1,i2,i3,2);
      if( abs(xd)<epsx && abs(yd)<epsx )
      {
        xd=epsx;  //  avoid atan2(0,0)
        yd=epsx;
      }
      const Real theta = atan2(yd,xd);
      Real r = sqrt( xd*xd + yd*yd + zd*zd );

      // const Real cosphi = (abs(r)<tol) ? (zd/tol) : (zd/r);
      const Real cosphi = fabs(r)<phiTol ? 1.0 : zd/r;

      Real Pnk; 
      evalAssociatedLegendreFunction( mPhi,mTheta,cosphi, Pnk );

      Real kr=lambda*r; 
      if( fabs(r)<rTol )
      {
        // Use Small r approximations for the spherical Bessel: 
        evalSphericalBesselTaylor( mPhi,kr,sphericalBessel );
      }
      else
      {
        rjbesl(kr, alpha, nb, jnka[0], ncalc); // this computes jn_0, jn_1, ..., jn_{nb-1}
        sphericalBessel = sqrt(Pi/(2.0*r))*jnka[mPhi]; 
      }

      uLocal(i1,i2,i3,0) = sphericalBessel*cos(mTheta*theta)*Pnk*coswt;

    }

  }

  else if( userKnownSolution=="cylinderScattering" )
  {
    // **************New way**************
    
    // --- Scattering solution of a wave impinging on a circular inclusion ---
    // --- this is a series solution made up of Hankel functions ---

    // *** inclusion must be at (0,0) (for now) ***
    // *** only cos( k*(x-c*t) ) for the incident wave (for now) *** 

    // --- we could avoid building the vertex array on Cartesian grids ---
    GET_VERTEX_ARRAY(x);

    const int & bcOption  = ipar[0];      

    const Real & ra       = rpar[0];
    const Real & k        = rpar[1];
    const Real & amp      = rpar[2];
    
         
    assert( numberOfDimensions == 2 );

    
    // if( t<=3.*dt )
    //   printF("UDKS: Cylindrical Scattering: ra=%e, k=%e, amp=%e, bcOption=%d \n",ra,k,amp,bcOption);

    if( !db.has_key("cylScatSolution") )
    {
      // Create a array to keep track of when the solution is initialized
      IntegerArray & initStage = db.put<IntegerArray>("initStage");
      initStage.redim(cg.numberOfComponentGrids());
      initStage=true;

      // create an array tp store the real and imag parts of the solution
      realCompositeGridFunction & cylScatSolution = db.put<realCompositeGridFunction>("cylScatSolution");
      Range all;
      cylScatSolution.updateToMatchGrid(cg,all,all,all,2); // store real and imaginary parts

    }

    realCompositeGridFunction & cylScatSolution = db.get<realCompositeGridFunction>("cylScatSolution");
    OV_GET_SERIAL_ARRAY(Real,cylScatSolution[grid],cylLocal);

    IntegerArray & initStage = db.get<IntegerArray>("initStage");   
    if( initStage(grid) )
    {
      // ---- initialization stage -----
      initStage(grid)=false;

      printF("\n --- INFO: userDefinedKnownSolution: Initialize cylinder scattering solution for grid=%d -----\n\n",grid);
      printF("UDKS: Cylindrical Scattering: ra=%e, k=%e, amp=%e, bcOption=%d \n",ra,k,amp,bcOption);      

      // declaring some things for the solution
      Real Jp, HpReal, HpImag, dividedReal, dividedImag, tol, thing;

      // Estimate how many terms are needed **THIS IS FROM THE CGMX SOLUTION : CHECK ME ****
      // ! I estimate that the number of terms, N, should satisfy
      // !        ??? N * eps**(1/N) > e*k*a/2 * 1/(2*pi)**(1/N)
      // ! where eps=size of the final term (series is alternating)
      // ! Take N = max( e*k*a, log(1/eps) ) 
      const Real ka = k*ra;      
      int ntermEstimated = max( fabs(7.*ka), log10(1./REAL_EPSILON) );


      int maxTerms=1000;
      RealArray coeffReal(maxTerms), coeffImag(maxTerms);
      // Real coefReal[NtermsMax+1];
      // Real coefImag[NtermsMax+1];
      int Nterms;


      // declaring some things for plotting the scattered field
      Real & ampPlaneWave   = dbase.get<Real>("ampPlaneWave");
      Real & kxPlaneWave    = dbase.get<Real>("kxPlaneWave");
      Real & kyPlaneWave    = dbase.get<Real>("kyPlaneWave");
      Real & kzPlaneWave    = dbase.get<Real>("kzPlaneWave");
      Real & phiPlaneWave   = dbase.get<Real>("phiPlaneWave");
      Real & omegaPlaneWave = dbase.get<Real>("omegaPlaneWave");

      ampPlaneWave   = amp;
      kxPlaneWave    = k; // because of the current specific incident wave
      kyPlaneWave    = 0; // because of the current specific incident wave
      kzPlaneWave    = 0; // because of the current specific incident wave
      phiPlaneWave   = twoPi/4; // is there something for just pi?
      omegaPlaneWave = c*k;

      
      // defining the coefficients in the series solution
      // it depends on the term number and k, so we can define it outside of the for 3D loop

      tol = pow(10,-50); // must be quite small, as this is just the coefficient, [10^{-60},10^{-40}] suggested

      thing = 1; // will be the magnitude of the coefficient
      Nterms=-1;
      //for ( int l=0; l<=Nterms; ++l )
      while( thing > tol  )
      {
        Nterms = Nterms+1;
        if( Nterms>=maxTerms )
        {
          printF("UDKS:ERROR: too many terms in scattering solution, Nterms=%d. FIX ME\n",Nterms);
          OV_ABORT("UKDS: ERROR");
        }
        
        if( bcOption == 1 )
        {
          // Neumann BC
          Jp     = -jn(Nterms+1,k*ra) + (Nterms/(k*ra))*jn(Nterms,k*ra);
          HpReal = -jn(Nterms+1,k*ra) + (Nterms/(k*ra))*jn(Nterms,k*ra);
          HpImag = -yn(Nterms+1,k*ra) + (Nterms/(k*ra))*yn(Nterms,k*ra);
        }
        else 
        {
          // Dirichlet BC
          Jp     = jn(Nterms,k*ra);
          HpReal = jn(Nterms,k*ra);
          HpImag = yn(Nterms,k*ra);
        }

        // dividing them as complex numbers
        dividedReal =  Jp*HpReal/( pow(HpReal,2) + pow(HpImag,2) );
        dividedImag = -Jp*HpImag/( pow(HpReal,2) + pow(HpImag,2) );

        // multiplying by I^l
        if( Nterms%4 == 0 )
        {
          coeffReal(Nterms) = dividedReal;
          coeffImag(Nterms) = dividedImag;
        }
        else if( Nterms%4 == 1 )
        {
          coeffReal(Nterms) = -dividedImag;
          coeffImag(Nterms) =  dividedReal;
        }
        else if( Nterms%4 == 2 )
        {
          coeffReal(Nterms) = -dividedReal;
          coeffImag(Nterms) = -dividedImag;
        }
        else
        {
          coeffReal(Nterms) = dividedImag;
          coeffImag(Nterms) = -dividedReal;
        }

        if( Nterms == 0 )
        {
          coeffReal(Nterms) = -amp*coeffReal(Nterms);
          coeffImag(Nterms) = -amp*coeffImag(Nterms);
        }
        else
        {
          coeffReal(Nterms) = -2*amp*coeffReal(Nterms);
          coeffImag(Nterms) = -2*amp*coeffImag(Nterms);
        }

        // magnitude of the coefficient decides the number of terms in the series
        thing = sqrt( pow(coeffReal(Nterms),2) + pow(coeffImag(Nterms),2) );
        
        
      }

      // quit if too many terms/series not converging
      
      //printF("%d terms kept in scattering series solution, size of coef: %e\n",Nterms,thing);
      if( t<=3.*dt )
        printF("UDKS: cylScat: There were %d terms kept in scattering series solution, grid=%d. (ntermEstimated=%d) *********\n",Nterms,grid,ntermEstimated);
      
      
      // declaring some stuff we need to create the solution in the 3D loop
      Real termReal, termImag, HankelReal, HankelImag, arg;
      Real usReal, usImag; // scattered part of the solution 
      Real uiReal, uiImag; // incident wave
      Real utReal, utImag; // total solution
      //Real phiReal, phiImag;
      Real uReal, uImag;

      Real xd, yd, theta, r;
      
      Index J1,J2,J3; // evaluate solution at all points on the grid
      getIndex(mg.dimension(),J1,J2,J3);

      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        if( !isRectangular )
        {
          xd = x(i1,i2,i3,0);
          yd = x(i1,i2,i3,1);
        }
        else
        {
          xd = XC(iv,0);
          yd = XC(iv,1);
        }
        theta = atan2(yd,xd);
        r = sqrt( xd*xd + yd*yd );

        // resetting the summed solution
        usReal = 0;
        usImag = 0;

        // computing scattering solution first (the series part)
        for ( int l=0; l<=Nterms; ++l )
        {
          // defining Hankel function
          arg = k*r;
          HankelReal = jn(l,arg);
          HankelImag = yn(l,arg);
          
          // the scattered solution
          termReal = ( coeffReal(l)*HankelReal - coeffImag(l)*HankelImag )*cos( l*theta );
          termImag = ( coeffReal(l)*HankelImag + coeffImag(l)*HankelReal )*cos( l*theta );
          
          // adding together
          usReal = usReal + termReal;
          usImag = usImag + termImag;
          
        }

        // save real and imaginary parts
        cylLocal(i1,i2,i3,0)=usReal;
        cylLocal(i1,i2,i3,1)=usImag;
      } 


    } // end initialization stage

    Real cost,sint;
    if( numberOfTimeDerivatives==0 )
    {
      cost = cos( -c*k*t );
      sint = sin( -c*k*t );
    }
    else if( numberOfTimeDerivatives==1 )
    {
      cost =  c*k*sin( -c*k*t );  // time derivative 
      sint = -c*k*cos( -c*k*t );
    }
    else
    {
      printF("cylinderScattering:ERROR: numberOfTimeDerivatives=%d not implemented\n");
      OV_ABORT("ERROR");
    }

    Real *pu   = uLocal.getDataPointer(); // pointer to contiguous array data
    Real *pcyl = cylLocal.getDataPointer(); // pointer to contiguous array data
    const int nd1a = uLocal.getBase(0), nd1b=uLocal.getBound(0);
    const int nd2a = uLocal.getBase(1), nd2b=uLocal.getBound(1);
    const int nd3a = uLocal.getBase(2), nd3b=uLocal.getBound(2);
    const int nd4a = uLocal.getBase(3), nd4b=uLocal.getBound(3);

    const int nd1 = nd1b-nd1a+1;
    const int nd2 = nd2b-nd2a+1;
    const int nd3 = nd3b-nd3a+1;

    // Macro to access elements of u directly 
    // Data is stored in row major order (i1 varies most rapidly)
    #define U(i1,i2,i3) pu[ ((i1)-nd1a) + nd1*( (i2)-nd2a + nd2*( (i3)-nd3a ) ) ]
    #define CYL(i1,i2,i3,i4) pcyl[ ((i1)-nd1a) + nd1*( (i2)-nd2a + nd2*( (i3)-nd3a + nd3*( (i4)-nd4a )) ) ]

    // --- Evaluate the solution at the requested points  ---
    Real xd,yd; 
    FOR_3D(i1,i2,i3,I1,I2,I3)
    {
      if( !isRectangular )
      {
        xd = x(i1,i2,i3,0);
        // yd = x(i1,i2,i3,1);
      }
      else
      {
        xd = XC(iv,0);
        // yd = XC(iv,1);
      }

      // Real uReal = cylLocal(i1,i2,i3,0)*cost - cylLocal(i1,i2,i3,1)*sint;
      Real uReal = CYL(i1,i2,i3,0)*cost - CYL(i1,i2,i3,1)*sint;

      // Real uReal = cylLocal(i1,i2,i3,0)*cos( -c*k*t ) - cylLocal(i1,i2,i3,1)*sin( -c*k*t );
      // uImag = cylLocal(i1,i2,i3,1)*cos( -c*k*t ) + cylLocal(i1,i2,i3,0)*sin( -c*k*t );

      // add the incident wave
      if( numberOfTimeDerivatives==0 )
      {
        uReal += cos( k*(xd-c*t) );
        // uImag += sin( k*(xd-c*t) );
      }
      else
      {
        uReal += (c*k)*sin( k*(xd-c*t) ); // time derivative of incident field
      }

      // uLocal(i1,i2,i3,0) = amp*uReal;
      U(i1,i2,i3) = amp*uReal;
      
    }

  }
  
  else if( userKnownSolution=="cylindrical scattering" )
  {
    // *************OLD WAY****************

    // --- Scattering solution of a wave impinging on a circular inclusion ---
    // --- this is a series solution made up of Hankel functions ---

    // *** inclusion must be at (0,0) (for now) ***
    // *** only cos( k*(x-c*t) ) for the incident wave (for now) *** 

    // --- we could avoid building the vertex array on Cartesian grids ---
    GET_VERTEX_ARRAY(x);

    const int NtermsMax = ipar[0];  // number of terms included in the series solution
    const int bcOpt     = ipar[1];

    const Real ra       = rpar[0];  // radius of inclusion
    const Real k        = rpar[1];  // wave number
    const Real amp      = rpar[2];
    
         
    assert( numberOfDimensions == 2 );

    
    if( t<=3.*dt )
      printF("UDKS: Cylindrical Scattering: ra=%e, k=%e, amp=%e, NtermsMax=%d, bcOpt=%d \n",ra,k,amp,NtermsMax,bcOpt);


    // declaring some things for the solution
    Real Jp, HpReal, HpImag, dividedReal, dividedImag, tol, thing;
    Real coefReal[NtermsMax+1];
    Real coefImag[NtermsMax+1];
    int Nterms;


    // declaring some things for plotting the scattered field
    Real & ampPlaneWave   = dbase.get<Real>("ampPlaneWave");
    Real & kxPlaneWave    = dbase.get<Real>("kxPlaneWave");
    Real & kyPlaneWave    = dbase.get<Real>("kyPlaneWave");
    Real & kzPlaneWave    = dbase.get<Real>("kzPlaneWave");
    Real & phiPlaneWave   = dbase.get<Real>("phiPlaneWave");
    Real & omegaPlaneWave = dbase.get<Real>("omegaPlaneWave");

    ampPlaneWave   = amp;
    kxPlaneWave    = k; // because of the current specific incident wave
    kyPlaneWave    = 0; // because of the current specific incident wave
    kzPlaneWave    = 0; // because of the current specific incident wave
    phiPlaneWave   = twoPi/4; // is there something for just pi?
    omegaPlaneWave = c*k;

    
    // defining the coefficients in the series solution
    // it depends on the term number and k, so we can define it outside of the for 3D loop
    tol = pow(10,-50); // must be quite small, as this is just the coefficient, [10^{-60},10^{-40}] suggested
    thing = 1; // will be the magnitude of the coefficient
    Nterms=-1;
    //for ( int l=0; l<=Nterms; ++l )
    while( thing > tol && Nterms <= NtermsMax )
    {
      Nterms = Nterms+1;
      
      if( bcOpt == 1 )
      {
        // definition of derivatives
        Jp     = -jn(Nterms+1,k*ra) + (Nterms/(k*ra))*jn(Nterms,k*ra);
        HpReal = -jn(Nterms+1,k*ra) + (Nterms/(k*ra))*jn(Nterms,k*ra);
        HpImag = -yn(Nterms+1,k*ra) + (Nterms/(k*ra))*yn(Nterms,k*ra);
      }
      else 
      {
        Jp     = jn(Nterms,k*ra);
        HpReal = jn(Nterms,k*ra);
        HpImag = yn(Nterms,k*ra);
      }

      // dividing them as complex numbers
      dividedReal =  Jp*HpReal/( pow(HpReal,2) + pow(HpImag,2) );
      dividedImag = -Jp*HpImag/( pow(HpReal,2) + pow(HpImag,2) );

      // multiplying by I^l
      if( Nterms%4 == 0 )
      {
        coefReal[Nterms] = dividedReal;
        coefImag[Nterms] = dividedImag;
      }
      else if( Nterms%4 == 1 )
      {
        coefReal[Nterms] = -dividedImag;
        coefImag[Nterms] =  dividedReal;
      }
      else if( Nterms%4 == 2 )
      {
        coefReal[Nterms] = -dividedReal;
        coefImag[Nterms] = -dividedImag;
      }
      else
      {
        coefReal[Nterms] = dividedImag;
        coefImag[Nterms] = -dividedReal;
      }

      if( Nterms == 0 )
      {
        coefReal[Nterms] = -amp*coefReal[Nterms];
        coefImag[Nterms] = -amp*coefImag[Nterms];
      }
      else
      {
        coefReal[Nterms] = -2*amp*coefReal[Nterms];
        coefImag[Nterms] = -2*amp*coefImag[Nterms];
      }

      // magnitude of the coefficient decides the number of terms in the series
      thing = sqrt( pow(coefReal[Nterms],2) + pow(coefImag[Nterms],2) );
      
      
    }

    // quit if too many terms/series not converging
    assert( Nterms < NtermsMax );
    
    //printF("%d terms kept in scattering series solution, size of coef: %e\n",Nterms,thing);
    if( t<=3.*dt )
      printF("%d terms kept in scattering series solution\n",Nterms);
    
    
    // declaring some stuff we need to create the solution in the 3D loop
    Real termReal, termImag, HankelReal, HankelImag, arg;
    Real usReal, usImag; // scattered part of the solution 
    Real uiReal, uiImag; // incident wave
    Real utReal, utImag; // total solution
    //Real phiReal, phiImag;
    Real uReal, uImag;

    Real xd, yd, theta, r;
    
    
    FOR_3D(i1,i2,i3,I1,I2,I3)
    {
       if( !isRectangular )
        {
          xd = x(i1,i2,i3,0);
          yd = x(i1,i2,i3,1);
        }
        else
        {
          xd = XC(iv,0);
          yd = XC(iv,1);
        }
       theta = atan2(yd,xd);
       r = sqrt( xd*xd + yd*yd );

      // resetting the summed solution
      usReal = 0;
      usImag = 0;
       

      // computing scattering solution first (the series part)
      for ( int l=0; l<=Nterms; ++l )
      {
        // defining Hankel function
        arg = k*r;
        HankelReal = jn(l,arg);
        HankelImag = yn(l,arg);
        
        // the scattered solution
        termReal = ( coefReal[l]*HankelReal - coefImag[l]*HankelImag )*cos( l*theta );
        termImag = ( coefReal[l]*HankelImag + coefImag[l]*HankelReal )*cos( l*theta );
        
        // adding together
        usReal = usReal + termReal;
        usImag = usImag + termImag;
        
      }

      // multiplying by time part

      uReal = usReal*cos( -c*k*t ) - usImag*sin( -c*k*t );
      uImag = usImag*cos( -c*k*t ) + usReal*sin( -c*k*t );

      // adding the incident wave
      uReal = uReal + cos( k*(xd-c*t) );
      uImag = uImag + sin( k*(xd-c*t) );

      uLocal(i1,i2,i3,0) = uReal;
      
    }

  }

  else
  {
    printF("getUserDefinedKnownSolution:ERROR: unknown value for userDefinedKnownSolution=%s\n",
           (const char*)userKnownSolution);
    OV_ABORT("ERROR");
  }
  

  timing(timeForUserDefinedKnownSolution) += getCPU()-cpu0;
  
  return 0;
}


int CgWave::
updateUserDefinedKnownSolution()
// ==========================================================================================
/// \brief This function is called to set the user defined known solution.
///
/// Choose a user defined known solution (UDKS) and any associated parameters. The UDKS can
/// be used for initial conditions, boundary conditions (exact BCs) and computing errors.
// ==========================================================================================
{
  // Make  dbase.get<real >("a") sub-directory in the data-base to store variables used here
  if( ! dbase.has_key("userDefinedKnownSolutionData") )
     dbase.put<DataBase>("userDefinedKnownSolutionData");
  DataBase & db =  dbase.get<DataBase>("userDefinedKnownSolutionData");

  if( !db.has_key("userKnownSolution") )
  {
    db.put<aString>("userKnownSolution");
    db.get<aString>("userKnownSolution")="unknownSolution";
    
    // wave numbers (kx,ky,kz) for plane wave and Gaussian plane wave , will be scaled by 2*Pi
    real *kv = db.put<real[3]>("kv");
    kv[0]=1.;
    kv[1]=1.;
    kv[2]=1.;

    // Offset (x0,y0,z0) for Gaussian plane wave 
    real *x0v = db.put<real[3]>("x0v");
    x0v[0]=0.;
    x0v[1]=0.;
    x0v[2]=0.; 

    // Exponential factor "beta" for Gaussian plane wave 
    db.put<Real>("beta")=20.;

    // Modulation wave-number for Gaussian plane wave 
    db.put<Real>("k0")=0.;


    db.put<real[20]>("rpar");
    db.put<int[20]>("ipar");
  }
  real *kv    = db.get<real[3]>("kv");
  real *x0v   = db.get<real[3]>("x0v");
  Real & beta = db.get<Real>("beta");
  Real & k0   = db.get<Real>("k0");

  aString & userKnownSolution = db.get<aString>("userKnownSolution");
  real *rpar = db.get<real[20]>("rpar");
  int *ipar = db.get<int[20]>("ipar");


  // Build a dialog menu for changing parameters
  GUIState gui;
  DialogData & dialog=gui;

  dialog.setWindowTitle("Known Solutions");
  dialog.setExitCommand("exit", "exit");

  // -------- PUSH BUTTONS ---------
  aString pbLabels[] = {
                        "no known solution",
                        "plane wave",
                        "gaussian plane wave",
                        "box Helmholtz",
                        "poly periodic",
                        "computed Helmholtz",
                        "modulated Gaussian",
                        "disk eigenfunction",
                        "annulus eigenfunction",
                        "square eigenfunction",
                        "sphere eigenfunction",
                        "scattering from a cylinder",
                        "cylindrical scattering",      // old way 
                        "done",    
                        ""};
  int numRows=3;
  dialog.setPushButtons( pbLabels, pbLabels, numRows ); 

 // ----- Text boxes ------
  const int numberOfTextStrings=10;            // max number of text boxes 
  aString textCommands[numberOfTextStrings];
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];
  int nt=0; 
  textCommands[nt] = "wave numbers:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g, %g, %g (kx,ky,kz)",kv[0],kv[1],kv[2]);     nt++; 

  textCommands[nt] = "offset:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g, %g, %g (x0,y0,z0)",x0v[0],x0v[1],x0v[2]);  nt++;  

  textCommands[nt] = "beta:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g",beta);                                    nt++; 

  textCommands[nt] = "k0:";  textLabels[nt]=textCommands[nt];
  sPrintF(textStrings[nt], "%g",k0);                                      nt++; 
 
   // null strings terminal list
  textCommands[nt]="";   textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
  dialog.setTextBoxes(textCommands, textLabels, textStrings);

  // const aString menu[]=
  //   {
  //     "no known solution",
  //     "plane wave",
  //     "box helmholtz",
  //     "done",
  //     ""
  //   }; 

  gi.pushGUI(gui);

  gi.appendToTheDefaultPrompt("userDefinedKnownSolution>");
  aString answer;
  int len;
  for( ;; ) 
  {

    // int response=gi.getMenuItem(menu,answer,"Choose a known solution");
    
    gi.getAnswer(answer,""); 

    if( answer=="done" || answer=="exit" )
    {
      break;
    }
    else if( answer=="no known solution" )
    {
      userKnownSolution="unknownSolution";
    }
    else if( answer=="plane wave" ) 
    {
      userKnownSolution="planeWave";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      gi.inputString(answer,"Enter amp,kx,ky,kz");
      sScanF(answer,"%e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3]);
      printF(" Setting amp=%g, [kx,ky,kz]=[%g,%g,%g]\n",rpar[0],rpar[1],rpar[2],rpar[3]);



      // Save parameters in dbase so we can look them up in bcOptWave
      const Real amp=rpar[0], kx=rpar[1]*twoPi, ky=rpar[2]*twoPi, kz=rpar[3]*twoPi; 
      const Real & c= dbase.get<real>("c");
      real k;
      if( cg.numberOfDimensions()==2 )
        k = sqrt( kx*kx + ky*ky );
      else      
        k = sqrt( kx*kx + ky*ky +kz*kz );
      const real omega = c*k;      

      // --new way: store variables here: 
      dbase.get<Real>("ampPlaneWave")   = amp;
      dbase.get<Real>("kxPlaneWave")    = kx;
      dbase.get<Real>("kyPlaneWave")    = ky;
      dbase.get<Real>("kzPlaneWave")    = kz;
      dbase.get<Real>("phiPlaneWave")   = 0.; 
      dbase.get<Real>("omegaPlaneWave") = omega;

      
    }
    else if( answer=="gaussian plane wave")
    {
      printF("--- Gaussian plane wave (possibly modulated at frequency k0)--- \n"
             "    u(x,y,z,t) = exp( -beta*(xi^2) )*cos( k0*xi ) \n"
             " where \n"
             "    xi = kx*( x-x0) + ky*(y-y0) + kz*(z-z0) - c*t \n"
             "    k0 : most energy will be at this wave-number. \n"
             "    (kx,ky,kz) will be normalized to a unit vector. \n"
             " Set parameters (kx,ky,kz) (x0,y0,z0), beta and k0 in the text boxes.\n");

      userKnownSolution="gaussianPlaneWave";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time

      // Save parameters in dbase so we can look them up in bcOptWave
      // These are updated below (in case the user has changed kx,ky,kz, etc.)
      if( !dbase.has_key("kxGPW") )
      {
        const Real kNorm  = max( REAL_MIN*1000., sqrt( SQR(kv[0]) + SQR(kv[1]) + SQR(kv[2] ) ) ); 
        dbase.put<Real>("kxGPW")   = kv[0]/kNorm;
        dbase.put<Real>("kyGPW")   = kv[1]/kNorm;
        dbase.put<Real>("kzGPW")   = kv[2]/kNorm; 
    
        dbase.put<Real>("x0GPW")   = x0v[0];
        dbase.put<Real>("y0GPW")   = x0v[1];
        dbase.put<Real>("z0GPW")   = x0v[2];
  
        dbase.put<Real>("betaGPW") = beta;
        dbase.put<Real>("k0GPW")   = k0;
      }

    }
    else if( answer=="box Helmholtz" ) 
    {
      printF("----------------- box helmholtz -----------------\n"
             " Define a time-periodic solution for a square or box that depends on a forcing term.\n");
      printF("   We solve :   utt = c^2 * Delta(u) - f(x)*cos(omega*t) \n");
      printF("                u=0 on the boundary                    ) \n");
      printF("The solution is of the form: cos(omega*t)*sin(kx*2*pi*x)*sin(ky*2*pi*y)\n");
      
      userKnownSolution="boxHelmholtz";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      gi.inputString(answer,"Enter omega,kx,ky,kz");
      sScanF(answer,"%e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3]);
      printF(" Setting omega=%g, [kx,ky,kz]=[%g,%g,%g]\n",rpar[0],rpar[1],rpar[2],rpar[3]);

      Real & omega = dbase.get<real>("omega");
      omega = rpar[0]; // define the Helmholtz omega for advance 

      // do this for now: 
      const RealArray & frequencyArray  = dbase.get<RealArray>("frequencyArray");
      frequencyArray(0) = omega;

      // Save parameters in dbase so we can look them up in bcOptWave
      const Real kx=rpar[1]*twoPi, ky=rpar[2]*twoPi, kz=rpar[3]*twoPi; 
      dbase.put<Real>("omegaBoxHelmholtz") = omega;
      dbase.put<Real>("kxBoxHelmholtz")    = kx;
      dbase.put<Real>("kyBoxHelmholtz")    = ky;
      dbase.put<Real>("kzBoxHelmholtz")    = kz;
      
    }
    else if( answer=="poly periodic" ) 
    {
      printF("----------------- polynomial in space and periodic in time -----------------\n");
      printF("   We solve :   utt = c^2 * Delta(u) - f(x)*cos(omega*t) \n");
      printF("The solution is of the form: (a0 + a1*x + a2*x^2 + ... b1*y + b2*y^2 + ... + c1*z + c2*z^2 + ...)*cos(omega*t)\n");
      
      userKnownSolution="polyPeriodic";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time

      // Save parameters in dbase so we can look them up in bcOptWave
      real & omega        = dbase.put<Real>("omegaPolyPeriodic");
      int & degreeInSpace = dbase.put<int>("degreeInSpacePolyPeriodic");
      real & a0           = dbase.put<Real>("a0PolyPeriodic");
      real & a1           = dbase.put<Real>("a1PolyPeriodic");
      real & b1           = dbase.put<Real>("b1PolyPeriodic");
      real & c1           = dbase.put<Real>("c1PolyPeriodic");

      omega=1.; degreeInSpace=1; 
      a0=1.; a1=1.; b1=1.; c1=1.;

      gi.inputString(answer,"Enter omega,degreeInSpace");
      sScanF(answer,"%e %i",&omega,&degreeInSpace);
      printF(" Setting omega=%g, degreeInSpace=%d\n",omega,degreeInSpace);

      if( degreeInSpace==0 )
      {
        a1=0.; b1=0; c1=0; 
      }


    }
    else if( answer=="computed Helmholtz" )
    {
      printF("Known solution will be found from the discrete solution to the Helmholtz problem.\n");
      printF("     u(x,t) = uHelmholtz(x) * cos(omega*t) \n");
      printF("NOTE: uHelmholtz(x) is current computed by cgwh.\n");

      userKnownSolution="computedHelmholtz";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time

      // --- do this for now : only works with boxHelmholtz solution 
      gi.inputString(answer,"Enter omega,kx,ky,kz");
      sScanF(answer,"%e %e %e %e",&rpar[0],&rpar[1],&rpar[2],&rpar[3]);
      printF(" Setting omega=%g, [kx,ky,kz]=[%g,%g,%g]\n",rpar[0],rpar[1],rpar[2],rpar[3]);

      dbase.get<real>("omega") = rpar[0]; // define the Helmholtz omega for advance 

      // Save parameters in dbase so we can look them up in bcOptWave
      const Real omega=rpar[0], kx=rpar[1]*twoPi, ky=rpar[2]*twoPi, kz=rpar[3]*twoPi; 
      dbase.put<Real>("omegaBoxHelmholtz") = omega;
      dbase.put<Real>("kxBoxHelmholtz")    = kx;
      dbase.put<Real>("kyBoxHelmholtz")    = ky;
      dbase.put<Real>("kzBoxHelmholtz")    = kz;

    }
    else if( answer=="modulated Gaussian")
    {
      printF("--- Modulated Gaussian Initial Condition --- \n"
             "    u(x,y,z,t) = exp( -beta*( r^2 ) )*cos( 2*pi*k0*r ) \n"
             " where \n"
             "    r = sqrt( (x-x0)^2 + (y-y0)^2 + (z-z0)^2 ) \n"
             "    k0 : most energy will be at this wave-number. \n"
             "    (kx,ky,kz) will be normalized to a unit vector. \n"
             " Set parameters (x0,y0,z0), beta and k0 in the text boxes.\n");

      userKnownSolution="modulatedGaussian";
      dbase.get<bool>("knownSolutionIsTimeDependent")=false;  // this is not a known solution

      // Save parameters in dbase so we can look them up in bcOptWave
      // These are updated below (in case the user has changed x0,y0,z0, etc.)
      if( !dbase.has_key("kxGPW") )
      {
        dbase.put<Real>("x0GPW")   = x0v[0];
        dbase.put<Real>("y0GPW")   = x0v[1];
        dbase.put<Real>("z0GPW")   = x0v[2];
  
        dbase.put<Real>("betaGPW") = beta;
        dbase.put<Real>("k0GPW")   = k0;
      }

    }

    else if( answer=="square eigenfunction" ) 
    {
      printF("----------------- Eigenfunction on a square or box -----------------\n"
             "The solution is of the form:\n" 
             "bcOpt=0: u(x,y,z,t) = sin(kx*2*pi*x)*sin(ky*2*pi*y)*sin(kz*2*pi*z)*cos(omega*t)*\n"
             "bcOpt=1: u(x,y,z,t) = cos(kx*2*pi*x)*cos(ky*2*pi*y)*cos(kz*2*pi*z)*cos(omega*t)*\n");
      
      userKnownSolution="squareEigenfunction";
      dbase.get<bool>("knownSolutionIsTimeDependent")=true;  // known solution depends on time
      
      int & bcOpt = ipar[0]; 
      bcOpt =0; // 0= Dirichlet BC 
      gi.inputString(answer,"Enter kx,ky,kz,bcOpt");
      sScanF(answer,"%e %e %e %i",&rpar[0],&rpar[1],&rpar[2],&bcOpt);
      printF(" Setting [kx,ky,kz]=[%g,%g,%g], bcOpt=%d\n",rpar[0],rpar[1],rpar[2],bcOpt);

    }

    else if( answer=="disk eigenfunction" )
    {

      userKnownSolution="diskEigenfunction";

      int & n     = ipar[0];
      int & m     = ipar[1];
      int & bcOpt = ipar[2];      
      int & mz    = ipar[3];      

      Real & a   = rpar[0];
      Real & amp = rpar[1];
      Real & za  = rpar[2];
      Real & zb  = rpar[3];

      m=0; n=0; amp=1.; a=1.;
      mz = 1;
      za=0.; zb=1.; 
      
      printF("--- Eigenfunction for the Wave Equation on a disk or 3D cylinder ---\n"
             "    u = cos( c*lambda_{m,n} *t ) * Jn(lambda_m*r) * cos(n*theta)  [2D, Dirichlet BCs]\n"
             "    u = cos( c*lambda_{m,n} *t ) * Jn(lambda_m*r) * cos(n*theta) *sin( mz*(z-za)/(zb-za)) [3D, Dirichlet BCs]\n"
             "    n = angular number, n=0,1,2,\n"
             "    m = radial number (m'th zero of Bessel Jn(lambda*a)=0 \n"
             "    mz = axial (z-axis) number (3D cyl)\n"
             "    a = radius of the disk\n"
             "    amp = amplitude\n"
             "    za,zb : extent in z-direction\n"
             "    bcOpt : 0=Dirichlet, 1=Neumann BCs\n"             
        );
      
      gi.inputString(answer,"Enter n, m, a, amp, bcOpt, mz, za, zb for the exact solution");
      sScanF(answer,"%i %i %e %e %i %i %e %e",&n,&m,&a,&amp,&bcOpt,&mz,&za,&zb);

      if( cg.numberOfDimensions()==2 )
        printF("Disk eigenfuncton: n=%i, m=%i, a=%g, amp=%g, bcOpt=%d\n",n,m,a,amp,bcOpt);
      else
        printF("Disk eigenfuncton: n=%i, m=%i, mz=%i, a=%g, [za,zb]=[%g,%g] amp=%g, bcOpt=%d\n",n,m,mz,za,zb,a,amp,bcOpt);

      dbase.get<bool>("knownSolutionIsTimeDependent")= true;  // known solution is time dependent

    }  

    else if( answer=="annulus eigenfunction" )
    {
      userKnownSolution="annulusEigenfunction";

      int & n     = ipar[0];
      int & m     = ipar[1];
      int & bcOpt = ipar[2];

      Real & amp = rpar[0];

      m=0; n=0; amp=1.; bcOpt=0;
      
      printF("--- Eigenfunction for the Wave Equation in an annulus---\n"
             "    u = cos( c*lambda_{m,n} *t ) * uHat(r) * cos(n*theta),\n"
             "    uHat(r) = c1*Jn(lambda*r) + c2*Yn(lambda*r),\n"
             "    Annulus: ra=.5, rb=1.\n"
             "    n = angular number, n=0,1,2,\n"
             "    m = radial number (m'th zero of determinant condition). \n"
             "    amp = amplitude.\n"
             "    bcOpt : 0=Dirichlet, 1=Neumann BCs on the annulus.\n"
        );
      
      gi.inputString(answer,"Enter n,m,amp,bcOpt for the exact solution");
      sScanF(answer,"%i %i %e %i",&n,&m,&amp,&bcOpt);

      printF("Annulus eigenfuncton: n=%i, m=%i, amp=%g, bcOpt=%d\n",n,m,amp,bcOpt);

      dbase.get<bool>("knownSolutionIsTimeDependent")= true;  // known solution is time dependent

    } 

    else if( answer=="sphere eigenfunction" )
    {
      userKnownSolution="sphereEigenfunction";

      int & mTheta  = ipar[0];
      int & mPhi    = ipar[1];
      int & mr      = ipar[2];
      int & bcOpt   = ipar[3];      

      Real & a   = rpar[0];
      Real & amp = rpar[1];

      mPhi=1; mTheta=1; mr=0; amp=1.; a=1.;
      
      printF("--- Eigenfunction for the Wave Equation on a Solid Sphere ---\n"
             "    u  = (sqrt(pi/2*r))*jn((mPhi+0.5),lambda*r)*cos(mTheta*theta)*Pnk(mPhi,mTheta,cosphi)*coswt \n"
             "                                                                                                \n"
             "    mPhi   = angular number in phi, mPhi=0,1,2, (degree of the associated Legendre function)\n"
             "    mTheta = angular number in theta, mTheta=0,1,..,mPhi, (order of the associated Legendre function)\n"
             "    mr     = radial number (mr'th zero of determinant condition), mr=0,1,2,... \n"
             "    a      = radius of the sphere\n"
             "    amp    = amplitude\n"
             "    bcOpt : 0=Dirichlet, 1=Neumann BCs on the sphere.\n"             
        );
      
      gi.inputString(answer,"Enter mPhi,mTheta,mr,a,amp,bcOpt for the exact solution");
      sScanF(answer,"%i %i %i %e %e %i",&mPhi,&mTheta,&mr,&a,&amp,&bcOpt);

      printF("Sphere eigenfuncton: mPhi=%i, mTheta=%i, mr=%i, a=%g, amp=%g, bcOpt=%d\n",
             mPhi,mTheta,mr,a,amp,bcOpt);

      dbase.get<bool>("knownSolutionIsTimeDependent")= true;  // known solution is time dependent

    }  

    else if( answer=="scattering from a cylinder" )
    {
      // *new way* Dec 2023 *wdh*
      userKnownSolution="cylinderScattering";

      int & bcOption = ipar[0];      

      Real & ra       = rpar[0];
      Real & k        = rpar[1];
      Real & amp      = rpar[2];
      
      printF("--- Scattering of a plane wave from a cylinder  ---\n"
             "    ra        = radius of the cylinder.\n"
             "    k         = wave number of incident wave.\n"
             "    amp       = amplitude of the incident wave.\n"
             "    bcOption : 0=Dirichlet, 1=Neumann BCs on the cylinder.\n"             
        );
      
      gi.inputString(answer,"Enter ra,k,amp,bcOption for the exact solution");
      sScanF(answer,"%e %e %e %i",&ra,&k,&amp,&bcOption);

      printF("Scattering: ra=%e, k=%e, amp=%e, bcOption=%d (0=Dirichlet, 1=Neumann)\n",ra,k,amp,bcOption);

      dbase.get<bool>("knownSolutionIsTimeDependent")= true;  // known solution is time dependent

    }  

    else if( answer=="cylindrical scattering" )
    {
      // Old way Allison Carson
      userKnownSolution="cylindrical scattering";

      int & NtermsMax = ipar[0];
      int & bcOpt     = ipar[1];      

      Real & ra       = rpar[0];
      Real & k        = rpar[1];
      Real & amp      = rpar[2];
      
      
      printF("--- Scattering from a cylinder in two dimensions ---\n"
             "    ra        = radius of the cylinder\n"
             "    k         = wave number\n"
             "    amp       = amplitude of the incident wave\n"
             "    NtermsMax = max number of terms in the series solution\n"
             "    bcOpt : 0=Dirichlet, 1=Neumann BCs on the annulus.\n"             
        );
      
      gi.inputString(answer,"Enter ra,k,amp,NtermsMax,bcOpt for the exact solution");
      sScanF(answer,"%e %e %e %i %i",&ra,&k,&amp,&NtermsMax,&bcOpt);

      printF("Scattering: ra=%e, k=%e, amp=%e, NtermsMax=%d, bcOpt=%d\n",ra,k,amp,NtermsMax,bcOpt);

      dbase.get<bool>("knownSolutionIsTimeDependent")= true;  // known solution is time dependent

    }  

    else if( dialog.getTextValue(answer,"beta:","%e",beta) )
    {
      printF("UDKS: Setting beta=%g (exponential factor in Gaussian plane wave)\n",beta);
    }
    else if( dialog.getTextValue(answer,"k0:","%e",k0) )
    {
      printF("UDKS: Setting k0=%g : modulation wave-number in Gaussian plane wave, will be scaled by 2*pi.\n",k0);
    }

    else if( (len=answer.matches("wave numbers:")) )
    {
      sScanF(answer(len,answer.length()-1),"%e %e %e",&kv[0],&kv[1],&kv[2]);
      printF("UDKS: Setting wave numbers: kx=%g, ky=%g, kz=%g (may be normalized or scaled by 2*pi)\n",kv[0],kv[1],kv[2]);
    }
    else if( (len=answer.matches("offset:")) )
    {
      sScanF(answer(len,answer.length()-1),"%e %e %e",&x0v[0],&x0v[1],&x0v[2]);
      printF("UDKS: Setting offset (x0,y0,z0)=(%g,%g,%g) (for Gaussian plane-wave)\n",x0v[0],x0v[1],x0v[2]);
    }


    else
    {
      printF("unknown response=[%s]\n",(const char*)answer);
      gi.stopReadingCommandFile();
    }
    
  }
  if( userKnownSolution == "gaussianPlaneWave" )
  {
    // Save parameters in dbase so we can look them up in bcOptWave
    const Real kNorm  = max( REAL_MIN*1000., sqrt( SQR(kv[0]) + SQR(kv[1]) + SQR(kv[2] ) ) ); 
    dbase.get<Real>("kxGPW")   = kv[0]/kNorm;
    dbase.get<Real>("kyGPW")   = kv[1]/kNorm;
    dbase.get<Real>("kzGPW")   = kv[2]/kNorm; 
    dbase.get<Real>("x0GPW")   = x0v[0];
    dbase.get<Real>("y0GPW")   = x0v[1];
    dbase.get<Real>("z0GPW")   = x0v[2];
    dbase.get<Real>("betaGPW") = beta;
    dbase.get<Real>("k0GPW")   = k0;

  }
  gi.unAppendTheDefaultPrompt();

  gi.popGUI();  // pop dialog

  bool knownSolutionChosen = userKnownSolution!="unknownSolution";
  return knownSolutionChosen;
}


