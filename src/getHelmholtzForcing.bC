#include "CgWave.h"
#include "ParallelUtility.h"
#include "ParallelGridUtility.h"
#include "OGFunction.h"

// -------- function prototypes for Fortran routines --------
#define bcOptWave EXTERN_C_NAME(bcoptwave)
extern "C"
{

void bcOptWave( const int&nd, 
                const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
                const int&gridIndexRange, const int& dimRange, const int &isPeriodic, real&u, const real & un, const int&mask,
                const real&rsxy, const real&xy, real &uTemp1, real & uTemp2, 
                const int&boundaryCondition, const real & frequencyArray, 
                const DataBase *pdb, const int&ipar, const real&rpar, int&ierr );

}


// The getBcOptParameters macro is defined here:
#Include "boundaryConditionMacros.h"

// =======================================================================================================
/// \brief Fill in the forcing (right-hand-side) for the direct Helmholtz solver (solveHelmHoltz)
/// \details Fill in the interior forcing and boundary conditions 
/// \param f (output) 
// =======================================================================================================
int CgWave::getHelmholtzForcing( realCompositeGridFunction & f  )
{
  const int myid = max(0,Communication_Manager::My_Process_Number);
  const int np   = max(1,Communication_Manager::numberOfProcessors());

  const int & debug = dbase.get<int>("debug");

  const int & orderOfAccuracy = dbase.get<int>("orderOfAccuracy");
  const Real & c              = dbase.get<real>("c");
  const real & dt             = dbase.get<real>("dt");
  const int & upwind                = dbase.get<int>("upwind");
  // const real & ad4            = dbase.get<real>("ad4"); // coeff of the artificial dissipation.
  // bool useUpwindDissipation   = ad4  > 0.;
  bool useUpwindDissipation   = upwind!=0;
  const int & solveHelmholtz  = dbase.get<int>("solveHelmholtz");

  const int & numberOfFrequencies       = dbase.get<int>("numberOfFrequencies");
  const RealArray & frequencyArray      = dbase.get<RealArray>("frequencyArray");
  const RealArray & frequencyArraySave  = dbase.get<RealArray>("frequencyArraySave");  

  const aString & knownSolutionOption = dbase.get<aString>("knownSolutionOption"); 

  const int & applyKnownSolutionAtBoundaries = dbase.get<int>("applyKnownSolutionAtBoundaries"); // by default, do NOT apply known solution at boundaries

  const int & addForcing                  = dbase.get<int>("addForcing");
  const ForcingOptionEnum & forcingOption = dbase.get<ForcingOptionEnum>("forcingOption");
  const bool twilightZone = forcingOption==twilightZoneForcing; 

  const BoundaryConditionApproachEnum & bcApproach  = dbase.get<BoundaryConditionApproachEnum>("bcApproach");

  Range all; 
  f.updateToMatchGrid(cg,all,all,all,numberOfFrequencies);
  
  Index I1,I2,I3;

  if( forcingOption==helmholtzForcing )
  {
    printF("CgWave::getHelmholtzForcing: ***FILL IN RHS FOR DIRECT HELMHOLTZ SOLVER***\n");
    
    int current=0; // not used 
    real t=0.;

    int ipar[10];
    real rpar[10];
    ipar[1]=current;
    rpar[0]=t;
    rpar[1]=dt;
    // -- evaluate the forcing for a Helmholtz solve ---
    for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    {
      ipar[0]=grid;
      userDefinedForcing( f[grid], ipar,rpar );
    }
    
  }
  else
  {
    f=0.;
  }

  // -------- Fill in boundary conditions for the direct Helmholtz solver ---------

  Real t=0.; // this should not matter
  int numGhost = orderOfAccuracy/2;
  if( useUpwindDissipation ) numGhost++;

  const int assignBCForImplicit = 1; 

  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cg[grid];
    // const IntegerArray & gid = mg.gridIndexRange();
    
    OV_GET_SERIAL_ARRAY(Real,f[grid],fLocal);
    OV_GET_SERIAL_ARRAY(int,mg.mask(),maskLocal);

    // get parameters for calling fortran
    getBcOptParameters(f,fLocal,fLocal);

    int ierr=0;
    bcOptWave(mg.numberOfDimensions(),
              fLocal.getBase(0),fLocal.getBound(0),fLocal.getBase(1),fLocal.getBound(1),
              fLocal.getBase(2),fLocal.getBound(2),
              indexRangeLocal(0,0), dimLocal(0,0), mg.isPeriodic(0),
              *pu, *pun, *pmask, *prsxy, *pxy, *puTemp1, *puTemp2,
              bcLocal(0,0), frequencyArray(0), 
              pdb, ipar[0],rpar[0], ierr );

    // // ...swap periodic edges 
    // u[grid].periodicUpdate();
    // u[grid].updateGhostBoundaries();

    

  } // end for grid 


  return 0;
}