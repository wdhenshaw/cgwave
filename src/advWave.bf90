!
! =======================================================================
! ============ Optimized advance routines for CgWave ====================
! =======================================================================
!
! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
#Include "defineDiffOrder2f.h"
#Include "defineDiffOrder4f.h"

! 6th-order
#Include "defineDiffOrder6f.h"

! 8th order
#Include "defineDiffOrder8f.h"

! define macros to evaluate derivatives for the 6th order method (from maple/makeGetDerivativesMacros.maple)
#Include "../maple/defineGetSixthDerivativesMacros.h"



! ======================================================================================
!   Evaluate the TZ exact solution in 2D
! ======================================================================================
#beginMacro OGDERIV2D( ntd,nxd,nyd,nzd,i1,i2,i3,t, n,val)
  call ogDeriv(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t, n,val )
#endMacro

! ======================================================================================
!   Evaluate the TZ exact solution in 3D
! ======================================================================================
#beginMacro OGDERIV3D( ntd,nxd,nyd,nzd,i1,i2,i3,t, n,val)
  call ogDeriv(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t, n,val )
#endMacro

  

! ---------------------------------------------------------------------------
! Macro : beginLoopsMask
! ---------------------------------------------------------------------------
#beginMacro beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
    if( mask(i1,i2,i3).gt.0 )then
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoopsMask
! ---------------------------------------------------------------------------
#beginMacro endLoopsMask()
    end if
  end do
  end do
  end do
#endMacro

! ---------------------------------------------------------------------------
! Macro : beginLoops
! ---------------------------------------------------------------------------
#beginMacro beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoopsMask
! ---------------------------------------------------------------------------
#beginMacro endLoops()
  end do
  end do
  end do
#endMacro


#defineMacro LAP2D2(U,i1,i2,i3,c) \
                       (U(i1+1,i2,i3,c)-2.*U(i1,i2,i3,c)+U(i1-1,i2,i3,c))*dxsqi\
                      +(U(i1,i2+1,i3,c)-2.*U(i1,i2,i3,c)+U(i1,i2-1,i3,c))*dysqi
#defineMacro LAP3D2(U,i1,i2,i3,c) \
                       (U(i1+1,i2,i3,c)-2.*U(i1,i2,i3,c)+U(i1-1,i2,i3,c))*dxsqi\
                      +(U(i1,i2+1,i3,c)-2.*U(i1,i2,i3,c)+U(i1,i2-1,i3,c))*dysqi\
                      +(U(i1,i2,i3+1,c)-2.*U(i1,i2,i3,c)+U(i1,i2,i3-1,c))*dzsqi

#defineMacro LAP2D2POW2(U,i1,i2,i3,c) ( 6.*U(i1,i2,i3,c)   \
                      - 4.*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c))    \
                      +(U(i1+2,i2,i3,c)+U(i1-2,i2,i3,c)) )*dxi4 \
                      +( 6.*U(i1,i2,i3,c)    \
                      -4.*(U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c))    \
                      +(U(i1,i2+2,i3,c)+U(i1,i2-2,i3,c)) )*dyi4  \
                      +( 8.*U(i1,i2,i3,c)     \
                      -4.*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c)+U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c))   \
                      +2.*(U(i1+1,i2+1,i3,c)+U(i1-1,i2+1,i3,c)+U(i1+1,i2-1,i3,c)+U(i1-1,i2-1,i3,c)) )*dxdyi2

#defineMacro LAP3D2POW2(U,i1,i2,i3,c) ( 6.*U(i1,i2,i3,c)   \
        - 4.*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c))    \
            +(U(i1+2,i2,i3,c)+U(i1-2,i2,i3,c)) )*dxi4 \
       +(  +6.*U(i1,i2,i3,c)    \
         -4.*(U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c))    \
            +(U(i1,i2+2,i3,c)+U(i1,i2-2,i3,c)) )*dyi4\
       +(  +6.*U(i1,i2,i3,c)    \
         -4.*(U(i1,i2,i3+1,c)+U(i1,i2,i3-1,c))    \
            +(U(i1,i2,i3+2,c)+U(i1,i2,i3-2,c)) )*dzi4\
        +(8.*U(i1,i2,i3,c)     \
         -4.*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c)+U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c))   \
         +2.*(U(i1+1,i2+1,i3,c)+U(i1-1,i2+1,i3,c)+U(i1+1,i2-1,i3,c)+U(i1-1,i2-1,i3,c)) )*dxdyi2 \
        +(8.*U(i1,i2,i3,c)     \
         -4.*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c)+U(i1,i2,i3+1,c)+U(i1,i2,i3-1,c))   \
         +2.*(U(i1+1,i2,i3+1,c)+U(i1-1,i2,i3+1,c)+U(i1+1,i2,i3-1,c)+U(i1-1,i2,i3-1,c)) )*dxdzi2 \
        +(8.*U(i1,i2,i3,c)     \
         -4.*(U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c)+U(i1,i2,i3+1,c)+U(i1,i2,i3-1,c))   \
         +2.*(U(i1,i2+1,i3+1,c)+U(i1,i2-1,i3+1,c)+U(i1,i2+1,i3-1,c)+U(i1,i2-1,i3-1,c)) )*dydzi2 

#defineMacro LAP2D4(U,i1,i2,i3,c) ( -30.*U(i1,i2,i3,c)     \
        +16.*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c))     \
            -(U(i1+2,i2,i3,c)+U(i1-2,i2,i3,c)) )*dxsq12i + \
       ( -30.*U(i1,i2,i3,c)     \
        +16.*(U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c))     \
            -(U(i1,i2+2,i3,c)+U(i1,i2-2,i3,c)) )*dysq12i

#defineMacro LAP3D4(U,i1,i2,i3,c) ( -30.*U(i1,i2,i3,c)     \
        +16.*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c))     \
            -(U(i1+2,i2,i3,c)+U(i1-2,i2,i3,c)) )*dxsq12i + \
       ( -30.*U(i1,i2,i3,c)     \
        +16.*(U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c))     \
            -(U(i1,i2+2,i3,c)+U(i1,i2-2,i3,c)) )*dysq12i+ \
       ( -30.*U(i1,i2,i3,c)      \
        +16.*(U(i1,i2,i3+1,c)+U(i1,i2,i3-1,c))      \
            -(U(i1,i2,i3+2,c)+U(i1,i2,i3-2,c)) )*dzsq12i

#defineMacro LAP2D6(U,i1,i2,i3,c) \
               c00lap2d6*U(i1,i2,i3,c)     \
              +c10lap2d6*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c)) \
              +c01lap2d6*(U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c)) \
              +c20lap2d6*(U(i1+2,i2,i3,c)+U(i1-2,i2,i3,c)) \
              +c02lap2d6*(U(i1,i2+2,i3,c)+U(i1,i2-2,i3,c)) \
              +c30lap2d6*(U(i1+3,i2,i3,c)+U(i1-3,i2,i3,c)) \
              +c03lap2d6*(U(i1,i2+3,i3,c)+U(i1,i2-3,i3,c))

#defineMacro LAP3D6(U,i1,i2,i3,c) \
               c000lap3d6*U(i1,i2,i3,c) \
              +c100lap3d6*(U(i1+1,i2,i3,c)+U(i1-1,i2,i3,c)) \
              +c010lap3d6*(U(i1,i2+1,i3,c)+U(i1,i2-1,i3,c)) \
              +c001lap3d6*(U(i1,i2,i3+1,c)+U(i1,i2,i3-1,c)) \
              +c200lap3d6*(U(i1+2,i2,i3,c)+U(i1-2,i2,i3,c)) \
              +c020lap3d6*(U(i1,i2+2,i3,c)+U(i1,i2-2,i3,c)) \
              +c002lap3d6*(U(i1,i2,i3+2,c)+U(i1,i2,i3-2,c)) \
              +c300lap3d6*(U(i1+3,i2,i3,c)+U(i1-3,i2,i3,c)) \
              +c030lap3d6*(U(i1,i2+3,i3,c)+U(i1,i2-3,i3,c)) \
              +c003lap3d6*(U(i1,i2,i3+3,c)+U(i1,i2,i3-3,c))

! ===========================================================================================
! Macro: compute the coefficients in the sosup dissipation for curvilinear grids
! ===========================================================================================
#beginMacro getSosupDissipationCoeff2d(adxSosup)
 do dir=0,1
   ! diss-coeff ~= 1/(change in x along direction r(dir) )
   ! Assuming a nearly orthogonal grid gives ||dx|| = || grad_x(r_i) || / dr_i 
   adxSosup(dir) = adSosup*uDotFactor*sqrt( rsxy(i1,i2,i3,dir,0)**2 + rsxy(i1,i2,i3,dir,1)**2 )/dr(dir) 
 end do
#endMacro

#beginMacro getSosupDissipationCoeff3d(adxSosup)
 do dir=0,2
   ! diss-coeff ~= 1/(change in x along direction r(dir) )
   ! Assuming a nearly orthogonal grid gives ||dx|| = || grad_x(r_i) || / dr_i 
   adxSosup(dir) = adSosup*uDotFactor*sqrt( rsxy(i1,i2,i3,dir,0)**2 + rsxy(i1,i2,i3,dir,1)**2  + rsxy(i1,i2,i3,dir,2)**2 )/dr(dir) 
 end do
 ! write(*,'(" adxSosup =",3(1pe10.2))') (adxSosup(dir),dir=0,2)
#endMacro

! ===========================================================================================
! Macro: Output some debug info for the first few time-steps 
! ===========================================================================================
#beginMacro INFO(string)
if( t.le.3.*dt )then
  write(*,'("advMxUp>>>",string)')
end if
#endMacro

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (4th-order difference used with 2nd-order scheme) 
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d4(uDot,i1,i2,i3,n) \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                   -(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n)) )*adxSosup(0) + \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                   -(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n)) )*adxSosup(1)

#defineMacro sosupDiss3d4(uDot,i1,i2,i3,n) \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                   -(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n)) )*adxSosup(0) + \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                   -(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n)) )*adxSosup(1) + \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
                   -(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n)) )*adxSosup(2)

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (6th-order difference used with 4th-order scheme)
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d6(uDot,i1,i2,i3,n) \
             ( -20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                -6.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                   +(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))  )*adxSosup(0) + \
              (-20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                -6.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                   +(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))  )*adxSosup(1)

#defineMacro sosupDiss3d6(uDot,i1,i2,i3,n) \
             ( -20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                -6.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                   +(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))  )*adxSosup(0) + \
              (-20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                -6.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                   +(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))  )*adxSosup(1) + \
              (-20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
                -6.*(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n))     \
                   +(uDot(i1,i2,i3+3,n)+uDot(i1,i2,i3-3,n))  )*adxSosup(2)

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (8th-order difference used with 6th-order scheme)
! (x+y)^8 = x^8 + 8*x^7*y + 28*x^6*y^2 + 56*x^5*y^3 + 70*x^4*y^4 + 56*x^3*y^5 + 28*x^2*y^6 + 8*x*y^7 + y^8
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d8(uDot,i1,i2,i3,n) \
             ( -70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -28.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +8.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                   -(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))  )*adxSosup(0) + \
              (-70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -28.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +8.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                   -(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))  )*adxSosup(1)

#defineMacro sosupDiss3d8(uDot,i1,i2,i3,n) \
             ( -70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -28.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +8.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                   -(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))  )*adxSosup(0) + \
              (-70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -28.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +8.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                   -(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))  )*adxSosup(1) + \
              (-70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
               -28.*(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n))     \
                +8.*(uDot(i1,i2,i3+3,n)+uDot(i1,i2,i3-3,n))     \
                   -(uDot(i1,i2,i3+4,n)+uDot(i1,i2,i3-4,n))  )*adxSosup(2)              

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (10th-order difference used with 8th-order scheme)
! (x+y)^10 = x^10 + 10*x^9*y + 45*x^8*y^2 + 120*x^7*y^3 + 210*x^6*y^4 + 252*x^5*y^5 + 210*x^4*y^6 + 120*x^3*y^7 + 45*x^2*y^8 + 10*x*y^9 + y^10
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d10(uDot,i1,i2,i3,n) \
             ( -252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -120.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +45.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                -10.*(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))     \
                +    (uDot(i1+5,i2,i3,n)+uDot(i1-5,i2,i3,n))  )*adxSosup(0) + \
              (-252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -120.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +45.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                -10.*(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))     \
                +    (uDot(i1,i2+5,i3,n)+uDot(i1,i2-5,i3,n))  )*adxSosup(1)

#defineMacro sosupDiss3d10(uDot,i1,i2,i3,n) \
             ( -252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -120.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +45.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                -10.*(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))     \
                +    (uDot(i1+5,i2,i3,n)+uDot(i1-5,i2,i3,n))  )*adxSosup(0) + \
              (-252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -120.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +45.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                -10.*(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))     \
                +    (uDot(i1,i2+5,i3,n)+uDot(i1,i2-5,i3,n))  )*adxSosup(1) + \
              (-252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
               -120.*(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n))     \
                +45.*(uDot(i1,i2,i3+3,n)+uDot(i1,i2,i3-3,n))     \
                -10.*(uDot(i1,i2,i3+4,n)+uDot(i1,i2,i3-4,n))     \
                +    (uDot(i1,i2,i3+5,n)+uDot(i1,i2,i3-5,n))  )*adxSosup(2) 


! =========================================================================================
! Macro: Compute v=Delta(u) to second order for fourth-order scheme on curvilinear grids
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro computeLaplacianOrder2(DIM)
  ! write(*,'("advWave: COMPUTE V= LAP(U) TO SECOND ORDER dim=DIM")') 
  ! We need Lap2h(u) at an extra point 
  numGhost=orderOfAccuracy/2 -1 
  m1a=n1a-numGhost
  m1b=n1b+numGhost
  m2a=n2a-numGhost
  m2b=n2b+numGhost
  if( nd.eq.2 )then
  m3a=n3a
  m3b=n3b
  else
   m3a=n3a-numGhost
   m3b=n3b+numGhost
  end if
  ! write(*,'(" Lap(u) : numGhost=",i2," m1a,m1b,m2a,m2b=",4i4)') numGhost,m1a,m1b,m2a,m2b

  if( useSuperGrid==0 )then
    beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
     #If #DIM eq "2"
      v(i1,i2,i3,0) = uxx22(i1,i2,i3,0) + uyy22(i1,i2,i3,0)
      ! OGDERIV2D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      ! write(*,'(" i1,i2=",2i4," uxx2=",e10.2," true=",e10.2)') i1,i2,uxx22(i1,i2,i3,0),evxx(0)
     #Else
       v(i1,i2,i3,0) = uxx23(i1,i2,i3,0) + uyy23(i1,i2,i3,0) + uzz23(i1,i2,i3,0)
     #End 
    endLoops()

  else
    ! superGrid -- **Cartesian Grid**
    beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
     #If #DIM eq "2"
      v(i1,i2,i3,0) =  etax(i1,0)*uxx22r(i1,i2,i3,0) + etax(i1,1)*ux22r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy22r(i1,i2,i3,0) + etay(i2,1)*uy22r(i1,i2,i3,0)
      ! v(i1,i2,i3,0) = uxx22(i1,i2,i3,0) + uyy22(i1,i2,i3,0)
     #Else
       v(i1,i2,i3,0) = etax(i1,0)*uxx23r(i1,i2,i3,0) + etax(i1,1)*ux23r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy23r(i1,i2,i3,0) + etay(i2,1)*uy23r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz23r(i1,i2,i3,0) + etaz(i3,1)*uz23r(i1,i2,i3,0)
       ! v(i1,i2,i3,0) = uxx23(i1,i2,i3,0) + uyy23(i1,i2,i3,0) + uzz23(i1,i2,i3,0)
     #End 
    endLoops()

  end if


#endMacro
  
! =========================================================================================
! Macro: Compute the forcing for the update of u
! =========================================================================================
#beginMacro getForcing(DIM,ORDER,ORDERINTIME,GRIDTYPE) 
  if( addForcing.eq.0 )then
    ! THIS ADDED March 24, 2023 *** CHECK ME ***
    fv(m)=0.
  else if( forcingOption.eq.twilightZoneForcing )then
    if( nd.eq.2 )then
      OGDERIV2D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      OGDERIV2D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      OGDERIV2D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      OGDERIV2D( 0,0,2,0,i1,i2,i3,t, ec, evyy(m) )
      fv(m) = evtt(m) - csq*( evxx(m) + evyy(m) )
    else
      OGDERIV3D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      OGDERIV3D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      OGDERIV3D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      OGDERIV3D( 0,0,2,0,i1,i2,i3,t, ec, evyy(m) )
      OGDERIV3D( 0,0,0,2,i1,i2,i3,t, ec, evzz(m) )
      fv(m) = evtt(m) - csq*( evxx(m) + evyy(m)  + evzz(m) )
   end if
   #If ORDER ge 4 && ORDERINTIME ge 4
     #If #DIM eq "2"
       ! Correct forcing for fourth-order ME in2D
       OGDERIV2D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
       OGDERIV2D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(m) )
       OGDERIV2D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(m) )
       OGDERIV2D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(m) )
       fv(m) = fv(m) + (dtSq/12.)*evtttt(m) - (cdtsq12/dtSq)*( evxxxx(m) + 2.*evxxyy(m) + evyyyy(m) )
     #Else
       ! Correct forcing for fourth-order ME in 3D
       OGDERIV3D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
       OGDERIV3D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(m) )
       OGDERIV3D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(m) )
       OGDERIV3D( 0,2,0,2,i1,i2,i3,t, ec, evxxzz(m) )
       OGDERIV3D( 0,0,2,2,i1,i2,i3,t, ec, evyyzz(m) )
       OGDERIV3D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(m) )
       OGDERIV3D( 0,0,0,4,i1,i2,i3,t, ec, evzzzz(m) )
       fv(m) = fv(m) + (dtSq/12.)*evtttt(m) - (cdtsq12/dtSq)*( evxxxx(m) + 2.*( evxxyy(m) + evxxzz(m) + evyyzz(m) ) + evyyyy(m) + evzzzz(m) )       
     #End
   #End
   #If ORDER ge 6 && ORDERINTIME ge 6
     #If #DIM eq "2"
       ! Correct forcing for sixth-order ME in 2D
       OGDERIV2D( 6,0,0,0,i1,i2,i3,t, ec, evtttttt(m) )
       OGDERIV2D( 0,6,0,0,i1,i2,i3,t, ec, evxxxxxx(m) )
       OGDERIV2D( 0,4,2,0,i1,i2,i3,t, ec, evxxxxyy(m) )
       OGDERIV2D( 0,2,4,0,i1,i2,i3,t, ec, evxxyyyy(m) )
       OGDERIV2D( 0,0,6,0,i1,i2,i3,t, ec, evyyyyyy(m) )
       fv(m) = fv(m) + (dtSq**2/360.)*evtttttt(m) - (cdtPow6By360/dtSq)*( evxxxxxx(m) + evyyyyyy(m) + 3.*(evxxxxyy(m) + evxxyyyy(m) )  )
     #Else
       ! Correct forcing for sixth-order ME in 3D
       OGDERIV3D( 6,0,0,0,i1,i2,i3,t, ec, evtttttt(m) )
       OGDERIV3D( 0,6,0,0,i1,i2,i3,t, ec, evxxxxxx(m) )
       OGDERIV3D( 0,0,6,0,i1,i2,i3,t, ec, evyyyyyy(m) )
       OGDERIV3D( 0,0,0,6,i1,i2,i3,t, ec, evzzzzzz(m) )       

       OGDERIV3D( 0,4,2,0,i1,i2,i3,t, ec, evxxxxyy(m) )
       OGDERIV3D( 0,2,4,0,i1,i2,i3,t, ec, evxxyyyy(m) )
       OGDERIV3D( 0,4,0,2,i1,i2,i3,t, ec, evxxxxzz(m) )
       OGDERIV3D( 0,2,0,4,i1,i2,i3,t, ec, evxxzzzz(m) )

       OGDERIV3D( 0,0,4,2,i1,i2,i3,t, ec, evyyyyzz(m) )
       OGDERIV3D( 0,0,2,4,i1,i2,i3,t, ec, evyyzzzz(m) )

       OGDERIV3D( 0,2,2,2,i1,i2,i3,t, ec, evxxyyzz(m) )

       fv(m) = fv(m) + (dtSq**2/360.)*evtttttt(m) \
            - (cdtPow6By360/dtSq)*( evxxxxxx(m) + evyyyyyy(m) + evzzzzzz(m) \
                                + 3.*(evxxxxyy(m) + evxxyyyy(m) + evyyyyyy(m) + evyyyyzz(m) + evyyzzzz(m) )  + 6.*evxxyyzz(m)  )
     #End
   #End       

 else if( forcingOption.eq.helmholtzForcing )then

    ! forcing for solving the Helmholtz equation   
    ! NOTE: change sign of forcing since for Helholtz we want to solve
    !      ( omega^2 I + c^2 Delta) w = f 
    ! fv(m) = -f(i1,i2,i3,0)*coswt  

    fv(m)=0.
    do freq=0,numberOfFrequencies-1 
      omega = frequencyArray(freq)
      coswt = cosFreqt(freq)    
      #If #ORDERINTIME eq "2"
       ! if( i1.eq.2 .and. i2.eq.2 )then 
       !   write(*,'(" adv: forcing f(i1,i2,i3)=",1pe12.4," coswt=",1pe12.4," t=",1pe12.4," omega=",1pe12.4)') f(i1,i2,i3,0),coswt,t,omega
       ! end if

       ! fv(m) = -f(i1,i2,i3,0)*coswt  

       fv(m) = fv(m) - f(i1,i2,i3,freq)*coswt

      #Else
        ! Add corrections for 4th order modified equation 
        !  fv = f + (dt^2/12)*( c^2 Delta(u) + ftt )
        #If #GRIDTYPE eq "rectangular"
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22r(i1,i2,i3,freq) + fyy22r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23r(i1,i2,i3,freq) + fyy23r(i1,i2,i3,freq) + fzz23r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #End
        #Else
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22(i1,i2,i3,freq) + fyy22(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23(i1,i2,i3,freq) + fyy23(i1,i2,i3,freq) + fzz23(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #End
        #End           
      #End
    end do ! do freq  
 else if( addForcing.ne.0 )then  
    fv(m) = f(i1,i2,i3,0)
 end if


#endMacro

! =========================================================================================
!
! Macro: Advance the wave equation, EXPLICIT TIME-STEPPING
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveOpt(DIM,ORDER,ORDERINTIME,GRIDTYPE,FORCING)

  #If #FORCING eq "USEFORCING"
  #defineMacro FV(m) + tsf*fv(m)
  #Else
  #defineMacro FV(m) 
  #End

  if( (orderOfAccuracy.eq.6 .or. debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("advWave: ADVANCE dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE... t=",e10.2)') t
  end if
  

  ! --- TAYLOR TIME-STEPPING --- 
 
  m=0 ! component number 
  ec = 0 ! component number

  #If #GRIDTYPE eq "curvilinear"
    #If #ORDER eq "4" && #ORDERINTIME eq "4"
      computeLaplacianOrder2(DIM)
    #End
  #End
      
  if( forcingOption.eq.helmholtzForcing )then
    coswt = cos(omega*t)
  end if 

  fv(m)=0.
 ! ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
 ! #If #FORCING eq "NOFORCING"
 ! ! do not use mask for Cartesian grid , no forcing 
 beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #Else
 !  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #End

   #If #FORCING eq "USEFORCING"
    getForcing(DIM,ORDER,ORDERINTIME,GRIDTYPE) 
   #End

   #If #ORDER eq "2"

     ! --- SECOND ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( uxx22r(i1,i2,i3,0) + uyy22r(i1,i2,i3,0) ) FV(m)

        ! write(*,'(" adv: i1,i2=",2i4," un,u,um=",3e12.2," cdtSq,fv=",2e12.2)') i1,i2,un(i1,i2,i3,m),u(i1,i2,i3,m),um(i1,i2,i3,m),cdtSq,fv(m)

       #Else
         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( uxx22(i1,i2,i3,0)  + uyy22(i1,i2,i3,0) ) FV(m)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( uxx23r(i1,i2,i3,0) + uyy23r(i1,i2,i3,0) + uzz23r(i1,i2,i3,0) ) FV(m)
       #Else
         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( uxx23(i1,i2,i3,0)  + uyy23(i1,i2,i3,0)  + uzz23(i1,i2,i3,0)  ) FV(m)
       #End
     #End

   #Elif #ORDER eq "4"

     ! --- -FOURTH ORDER ---

     #If #DIM eq "2"
       ! --- FOUTH-ORDER TWO DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! orderInSpace=4 and orderInTime=4 
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) + cdtsq12*lap2d2pow2(i1,i2,i3,m) FV(m)
         #Else
           ! v is assumed to hold Lap(u) to 2nd-order
           ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
                                                           + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) FV(m)
         #End
       #Else
         ! orderInSpace==4 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) FV(m)
         #Else
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) FV(m)
         #End

       #End                                                          
     #Else
       ! --- FOURTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "4"
         ! orderInSpace=4 and orderInTime=4 
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap3d4(i1,i2,i3,m) + cdtsq12*lap3d2pow2(i1,i2,i3,m) FV(m)
         #Else
           ! v is assumed to hold Lap(u) to 2nd-order
           ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) \
                                                           + cdtsq12*( vxx23(i1,i2,i3,m) + vyy23(i1,i2,i3,m) + vzz23(i1,i2,i3,m) ) FV(m)
         #End
       #Else
         ! orderInSpace==4 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap3d4(i1,i2,i3,m) FV(m)
         #Else
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) FV(m)
         #End

       #End     


     #End

   #Elif #ORDER eq "6"
         
     ! ---- SIXTH ORDER ---

     #If #DIM eq "2"

       ! --- SIXTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

         ! orderInSpace==6 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx62r(i1,i2,i3,m) + uyy62r(i1,i2,i3,m) ) FV(m)
         #Else
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx62(i1,i2,i3,m)  +  uyy62(i1,i2,i3,m) ) FV(m)
         #End       

       #Else

         ! ---- MODIFIED EQUATION ORDER=6 2D -----

          write(*,*) "advWave: Order 6 ME is now done by another routine in advWaveME.bf90"
          stop 6666
         ! getSixthDerivatives2d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)


         if( i1.eq.21 .and. i2.eq.11 )then
           OGDERIV2D( 0,2,0,0,i1,i2,i3,t, ec, evxx(0) )
           OGDERIV2D( 0,0,2,0,i1,i2,i3,t, ec, evyy(0) )
           OGDERIV2D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(0) )
           OGDERIV2D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(0) )
           OGDERIV2D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(0) )
           write(*,'("i1,i2=",2i4)') i1,i2
           write(*,'(" uxx  =",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uxx  ,evxx(0)  ,abs(uxx  -evxx(0)  )
           write(*,'(" uyy  =",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uyy  ,evyy(0)  ,abs(uyy  -evyy(0)  )
           write(*,'(" uxxxx=",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uxxxx,evxxxx(0),abs(uxxxx-evxxxx(0))
           write(*,'(" uxxyy=",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uxxyy,evxxyy(0),abs(uxxyy-evxxyy(0))
           write(*,'(" uyyyy=",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uyyyy,evyyyy(0),abs(uyyyy-evyyyy(0))

! uxxxx    = rxi**4*urrrr+4.*rxi**3*sxi*urrrs+6.*rxi**2*sxi**2*urrss+4.*rxi*sxi**3*ursss+sxi**4*ussss+6.*rxi**2*rxx*urrr+(7.*sxi*rxi*rxx+sxx*rxi**2+rxi*(3.*rxi*sxx+3.*rxx*sxi)+rxi*(2.*rxi*sxx+2.*rxx*sxi))*urrs+(sxi*(3.*rxi*sxx+3.*rxx*sxi)+7.*rxi*sxx*sxi+rxx*sxi**2+sxi*(2.*rxi*sxx+2.*rxx*sxi))*urss+6.*sxi**2*sxx*usss+(4.*rxi*rxxx+3.*rxx**2)*urr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*urs+(4.*sxi*sxxx+3.*sxx**2)*uss+rxxxx*ur+sxxxx*us

           stop 1111
         end if
         ! cdtPow4By12  = (c*dt)^4/12 
         ! cdtPow6By360 = (c*dt)^6/360

         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                         + cdtSq*( uxx + uyy ) \
                         + cdtPow4By12*( uxxxx + uyyyy + 2.*uxxyy )  \
                         + cdtPow6By360*( uxxxxxx + uyyyyyy + 3.*(uxxxxyy + uxxyyyy) ) \
                         FV(m)

       #End                                                          

    #Else

       ! --- SIXTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! orderInSpace==6 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx63r(i1,i2,i3,m) + uyy63r(i1,i2,i3,m) + uzz63r(i1,i2,i3,m) ) FV(m)
         #Else
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx63(i1,i2,i3,m)  + uyy63(i1,i2,i3,m)  + uzz63(i1,i2,i3,m) )  FV(m)
         #End       

       #Else

         ! MODIFIED EQUATION ORDER=6 3D

         ! Turn off for now: 
         ! getSixthDerivatives3d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

         write(*,'("advWave: order=ORDER, orderInTime=ORDERINTIME FINISH ME")')
         stop 7777

         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                         + cdtSq*( uxx + uyy +uzz ) \
                         + cdtPow4By12*( uxxxx + uyyyy + uzzzz + 2.*( uxxyy +uxxzz + uyyzz ) )  \
                         + cdtPow6By360*( uxxxxxx +  uyyyyyy + uzzzzzz + 3.*(uxxxxyy + uxxyyyy + uxxxxzz + uyyyyzz + uxxzzzz + uyyzzzz ) + 6.*uxxyyzz ) \
                         FV(m)

       #End     


     #End

   #Elif #ORDER eq "8"
         
     ! ---- EIGTH ORDER ---

     #If #DIM eq "2"

       ! --- EIGTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

         ! orderInSpace==8 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx82r(i1,i2,i3,m) + uyy82r(i1,i2,i3,m) ) FV(m)
         #Else
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx82(i1,i2,i3,m)  +  uyy82(i1,i2,i3,m) ) FV(m)
         #End       

       #Else

         write(*,'("advWave: order=ORDER, orderInTime=ORDERINTIME FINISH ME")')
         stop 7777

         ! ! orderInSpace=4 and orderInTime=4 
         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) + cdtsq12*lap2d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End


       #End                                                          

    #Else

       ! --- EIGTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! orderInSpace==8 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx83r(i1,i2,i3,m) + uyy83r(i1,i2,i3,m) + uzz83r(i1,i2,i3,m) )  FV(m)
         #Else
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( uxx83(i1,i2,i3,m)  + uyy83(i1,i2,i3,m)  + uzz83(i1,i2,i3,m)  )  FV(m)
         #End       

       #Else

         write(*,'("advWave: order=ORDER, orderInTime=ORDERINTIME FINISH ME")')
         stop 7777

         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap3d4(i1,i2,i3,m) + cdtsq12*lap3d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx23(i1,i2,i3,m) + vyy23(i1,i2,i3,m) + vzz23(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End

       #End     


     #End


   #Else

     write(*,'("advWave: UNKNOWN order=ORDER")')
     stop 7777

   #End         

   ! write(*,'("i1,i2=",2i3," u-ue=",e10.2)') i1,i2,u(i1,i2,i3,m)-ev(m)

   ! write(*,'(" uxx-uxxe =",e10.2)') uxx22r(i1,i2,i3,0)-evxx(m)

   ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t+dt, ec, ev(m)  )
   ! write(*,'(" un-ue=",e10.2)') un(i1,i2,i3,m)-ev(m)

  ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
  !#If #FORCING eq "NOFORCING"
  endLoops()
  !#Else
  ! endLoopsMask()
  !#End


#endMacro
  


! =========================================================================================
!
! Macro: Advance the wave equation, EXPLICIT TIME-STEPPING and 
!
!     +++++++++ SUPERGRID ++++++++++++++
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveOptSuperGrid(DIM,ORDER,ORDERINTIME,GRIDTYPE,FORCING)

  #If #FORCING eq "USEFORCING"
  #defineMacro FV(m) + tsf*fv(m)
  #Else
  #defineMacro FV(m) 
  #End

  if( (orderOfAccuracy.eq.2 .or. debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("advWave: ADVANCE SUPERGRID dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE... t=",e10.2)') t
  end if
  
  #If #GRIDTYPE eq "curvilinear"
    write(*,'("advWave: ADVANCE SUPERGRID: This function should not be called for curvilinear grids, use normal one.")' )
    stop 666
  #End

  ! --- TAYLOR TIME-STEPPING --- 
 
  m=0 ! component number 
  ec = 0 ! component number

  #If #ORDER eq "4" && #ORDERINTIME eq "4"
    computeLaplacianOrder2(DIM)
  #End
      
  if( forcingOption.eq.helmholtzForcing )then
    coswt = cos(omega*t)
  end if 

  fv(m)=0.
 ! ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
 ! #If #FORCING eq "NOFORCING"
 ! ! do not use mask for Cartesian grid , no forcing 
 beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #Else
 !  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #End

   #If #FORCING eq "USEFORCING"
    getForcing(DIM,ORDER,ORDERINTIME,GRIDTYPE) 
   #End

   #If #ORDER eq "2"

     ! --- SECOND ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) \
              + (cdtSq)*( etax(i1,0)*uxx22r(i1,i2,i3,0) + etax(i1,1)*ux22r(i1,i2,i3,0) \
                        + etay(i2,0)*uyy22r(i1,i2,i3,0) + etay(i2,1)*uy22r(i1,i2,i3,0) ) FV(m)

       ! write(*,'(" adv: i1,i2=",2i4," un,u,um=",3e12.2," cdtSq,fv=",2e12.2)') i1,i2,un(i1,i2,i3,m),u(i1,i2,i3,m),um(i1,i2,i3,m),cdtSq,fv(m)

     #Else
       ! --- THREE DIMENSIONS ---

        un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) \
           + (cdtSq)*( etax(i1,0)*uxx23r(i1,i2,i3,0) + etax(i1,1)*ux23r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy23r(i1,i2,i3,0) + etay(i2,1)*uy23r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz23r(i1,i2,i3,0) + etaz(i3,1)*uz23r(i1,i2,i3,0) ) FV(m)

     #End

   #Elif #ORDER eq "4"

     ! --- -FOURTH ORDER ---

     #If #DIM eq "2"
       ! --- FOUTH-ORDER TWO DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 2D, orderInSpace=4 and orderInTime=4 

          ! v is assumed to hold Lap(u) to 2nd-order
          un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                 + cdtSq*( etax(i1,0)*uxx42r(i1,i2,i3,0) + etax(i1,1)*ux42r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy42r(i1,i2,i3,0) + etay(i2,1)*uy42r(i1,i2,i3,0) ) \
               + cdtsq12*( etax(i1,0)*vxx22r(i1,i2,i3,0) + etax(i1,1)*vx22r(i1,i2,i3,0)   \
                         + etay(i2,0)*vyy22r(i1,i2,i3,0) + etay(i2,1)*vy22r(i1,i2,i3,0) ) \
                 FV(m)
       #Else
         ! 2D orderInSpace==4 and orderInTime==2
         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                 + cdtSq*( etax(i1,0)*uxx42r(i1,i2,i3,0) + etax(i1,1)*ux42r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy42r(i1,i2,i3,0) + etay(i2,1)*uy42r(i1,i2,i3,0) ) \
                 FV(m)                                                            

       #End                                                          
     #Else
       ! --- FOURTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "4"
         ! 3D, orderInSpace=4 and orderInTime=4 

          un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) \
               + (cdtSq)*( etax(i1,0)*uxx43r(i1,i2,i3,0) + etax(i1,1)*ux43r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy43r(i1,i2,i3,0) + etay(i2,1)*uy43r(i1,i2,i3,0)   \
                         + etaz(i3,0)*uzz43r(i1,i2,i3,0) + etaz(i3,1)*uz43r(i1,i2,i3,0) ) \
               + cdtsq12*( etax(i1,0)*vxx23r(i1,i2,i3,0) + etax(i1,1)*vx23r(i1,i2,i3,0)   \
                         + etay(i2,0)*vyy23r(i1,i2,i3,0) + etay(i2,1)*vy23r(i1,i2,i3,0)   \
                         + etaz(i3,0)*vzz23r(i1,i2,i3,0) + etaz(i3,1)*vz23r(i1,i2,i3,0) ) \
                                          FV(m)

        #Else
         ! 3D, orderInSpace==4 and orderInTime==2                                                   

          un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) \
           + (cdtSq)*( etax(i1,0)*uxx43r(i1,i2,i3,0) + etax(i1,1)*ux43r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy43r(i1,i2,i3,0) + etay(i2,1)*uy43r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz43r(i1,i2,i3,0) + etaz(i3,1)*uz43r(i1,i2,i3,0) ) FV(m)

       #End     


     #End

   #Elif #ORDER eq "6"
         
     ! ---- SIXTH ORDER ---

     #If #DIM eq "2"

       ! --- SIXTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

        ! 2D, orderInSpace==6 and orderInTime==2
        un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                 + cdtSq*( etax(i1,0)*uxx62r(i1,i2,i3,0) + etax(i1,1)*ux62r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy62r(i1,i2,i3,0) + etay(i2,1)*uy62r(i1,i2,i3,0) ) \
                 FV(m)                                                                        

       #Else

         ! ---- MODIFIED EQUATION ORDER=6 2D -----

          write(*,'("advWave: ADVANCE SUPERGRID: order 6 FINISH ME.")' )
          stop 666

         ! getSixthDerivatives2d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

         ! cdtPow4By12  = (c*dt)^4/12 
         ! cdtPow6By360 = (c*dt)^6/360

         ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
         !                 + cdtSq*( uxx + uyy ) \
         !                 + cdtPow4By12*( uxxxx + uyyyy + 2.*uxxyy )  \
         !                 + cdtPow6By360*( uxxxxxx + uyyyyyy + 3.*(uxxxxyy + uxxyyyy) ) \
         !                 FV(m)

       #End                                                          

    #Else

       ! --- SIXTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! 3D, orderInSpace==6 and orderInTime==2  

          un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) \
           + (cdtSq)*( etax(i1,0)*uxx63r(i1,i2,i3,0) + etax(i1,1)*ux63r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy63r(i1,i2,i3,0) + etay(i2,1)*uy63r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz63r(i1,i2,i3,0) + etaz(i3,1)*uz63r(i1,i2,i3,0) ) FV(m)

       #Else

         ! MODIFIED EQUATION ORDER=6 3D
          write(*,'("advWave: ADVANCE SUPERGRID: order 6 3D FINISH ME.")' )
          stop 666         

         ! Turn off for now: 
         ! getSixthDerivatives3d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

         ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
         !                 + cdtSq*( uxx + uyy +uzz ) \
         !                 + cdtPow4By12*( uxxxx + uyyyy + uzzzz + 2.*( uxxyy +uxxzz + uyyzz ) )  \
         !                 + cdtPow6By360*( uxxxxxx +  uyyyyyy + uzzzzzz + 3.*(uxxxxyy + uxxyyyy + uxxxxzz + uyyyyzz + uxxzzzz + uyyzzzz ) + 6.*uxxyyzz ) \
         !                 FV(m)

       #End     


     #End

   #Elif #ORDER eq "8"
         

     ! ---- EIGTH ORDER ---

     #If #DIM eq "2"

       ! --- EIGTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

         ! 2D, orderInSpace==8 and orderInTime==2   
         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                 + cdtSq*( etax(i1,0)*uxx82r(i1,i2,i3,0) + etax(i1,1)*ux82r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy82r(i1,i2,i3,0) + etay(i2,1)*uy82r(i1,i2,i3,0) ) \
                 FV(m)                                                                                      

       #Else


         write(*,'("advWave: ADVANCE SUPERGRID: order 8 FINISH ME.")' )
         stop 666

         ! ! orderInSpace=4 and orderInTime=4 
         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) + cdtsq12*lap2d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End


       #End                                                          

    #Else

       ! --- EIGHTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! 3D, orderInSpace==8 and orderInTime==2   

          un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) \
           + (cdtSq)*( etax(i1,0)*uxx83r(i1,i2,i3,0) + etax(i1,1)*ux83r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy83r(i1,i2,i3,0) + etay(i2,1)*uy83r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz83r(i1,i2,i3,0) + etaz(i3,1)*uz83r(i1,i2,i3,0) ) FV(m)

       #Else

         write(*,'("advWave: ADVANCE SUPERGRID: order 8 FINISH ME.")' )
         stop 666

         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap3d4(i1,i2,i3,m) + cdtsq12*lap3d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx23(i1,i2,i3,m) + vyy23(i1,i2,i3,m) + vzz23(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End

       #End     


     #End


   #Else

     write(*,'("advWave: UNKNOWN order=ORDER")')
     stop 7777

   #End         

   ! write(*,'("i1,i2=",2i3," u-ue=",e10.2)') i1,i2,u(i1,i2,i3,m)-ev(m)

   ! write(*,'(" uxx-uxxe =",e10.2)') uxx22r(i1,i2,i3,0)-evxx(m)

   ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t+dt, ec, ev(m)  )
   ! write(*,'(" un-ue=",e10.2)') un(i1,i2,i3,m)-ev(m)

  ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
  !#If #FORCING eq "NOFORCING"
  endLoops()
  !#Else
  ! endLoopsMask()
  !#End


#endMacro
  

! =========================================================================================
! Macro: Compute the forcing for the IMPLICIT update of u
! =========================================================================================
#beginMacro getForcingImplicit(DIM,ORDER,ORDERINTIME,GRIDTYPE)
  if( addForcing.eq.0 )then ! *wdh* Tues March 28, 2023
    fv(m) = 0.
  else if( forcingOption.eq.twilightZoneForcing )then
    if( nd.eq.2 )then
      ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      OGDERIV2D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      fv(m) = evtt(m)
      ! We weight the TZ forcing with the implicit weights to make the solution exact for polynomials
      do mt=-1,1
        tm = t + dt*mt
        OGDERIV2D( 0,2,0,0,i1,i2,i3,tm, ec, evxx(m) )
        OGDERIV2D( 0,0,2,0,i1,i2,i3,tm, ec, evyy(m) )
        fv(m) = fv(m) -csq*( cImp(mt,0)*( evxx(m) + evyy(m) )  )
      end do

    else
      ! OGDERIV3D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )

      OGDERIV3D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      fv(m) = evtt(m)
      ! We weight the TZ forcing with the implicit weights to make the solution exact for polynomials
      do mt=-1,1
        tm = t + dt*mt       
        OGDERIV3D( 0,2,0,0,i1,i2,i3,tm, ec, evxx(m) )
        OGDERIV3D( 0,0,2,0,i1,i2,i3,tm, ec, evyy(m) )
        OGDERIV3D( 0,0,0,2,i1,i2,i3,tm, ec, evzz(m) )
        fv(m) = fv(m) -csq*( cImp(mt,0)*( evxx(m) + evyy(m) + evzz(m) )  ) 
      end do
   end if

   #If #ORDER eq "4" && #ORDERINTIME eq "4"
     #If #DIM eq "2"
       ! Correct forcing for fourth-order ME
       ! WHAT SHOULD THIS BE FOR IMPLICIT ?
       write(*,'("getForcingImplicit: finish me for ME order 4, 2D")')
       stop 2222
       OGDERIV2D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
       OGDERIV2D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(m) )
       OGDERIV2D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(m) )
       OGDERIV2D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(m) )
       fv(m) = fv(m) + (dtSq/12.)*evtttt(m) - (cdtsq12/dtSq)*( evxxxx(m) + 2.*evxxyy(m) + evyyyy(m) )
     #Else
       write(*,'("getForcingImplicit: finish me for ME order 4, 3D")')
       stop 3333
     #End
   #End

 else if( forcingOption.eq.helmholtzForcing )then
   ! forcing for solving the Helmholtz equation   
   ! NOTE: change sign of forcing since for Helholtz we want to solve
   !      ( omega^2 I + c^2 Delta) w = f    
   ! Define
   !   coswtAve = cImp(-1)*cos(omega*(t-dt)) + cImp(0)*cos(omega*t) + cImp(1)*cos(omega*(t+dt))
    fv(m)=0. 
    do freq=0,numberOfFrequencies-1
      omega = frequencyArray(freq)
      #If #ORDERINTIME eq "2" 
        fv(m) = fv(m) -f(i1,i2,i3,freq)*coswtAve(freq)    
      #Else
        ! Add corrections for 4th order modified equation 
        !  fv = f + (dt^2/12)*( c^2 Delta(u) + ftt )
        #If #GRIDTYPE eq "rectangular"
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22r(i1,i2,i3,freq) + fyy22r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq)
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23r(i1,i2,i3,freq) + fyy23r(i1,i2,i3,freq) + fzz23r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq) 
          #End
        #Else
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22(i1,i2,i3,freq) + fyy22(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq)
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23(i1,i2,i3,freq) + fyy23(i1,i2,i3,freq) + fzz23(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq) 
          #End
        #End           
      #End
    end do
 else if( addForcing.ne.0 )then  
    fv(m) = f(i1,i2,i3,0)
 end if

#endMacro

! =========================================================================================
!
! Macro: FILL IN THE RHS FOR IMPLICIT TIME-STEPPING
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveImplicitOpt(DIM,ORDER,ORDERINTIME,GRIDTYPE,FORCING)

  if( (debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("advWave: ADVANCE IMPLICIT dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE, t=",e10.2)') t
  end if
  

  ! --- IMPLICIT TAYLOR TIME-STEPPING --- 
  !  D+t D-t u = c^2 Delta( cImp(1) *u^{n+1} + cImp(0) *u^n + cImp(-1)* u^{n-1} )

  m=0 ! component number 
  ec = 0 ! component number

  ! #If #GRIDTYPE eq "curvilinear"
  !   #If #ORDER eq "4" && #ORDERINTIME eq "4"
  !     computeLaplacianOrder2(DIM)
  !   #End
  ! #End
      
  if( forcingOption.eq.helmholtzForcing .and. addForcing.ne.0 )then
    do freq=0,numberOfFrequencies-1
      coswt = cos(frequencyArray(freq)*t) ! is this used?
      omega = frequencyArray(freq)
      coswtAve(freq) = cImp(-1,0)*cos(omega*(t-dt)) + cImp(0,0)*cos(omega*t) + cImp(1,0)*cos(omega*(t+dt))
    end do

    ! coswt = cos(omega*t)
    ! coswtAve = cImp(-1,0)*cos(omega*(t-dt)) + cImp(0,0)*cos(omega*t) + cImp(1,0)*cos(omega*(t+dt))    
  end if 

  fv(m)=0.
  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

    getForcingImplicit(DIM,ORDER,ORDERINTIME,GRIDTYPE)



   #If #ORDER eq "2"

     ! --- SECOND ORDER ---

     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx22r(i1,i2,i3,0) +  uyy22r(i1,i2,i3,0) )  \
                                                              + ts4*(umxx22r(i1,i2,i3,0) + umyy22r(i1,i2,i3,0) )  \
                                                              + tsf*fv(m)       
         ! #If #FIRSTSTEP eq "firstStep"
         !   ! first-step implicit:
         !   !   Assumes um = ut(t=0) 
         !   ! AND 
         !   !   cImp(1,0) = cImp(-1,0)
         !   !   RHS = u + dt*ut + (dt^2/2)*L * ( cImp(0,0)*u - 2.*dt*cImp(1,0)*ut ) + .5*dt^2 * f
         !   !
         !   un(i1,i2,i3,m)= u(i1,i2,i3,m) + dt*um(i1,i2,i3,m) + (.5*cdtSq)*(       cImp( 0,0) *( uxx22r(i1,i2,i3,0) +  uyy22r(i1,i2,i3,0) )   \
         !                                                                   -2.*dt*cImp(-1,0) *(umxx22r(i1,i2,i3,0) + umyy22r(i1,i2,i3,0) ) )  \
         !                                                     + .5*dtSq*fv(m)       
         ! #Else

         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *( uxx22r(i1,i2,i3,0) +  uyy22r(i1,i2,i3,0) ) +  \
         !                                                                 cImp(-1,0) *(umxx22r(i1,i2,i3,0) + umyy22r(i1,i2,i3,0) ) )  \
         !                                                     + dtSq*fv(m)
         ! #End                                                  
       #Else

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx22(i1,i2,i3,0) +  uyy22(i1,i2,i3,0) )  \
                                                              + ts4*(umxx22(i1,i2,i3,0) + umyy22(i1,i2,i3,0) )  \
                                                              + tsf*fv(m)                
         ! #If #FIRSTSTEP eq "firstStep"
         !  un(i1,i2,i3,m)= u(i1,i2,i3,m) + dt*um(i1,i2,i3,m) + (.5*cdtSq)*(       cImp( 0,0) *( uxx22(i1,i2,i3,0) +  uyy22(i1,i2,i3,0) )   \
         !                                                                  -2.*dt*cImp(-1,0) *(umxx22(i1,i2,i3,0) + umyy22(i1,i2,i3,0) ) )  \
         !                                                     + .5*dtSq*fv(m)                                                                    
         ! #Else                                                    
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *(  uxx22(i1,i2,i3,0) +  uyy22(i1,i2,i3,0) ) +  \
         !                                                                 cImp(-1,0) *( umxx22(i1,i2,i3,0) + umyy22(i1,i2,i3,0) ) )  \
         !                                                     + dtSq*fv(m)
         ! #End                                                   
       #End
     #Else
       ! --- THREE DIMENSIONS ---

       #If #GRIDTYPE eq "rectangular"

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx23r(i1,i2,i3,0) +  uyy23r(i1,i2,i3,0) +  uzz23r(i1,i2,i3,0) )  \
                                                               + ts4*( umxx23r(i1,i2,i3,0) + umyy23r(i1,i2,i3,0) + umzz23r(i1,i2,i3,0) )  \
                                                               + tsf*fv(m)       

         ! #If #FIRSTSTEP eq "firstStep"
         !   ! first-step implicit:
         !   !   Assumes um = ut(t=0) 
         !   ! AND 
         !   !   cImp(1,0) = cImp(-1,0)
         !   !   RHS = u + dt*ut + (dt^2/2)*L * ( cImp(0,0)*u - 2.*dt*cImp(1,0)*ut ) + .5*dt^2 * f
         !   !
         !   un(i1,i2,i3,m)= u(i1,i2,i3,m) +dt*um(i1,i2,i3,m) + (.5*cdtSq)*(       cImp( 0,0) *(  uxx23r(i1,i2,i3,0) +  uyy23r(i1,i2,i3,0) +  uzz23r(i1,i2,i3,0) )  \
         !                                                                  -2.*dt*cImp(-1,0) *( umxx23r(i1,i2,i3,0) + umyy23r(i1,i2,i3,0) + umzz23r(i1,i2,i3,0) ) )  \
         !                                                     + .5*dtSq*fv(m)
         ! #Else
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *(  uxx23r(i1,i2,i3,0) +  uyy23r(i1,i2,i3,0) +  uzz23r(i1,i2,i3,0) ) + \
         !                                                                 cImp(-1,0) *( umxx23r(i1,i2,i3,0) + umyy23r(i1,i2,i3,0) + umzz23r(i1,i2,i3,0) ) )  \
         !                                                     + dtSq*fv(m)
         ! #End
       #Else
        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx23(i1,i2,i3,0) +  uyy23(i1,i2,i3,0) +  uzz23(i1,i2,i3,0) )  \
                                                               + ts4*( umxx23(i1,i2,i3,0) + umyy23(i1,i2,i3,0) + umzz23(i1,i2,i3,0) )  \
                                                               + tsf*fv(m)           
       !   #If #FIRSTSTEP eq "firstStep"
       !     un(i1,i2,i3,m)= u(i1,i2,i3,m) +dt*um(i1,i2,i3,m) + (.5*cdtSq)*(       cImp( 0,0) *(  uxx23(i1,i2,i3,0) +  uyy23(i1,i2,i3,0) +  uzz23(i1,i2,i3,0) )  \
       !                                                                    -2.*dt*cImp(-1,0) *( umxx23(i1,i2,i3,0) + umyy23(i1,i2,i3,0) + umzz23(i1,i2,i3,0) ) )  \
       !                                                       + .5*dtSq*fv(m)                                                             
       !   #Else                                                             
       !     un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *(  uxx23(i1,i2,i3,0)  +  uyy23(i1,i2,i3,0)  +  uzz23(i1,i2,i3,0) ) + \
       !                                                                   cImp(-1,0) *( umxx23(i1,i2,i3,0)  + umyy23(i1,i2,i3,0)  + umzz23(i1,i2,i3,0) )  ) \
       !                                                   + dtSq*fv(m)
       !   #End

       #End
     #End

   #Else
     ! --- -FOURTH ORDER ---
      #If #FIRSTSTEP eq "firstStep"
         write(*,'(" TAKE IMPLICIT FIRST STEP : FINISH ME")')
         stop 2323
      #End     

     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 2D orderInSpace=4 and orderInTime=4 IMPLICIT
         #If #GRIDTYPE eq "rectangular"

           write(*,'("advWave: finish me for GRIDTYPE IMPLICIT order=ORDER, dim=DIM")')
           stop 4444

           ! This could be maybe optimized by first computing w = cImp(0)*u + cImp(-1)*um and then computing laplacian(w)
           ! FIX ME : Need different Implicit weights for lap^2
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( cImp( 0,0)*LAP2D4(u ,i1,i2,i3,m)       \
                                                          +          cImp(-1,0)*LAP2D4(um,i1,i2,i3,m) )     \
                                                         + cdtsq12*( cImp( 0,1)*LAP2D2POW2(u ,i1,i2,i3,m)   \
                                                         +           cImp(-1,1)*LAP2D2POW2(um,i1,i2,i3,m) ) \
                                                         + dtSq*fv(m)
         #Else
           write(*,'("advWave: finish me for IMPLICIT order=ORDER, dim=DIM")')
           stop 4444
           ! v is assumed to hold Lap(u) to 2nd-order
           ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
                                                           + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) + dtSq*fv(m)
         #End

       #Else

         ! 2D orderInSpace==4 and orderInTime==2  IMPLICIT                                                 
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42r(i1,i2,i3,0) +  uyy42r(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42r(i1,i2,i3,0) + umyy42r(i1,i2,i3,0) )  \
                                                                 + tsf*fv(m)             
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *( uxx42r(i1,i2,i3,0) +  uyy42r(i1,i2,i3,0) ) +  \
           !                                                               cImp(-1,0) *(umxx42r(i1,i2,i3,0) + umyy42r(i1,i2,i3,0) ) )  \
           !                                                   + dtSq*fv(m)         
         #Else
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42(i1,i2,i3,0) +  uyy42(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42(i1,i2,i3,0) + umyy42(i1,i2,i3,0) )  \
                                                                 + tsf*fv(m)               
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *(  uxx42(i1,i2,i3,0) +  uyy42(i1,i2,i3,0) ) +   \
           !                                                               cImp(-1,0) *( umxx42(i1,i2,i3,0) + umyy42(i1,i2,i3,0) ) )   \
           !                                                   + dtSq*fv(m)                                                             
         #End

       #End                                                          
     #Else

       ! --- THREE DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 3D orderInSpace=4 and orderInTime=4 IMPLICIT
         #If #GRIDTYPE eq "rectangular"
           write(*,'("advWave: finish me for IMPLICIT order=ORDER, dim=DIM")')
           stop 4444
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) + cdtsq12*lap2d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         #Else
           write(*,'("advWave: finish me for IMPLICIT order=ORDER, dim=DIM")')
           stop 4444
           ! v is assumed to hold Lap(u) to 2nd-order
           ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
                                                           + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) + dtSq*fv(m)
         #End

       #Else

         ! 3D orderInSpace==4 and orderInTime==2 IMPLICIT                                                  
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx43r(i1,i2,i3,0) +  uyy43r(i1,i2,i3,0) +  uzz43r(i1,i2,i3,0) )  \
                                                                  + ts4*( umxx43r(i1,i2,i3,0) + umyy43r(i1,i2,i3,0) + umzz43r(i1,i2,i3,0) )  \
                                                                  + tsf*fv(m)          
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *( uxx43r(i1,i2,i3,0) +  uyy43r(i1,i2,i3,0) +  uzz43r(i1,i2,i3,0) ) +  \
           !                                                               cImp(-1,0) *(umxx43r(i1,i2,i3,0) + umyy43r(i1,i2,i3,0) + umzz43r(i1,i2,i3,0) ) )  \
           !                                                   + dtSq*fv(m)         
         #Else
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx43(i1,i2,i3,0) +  uyy43(i1,i2,i3,0) +  uzz43(i1,i2,i3,0) )  \
                                                                  + ts4*( umxx43(i1,i2,i3,0) + umyy43(i1,i2,i3,0) + umzz43(i1,i2,i3,0) )  \
                                                                  + tsf*fv(m)                     
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *(  uxx43(i1,i2,i3,0) +  uyy43(i1,i2,i3,0) +  uzz43(i1,i2,i3,0) ) +   \
           !                                                               cImp(-1,0) *( umxx43(i1,i2,i3,0) + umyy43(i1,i2,i3,0) + umzz43(i1,i2,i3,0) ) )   \
           !                                                   + dtSq*fv(m)                                                             
         #End
      #End

     #End


   #End         

   ! write(*,'("i1,i2=",2i3," u-ue=",e10.2)') i1,i2,u(i1,i2,i3,m)-ev(m)

   ! write(*,'(" uxx-uxxe =",e10.2)') uxx22r(i1,i2,i3,0)-evxx(m)

   ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t+dt, ec, ev(m)  )
   ! write(*,'(" un-ue=",e10.2)') un(i1,i2,i3,m)-ev(m)


  endLoopsMask()



#endMacro



! =========================================================================================
! Macro: ADD UPWIND DISSIPATION
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro addUpwindDiss(DIM,ORDER,GRIDTYPE,uDot)

  if( debug.gt.3 .and. t.lt.4*dt )then
    write(*,'("addUpwindDiss: UPWIND DISS using u.t=uDot dim=DIM order=ORDER grid=GRIDTYPE... t=",e10.2)') t
    write(*,'(" adxSosup=",3e12.4)') adxSosup(0), adxSosup(1),adxSosup(2)
  end if
  

  m=0 ! component number 
  ec = 0 ! component number
  
  ! +++ ADD UPWIND DISSIPATION +++
  
  ! beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

   #If #ORDER eq "2"
     ! --- SECOND ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d4(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d4(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d4(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d4(uDot,i1,i2,i3,ec)
       #End
     #End

   #Elif #ORDER eq "4"

     ! --- -FOURTH ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d6(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d6(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d6(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d6(uDot,i1,i2,i3,ec)
       #End
     #End

   #Elif #ORDER eq "6"

     ! ---- SIXTH ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d8(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d8(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d8(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d8(uDot,i1,i2,i3,ec)
       #End
     #End         

   #Elif #ORDER eq "8"

     ! ---- EIGHTH ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         ! write(*,*) "add upwind order ORDER"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d10(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d10(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d10(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d10(uDot,i1,i2,i3,ec)
       #End
     #End 


   #Else
      write(*,*) "upwind dissipation not implemented for order ORDER"
      stop 8888
   #End   

  endLoopsMask()
  ! endLoops()

#endMacro


! =========================================================================================
! Macro: ADD UPWIND DISSIPATION FOR IMPLICIT TIME-STEPPING
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro addUpwindDissImplicit(DIM,ORDER,GRIDTYPE)

  if( (.true. .or. debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("addUpwindDissImplicit: UPWIND DISS dim=DIM order=ORDER grid=GRIDTYPE... t=",e10.2)') t
    write(*,'(" adxSosup=",3e12.4)') adxSosup(0), adxSosup(1),adxSosup(2)
  end if
  

  ! from formImplicitTimeSteppingMatrix
    ! // fourth-order dissipation for 2nd-order scheme:
    ! Real upwindCoeff4[4][5] = { 1.,-4.,6.,-4.,1.,
    !                             1.,-3.,3.,-1.,0.,   // extrap right-most point D-^3 u(2)
    !                             0.,-1.,3.,-3.,1.,   // extrap left -most point D+^3 u(-2)
    !                             0.,-1.,2.,-1.,0.
    !                           };

    ! // sixth-order dissipation for 4th-order scheme
    ! Real upwindCoeff6[4][7] = {1.,-6.,15.,-20.,15.,-6.,1.,
    !                            1.,-5.,10.,-10., 5.,-1.,0.,  // extrap right-most point D-^5 u(3)
    !                            0.,-1., 5.,-10.,10., 5.,1.,  // extrap left -most point D+^5 u(-3)
    !                            0.,-1., 4., -6., 4.,-1.,0.
    !                           };
  

  ! -- Note: Could adjust loop bounds to avoid Dirichlet boundaries

  m=0 ! component number 
  ec = 0 ! component number
  
  ! Compute some things needed in the loops below
  if( adjustHelmholtzForUpwinding.eq.1 )then
    do freq=0,numberOfFrequencies-1
      cosineFactor(freq) = cos(frequencyArray(freq)*(t+dt)) - cos(frequencyArray(freq)*(t-dt))
    end do
  end if 
    
  ! stencil width = order + 1
  ! upwind stencil = stencilWidth + 2 = order+1 + 2
  upwindHalfStencilWidth = (orderOfAccuracy+2)/2 

  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

    #If #GRIDTYPE eq "curvilinear"
      ! --- Compute UPW coefficient for curvilinear grids ---
      #If #DIM eq "2"
        getSosupDissipationCoeff2d(adxSosup)
      #Else
        getSosupDissipationCoeff3d(adxSosup)
      #End
    #End

    ! --- loop over directions ---
    do dir=0,nd-1

      idv(0)=0; idv(1)=0; idv(2)=0
      idv(dir)=1 ! active direction

      ! check if left-most and right-most entries in the upwind stencil are valid 
      i1l = i1-upwindHalfStencilWidth*idv(0); i1r = i1+upwindHalfStencilWidth*idv(0);
      i2l = i2-upwindHalfStencilWidth*idv(1); i2r = i2+upwindHalfStencilWidth*idv(1);
      i3l = i3-upwindHalfStencilWidth*idv(2); i3r = i3+upwindHalfStencilWidth*idv(2);

      !  Note: there are at most four cases at any order, since we have order/2 layers of interpolation points 
      !   Example, order=2, upwind-order=4
      !     X---X---C---X---X           C = center point = valid discretization point
      !     X---X---C---X               missing right-most 
      !         X---C---X---X           missing left-most
      !         X---C---X               missing left and right-most

      upwCase=0 
      if( mask(i1l,i2l,i3l) .ne. 0 .and. mask(i1r,i2r,i3r) .ne. 0 ) then
        upwCase=0  ! centred, full-width stencil
      else if( mask(i1l,i2l,i3l) .ne. 0 ) then
        upwCase=1  ! left biased stencil
      else if( mask(i1r,i2r,i3r) .ne. 0 ) then
        upwCase=2  ! right biased stencil   
      else  
        upwCase=3  ! centred smaller stencil     
      end if



      upw = 0. 
      do iStencil=-upwindHalfStencilWidth,upwindHalfStencilWidth

        j1 = i1 + iStencil*idv(0);  j2 = i2 + iStencil*idv(1);  j3 = i3 + iStencil*idv(2)

        umj = um(j1,j2,j3,0)
        if( adjustHelmholtzForUpwinding.eq.1 )then
          do freq=0,numberOfFrequencies-1
            umj = umj + cosineFactor(freq)*vh(j1,j2,j3,freq)
          end do
        end if
        upw = upw + upwindCoeff(iStencil,upwCase)*umj

        ! upw = upw + upwindCoeff(iStencil,upwCase)*um(j1,j2,j3,ec)  ! *** CHECK ME 


        ! write(*,'("upw-rhs: i1,i2=",2i4," j1,j2=",2i4," upwindCoeff=",1pe9.2, " um=",1pe9.2," upw=",1pe9.2)') i1,i2,j1,j2,upwindCoeff(iStencil,upwCase),um(j1,j2,j3,ec),upw
      end do 
      ! if( abs(upw).gt.1e-10 )then
      !   write(*,'(">>upw-rhs: i1,i2=",2i4," upw=",1pe9.2)') i1,i2,upw
      ! end if 

      ! This is the coeff of um in
      !         + adxSosup(dir)*(UpwindStencil)( un - um )
      un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - adxSosup(dir)*upw 

      ! TEST un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - adxSosup(dir)*upw 

    end do

  endLoopsMask()



#endMacro

  
! =========================================================================================
! Macro: COMPUTE uDot = (un -um )
!
! ========================================================================================
#beginMacro computeUDot()
  ! precompute "uDot" = dt*du/dt used in the dissipation and store in v 
  ! we need uDot at enough ghost points for the dissipation operator 
  if( debug.gt.3 .and. t.le.3.*dt )then
   write(*,'(" advWave: add UPWIND DISSIPATION: Evaluate v= uDot")') 
  end if
  numGhost=orderOfAccuracy/2
  numGhost=numGhost+1
  m1a=n1a-numGhost
  m1b=n1b+numGhost
  m2a=n2a-numGhost
  m2b=n2b+numGhost
  if( nd.eq.2 )then
  m3a=n3a
  m3b=n3b
  else
   m3a=n3a-numGhost
   m3b=n3b+numGhost
  end if

  ! write(*,'(" numGhost=",i2," m1a,m1b,m2a,m2b=",4i4)') numGhost,m1a,m1b,m2a,m2b

  ! We need v at ghost outside interpolation points -- do not use mask here
  
   
  if( (adjustHelmholtzForUpwinding.eq.0) .or. adjustOmega.eq.0 .or. solveHelmholtz.eq.0 )then 

    beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
      v(i1,i2,i3,0)=un(i1,i2,i3,0)-um(i1,i2,i3,0)
    endLoops()

  else 
    ! ***THIS OPTION IS UNDER DEVELOPMENT***


    ! subtract off upwinding applied to current Helmholtz solution to cancel the effect of upwinding.
    ! Periodic solution:
    !    up = vk * cos( omega * t )
    !   D0t( up  ) = vk * D0t( cos( omega * t ) )
    ! NOTE: upwinding is called at the start of the step to previous times (t) (t-dt) and (t-2*dt)

    ! write(*,'("advOpt: adjust upwinding: t=",e10.3," freq=",e14.6)') t,frequencyArray(0)

    ! cosineFactor = cos(frequencyArray(0)*(t+0.*dt)) - cos(frequencyArray(0)*(t-2.*dt))
    ! Compute some things needed in the loops below
    if( adjustHelmholtzForUpwinding.eq.1 )then
      do freq=0,numberOfFrequencies-1
        ! NOTE: upwinding is called at the start of the step to previous times (t) (t-dt) and (t-2*dt)
        cosineFactor(freq) = cos(frequencyArray(freq)*(t+0.*dt)) - cos(frequencyArray(freq)*(t-2.*dt))
      end do
    end if

    if( .true. )then

      ! ----- Adjustment for upwinding in Helmholtz solves ----
      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        v(i1,i2,i3,0)= (un(i1,i2,i3,0)-um(i1,i2,i3,0)) 
        do freq=0,numberOfFrequencies-1
          v(i1,i2,i3,0) = v(i1,i2,i3,0) - vh(i1,i2,i3,freq)*cosineFactor(freq)
        end do
      endLoops() 

    else if( .false. )then
      ! **TESTING : 
      !   CHECK: u = vk * cos( omega * t )
      ! BUT DO NOT ADD UPWINDING 
      maxDiff=0.
      ! beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
      beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
        v(i1,i2,i3,0)= um(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt))
        ! write(*,'("(i1,i2)=",2i4," um=",e12.4," vh*cos=",e12.4," diff=",e8.2)') i1,i2,um(i1,i2,i3,0), vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt)),v(i1,i2,i3,0)
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(um-vh*cos)=",e10.3," (no ghost)")') maxDiff

      maxDiff=0.
      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        v(i1,i2,i3,0)= um(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt))
        ! write(*,'("(i1,i2)=",2i4," um=",e12.4," vh*cos=",e12.4," diff=",e8.2)') i1,i2,um(i1,i2,i3,0), vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt)),v(i1,i2,i3,0)
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(um-vh*cos)=",e10.3," (with ghost)")') maxDiff      

      maxDiff=0.
      ! beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
      beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
        v(i1,i2,i3,0)= un(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t+0.*dt))
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(un-vh*cos)=",e10.3," (no ghost)")') maxDiff 

      maxDiff=0.
      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        v(i1,i2,i3,0)= un(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t+0.*dt))
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(un-vh*cos)=",e10.3, " (with ghost)")') maxDiff            

      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        ! v(i1,i2,i3,0)= (un(i1,i2,i3,0)-um(i1,i2,i3,0)) - vh(i1,i2,i3,0)*cosineFactor
        v(i1,i2,i3,0)= 0.
      endLoops() 


    end if  
  end if

#endMacro 


! Argument list
#defineMacro ARGLIST() nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
                       mask,xy,rsxy,  um,u,un, f, stencilCoeff, v, vh, lapCoeff, \
                       etax, etay, etaz, bc, frequencyArray, ipar, rpar, ierr

! ==================================================================
! ==================================================================
#beginMacro declareInputVariables()
integer nd, n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

 real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real fa(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b,0:*)  ! forcings at different times
 real stencilCoeff(0:*)   ! holds stencil coeffs

 real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1) 
 real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real vh(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)  ! holds current Helmholtz solutions
 real lapCoeff(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)  ! holds coeff of Laplacian for HA scheme

 real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)

 real etax(nd1a:nd1b,0:*)  ! superGrid functions
 real etay(nd2a:nd2b,0:*)
 real etaz(nd3a:nd3b,0:*)

 integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
 integer bc(0:1,0:2),ierr  

 real frequencyArray(0:*)

 integer ipar(0:*)
 real rpar(0:*)

#endMacro                       

! **********************************************************************************
! Macro ADV_WAVE:
!  NAME: name of the subroutine
!  DIM : 2 or 3
!  ORDER : 2 ,4, 6 or 8
!  GRIDTYPE : rectangular, curvilinear
! **********************************************************************************
#beginMacro ADV_WAVE(NAME,DIM,ORDER,GRIDTYPE)
 subroutine NAME( ARGLIST() )
!======================================================================
!   Advance a time step for Waves equations
!
! nd : number of space dimensions
! um,u,un : u(t-dt), u(t), u(t+dt)
!
! ipar(0)  = option : option=0 - advance wave equation
!                           =1 - add upwind dissipation (predictor corrector mode)
!
!======================================================================
 implicit none

 declareInputVariables()

 ! integer nd, n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

 ! real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! ! real fa(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b,0:*)  ! forcings at different times
 ! real stencilCoeff(0:*)   ! holds stencil coeffs

 ! real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1) 
 ! real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real vh(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)  ! holds current Helmholtz solutions
 ! real lapCoeff(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)  ! holds coeff of Laplacian for HA scheme

 ! real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)

 ! integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
 ! integer bc(0:1,0:2),ierr

 ! real frequencyArray(0:*)

 ! integer ipar(0:*)
 ! real rpar(0:*)
      
!     ---- local variables -----
 integer m1a,m1b,m2a,m2b,m3a,m3b,numGhost,nStart,nEnd,mt

 integer c,i1,i2,i3,n,gridType,orderOfAccuracy,orderInTime,axis,dir,grid,freq
 integer addForcing,orderOfDissipation,option,gridIsImplicit,preComputeUpwindUt,modifiedEquationApproach
 integer useNewForcingMethod,numberOfForcingFunctions,fcur,fnext,fprev,numberOfFrequencies
 real t,tm,cc,dt,dy,dz,cdt,cdtdx,cdtdy,cdtdz
 ! ,adc,adcdt,add,adddt
 real dt4by12
 ! logical addDissipation
 integer debug
 integer adjustHelmholtzForUpwinding, useSuperGrid

 real dx(0:2),dr(0:2)

 real dx2i,dy2i,dz2i,dxsqi,dysqi,dzsqi,dxi,dyi,dzi
 real dx12i,dy12i,dz12i,dxsq12i,dysq12i,dzsq12i,dxy4i,dxz4i,dyz4,time0,time1

 real dxi4,dyi4,dzi4,dxdyi2,dxdzi2,dydzi2

 real c0,c1,csq,dtSq,cdtSq,cdtsq12,cdtSqBy12
 real gridCFL

 integer maxOrderOfAccuracy
 parameter( maxOrderOfAccuracy=12 )
 ! Coefficients in the implicit scheme
 real bImp(0:maxOrderOfAccuracy-1)
 real cImp(-1:1,0:maxOrderOfAccuracy-1)
 real alpha2,alpha4,alpha6,alpha8, beta2,beta4,beta6,beta8

 integer rectangular,curvilinear
 parameter( rectangular=0, curvilinear=1 )

 integer timeSteppingMethod
 integer defaultTimeStepping,adamsSymmetricOrder3,rungeKuttaFourthOrder,\
         stoermerTimeStepping,modifiedEquationTimeStepping
 parameter(defaultTimeStepping=0,adamsSymmetricOrder3=1,\
           rungeKuttaFourthOrder=2,stoermerTimeStepping=3,modifiedEquationTimeStepping=4)
!- ! Dispersion models
!- integer noDispersion,drude
!- parameter( noDispersion=0, drude=1 )

!...........start statement function
 integer kd,m
 real rx,ry,rz,sx,sy,sz,tx,ty,tz

  ! --- declare variables used in the difference approximations (defined below) ---
  declareDifferenceOrder2(u,RX)
  declareDifferenceOrder2(um,none)
  declareDifferenceOrder2(v,none)
!  declareDifferenceOrder2(um,none)
  declareDifferenceOrder2(f,none)

  declareDifferenceOrder4(u,RX)
  declareDifferenceOrder4(um,none)
  declareDifferenceOrder4(v,none)

  declareDifferenceOrder6(u,RX)
  declareDifferenceOrder6(um,none)
  declareDifferenceOrder6(v,none)

  declareDifferenceOrder8(u,RX)
  declareDifferenceOrder8(um,none)
  declareDifferenceOrder8(v,none)

 ! define variables for getDerivatives macros
 #Include "../include/declareGetSixthDerivativesMacrosVariables.h"

 ! real cdt4by360,cdt6by20160
 real cdtPow4By12,cdtPow6By360


 real lap2d2,lap3d2,lap2d4,lap3d4,lap2d6,lap3d6,lap2d8,lap3d8,lap2d2Pow2,lap3d2Pow2,lap2d2Pow3,lap3d2Pow3,\
      lap2d2Pow4,lap3d2Pow4,lap2d4Pow2,lap3d4Pow2,lap2d4Pow3,lap3d4Pow3,lap2d6Pow2,lap3d6Pow2
 real lap2d2m,lap3d2m
 real du,fd22d,fd23d,fd42d,fd43d,fd62d,fd63d,fd82d,fd83d
 real DztU

 ! forcing correction functions: 
 real lap2d2f,f2drme44, lap3d2f, f3drme44, f2dcme44, f3dcme44, ff

 ! real cdSosupx,cdSosupy,cdSosupz
 real adSosup,sosupParameter, uDotFactor, adxSosup(0:2)
 integer useSosupDissipation,sosupDissipationOption
 integer updateSolution,updateDissipation,computeUt

 integer ec 
 real ep 
 real fv(0:1) , ev(0:1), evtt(0:1), evxx(0:1), evyy(0:1), evzz(0:1)
 real evxxxx(0:1), evxxyy(0:1), evyyyy(0:1), evxxzz(0:1), evyyzz(0:1), evzzzz(0:1), evtttt(0:1)
 real evtttttt(0:1)
 real evxxxxxx(0:1)
 real evyyyyyy(0:1)
 real evzzzzzz(0:1)       
 real evxxyyyy(0:1)
 real evxxxxyy(0:1)
 real evxxxxzz(0:1)
 real evxxzzzz(0:1)
 real evyyyyzz(0:1)
 real evyyzzzz(0:1)
 real evxxyyzz(0:1)

 real omega, coswt

 integer maxFreq
 parameter( maxFreq=500 )
 real cosFreqt(0:maxFreq), coswtAve(0:maxFreq), cosineFactor(0:maxFreq)

 integer idv(0:2),j1,j2,j3
 integer iStencil,upwCase,upwindHalfStencilWidth,i1l,i2l,i3l, i1r,i2r,i3r
 integer useUpwindDissipation,useImplicitUpwindDissipation,adjustOmega,solveHelmholtz
 integer takeImplicitFirstStep
 real upw,maxDiff,umj
 real upwindCoeff(-3:3,0:3) 

 real ts1,ts2,ts3,ts4,tsf
 
 integer forcingOption
 ! forcingOptions -- these should match ForcingEnum in CgWave.h 
 ! enum ForcingOptionEnum
 ! {
 !   noForcing=0,
 !   twilightZoneForcing,
 !   userForcing,
 !   helmholtzForcing
 ! };
 integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
 parameter(noForcing           =0,\
           twilightZoneForcing =1,\
           userForcing         =2,\
           helmholtzForcing    =3 )

           
! real unxx22r,unyy22r,unxy22r,unx22r

!.......statement functions for jacobian
 rx(i1,i2,i3)=rsxy(i1,i2,i3,0,0)
 ry(i1,i2,i3)=rsxy(i1,i2,i3,0,1)
 rz(i1,i2,i3)=rsxy(i1,i2,i3,0,2)
 sx(i1,i2,i3)=rsxy(i1,i2,i3,1,0)
 sy(i1,i2,i3)=rsxy(i1,i2,i3,1,1)
 sz(i1,i2,i3)=rsxy(i1,i2,i3,1,2)
 tx(i1,i2,i3)=rsxy(i1,i2,i3,2,0)
 ty(i1,i2,i3)=rsxy(i1,i2,i3,2,1)
 tz(i1,i2,i3)=rsxy(i1,i2,i3,2,2)

 !  The next macro will define the difference approximation statement functions for u
 defineDifferenceOrder2Components1(u,RX)
 defineDifferenceOrder4Components1(u,RX)
 defineDifferenceOrder6Components1(u,RX)
 defineDifferenceOrder8Components1(u,RX)

 ! Difference approximations um (old time)
 defineDifferenceOrder2Components1(um,none)
 defineDifferenceOrder4Components1(um,none)

 ! Define difference approximations for v
 defineDifferenceOrder2Components1(v,none)
 defineDifferenceOrder4Components1(v,none)

 defineDifferenceOrder2Components1(f,none)


  ! 2D laplacian squared = u.xxxx + 2 u.xxyy + u.yyyy
  lap2d2Pow2(i1,i2,i3,c)= ( 6.*u(i1,i2,i3,c)   \
    - 4.*(u(i1+1,i2,i3,c)+u(i1-1,i2,i3,c))    \
        +(u(i1+2,i2,i3,c)+u(i1-2,i2,i3,c)) )*dxi4 \
    +( 6.*u(i1,i2,i3,c)    \
     -4.*(u(i1,i2+1,i3,c)+u(i1,i2-1,i3,c))    \
        +(u(i1,i2+2,i3,c)+u(i1,i2-2,i3,c)) )*dyi4  \
    +( 8.*u(i1,i2,i3,c)     \
     -4.*(u(i1+1,i2,i3,c)+u(i1-1,i2,i3,c)+u(i1,i2+1,i3,c)+u(i1,i2-1,i3,c))   \
     +2.*(u(i1+1,i2+1,i3,c)+u(i1-1,i2+1,i3,c)+u(i1+1,i2-1,i3,c)+u(i1-1,i2-1,i3,c)) )*dxdyi2
 
  ! 3D laplacian squared = u.xxxx + u.yyyy + u.zzzz + 2 (u.xxyy + u.xxzz + u.yyzz )
  lap3d2Pow2(i1,i2,i3,c)= ( 6.*u(i1,i2,i3,c)   \
    - 4.*(u(i1+1,i2,i3,c)+u(i1-1,i2,i3,c))    \
        +(u(i1+2,i2,i3,c)+u(i1-2,i2,i3,c)) )*dxi4 \
   +(  +6.*u(i1,i2,i3,c)    \
     -4.*(u(i1,i2+1,i3,c)+u(i1,i2-1,i3,c))    \
        +(u(i1,i2+2,i3,c)+u(i1,i2-2,i3,c)) )*dyi4\
   +(  +6.*u(i1,i2,i3,c)    \
     -4.*(u(i1,i2,i3+1,c)+u(i1,i2,i3-1,c))    \
        +(u(i1,i2,i3+2,c)+u(i1,i2,i3-2,c)) )*dzi4\
    +(8.*u(i1,i2,i3,c)     \
     -4.*(u(i1+1,i2,i3,c)+u(i1-1,i2,i3,c)+u(i1,i2+1,i3,c)+u(i1,i2-1,i3,c))   \
     +2.*(u(i1+1,i2+1,i3,c)+u(i1-1,i2+1,i3,c)+u(i1+1,i2-1,i3,c)+u(i1-1,i2-1,i3,c)) )*dxdyi2 \
    +(8.*u(i1,i2,i3,c)     \
     -4.*(u(i1+1,i2,i3,c)+u(i1-1,i2,i3,c)+u(i1,i2,i3+1,c)+u(i1,i2,i3-1,c))   \
     +2.*(u(i1+1,i2,i3+1,c)+u(i1-1,i2,i3+1,c)+u(i1+1,i2,i3-1,c)+u(i1-1,i2,i3-1,c)) )*dxdzi2 \
    +(8.*u(i1,i2,i3,c)     \
     -4.*(u(i1,i2+1,i3,c)+u(i1,i2-1,i3,c)+u(i1,i2,i3+1,c)+u(i1,i2,i3-1,c))   \
     +2.*(u(i1,i2+1,i3+1,c)+u(i1,i2-1,i3+1,c)+u(i1,i2+1,i3-1,c)+u(i1,i2-1,i3-1,c)) )*dydzi2 

!    ** 4th order ****

  lap2d4(i1,i2,i3,c)=( -30.*u(i1,i2,i3,c)     \
    +16.*(u(i1+1,i2,i3,c)+u(i1-1,i2,i3,c))     \
        -(u(i1+2,i2,i3,c)+u(i1-2,i2,i3,c)) )*dxsq12i + \
   ( -30.*u(i1,i2,i3,c)     \
    +16.*(u(i1,i2+1,i3,c)+u(i1,i2-1,i3,c))     \
        -(u(i1,i2+2,i3,c)+u(i1,i2-2,i3,c)) )*dysq12i 
 
  lap3d4(i1,i2,i3,c)=lap2d4(i1,i2,i3,c)+ \
   ( -30.*u(i1,i2,i3,c)      \
    +16.*(u(i1,i2,i3+1,c)+u(i1,i2,i3-1,c))      \
        -(u(i1,i2,i3+2,c)+u(i1,i2,i3-2,c)) )*dzsq12i 

  lap2d4Pow2(i1,i2,i3,c)=LAP2D4(lap2d4,i1,i2,i3,c)
  lap3d4Pow2(i1,i2,i3,c)=LAP3D4(lap3d4,i1,i2,i3,c)
 
  lap2d4Pow3(i1,i2,i3,c)=LAP2D4(lap2d4Pow2,i1,i2,i3,c)
  lap3d4Pow3(i1,i2,i3,c)=LAP3D4(lap3d4Pow2,i1,i2,i3,c)

  ! D-zero in time (really undivided)
  DztU(i1,i2,i3,n) = (un(i1,i2,i3,n)-um(i1,i2,i3,n))

  !...........end   statement functions


  ! write(*,*) 'Inside advWave...'
 
  cc             = rpar( 0)  ! this is c
  dt             = rpar( 1)
  dx(0)          = rpar( 2)
  dx(1)          = rpar( 3)
  dx(2)          = rpar( 4)
  dr(0)          = rpar( 5)
  dr(1)          = rpar( 6)
  dr(2)          = rpar( 7)
  t              = rpar( 8)
  ep             = rpar( 9)
  sosupParameter = rpar(10)
  omega          = rpar(11) ! for helmholtz 
  bImp( 0)       = rpar(12) ! beta2 : coefficient for implicit time-stepping
  bImp( 1)       = rpar(13) ! beta4 : coefficient for implicit time-stepping
  bImp( 2)       = rpar(14) ! beta6 (for future)
  bImp( 3)       = rpar(15) ! beta8 (for future)
  gridCFL        = rpar(16)
 
  dy=dx(1)  ! Are these needed?
  dz=dx(2)

 
  option                       = ipar( 0)
  grid                         = ipar( 1)
  gridType                     = ipar( 2)
  orderOfAccuracy              = ipar( 3)
  orderInTime                  = ipar( 4)
  addForcing                   = ipar( 5)
  forcingOption                = ipar( 6)
  numberOfForcingFunctions     = ipar( 7)
  fcur                         = ipar( 8) 
  debug                        = ipar( 9)
  gridIsImplicit               = ipar(10)
  useUpwindDissipation         = ipar(11)  ! explicit upwind dissipation
  useImplicitUpwindDissipation = ipar(12)  ! true if upwind-dissipation is on for implicit time-stepping
  preComputeUpwindUt           = ipar(13)
  numberOfFrequencies          = ipar(14)
  adjustOmega                  = ipar(15)
  solveHelmholtz               = ipar(16)
  adjustHelmholtzForUpwinding  = ipar(17)
  modifiedEquationApproach     = ipar(18)
  takeImplicitFirstStep        = ipar(19)
  useSuperGrid                 = ipar(20)

  fprev = mod(fcur-1+numberOfForcingFunctions,max(1,numberOfForcingFunctions))
  fnext = mod(fcur+1                         ,max(1,numberOfForcingFunctions))
  

  ! ** fix me ***
  timeSteppingMethod=modifiedEquationTimeStepping

  ! Set dr(:) = dx(:) for 6th-order derivatives
  if( gridType.eq.rectangular )then
    do axis=0,2
      dr(axis)=dx(axis)
    end do
  end if

  ! ---- Compute the coefficients in the implicit time-stepping scheme ----

  beta2=bImp(0)
  beta4=bImp(1)
  alpha2 = (1.-beta2)/2.
  alpha4 = (alpha2-beta4-1./12.)/2. 
  cImp(-1,0)=alpha2
  cImp( 0,0)= beta2
  cImp( 1,0)=alpha2
  cImp(-1,1)=alpha4
  cImp( 0,1)= beta4
  cImp( 1,1)=alpha4  
 
  ! ! addDissipation=.true. if we add the dissipation in the dis(i1,i2,i3,c) array
  ! !  if combineDissipationWithAdvance.ne.0 we compute the dissipation on the fly in the time step
  ! !  rather than pre-computing it in diss(i1,i2,i3,c)
  ! addDissipation = adc.gt.0.
  ! adcdt=adc*dt
 
  csq=cc**2
  dtSq=dt**2
  cdtSq=(cc**2)*(dt**2)
 
  cdt=cc*dt
 
  ! new: 
  cdtPow4By12  = cdt**4/12.
  cdtPow6By360 = cdt**6/360 
 
  cdtsq12=cdtSq*cdtSq/12.  ! c^4 dt^4 /12 
  ! cdt4by360=(cdt)**4/360.  ! (c*dt)^4/360 
  ! cdt6by20160=cdt**6/(8.*7.*6.*5.*4.*3.)
 
  cdtSqBy12= cdtSq/12.   ! c^2*dt*2/12
 
  dt4by12=dtSq*dtSq/12.
 
  cdtdx = (cc*dt/dx(0))**2
  cdtdy = (cc*dt/dy)**2
  cdtdz = (cc*dt/dz)**2
 
  dxsqi=1./(dx(0)**2)
  dysqi=1./(dy**2)
  dzsqi=1./(dz**2)
 
  dxsq12i=1./(12.*dx(0)**2)
  dysq12i=1./(12.*dy**2)
  dzsq12i=1./(12.*dz**2)
 
  dxi4=1./(dx(0)**4)
  dyi4=1./(dy**4)
  dxdyi2=1./(dx(0)*dx(0)*dy*dy)
 
  dzi4=1./(dz**4)
  dxdzi2=1./(dx(0)*dx(0)*dz*dz)
  dydzi2=1./(dy*dy*dz*dz)
 
  if( option.eq.1 )then 
   useSosupDissipation = 1
  else
   useSosupDissipation = 0
  end if
 
   if( useImplicitUpwindDissipation.eq.1 )then

    ! Upwind dissipation for implicit time time-stepping
    ! from formImplicitTimeSteppingMatrix
    ! // fourth-order dissipation for 2nd-order scheme:
    ! Real upwindCoeff4[4][5] = { 1.,-4.,6.,-4.,1.,
    !                             1.,-3.,3.,-1.,0.,   // extrap right-most point D-^3 u(2)
    !                             0.,-1.,3.,-3.,1.,   // extrap left -most point D+^3 u(-2)
    !                             0.,-1.,2.,-1.,0.
    !                           };

    ! // sixth-order dissipation for 4th-order scheme
    ! Real upwindCoeff6[4][7] = {1.,-6.,15.,-20.,15.,-6.,1.,
    !                            1.,-5.,10.,-10., 5.,-1.,0.,  // extrap right-most point D-^5 u(3)
    !                            0.,-1., 5.,-10.,10.,-5.,1.,  // extrap left -most point D+^5 u(-3)
    !                            0.,-1., 4., -6., 4.,-1.,0.
    !                           };
    if( orderOfAccuracy.eq.2 )then
      ! UPW stencils for the 4 cases (depends on whether all points exist in the wider stencil )
      upwindCoeff(-2,0)=1.; upwindCoeff(-1,0)=-4.; upwindCoeff(0,0)=6.; upwindCoeff(1,0)=-4.; upwindCoeff(2,0)=1.   ! centred
      upwindCoeff(-2,1)=1.; upwindCoeff(-1,1)=-3.; upwindCoeff(0,1)=3.; upwindCoeff(1,1)=-1.; upwindCoeff(2,1)=0.   ! left biased
      upwindCoeff(-2,2)=0.; upwindCoeff(-1,2)=-1.; upwindCoeff(0,2)=3.; upwindCoeff(1,2)=-3.; upwindCoeff(2,2)=1.   ! right biased
      upwindCoeff(-2,3)=0.; upwindCoeff(-1,3)=-1.; upwindCoeff(0,3)=2.; upwindCoeff(1,3)=-1.; upwindCoeff(2,3)=0.   ! centred, lower-order

    else if( orderOfAccuracy.eq.4 )then

      upwindCoeff(-3,0)=1.; upwindCoeff(-2,0)=-6.; upwindCoeff(-1,0)=15.; upwindCoeff(0,0)=-20.; upwindCoeff(1,0)=15.; upwindCoeff(2,0)=-6.; upwindCoeff(3,0)=1.
      upwindCoeff(-3,1)=1.; upwindCoeff(-2,1)=-5.; upwindCoeff(-1,1)=10.; upwindCoeff(0,1)=-10.; upwindCoeff(1,1)= 5.; upwindCoeff(2,1)=-1.; upwindCoeff(3,1)=0.
      upwindCoeff(-3,2)=0.; upwindCoeff(-2,2)=-1.; upwindCoeff(-1,2)= 5.; upwindCoeff(0,2)=-10.; upwindCoeff(1,2)=10.; upwindCoeff(2,2)=-5.; upwindCoeff(3,2)=1.
      upwindCoeff(-3,3)=0.; upwindCoeff(-2,3)=-1.; upwindCoeff(-1,3)= 4.; upwindCoeff(0,3)= -6.; upwindCoeff(1,3)= 4.; upwindCoeff(2,3)=-1.; upwindCoeff(3,3)=0.

    else
      write(*,'("advWave: upwind coefficients are not set yet for orderOfAccuracy=",i4)') orderOfAccuracy
      stop 2222
    end if
   
   end if


  ! Scheme is 
  !   un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx22r(i1,i2,i3,0) +  uyy22r(i1,i2,i3,0) )  
  !                                                         + ts4*(umxx22r(i1,i2,i3,0) + umyy22r(i1,i2,i3,0) ) )  
  !                                                         + tsf*fv(m)       
  if( takeImplicitFirstStep.eq.0 )then
    ts1=2. 
    ts2=-1.
    ts3=cdtSq*cImp( 0,0)
    ts4=cdtSq*cImp(-1,0)
    tsf=dtSq
  else
    ! first-step implicit:
    !   Assumes um = ut(t=0) 
    ! AND 
    !   cImp(1,0) = cImp(-1,0)
    !   RHS = u + dt*ut + (dt^2/2)*L * ( cImp(0,0)*u - 2.*dt*cImp(1,0)*ut ) + .5*dt^2 * f    
    ts1=1. 
    ts2=dt
    ts3= .5*cdtSq*cImp( 0,0)
    ts4=-dt*cdtSq*cImp(-1,0)
    tsf=.5*dtSq    

  end if


  if( (.false. .or. debug.gt.1) .and. t.le.3*dt )then
    write(*,'("advWave: option=",i4," grid=",i4)') option,grid
    write(*,'("advWave: orderOfAccuracy=",i2," orderInTime=",i2  )') orderOfAccuracy,orderInTime
    write(*,'("advWave: addForcing=",i2," forcingOption=",i2)') addForcing,forcingOption
    write(*,'("advWave: useUpwindDissipation=",i2," (explicit), useImplicitUpwindDissipation=",i2," (implicit)")') useUpwindDissipation,useImplicitUpwindDissipation
    write(*,'("advWave: useSosupDissipation=",i2," (1= add upwind dissipation in this stage)")') useSosupDissipation
    write(*,'("advWave: t,dt,c,omega,gridCFL=",5(1pe10.2,1x))') t,dt,cc,omega,gridCFL
    write(*,'("advWave: gridIsImplicit=",i2," takeImplicitFirstStep=",i2)') gridIsImplicit,takeImplicitFirstStep
    write(*,'("advWave: adjustOmega=",i2," solveHelmholtz=",i2," adjustHelmholtz=",i2)') adjustOmega,solveHelmholtz,adjustHelmholtzForUpwinding
    if( forcingOption.eq.helmholtzForcing )then
      write(*,'("advWave: numberOfFrequencies=",i2)') numberOfFrequencies
      write(*,'("advWave: frequencyArray=",(1pe12.4,1x))') (frequencyArray(freq),freq=0,numberOfFrequencies-1)
    end if
    if( gridIsImplicit.eq.1 )then
      write(*,'("  Implicit coeff: cImp(-1:1,0) = ",3(1pe10.2,1x), "(for 2nd-order)")') cImp(-1,0),cImp(0,0),cImp(1,0)
      write(*,'("  Implicit coeff: cImp(-1:1,1) = ",3(1pe10.2,1x), "(for 4th-order)")') cImp(-1,1),cImp(0,1),cImp(1,1)
    end if
  end if
 
  if( forcingOption.eq.helmholtzForcing )then
    ! --- solving the Helmholtz problem ---
    if( t.le.dt .and. debug.gt.1 )then
      write(*,'("advWave: numberOfFrequencies=",i6," omega=",1pe12.4," frequencyArray(0)=",1pe12.4)') numberOfFrequencies,omega,frequencyArray(0)
    end if
    if( numberOfFrequencies.le.0 )then
      write(*,'("advWave: ERROR: numberOfFrequencies=",i6," is <= 0")') numberOfFrequencies
      stop 0123
    end if

    if( numberOfFrequencies.eq.1  .and. frequencyArray(0) .ne. omega )then
      write(*,'("advWave: ERROR: frequencyArray(0)=",1pe12.4," is not equal to omega=",1pe12.4)') frequencyArray(0),omega
      stop 1234
    end if

    if( numberOfFrequencies.gt.maxFreq )then
      write(*,'("advWave: ERROR: numberOfFrequencies > maxFreq=",i6," .. FIX ME")') maxFreq
      stop 2345
    end if

    ! if( numberOfFrequencies.gt.1 .and. gridIsImplicit.eq.1 )then
    !   write(*,'("advWave: ERROR: numberOfFrequencies > 1 and implicit time-stepping : FINISH ME")') 
    !   stop 3456  
    ! end if
      
    do freq=0,numberOfFrequencies-1
      cosFreqt(freq) = cos(frequencyArray(freq)*t)
    end do

  end if

  if( useSosupDissipation.ne.0 .or. useImplicitUpwindDissipation.eq.1 )then
  
    ! ---- coefficients of upwind dissipation ---
    !   **NOTE**: These must match the values in implicit.bC 

    ! if( .true. )then

    ! *new* way to define coefficients: (see cgWave.pdf)
    adSosup = cc*dt/( sqrt(1.*nd) * 2**(orderOfAccuracy+1) ) 


    uDotFactor=.5  ! By default uDot is D-zero and so we scale (un-um) by .5 --> .5*(un-um)/(dt)
  
    ! sosupParameter=gamma in sosup scheme  0<= gamma <=1   0=centered scheme
    adSosup=sosupParameter*adSosup

    if( gridIsImplicit.ne.0  )then

      if( t.le.2*dt )then
        write(*,'("advWave: gridIsImplicit: t=",e10.2," REDUCE UPWIND DISS COEFF by gridCFL=",e10.2)') t,gridCFL
      end if

      adSosup = adSosup/gridCFL 

    end if
  
    if( (.false. .or. debug.gt.1) .and. t.le.2*dt )then
      write(*,'("advMxWave: grid=",i3," gridType=",i2," orderOfAccuracy=",i2," useImplicitUpwindDissipation=",i2)') grid,gridType,orderOfAccuracy,useImplicitUpwindDissipation
      write(*,'("         : t,dt,adSosup=",3e10.2," adSosup/(c*dt)=",e12.4)')t,dt,adSosup,adSosup/(cc*dt)
      write(*,'("         : useSosupDissipation=",i2," sosupParameter=",1pe10.2," preComputeUpwindUt=",i2)') useSosupDissipation,sosupParameter,preComputeUpwindUt
      ! write(*,'("advMxUp: updateDissipation=",i2)') updateDissipation
      ! write(*,'("advMxUp: useNewForcingMethod=",i2)') useNewForcingMethod
    end if
  
    ! ! Coefficients of the sosup dissipation with Cartesian grids:
    ! cdSosupx= adSosup/dx(0)
    ! cdSosupy= adSosup/dx(1)
    ! cdSosupz= adSosup/dx(2)
  
    ! Note: these next values are only used for rectangular grids. (curvilinear grid values are computed in the loops)
    adxSosup(0)=  uDotFactor*adSosup/dx(0)
    adxSosup(1)=  uDotFactor*adSosup/dx(1)
    adxSosup(2)=  uDotFactor*adSosup/dx(2)
  end if
 
 
  if( useSosupDissipation.eq.1 .and. preComputeUpwindUt.eq.1 )then
    if( option.ne.1 )then
      write(*,'("advWaveOpt:ERROR: useSosupDissipation.eq.1 BUT option.ne.1")')
      stop 6663
    end if
 
    computeUDot()
 
  end if 


  ! write(*,'(" advWave: timeSteppingMethod=",i2)') timeSteppingMethod
  if( timeSteppingMethod.eq.defaultTimeStepping )then
   write(*,'(" advWave:ERROR: timeSteppingMethod=defaultTimeStepping -- this should be set")')
     ! '
   stop 83322
  end if



  if( useSosupDissipation.eq.0 )then
    
    if( gridIsImplicit.eq.0 )then 
 
      ! ------- EXPLIICT update the solution ---------

      if( useSuperGrid == 0 )then
        if( orderInTime.eq.2 )then
         ! FD24 : second-order in time and fourth-order in space
         ! FD26 : second-order in time and sixth-order in space

          if( addForcing.eq.0 )then
           updateWaveOpt(DIM,ORDER,2,GRIDTYPE,NOFORCING)
          else 
           updateWaveOpt(DIM,ORDER,2,GRIDTYPE,USEFORCING)
          end if
        else
          if( addForcing.eq.0 )then
            updateWaveOpt(DIM,ORDER,ORDER,GRIDTYPE,NOFORCING)
          else
            updateWaveOpt(DIM,ORDER,ORDER,GRIDTYPE,USEFORCING)
          end if
        end if 

      else
       
        ! write(*,'(" advWave: Use SUPER-GRID ")')

        #If #GRIDTYPE eq "rectangular"

        if( orderInTime.eq.2 )then
         ! FD24 : second-order in time and fourth-order in space
         ! FD26 : second-order in time and sixth-order in space

          if( addForcing.eq.0 )then
           updateWaveOptSuperGrid(DIM,ORDER,2,GRIDTYPE,NOFORCING)
          else 
           updateWaveOptSuperGrid(DIM,ORDER,2,GRIDTYPE,USEFORCING)
          end if
        else
          if( addForcing.eq.0 )then
            updateWaveOptSuperGrid(DIM,ORDER,ORDER,GRIDTYPE,NOFORCING)
          else
            updateWaveOptSuperGrid(DIM,ORDER,ORDER,GRIDTYPE,USEFORCING)
          end if
        end if 

        #Else
          write(*,'("advWave: ADVANCE SUPERGRID: This function should not be called for curvilinear grids, use normal one.")' )
          stop 666        

        #End

      end if
 

    else

      ! --- IMPLICIT: Fill in RHS to implicit time-stepping -----

      if( takeImplicitFirstStep.eq.1 )then
        if( orderInTime.eq.2 )then
          write(*,'(" advWave: TAKE IMPLICIT FIRST STEP ")')
        else
          write(*,'(" advWave: TAKE IMPLICIT FIRST STEP : FINISH ME, orderInTime =",i2)') orderInTime
          stop 468
        end if
        #If #ORDER eq "6" || #ORDER eq "8" 
          write(*,'(" advWave: TAKE IMPLICIT FIRST STEP : FINISH ME, order=ORDER, orderInTime =",i2)') orderInTime
          stop 468
        #End
      end if           


      #If #ORDER eq "4"

        if( orderOfAccuracy.eq.4 .and. orderInTime.eq.2 )then
         ! FD24 : second-order in time and fourth-order in space
         updateWaveImplicitOpt(DIM,ORDER,2,GRIDTYPE,FORCING)
        else
          updateWaveImplicitOpt(DIM,ORDER,ORDER,GRIDTYPE,FORCING)
        end if 
 
      #Else

        updateWaveImplicitOpt(DIM,ORDER,ORDER,GRIDTYPE,FORCING)
 
      #End

      ! --- Add contributions from upwind dissipation ---
      if( useImplicitUpwindDissipation.eq.1 )then
        addUpwindDissImplicit(DIM,ORDER,GRIDTYPE)
      end if 

    end if
    
  else

    ! ---- add upwind dissipation -----
    ! preComputeUpwindUt : true=precompute Ut in upwind dissipation,  (uses v=uDot computed above)
    !                      false=compute Ut inline in Gauss-Seidel fashion 
    if( preComputeUpwindUt.eq.1 )then
      ! precompute Ut in upwind dissipation,  (uses v=uDot computed above)
      addUpwindDiss(DIM,ORDER,GRIDTYPE,v)
    else
      ! compute Ut inline in Gauss-Seidel fashion (this is more stable)
      addUpwindDiss(DIM,ORDER,GRIDTYPE,Dztu)
    end if
  
  end if
 
 
 
  return
  end

#endMacro


! Macro to build separate files 
#beginMacro buildFile(NAME,DIM,ORDER,GRIDTYPE)
#beginFile NAME.f90
 ADV_WAVE(NAME,DIM,ORDER,GRIDTYPE)
#endFile
#endMacro


  ! ==== Build separate f90 files for different cases ====

  buildFile(advWave2dOrder2r,2,2,rectangular)
  buildFile(advWave3dOrder2r,3,2,rectangular)
  buildFile(advWave2dOrder2c,2,2,curvilinear)
  buildFile(advWave3dOrder2c,3,2,curvilinear)

  buildFile(advWave2dOrder4r,2,4,rectangular)
  buildFile(advWave3dOrder4r,3,4,rectangular)
  buildFile(advWave2dOrder4c,2,4,curvilinear)
  buildFile(advWave3dOrder4c,3,4,curvilinear)



  ! !   ORDER=6 : BC's not implemented yet -- needed for upwinding, SuperGrid
  ! buildFile(advWave2dOrder6r,2,6,rectangular)
  ! buildFile(advWave3dOrder6r,3,6,rectangular)
  ! buildFile(advWave2dOrder6c,2,6,curvilinear)
  ! buildFile(advWave3dOrder6c,3,6,curvilinear)

  ! ! ORDER 8 -- needed for upwinding,  SuperGrid
  ! buildFile(advWave2dOrder8r,2,8,rectangular)
  ! buildFile(advWave3dOrder8r,3,8,rectangular)
  ! buildFile(advWave2dOrder8c,2,8,curvilinear)
  ! buildFile(advWave3dOrder8c,3,8,curvilinear)


      subroutine advWave( ARGLIST() )
!======================================================================
!   Advance a time step for Maxwells eqution
!     OPTIMIZED version for rectangular grids.
! nd : number of space dimensions
!
! ipar(0)  = option : option=0 - Maxwell+Artificial diffusion
!                           =1 - AD only
!======================================================================
 implicit none
 declareInputVariables()      

      ! integer nd, n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

      ! real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      ! real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      ! real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      ! real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      ! ! real fa(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b,0:*)  ! forcings at different times
      ! real stencilCoeff(0:*)
      ! real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      ! real vh(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)  ! holds current Helmholtz solutions
      ! real lapCoeff(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)  ! holds current Helmholtz solutions

      ! real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
      ! real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)

      ! integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      ! integer bc(0:1,0:2),ierr

      ! integer ipar(0:*)
      ! real rpar(0:*)

      ! real frequencyArray(0:*)
      
!     ---- local variables -----
  integer c,i1,i2,i3,n,gridType,orderOfAccuracy,orderInTime
  integer addForcing,orderOfDissipation,option,addUpwinding,modifiedEquationApproach
  ! integer useImplicitUpwindDissipation,useUpwindDissipation
  integer useWhereMask,solveForE,solveForH,grid
  integer ex,ey,ez, hx,hy,hz

  integer rectangular,curvilinear
  parameter( rectangular=0, curvilinear=1 )

  integer standardME, hierarchicalME, stencilME
  parameter( standardME=0, hierarchicalME=1, stencilME=2 )
!...........end   statement functions



       
  option                    = ipar( 0)
  gridType                  = ipar( 2)
  orderOfAccuracy           = ipar( 3)
  orderInTime               = ipar( 4)
  modifiedEquationApproach  = ipar(18)

  ! write(*,*) 'Inside advWave...'
  ! write(*,*) 'option, orderOfAccuracy, modifiedEquationApproach=',option, orderOfAccuracy, modifiedEquationApproach

        ! useUpwindDissipation         = ipar(11)  ! explicit upwind dissipation
  ! useImplicitUpwindDissipation = ipar(12)  ! true if upwind-dissipation is on for impliciit time-stepping 

  if( option.eq.1 )then 
   addUpwinding = 1
  else
   addUpwinding = 0
  end if


  if( orderOfAccuracy.eq.2 )then

    if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder2r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder2c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder2r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder2c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder2r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder2c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder2r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder2c( ARGLIST() )
      else
       stop 8843
      end if 
    else if( modifiedEquationApproach.eq.stencilME ) then

     if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveStencil2dOrder2r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveStencil2dOrder2c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
       call advWaveStencil3dOrder2r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       call advWaveStencil3dOrder2c( ARGLIST() )
      else
       stop 8843
      end if 

    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if

    ! if( nd.eq.2 .and. gridType.eq.rectangular ) then
    !   call advWave2dOrder2r( ARGLIST() )
    ! else if( nd.eq.2 .and. gridType.eq.curvilinear ) then
    !   call advWave2dOrder2c( ARGLIST() )
    ! else if( nd.eq.3 .and. gridType.eq.rectangular ) then
    !   call advWave3dOrder2r( ARGLIST() )
    ! else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
    !   call advWave3dOrder2c( ARGLIST() )
    ! else
    !   stop 2271
    ! end if

  else if( orderOfAccuracy.eq.4 ) then

    if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder4r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder4c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder4r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder4c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder4r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder4c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder4r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder4c( ARGLIST() )
      else
       stop 8843
      end if 

    else if( modifiedEquationApproach.eq.stencilME ) then

     if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveStencil2dOrder4r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveStencil2dOrder4c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveStencil3dOrder4r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       call advWaveStencil3dOrder4c( ARGLIST() )
      else
       stop 8843
      end if 

    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if

  else if( orderOfAccuracy.eq.6 ) then

    if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder6r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder6c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder6r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder6c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder6r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder6c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder6r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder6c( ARGLIST() )
      else
       stop 8843
      end if 
    else if( modifiedEquationApproach.eq.stencilME ) then

     if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveStencil2dOrder6r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveStencil2dOrder6c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
       call advWaveStencil3dOrder6r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       call advWaveStencil3dOrder6c( ARGLIST() )
      else
       stop 8843
      end if 

    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if


  else if( orderOfAccuracy.eq.8 ) then

  if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder8r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder8c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder8r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder8c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder8r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder8c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder8r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder8c( ARGLIST() )
      else
       stop 8843
      end if 

    else if( modifiedEquationApproach.eq.stencilME ) then


     if( nd.eq.2 .and. gridType.eq.rectangular )then
       call advWaveStencil2dOrder8r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
       call advWaveStencil2dOrder8c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
       call advWaveStencil3dOrder8r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       ! call advWaveStencil3dOrder8c( ARGLIST() )
      else
       stop 8843
      end if                  
    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if


   !  if( nd.eq.2 .and. gridType.eq.rectangular )then
   !    if( addUpwinding==0 )then
   !      ! new ME scheme
   !      call advWaveME2dOrder8r( ARGLIST() )
   !    else
   !      call advWave2dOrder8r( ARGLIST() )
   !    end if

   !  else if(nd.eq.2 .and. gridType.eq.curvilinear )then
   !   if( addUpwinding==0 )then
   !      ! new ME scheme
   !      call advWaveME2dOrder8c( ARGLIST() )
   !    else
   !      call advWave2dOrder8c( ARGLIST() )
   !    end if  

   !  else if(  nd.eq.3 .and. gridType.eq.rectangular )then
   !    call advWave3dOrder8r( ARGLIST() )
   !  else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
   !    call advWave3dOrder8c( ARGLIST() )
   ! else
   !   stop 8843
   ! end if



  else
    write(*,'(" advWave:ERROR: un-implemented order of accuracy =",i6)') orderOfAccuracy
      ! '
    stop 11122
  end if

  return
  end








