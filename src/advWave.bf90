!
! =======================================================================
! ============ Optimized advance routines for CgWave ====================
! =======================================================================
!
! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
#Include "defineDiffOrder2f.h"
#Include "defineDiffOrder4f.h"

! 6th-order
#Include "defineDiffOrder6f.h"

! 8th order
#Include "defineDiffOrder8f.h"

! define macros to evaluate derivatives for the 6th order method (from maple/makeGetDerivativesMacros.maple)
#Include "../maple/defineGetSixthDerivativesMacros.h"

! From bcOptSmFOS.bf
! DataBase *pdb = &parameters.dbase;
! double precision pdb  ! pointer to data base
! ====================================================================
! Look up an integer parameter from the data base
! ====================================================================
#beginMacro getIntParameter(name)
 ok=getInt(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** advWave:getInt:ERROR: unable to find name")') 
   stop 1122
 end if
#endMacro

! ====================================================================
! Look up a real parameter from the data base
! ====================================================================
#beginMacro getRealParameter(name)
 ok=getReal(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** advWave:getReal:ERROR: unable to find name")') 
   stop 1133
 end if
#endMacro

! ======================================================================================
!   Evaluate the TZ exact solution in 2D
! ======================================================================================
#beginMacro OGDERIV2D( ntd,nxd,nyd,nzd,i1,i2,i3,t, n,val)
  call ogDeriv(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t, n,val )
#endMacro

! ======================================================================================
!   Evaluate the TZ exact solution in 3D
! ======================================================================================
#beginMacro OGDERIV3D( ntd,nxd,nyd,nzd,i1,i2,i3,t, n,val)
  call ogDeriv(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t, n,val )
#endMacro

  

! ---------------------------------------------------------------------------
! Macro : beginLoopsMask
! ---------------------------------------------------------------------------
#beginMacro beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
    if( mask(i1,i2,i3).gt.0 )then
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoopsMask
! ---------------------------------------------------------------------------
#beginMacro endLoopsMask()
    end if
  end do
  end do
  end do
#endMacro

! ---------------------------------------------------------------------------
! Macro : beginLoops
! ---------------------------------------------------------------------------
#beginMacro beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoopsMask
! ---------------------------------------------------------------------------
#beginMacro endLoops()
  end do
  end do
  end do
#endMacro


#defineMacro LAP2D2(U,i1,i2,i3,ic) \
                       (U(i1+1,i2,i3,ic)-2.*U(i1,i2,i3,ic)+U(i1-1,i2,i3,ic))*dxsqi\
                      +(U(i1,i2+1,i3,ic)-2.*U(i1,i2,i3,ic)+U(i1,i2-1,i3,ic))*dysqi
#defineMacro LAP3D2(U,i1,i2,i3,ic) \
                       (U(i1+1,i2,i3,ic)-2.*U(i1,i2,i3,ic)+U(i1-1,i2,i3,ic))*dxsqi\
                      +(U(i1,i2+1,i3,ic)-2.*U(i1,i2,i3,ic)+U(i1,i2-1,i3,ic))*dysqi\
                      +(U(i1,i2,i3+1,ic)-2.*U(i1,i2,i3,ic)+U(i1,i2,i3-1,ic))*dzsqi

#defineMacro LAP2D2POW2(U,i1,i2,i3,ic) ( 6.*U(i1,i2,i3,ic)   \
                      - 4.*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic))    \
                      +(U(i1+2,i2,i3,ic)+U(i1-2,i2,i3,ic)) )*dxi4 \
                      +( 6.*U(i1,i2,i3,ic)    \
                      -4.*(U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic))    \
                      +(U(i1,i2+2,i3,ic)+U(i1,i2-2,i3,ic)) )*dyi4  \
                      +( 8.*U(i1,i2,i3,ic)     \
                      -4.*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic)+U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic))   \
                      +2.*(U(i1+1,i2+1,i3,ic)+U(i1-1,i2+1,i3,ic)+U(i1+1,i2-1,i3,ic)+U(i1-1,i2-1,i3,ic)) )*dxdyi2

#defineMacro LAP3D2POW2(U,i1,i2,i3,ic) ( 6.*U(i1,i2,i3,ic)   \
        - 4.*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic))    \
            +(U(i1+2,i2,i3,ic)+U(i1-2,i2,i3,ic)) )*dxi4 \
       +(  +6.*U(i1,i2,i3,ic)    \
         -4.*(U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic))    \
            +(U(i1,i2+2,i3,ic)+U(i1,i2-2,i3,ic)) )*dyi4\
       +(  +6.*U(i1,i2,i3,ic)    \
         -4.*(U(i1,i2,i3+1,ic)+U(i1,i2,i3-1,ic))    \
            +(U(i1,i2,i3+2,ic)+U(i1,i2,i3-2,ic)) )*dzi4\
        +(8.*U(i1,i2,i3,ic)     \
         -4.*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic)+U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic))   \
         +2.*(U(i1+1,i2+1,i3,ic)+U(i1-1,i2+1,i3,ic)+U(i1+1,i2-1,i3,ic)+U(i1-1,i2-1,i3,ic)) )*dxdyi2 \
        +(8.*U(i1,i2,i3,ic)     \
         -4.*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic)+U(i1,i2,i3+1,ic)+U(i1,i2,i3-1,ic))   \
         +2.*(U(i1+1,i2,i3+1,ic)+U(i1-1,i2,i3+1,ic)+U(i1+1,i2,i3-1,ic)+U(i1-1,i2,i3-1,ic)) )*dxdzi2 \
        +(8.*U(i1,i2,i3,ic)     \
         -4.*(U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic)+U(i1,i2,i3+1,ic)+U(i1,i2,i3-1,ic))   \
         +2.*(U(i1,i2+1,i3+1,ic)+U(i1,i2-1,i3+1,ic)+U(i1,i2+1,i3-1,ic)+U(i1,i2-1,i3-1,ic)) )*dydzi2 

#defineMacro LAP2D4(U,i1,i2,i3,ic) ( -30.*U(i1,i2,i3,ic)     \
        +16.*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic))     \
            -(U(i1+2,i2,i3,ic)+U(i1-2,i2,i3,ic)) )*dxsq12i + \
       ( -30.*U(i1,i2,i3,ic)     \
        +16.*(U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic))     \
            -(U(i1,i2+2,i3,ic)+U(i1,i2-2,i3,ic)) )*dysq12i

#defineMacro LAP3D4(U,i1,i2,i3,ic) ( -30.*U(i1,i2,i3,ic)     \
        +16.*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic))     \
            -(U(i1+2,i2,i3,ic)+U(i1-2,i2,i3,ic)) )*dxsq12i + \
       ( -30.*U(i1,i2,i3,ic)     \
        +16.*(U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic))     \
            -(U(i1,i2+2,i3,ic)+U(i1,i2-2,i3,ic)) )*dysq12i+ \
       ( -30.*U(i1,i2,i3,ic)      \
        +16.*(U(i1,i2,i3+1,ic)+U(i1,i2,i3-1,ic))      \
            -(U(i1,i2,i3+2,ic)+U(i1,i2,i3-2,ic)) )*dzsq12i

#defineMacro LAP2D6(U,i1,i2,i3,ic) \
               c00lap2d6*U(i1,i2,i3,ic)     \
              +c10lap2d6*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic)) \
              +c01lap2d6*(U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic)) \
              +c20lap2d6*(U(i1+2,i2,i3,ic)+U(i1-2,i2,i3,ic)) \
              +c02lap2d6*(U(i1,i2+2,i3,ic)+U(i1,i2-2,i3,ic)) \
              +c30lap2d6*(U(i1+3,i2,i3,ic)+U(i1-3,i2,i3,ic)) \
              +c03lap2d6*(U(i1,i2+3,i3,ic)+U(i1,i2-3,i3,ic))

#defineMacro LAP3D6(U,i1,i2,i3,ic) \
               c000lap3d6*U(i1,i2,i3,ic) \
              +c100lap3d6*(U(i1+1,i2,i3,ic)+U(i1-1,i2,i3,ic)) \
              +c010lap3d6*(U(i1,i2+1,i3,ic)+U(i1,i2-1,i3,ic)) \
              +c001lap3d6*(U(i1,i2,i3+1,ic)+U(i1,i2,i3-1,ic)) \
              +c200lap3d6*(U(i1+2,i2,i3,ic)+U(i1-2,i2,i3,ic)) \
              +c020lap3d6*(U(i1,i2+2,i3,ic)+U(i1,i2-2,i3,ic)) \
              +c002lap3d6*(U(i1,i2,i3+2,ic)+U(i1,i2,i3-2,ic)) \
              +c300lap3d6*(U(i1+3,i2,i3,ic)+U(i1-3,i2,i3,ic)) \
              +c030lap3d6*(U(i1,i2+3,i3,ic)+U(i1,i2-3,i3,ic)) \
              +c003lap3d6*(U(i1,i2,i3+3,ic)+U(i1,i2,i3-3,ic))

! ===========================================================================================
! Macro: compute the coefficients in the sosup dissipation for curvilinear grids
! ===========================================================================================
#beginMacro getSosupDissipationCoeff2d(adxSosup)
 do dir=0,1
   ! diss-coeff ~= 1/(change in x along direction r(dir) )
   ! Assuming a nearly orthogonal grid gives ||dx|| = || grad_x(r_i) || / dr_i 
   adxSosup(dir) = adSosup*uDotFactor*sqrt( rsxy(i1,i2,i3,dir,0)**2 + rsxy(i1,i2,i3,dir,1)**2 )/dr(dir) 
 end do
#endMacro

#beginMacro getSosupDissipationCoeff3d(adxSosup)
 do dir=0,2
   ! diss-coeff ~= 1/(change in x along direction r(dir) )
   ! Assuming a nearly orthogonal grid gives ||dx|| = || grad_x(r_i) || / dr_i 
   adxSosup(dir) = adSosup*uDotFactor*sqrt( rsxy(i1,i2,i3,dir,0)**2 + rsxy(i1,i2,i3,dir,1)**2  + rsxy(i1,i2,i3,dir,2)**2 )/dr(dir) 
 end do
 ! write(*,'(" adxSosup =",3(1pe10.2))') (adxSosup(dir),dir=0,2)
#endMacro

! ===========================================================================================
! Macro: Output some debug info for the first few time-steps 
! ===========================================================================================
#beginMacro INFO(string)
if( t.le.3.*dt )then
  write(*,'("advMxUp>>>",string)')
end if
#endMacro

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (4th-order difference used with 2nd-order scheme) 
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d4(uDot,i1,i2,i3,n) \
             ( ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                   -(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n)) )*adxSosup(0) + \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                   -(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n)) )*adxSosup(1) )

#defineMacro sosupDiss3d4(uDot,i1,i2,i3,n) \
            ( ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                   -(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n)) )*adxSosup(0) + \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                   -(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n)) )*adxSosup(1) + \
              ( -6.*uDot(i1,i2,i3,n)     \
                +4.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
                   -(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n)) )*adxSosup(2) )

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (6th-order difference used with 4th-order scheme)
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d6(uDot,i1,i2,i3,n) \
            ( ( -20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                -6.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                   +(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))  )*adxSosup(0) + \
              (-20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                -6.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                   +(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))  )*adxSosup(1) )

#defineMacro sosupDiss3d6(uDot,i1,i2,i3,n) \
           ( ( -20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
                -6.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                   +(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))  )*adxSosup(0) + \
              (-20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
                -6.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                   +(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))  )*adxSosup(1) + \
              (-20.*uDot(i1,i2,i3,n)     \
               +15.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
                -6.*(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n))     \
                   +(uDot(i1,i2,i3+3,n)+uDot(i1,i2,i3-3,n))  )*adxSosup(2) )

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (8th-order difference used with 6th-order scheme)
! (x+y)^8 = x^8 + 8*x^7*y + 28*x^6*y^2 + 56*x^5*y^3 + 70*x^4*y^4 + 56*x^3*y^5 + 28*x^2*y^6 + 8*x*y^7 + y^8
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d8(uDot,i1,i2,i3,n) \
            ( ( -70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -28.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +8.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                   -(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))  )*adxSosup(0) + \
              (-70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -28.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +8.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                   -(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))  )*adxSosup(1) )

#defineMacro sosupDiss3d8(uDot,i1,i2,i3,n) \
            ( ( -70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -28.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +8.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                   -(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))  )*adxSosup(0) + \
              (-70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -28.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +8.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                   -(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))  )*adxSosup(1) + \
              (-70.*uDot(i1,i2,i3,n)     \
               +56.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
               -28.*(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n))     \
                +8.*(uDot(i1,i2,i3+3,n)+uDot(i1,i2,i3-3,n))     \
                   -(uDot(i1,i2,i3+4,n)+uDot(i1,i2,i3-4,n))  )*adxSosup(2) )             

! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Upwind (sosup) dissipation (10th-order difference used with 8th-order scheme)
! (x+y)^10 = x^10 + 10*x^9*y + 45*x^8*y^2 + 120*x^7*y^3 + 210*x^6*y^4 + 252*x^5*y^5 + 210*x^4*y^6 + 120*x^3*y^7 + 45*x^2*y^8 + 10*x*y^9 + y^10
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#defineMacro sosupDiss2d10(uDot,i1,i2,i3,n) \
            ( ( -252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -120.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +45.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                -10.*(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))     \
                +    (uDot(i1+5,i2,i3,n)+uDot(i1-5,i2,i3,n))  )*adxSosup(0) + \
              (-252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -120.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +45.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                -10.*(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))     \
                +    (uDot(i1,i2+5,i3,n)+uDot(i1,i2-5,i3,n))  )*adxSosup(1) )

#defineMacro sosupDiss3d10(uDot,i1,i2,i3,n) \
            ( ( -252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1+1,i2,i3,n)+uDot(i1-1,i2,i3,n))     \
               -120.*(uDot(i1+2,i2,i3,n)+uDot(i1-2,i2,i3,n))     \
                +45.*(uDot(i1+3,i2,i3,n)+uDot(i1-3,i2,i3,n))     \
                -10.*(uDot(i1+4,i2,i3,n)+uDot(i1-4,i2,i3,n))     \
                +    (uDot(i1+5,i2,i3,n)+uDot(i1-5,i2,i3,n))  )*adxSosup(0) + \
              (-252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1,i2+1,i3,n)+uDot(i1,i2-1,i3,n))     \
               -120.*(uDot(i1,i2+2,i3,n)+uDot(i1,i2-2,i3,n))     \
                +45.*(uDot(i1,i2+3,i3,n)+uDot(i1,i2-3,i3,n))     \
                -10.*(uDot(i1,i2+4,i3,n)+uDot(i1,i2-4,i3,n))     \
                +    (uDot(i1,i2+5,i3,n)+uDot(i1,i2-5,i3,n))  )*adxSosup(1) + \
              (-252.*uDot(i1,i2,i3,n)                            \
               +210.*(uDot(i1,i2,i3+1,n)+uDot(i1,i2,i3-1,n))     \
               -120.*(uDot(i1,i2,i3+2,n)+uDot(i1,i2,i3-2,n))     \
                +45.*(uDot(i1,i2,i3+3,n)+uDot(i1,i2,i3-3,n))     \
                -10.*(uDot(i1,i2,i3+4,n)+uDot(i1,i2,i3-4,n))     \
                +    (uDot(i1,i2,i3+5,n)+uDot(i1,i2,i3-5,n))  )*adxSosup(2) )


! =========================================================================================
! Macro: Compute v=Delta(u) to second order for fourth-order scheme on curvilinear grids
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   GRIDTYPE : rectangular or curvilinear
!   OPTION = EXPLIICT, IMPLICIT
!      EXPLICIT: compute v(i1,i2,i3,0) = uLap
!      IMPLICIT: compute v(i1,i2,i3,0) = uLap, and v(i1,i2,i3,1) = umLap
! ========================================================================================
#beginMacro computeLaplacianOrder2(DIM,OPTION)
  ! write(*,'("advWave: COMPUTE V= LAP(U) TO SECOND ORDER dim=DIM")') 
  ! We need Lap2h(u) at an extra point 
  numGhost=orderOfAccuracy/2 -1 
  m1a=n1a-numGhost
  m1b=n1b+numGhost
  m2a=n2a-numGhost
  m2b=n2b+numGhost
  if( nd.eq.2 )then
  m3a=n3a
  m3b=n3b
  else
   m3a=n3a-numGhost
   m3b=n3b+numGhost
  end if
  ! write(*,'(" Lap(u) : numGhost=",i2," m1a,m1b,m2a,m2b=",4i4)') numGhost,m1a,m1b,m2a,m2b

  if( useSuperGrid==0 )then
    beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
     #If #DIM eq "2"
      v(i1,i2,i3,0) = uxx22(i1,i2,i3,0) + uyy22(i1,i2,i3,0)
      #If #OPTION eq "IMPLICIT"
        v(i1,i2,i3,1) = umxx22(i1,i2,i3,0) + umyy22(i1,i2,i3,0)
      #End
      ! OGDERIV2D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      ! write(*,'(" i1,i2=",2i4," uxx2=",e10.2," true=",e10.2)') i1,i2,uxx22(i1,i2,i3,0),evxx(0)
     #Else
       v(i1,i2,i3,0) = uxx23(i1,i2,i3,0) + uyy23(i1,i2,i3,0) + uzz23(i1,i2,i3,0)
       #If #OPTION eq "IMPLICIT"
        v(i1,i2,i3,1) = umxx23(i1,i2,i3,0) + umyy23(i1,i2,i3,0) + umzz23(i1,i2,i3,0)
       #End       
     #End 
    endLoops()

  else
    ! superGrid -- **Cartesian Grid**
    beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
     #If #DIM eq "2"
      v(i1,i2,i3,0) =  etax(i1,0)*uxx22r(i1,i2,i3,0) + etax(i1,1)*ux22r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy22r(i1,i2,i3,0) + etay(i2,1)*uy22r(i1,i2,i3,0)
      #If #OPTION eq "IMPLICIT"
      v(i1,i2,i3,1) =  etax(i1,0)*umxx22r(i1,i2,i3,0) + etax(i1,1)*umx22r(i1,i2,i3,0) \
                     + etay(i2,0)*umyy22r(i1,i2,i3,0) + etay(i2,1)*umy22r(i1,i2,i3,0)
      #End                     
      ! v(i1,i2,i3,0) = uxx22(i1,i2,i3,0) + uyy22(i1,i2,i3,0)
     #Else
       v(i1,i2,i3,0) = etax(i1,0)*uxx23r(i1,i2,i3,0) + etax(i1,1)*ux23r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy23r(i1,i2,i3,0) + etay(i2,1)*uy23r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz23r(i1,i2,i3,0) + etaz(i3,1)*uz23r(i1,i2,i3,0)
      #If #OPTION eq "IMPLICIT"
       v(i1,i2,i3,1) = etax(i1,0)*umxx23r(i1,i2,i3,0) + etax(i1,1)*umx23r(i1,i2,i3,0) \
                     + etay(i2,0)*umyy23r(i1,i2,i3,0) + etay(i2,1)*umy23r(i1,i2,i3,0) \
                     + etaz(i3,0)*umzz23r(i1,i2,i3,0) + etaz(i3,1)*umz23r(i1,i2,i3,0)                     

      #End                          
       ! v(i1,i2,i3,0) = uxx23(i1,i2,i3,0) + uyy23(i1,i2,i3,0) + uzz23(i1,i2,i3,0)
     #End 
    endLoops()

  end if


#endMacro
  
! =========================================================================================
! Macro: Compute the forcing for the update of u
! =========================================================================================
#beginMacro getForcing(DIM,ORDER,ORDERINTIME,GRIDTYPE) 
  if( addForcing.eq.0 )then
    ! THIS ADDED March 24, 2023 *** CHECK ME ***
    fv(m)=0.
  else if( forcingOption.eq.twilightZoneForcing )then
    #If #DIM eq "2"
      OGDERIV2D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      
      OGDERIV2D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      OGDERIV2D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      OGDERIV2D( 0,0,2,0,i1,i2,i3,t, ec, evyy(m) )
      fv(m) = evtt(m) - csq*( evxx(m) + evyy(m) ) 
    #Else
      OGDERIV3D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      OGDERIV3D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      OGDERIV3D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      OGDERIV3D( 0,0,2,0,i1,i2,i3,t, ec, evyy(m) )
      OGDERIV3D( 0,0,0,2,i1,i2,i3,t, ec, evzz(m) )
      fv(m) = evtt(m) - csq*( evxx(m) + evyy(m)  + evzz(m) )
    #End
    if( damp.ne.0. )then
      #If #DIM eq "2"
        OGDERIV2D( 1,0,0,0,i1,i2,i3,t, ec, evt(m) )
      #Else
        OGDERIV3D( 1,0,0,0,i1,i2,i3,t, ec, evt(m) )
      #End
      fv(m) = fv(m) + damp*evt(m)
    end if   

   #If ORDER ge 4 && ORDERINTIME ge 4
     #If #DIM eq "2"
       ! Correct forcing for fourth-order ME in2D
       OGDERIV2D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
       OGDERIV2D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(m) )
       OGDERIV2D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(m) )
       OGDERIV2D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(m) )
       fv(m) = fv(m) + (dtSq/12.)*evtttt(m) - (cdtsq12/dtSq)*( evxxxx(m) + 2.*evxxyy(m) + evyyyy(m) )
     #Else
       ! Correct forcing for fourth-order ME in 3D
       OGDERIV3D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
       OGDERIV3D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(m) )
       OGDERIV3D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(m) )
       OGDERIV3D( 0,2,0,2,i1,i2,i3,t, ec, evxxzz(m) )
       OGDERIV3D( 0,0,2,2,i1,i2,i3,t, ec, evyyzz(m) )
       OGDERIV3D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(m) )
       OGDERIV3D( 0,0,0,4,i1,i2,i3,t, ec, evzzzz(m) )
       fv(m) = fv(m) + (dtSq/12.)*evtttt(m) - (cdtsq12/dtSq)*( evxxxx(m) + 2.*( evxxyy(m) + evxxzz(m) + evyyzz(m) ) + evyyyy(m) + evzzzz(m) )       
     #End
   #End
   #If ORDER ge 6 && ORDERINTIME ge 6
     #If #DIM eq "2"
       ! Correct forcing for sixth-order ME in 2D
       OGDERIV2D( 6,0,0,0,i1,i2,i3,t, ec, evtttttt(m) )
       OGDERIV2D( 0,6,0,0,i1,i2,i3,t, ec, evxxxxxx(m) )
       OGDERIV2D( 0,4,2,0,i1,i2,i3,t, ec, evxxxxyy(m) )
       OGDERIV2D( 0,2,4,0,i1,i2,i3,t, ec, evxxyyyy(m) )
       OGDERIV2D( 0,0,6,0,i1,i2,i3,t, ec, evyyyyyy(m) )
       fv(m) = fv(m) + (dtSq**2/360.)*evtttttt(m) - (cdtPow6By360/dtSq)*( evxxxxxx(m) + evyyyyyy(m) + 3.*(evxxxxyy(m) + evxxyyyy(m) )  )
     #Else
       ! Correct forcing for sixth-order ME in 3D
       OGDERIV3D( 6,0,0,0,i1,i2,i3,t, ec, evtttttt(m) )
       OGDERIV3D( 0,6,0,0,i1,i2,i3,t, ec, evxxxxxx(m) )
       OGDERIV3D( 0,0,6,0,i1,i2,i3,t, ec, evyyyyyy(m) )
       OGDERIV3D( 0,0,0,6,i1,i2,i3,t, ec, evzzzzzz(m) )       

       OGDERIV3D( 0,4,2,0,i1,i2,i3,t, ec, evxxxxyy(m) )
       OGDERIV3D( 0,2,4,0,i1,i2,i3,t, ec, evxxyyyy(m) )
       OGDERIV3D( 0,4,0,2,i1,i2,i3,t, ec, evxxxxzz(m) )
       OGDERIV3D( 0,2,0,4,i1,i2,i3,t, ec, evxxzzzz(m) )

       OGDERIV3D( 0,0,4,2,i1,i2,i3,t, ec, evyyyyzz(m) )
       OGDERIV3D( 0,0,2,4,i1,i2,i3,t, ec, evyyzzzz(m) )

       OGDERIV3D( 0,2,2,2,i1,i2,i3,t, ec, evxxyyzz(m) )

       fv(m) = fv(m) + (dtSq**2/360.)*evtttttt(m) \
            - (cdtPow6By360/dtSq)*( evxxxxxx(m) + evyyyyyy(m) + evzzzzzz(m) \
                                + 3.*(evxxxxyy(m) + evxxyyyy(m) + evyyyyyy(m) + evyyyyzz(m) + evyyzzzz(m) )  + 6.*evxxyyzz(m)  )
     #End
   #End       

 else if( forcingOption.eq.helmholtzForcing )then

    ! forcing for solving the Helmholtz equation   
    ! NOTE: change sign of forcing since for Helholtz we want to solve
    !      ( omega^2 I + c^2 Delta) w = f 
    ! fv(m) = -f(i1,i2,i3,0)*coswt  

    fv(m)=0.
    do freq=0,numberOfFrequencies-1 
      omega = frequencyArray(freq)
      coswt = cosFreqt(freq)    
      #If #ORDERINTIME eq "2"
       ! if( i1.eq.2 .and. i2.eq.2 )then 
       ! if( .true. )then 
       !   write(*,'(" adv: forcing f(i1,i2,i3)=",1pe12.4," coswt=",1pe12.4," t=",1pe12.4," omega=",1pe12.4)') f(i1,i2,i3,0),coswt,t,omega
       ! end if

       ! fv(m) = -f(i1,i2,i3,0)*coswt  

       fv(m) = fv(m) - f(i1,i2,i3,freq)*coswt

      #Else
        ! Add corrections for 4th order modified equation 
        !  fv = f + (dt^2/12)*( c^2 Delta(u) + ftt )
        #If #GRIDTYPE eq "rectangular"
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22r(i1,i2,i3,freq) + fyy22r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23r(i1,i2,i3,freq) + fyy23r(i1,i2,i3,freq) + fzz23r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #End
        #Else
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22(i1,i2,i3,freq) + fyy22(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23(i1,i2,i3,freq) + fyy23(i1,i2,i3,freq) + fzz23(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #End
        #End           
      #End
    end do ! do freq  
 else if( addForcing.ne.0 )then  
    fv(m) = f(i1,i2,i3,0)
 end if


#endMacro

! =========================================================================================
!
! Macro: Advance the wave equation, EXPLICIT TIME-STEPPING
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveOpt(DIM,ORDER,ORDERINTIME,GRIDTYPE,FORCING)

  #If #FORCING eq "USEFORCING"
  #defineMacro FV(m) + cf*fv(m)
  #Else
  #defineMacro FV(m) 
  #End

  if( (orderOfAccuracy.eq.6 .or. debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("advWave: ADVANCE dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE... t=",e10.2)') t
  end if
  

  ! --- TAYLOR TIME-STEPPING --- 
 
  m=0 ! component number 
  ec = 0 ! component number

  #If #GRIDTYPE eq "curvilinear"
    #If #ORDER eq "4" && #ORDERINTIME eq "4"
      computeLaplacianOrder2(DIM,EXPLICIT)
    #End
  #End
      
  if( forcingOption.eq.helmholtzForcing )then
    coswt = cos(omega*t)
  end if 

  fv(m)=0.
 ! ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
 ! #If #FORCING eq "NOFORCING"
 ! ! do not use mask for Cartesian grid , no forcing 
 beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #Else
 !  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #End

   #If #FORCING eq "USEFORCING"
    getForcing(DIM,ORDER,ORDERINTIME,GRIDTYPE) 
   #End

   #If #ORDER eq "2"

     ! --- SECOND ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx22r(i1,i2,i3,0) + uyy22r(i1,i2,i3,0) ) FV(m)

        ! write(*,'(" adv: i1,i2=",2i4," un,u,um=",3e12.2," cdtSq,fv=",2e12.2)') i1,i2,un(i1,i2,i3,m),u(i1,i2,i3,m),um(i1,i2,i3,m),cdtSq,fv(m)

       #Else
         un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx22(i1,i2,i3,0)  + uyy22(i1,i2,i3,0) ) FV(m)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx23r(i1,i2,i3,0) + uyy23r(i1,i2,i3,0) + uzz23r(i1,i2,i3,0) ) FV(m)
       #Else
         un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx23(i1,i2,i3,0)  + uyy23(i1,i2,i3,0)  + uzz23(i1,i2,i3,0)  ) FV(m)
       #End
     #End

   #Elif #ORDER eq "4"

     ! --- -FOURTH ORDER ---

     #If #DIM eq "2"
       ! --- FOUTH-ORDER TWO DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! orderInSpace=4 and orderInTime=4 
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*lap2d4(i1,i2,i3,m) + cLapSq*lap2d2pow2(i1,i2,i3,m) FV(m)
         #Else
           ! v is assumed to hold Lap(u) to 2nd-order
           ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
                                                              + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) FV(m)
         #End
       #Else
         ! orderInSpace==4 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*lap2d4(i1,i2,i3,m) FV(m)
         #Else
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) FV(m)
         #End

       #End                                                          
     #Else
       ! --- FOURTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "4"
         ! orderInSpace=4 and orderInTime=4 
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*lap3d4(i1,i2,i3,m) + cLapSq*lap3d2pow2(i1,i2,i3,m) FV(m)
         #Else
           ! v is assumed to hold Lap(u) to 2nd-order
           ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) \
                                                               + cLapSq*( vxx23(i1,i2,i3,m) + vyy23(i1,i2,i3,m) + vzz23(i1,i2,i3,m) ) FV(m)
         #End
       #Else
         ! orderInSpace==4 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*lap3d4(i1,i2,i3,m) FV(m)
         #Else
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) FV(m)
         #End

       #End     


     #End

   #Elif #ORDER eq "6"
         
     ! ---- SIXTH ORDER ---

     #If #DIM eq "2"

       ! --- SIXTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

         ! orderInSpace==6 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx62r(i1,i2,i3,m) + uyy62r(i1,i2,i3,m) ) FV(m)
         #Else
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx62(i1,i2,i3,m)  +  uyy62(i1,i2,i3,m) ) FV(m)
         #End       

       #Else

         ! ---- MODIFIED EQUATION ORDER=6 2D -----

          write(*,*) "advWave: Order 6 ME is now done by another routine in advWaveME.bf90"
          stop 6666
         ! getSixthDerivatives2d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)


         if( i1.eq.21 .and. i2.eq.11 )then
           OGDERIV2D( 0,2,0,0,i1,i2,i3,t, ec, evxx(0) )
           OGDERIV2D( 0,0,2,0,i1,i2,i3,t, ec, evyy(0) )
           OGDERIV2D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(0) )
           OGDERIV2D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(0) )
           OGDERIV2D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(0) )
           write(*,'("i1,i2=",2i4)') i1,i2
           write(*,'(" uxx  =",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uxx  ,evxx(0)  ,abs(uxx  -evxx(0)  )
           write(*,'(" uyy  =",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uyy  ,evyy(0)  ,abs(uyy  -evyy(0)  )
           write(*,'(" uxxxx=",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uxxxx,evxxxx(0),abs(uxxxx-evxxxx(0))
           write(*,'(" uxxyy=",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uxxyy,evxxyy(0),abs(uxxyy-evxxyy(0))
           write(*,'(" uyyyy=",1pe12.4," true=",1pe12.4," err=",1pe8.2)') uyyyy,evyyyy(0),abs(uyyyy-evyyyy(0))

! uxxxx    = rxi**4*urrrr+4.*rxi**3*sxi*urrrs+6.*rxi**2*sxi**2*urrss+4.*rxi*sxi**3*ursss+sxi**4*ussss+6.*rxi**2*rxx*urrr+(7.*sxi*rxi*rxx+sxx*rxi**2+rxi*(3.*rxi*sxx+3.*rxx*sxi)+rxi*(2.*rxi*sxx+2.*rxx*sxi))*urrs+(sxi*(3.*rxi*sxx+3.*rxx*sxi)+7.*rxi*sxx*sxi+rxx*sxi**2+sxi*(2.*rxi*sxx+2.*rxx*sxi))*urss+6.*sxi**2*sxx*usss+(4.*rxi*rxxx+3.*rxx**2)*urr+(4.*rxi*sxxx+6.*rxx*sxx+4.*rxxx*sxi)*urs+(4.*sxi*sxxx+3.*sxx**2)*uss+rxxxx*ur+sxxxx*us

           stop 1111
         end if
         ! cdtPow4By12  = (c*dt)^4/12 
         ! cdtPow6By360 = (c*dt)^6/360

         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                         + cdtSq*( uxx + uyy ) \
                         + cdtPow4By12*( uxxxx + uyyyy + 2.*uxxyy )  \
                         + cdtPow6By360*( uxxxxxx + uyyyyyy + 3.*(uxxxxyy + uxxyyyy) ) \
                         FV(m)

       #End                                                          

    #Else

       ! --- SIXTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! orderInSpace==6 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx63r(i1,i2,i3,m) + uyy63r(i1,i2,i3,m) + uzz63r(i1,i2,i3,m) ) FV(m)
         #Else
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx63(i1,i2,i3,m)  + uyy63(i1,i2,i3,m)  + uzz63(i1,i2,i3,m) )  FV(m)
         #End       

       #Else

         ! MODIFIED EQUATION ORDER=6 3D

         ! Turn off for now: 
         ! getSixthDerivatives3d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

         write(*,'("advWave: order=ORDER, orderInTime=ORDERINTIME FINISH ME")')
         stop 7777

         un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
                         + cdtSq*( uxx + uyy +uzz ) \
                         + cdtPow4By12*( uxxxx + uyyyy + uzzzz + 2.*( uxxyy +uxxzz + uyyzz ) )  \
                         + cdtPow6By360*( uxxxxxx +  uyyyyyy + uzzzzzz + 3.*(uxxxxyy + uxxyyyy + uxxxxzz + uyyyyzz + uxxzzzz + uyyzzzz ) + 6.*uxxyyzz ) \
                         FV(m)

       #End     


     #End

   #Elif #ORDER eq "8"
         
     ! ---- EIGTH ORDER ---

     #If #DIM eq "2"

       ! --- EIGTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

         ! orderInSpace==8 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx82r(i1,i2,i3,m) + uyy82r(i1,i2,i3,m) ) FV(m)
         #Else
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx82(i1,i2,i3,m)  +  uyy82(i1,i2,i3,m) ) FV(m)
         #End       

       #Else

         write(*,'("advWave: order=ORDER, orderInTime=ORDERINTIME FINISH ME")')
         stop 7777

         ! ! orderInSpace=4 and orderInTime=4 
         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) + cdtsq12*lap2d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End


       #End                                                          

    #Else

       ! --- EIGTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! orderInSpace==8 and orderInTime==2                                                   
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx83r(i1,i2,i3,m) + uyy83r(i1,i2,i3,m) + uzz83r(i1,i2,i3,m) )  FV(m)
         #Else
           un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) + cLap*( uxx83(i1,i2,i3,m)  + uyy83(i1,i2,i3,m)  + uzz83(i1,i2,i3,m)  )  FV(m)
         #End       

       #Else

         write(*,'("advWave: order=ORDER, orderInTime=ORDERINTIME FINISH ME")')
         stop 7777

         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap3d4(i1,i2,i3,m) + cdtsq12*lap3d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx23(i1,i2,i3,m) + vyy23(i1,i2,i3,m) + vzz23(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End

       #End     


     #End


   #Else

     write(*,'("advWave: UNKNOWN order=ORDER")')
     stop 7777

   #End         

   ! write(*,'("i1,i2=",2i3," u-ue=",e10.2)') i1,i2,u(i1,i2,i3,m)-ev(m)

   ! write(*,'(" uxx-uxxe =",e10.2)') uxx22r(i1,i2,i3,0)-evxx(m)

   ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t+dt, ec, ev(m)  )
   ! write(*,'(" un-ue=",e10.2)') un(i1,i2,i3,m)-ev(m)

  ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
  !#If #FORCING eq "NOFORCING"
  endLoops()
  !#Else
  ! endLoopsMask()
  !#End


#endMacro
  


! =========================================================================================
!
! Macro: Advance the wave equation, EXPLICIT TIME-STEPPING and 
!
!     +++++++++ SUPERGRID ++++++++++++++
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveOptSuperGrid(DIM,ORDER,ORDERINTIME,GRIDTYPE,FORCING)

  #If #FORCING eq "USEFORCING"
  #defineMacro FV(m) + cf*fv(m)
  #Else
  #defineMacro FV(m) 
  #End

  if( (orderOfAccuracy.eq.2 .or. debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("advWave: ADVANCE SUPERGRID dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE... t=",e10.2)') t
  end if
  
  #If #GRIDTYPE eq "curvilinear"
    write(*,'("advWave: ADVANCE SUPERGRID: This function should not be called for curvilinear grids, use normal one.")' )
    stop 666
  #End

  ! --- TAYLOR TIME-STEPPING --- 
 
  m=0 ! component number 
  ec = 0 ! component number

  #If #ORDER eq "4" && #ORDERINTIME eq "4"
    computeLaplacianOrder2(DIM,EXPLICIT)
  #End
      
  if( forcingOption.eq.helmholtzForcing )then
    coswt = cos(omega*t)
  end if 

  fv(m)=0.
 ! ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
 ! #If #FORCING eq "NOFORCING"
 ! ! do not use mask for Cartesian grid , no forcing 
 beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #Else
 !  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
 ! #End

   #If #FORCING eq "USEFORCING"
    getForcing(DIM,ORDER,ORDERINTIME,GRIDTYPE) 
   #End

   #If #ORDER eq "2"

     ! --- SECOND ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
                 + cLap*( etax(i1,0)*uxx22r(i1,i2,i3,0) + etax(i1,1)*ux22r(i1,i2,i3,0) \
                        + etay(i2,0)*uyy22r(i1,i2,i3,0) + etay(i2,1)*uy22r(i1,i2,i3,0) ) FV(m)

      ! write(*,'(" adv: i1,i2=",2i4," un,u,um=",3e12.2," cdtSq,fv=",2e12.2)') i1,i2,un(i1,i2,i3,m),u(i1,i2,i3,m),um(i1,i2,i3,m),cdtSq,fv(m)
      ! write(*,'(" adv: etax=",2e12.2," etay=",2e12.2)') etax(i1,0),etax(i1,1), etay(i2,0),etay(i2,1)
      ! write(*,'(" adv: cn,cm,cLap,cf=",4e12.2)') cn,cm,cLap,cf

     #Else
       ! --- THREE DIMENSIONS ---

        un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
              + cLap*( etax(i1,0)*uxx23r(i1,i2,i3,0) + etax(i1,1)*ux23r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy23r(i1,i2,i3,0) + etay(i2,1)*uy23r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz23r(i1,i2,i3,0) + etaz(i3,1)*uz23r(i1,i2,i3,0) ) FV(m)

     #End

   #Elif #ORDER eq "4"

     ! --- -FOURTH ORDER ---

     #If #DIM eq "2"
       ! --- FOUTH-ORDER TWO DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 2D, orderInSpace=4 and orderInTime=4 

          ! v is assumed to hold Lap(u) to 2nd-order
          un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
                  + cLap*( etax(i1,0)*uxx42r(i1,i2,i3,0) + etax(i1,1)*ux42r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy42r(i1,i2,i3,0) + etay(i2,1)*uy42r(i1,i2,i3,0) ) \
               + cdtsq12*( etax(i1,0)*vxx22r(i1,i2,i3,0) + etax(i1,1)*vx22r(i1,i2,i3,0)   \
                         + etay(i2,0)*vyy22r(i1,i2,i3,0) + etay(i2,1)*vy22r(i1,i2,i3,0) ) \
                 FV(m)
       #Else
         ! 2D orderInSpace==4 and orderInTime==2
         un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
                  + cLap*( etax(i1,0)*uxx42r(i1,i2,i3,0) + etax(i1,1)*ux42r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy42r(i1,i2,i3,0) + etay(i2,1)*uy42r(i1,i2,i3,0) ) \
                 FV(m)                                                            

       #End                                                          
     #Else
       ! --- FOURTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "4"
         ! 3D, orderInSpace=4 and orderInTime=4 

          un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
                  + cLap*( etax(i1,0)*uxx43r(i1,i2,i3,0) + etax(i1,1)*ux43r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy43r(i1,i2,i3,0) + etay(i2,1)*uy43r(i1,i2,i3,0)   \
                         + etaz(i3,0)*uzz43r(i1,i2,i3,0) + etaz(i3,1)*uz43r(i1,i2,i3,0) ) \
                + cLapSq*( etax(i1,0)*vxx23r(i1,i2,i3,0) + etax(i1,1)*vx23r(i1,i2,i3,0)   \
                         + etay(i2,0)*vyy23r(i1,i2,i3,0) + etay(i2,1)*vy23r(i1,i2,i3,0)   \
                         + etaz(i3,0)*vzz23r(i1,i2,i3,0) + etaz(i3,1)*vz23r(i1,i2,i3,0) ) \
                                          FV(m)

        #Else
         ! 3D, orderInSpace==4 and orderInTime==2                                                   

          un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
              + cLap*( etax(i1,0)*uxx43r(i1,i2,i3,0) + etax(i1,1)*ux43r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy43r(i1,i2,i3,0) + etay(i2,1)*uy43r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz43r(i1,i2,i3,0) + etaz(i3,1)*uz43r(i1,i2,i3,0) ) FV(m)

       #End     


     #End

   #Elif #ORDER eq "6"
         
     ! ---- SIXTH ORDER ---

     #If #DIM eq "2"

       ! --- SIXTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

        ! 2D, orderInSpace==6 and orderInTime==2
        un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
                  + cLap*( etax(i1,0)*uxx62r(i1,i2,i3,0) + etax(i1,1)*ux62r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy62r(i1,i2,i3,0) + etay(i2,1)*uy62r(i1,i2,i3,0) ) \
                 FV(m)                                                                        

       #Else

         ! ---- MODIFIED EQUATION ORDER=6 2D -----

          write(*,'("advWave: ADVANCE SUPERGRID: order 6 FINISH ME.")' )
          stop 666

         ! getSixthDerivatives2d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

         ! cdtPow4By12  = (c*dt)^4/12 
         ! cdtPow6By360 = (c*dt)^6/360

         ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
         !                 + cdtSq*( uxx + uyy ) \
         !                 + cdtPow4By12*( uxxxx + uyyyy + 2.*uxxyy )  \
         !                 + cdtPow6By360*( uxxxxxx + uyyyyyy + 3.*(uxxxxyy + uxxyyyy) ) \
         !                 FV(m)

       #End                                                          

    #Else

       ! --- SIXTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! 3D, orderInSpace==6 and orderInTime==2  

          un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
              + cLap*( etax(i1,0)*uxx63r(i1,i2,i3,0) + etax(i1,1)*ux63r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy63r(i1,i2,i3,0) + etay(i2,1)*uy63r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz63r(i1,i2,i3,0) + etaz(i3,1)*uz63r(i1,i2,i3,0) ) FV(m)

       #Else

         ! MODIFIED EQUATION ORDER=6 3D
          write(*,'("advWave: ADVANCE SUPERGRID: order 6 3D FINISH ME.")' )
          stop 666         

         ! Turn off for now: 
         ! getSixthDerivatives3d(ORDER,GRIDTYPE,evalMetrics,i1,i2,i3)

         ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) \
         !                 + cdtSq*( uxx + uyy +uzz ) \
         !                 + cdtPow4By12*( uxxxx + uyyyy + uzzzz + 2.*( uxxyy +uxxzz + uyyzz ) )  \
         !                 + cdtPow6By360*( uxxxxxx +  uyyyyyy + uzzzzzz + 3.*(uxxxxyy + uxxyyyy + uxxxxzz + uyyyyzz + uxxzzzz + uyyzzzz ) + 6.*uxxyyzz ) \
         !                 FV(m)

       #End     


     #End

   #Elif #ORDER eq "8"
         

     ! ---- EIGTH ORDER ---

     #If #DIM eq "2"

       ! --- EIGTH-ORDER TWO DIMENSIONS ---

       #If #ORDERINTIME eq "2"

         ! 2D, orderInSpace==8 and orderInTime==2   
         un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
                  + cLap*( etax(i1,0)*uxx82r(i1,i2,i3,0) + etax(i1,1)*ux82r(i1,i2,i3,0)   \
                         + etay(i2,0)*uyy82r(i1,i2,i3,0) + etay(i2,1)*uy82r(i1,i2,i3,0) ) \
                 FV(m)                                                                                      

       #Else


         write(*,'("advWave: ADVANCE SUPERGRID: order 8 FINISH ME.")' )
         stop 666

         ! ! orderInSpace=4 and orderInTime=4 
         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) + cdtsq12*lap2d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End


       #End                                                          

    #Else

       ! --- EIGHTH-ORDER THREE DIMENSIONS ---

       #If #ORDERINTIME eq "2

         ! 3D, orderInSpace==8 and orderInTime==2   

          un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
              + cLap*( etax(i1,0)*uxx83r(i1,i2,i3,0) + etax(i1,1)*ux83r(i1,i2,i3,0) \
                     + etay(i2,0)*uyy83r(i1,i2,i3,0) + etay(i2,1)*uy83r(i1,i2,i3,0) \
                     + etaz(i3,0)*uzz83r(i1,i2,i3,0) + etaz(i3,1)*uz83r(i1,i2,i3,0) ) FV(m)

       #Else

         write(*,'("advWave: ADVANCE SUPERGRID: order 8 FINISH ME.")' )
         stop 666

         ! #If #GRIDTYPE eq "rectangular"
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap3d4(i1,i2,i3,m) + cdtsq12*lap3d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         ! #Else
         !   ! v is assumed to hold Lap(u) to 2nd-order
         !   ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
         !   un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx43(i1,i2,i3,m) + uyy43(i1,i2,i3,m) + uzz43(i1,i2,i3,m) ) \
         !                                                   + cdtsq12*( vxx23(i1,i2,i3,m) + vyy23(i1,i2,i3,m) + vzz23(i1,i2,i3,m) ) + dtSq*fv(m)
         ! #End

       #End     


     #End


   #Else

     write(*,'("advWave: UNKNOWN order=ORDER")')
     stop 7777

   #End         

   ! write(*,'("i1,i2=",2i3," u-ue=",e10.2)') i1,i2,u(i1,i2,i3,m)-ev(m)

   ! write(*,'(" uxx-uxxe =",e10.2)') uxx22r(i1,i2,i3,0)-evxx(m)

   ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t+dt, ec, ev(m)  )
   ! write(*,'(" un-ue=",e10.2)') un(i1,i2,i3,m)-ev(m)

  ! #If #GRIDTYPE eq "rectangular" && #FORCING eq "NOFORCING"
  !#If #FORCING eq "NOFORCING"
  endLoops()
  !#Else
  ! endLoopsMask()
  !#End


#endMacro
  

! =========================================================================================
! Macro: Compute the forcing for the IMPLICIT update of u
! =========================================================================================
#beginMacro getForcingImplicit(DIM,ORDER,ORDERINTIME,GRIDTYPE)
  if( addForcing.eq.0 )then ! *wdh* Tues March 28, 2023
    fv(m) = 0.
  else if( forcingOption.eq.twilightZoneForcing )then

    #If #DIM eq "2" 
      ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      OGDERIV2D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      fv(m) = evtt(m)
      ! We weight the TZ forcing with the implicit weights to make the solution exact for polynomials
      do mt=-1,1
        tm = t + dt*mt
        OGDERIV2D( 0,2,0,0,i1,i2,i3,tm, ec, evxx(m) )
        OGDERIV2D( 0,0,2,0,i1,i2,i3,tm, ec, evyy(m) )
        fv(m) = fv(m) -csq*( cImp(mt,0)*( evxx(m) + evyy(m) )  )
      end do


    #Else
      ! OGDERIV3D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )

      OGDERIV3D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      fv(m) = evtt(m)
      ! We weight the TZ forcing with the implicit weights to make the solution exact for polynomials
      do mt=-1,1
        tm = t + dt*mt       
        OGDERIV3D( 0,2,0,0,i1,i2,i3,tm, ec, evxx(m) )
        OGDERIV3D( 0,0,2,0,i1,i2,i3,tm, ec, evyy(m) )
        OGDERIV3D( 0,0,0,2,i1,i2,i3,tm, ec, evzz(m) )
        fv(m) = fv(m) -csq*( cImp(mt,0)*( evxx(m) + evyy(m) + evzz(m) )  ) 
      end do
    #End

    if( damp .ne. 0. )then
      #If #DIM eq "2"
        OGDERIV2D( 1,0,0,0,i1,i2,i3,t, ec, evt(m) )
      #Else
        OGDERIV3D( 1,0,0,0,i1,i2,i3,t, ec, evt(m) )
      #End
      fv(m) = fv(m) + damp*evt(m) 

    end if  

   #If #ORDER eq "4" && #ORDERINTIME eq "4"
    #If #DIM eq "2"
      ! Scheme is: 
      ! D+tD-t U = c^2 Lh4( alpha2*U^{n+1} + beta2 U^{n} + alpha2*U^{n-1} ) - dt^2 c^4 (L2h)^2 ( alpha4*U^{n+1} + beta4 U^{n} + alpha4*U^{n-1} ) + f 
 
      OGDERIV2D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
      fv(m) = fv(m) + (dtSq/12.)*evtttt(m) 

      ! We weight the TZ forcing with the implicit weights to make the solution exact for polynomials
      do mt=-1,1
        tm = t + dt*mt
        
        OGDERIV2D( 0,4,0,0,i1,i2,i3,tm, ec, evxxxx(m) )
        OGDERIV2D( 0,2,2,0,i1,i2,i3,tm, ec, evxxyy(m) )
        OGDERIV2D( 0,0,4,0,i1,i2,i3,tm, ec, evyyyy(m) )          

        fv(m) = fv(m) + (dt**2 * c**4)*( cImp(mt,1)*(  evxxxx(m) + 2.*evxxyy(m) + evyyyy(m) )  )
      end do

      if( takeImplicitFirstStep.eq.1 )then
        ! implicit first step: adjust forcing
        ! write(*,'("advWave: Adjust forcing for takeImplicitFirstStep, t=",e10.2)') t

        ! dt^3/6 * f_t 
        !  f_t = ue_ttt - L ue_t
        OGDERIV2D( 3,0,0,0,i1,i2,i3,t, ec, evttt(m) )
        OGDERIV2D( 1,2,0,0,i1,i2,i3,t, ec, evxxt(m) )
        OGDERIV2D( 1,0,2,0,i1,i2,i3,t, ec, evyyt(m) )
        fv(m) = fv(m) + (1./cf)*(dt**3/6.)*( evttt(m) - cSq*( evxxt(m) + evyyt(m) )) 

        ! -alpha2 * dt^5/6 *( L f_t )
        ! L f_t = (L ue)_ttt - L^2(ue)_t 
        OGDERIV2D( 3,2,0,0,i1,i2,i3,t, ec, evxxttt(m) )
        OGDERIV2D( 3,0,2,0,i1,i2,i3,t, ec, evyyttt(m) )

        OGDERIV2D( 1,4,0,0,i1,i2,i3,t, ec, evxxxxt(m) )
        OGDERIV2D( 1,2,2,0,i1,i2,i3,t, ec, evxxyyt(m) )
        OGDERIV2D( 1,0,4,0,i1,i2,i3,t, ec, evyyyyt(m) )

        fv(m) = fv(m) - (1./cf)*(cImp(-1,0)*dt**5/6.)*( cSq*(evxxttt(m) + evyyttt(m)) - cSq**2*( evxxxxt(m) + 2.*evxxyyt(m) + evyyyyt(m) )) 

        ! OGDERIV2D( 3,4,0,0,i1,i2,i3,t, ec, evxxxxttt(m) )
        ! OGDERIV2D( 3,2,2,0,i1,i2,i3,t, ec, evxxyyttt(m) )
        ! OGDERIV2D( 3,0,4,0,i1,i2,i3,t, ec, evyyyyttt(m) )
        ! fv(m) = fv(m) + (1./cf)*(cImp(-1,1)*dt**7/6.)*( cSq**2*( evxxxxttt(m) + 2.*evxxyyttt(m) + evyyyyttt(m) ) )     

      end if

    #Else

      OGDERIV3D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
      fv(m) = fv(m) + (dtSq/12.)*evtttt(m) 

      ! We weight the TZ forcing with the implicit weights to make the solution exact for polynomials
      do mt=-1,1
        tm = t + dt*mt
        
        OGDERIV3D( 0,4,0,0,i1,i2,i3,tm, ec, evxxxx(m) )
        OGDERIV3D( 0,2,2,0,i1,i2,i3,tm, ec, evxxyy(m) )
        OGDERIV3D( 0,0,4,0,i1,i2,i3,tm, ec, evyyyy(m) )  

        OGDERIV3D( 0,2,0,2,i1,i2,i3,tm, ec, evxxzz(m) )                
        OGDERIV3D( 0,0,2,2,i1,i2,i3,tm, ec, evyyzz(m) )                
        OGDERIV3D( 0,0,0,4,i1,i2,i3,tm, ec, evzzzz(m) )                


        fv(m) = fv(m) + (dt**2 * c**4)*( cImp(mt,1)*(  evxxxx(m) + 2.*evxxyy(m) + 2.*evxxzz(m) + 2.*evyyzz(m) + evyyyy(m) + evzzzz(m) )  )
      end do

      if( takeImplicitFirstStep.eq.1 )then
        ! implicit first step: adjust forcing
        write(*,'("advWave: Adjust forcing for takeImplicitFirstStep in 3D , t=",e10.2)') t


        ! dt^3/6 * f_t 
        !  f_t = ue_ttt - L ue_t
        OGDERIV3D( 3,0,0,0,i1,i2,i3,t, ec, evttt(m) )
        OGDERIV3D( 1,2,0,0,i1,i2,i3,t, ec, evxxt(m) )
        OGDERIV3D( 1,0,2,0,i1,i2,i3,t, ec, evyyt(m) )
        OGDERIV3D( 1,0,0,2,i1,i2,i3,t, ec, evzzt(m) )
        fv(m) = fv(m) + (1./cf)*(dt**3/6.)*( evttt(m) - cSq*( evxxt(m) + evyyt(m) + evzzt(m) ) ) 

        ! -alpha2 * dt^5/6 *( L f_t )
        ! L f_t = (L ue)_ttt - L^2(ue)_t 
        OGDERIV3D( 3,2,0,0,i1,i2,i3,t, ec, evxxttt(m) )
        OGDERIV3D( 3,0,2,0,i1,i2,i3,t, ec, evyyttt(m) )
        OGDERIV3D( 3,0,0,2,i1,i2,i3,t, ec, evzzttt(m) )

        OGDERIV3D( 1,4,0,0,i1,i2,i3,t, ec, evxxxxt(m) )
        OGDERIV3D( 1,0,4,0,i1,i2,i3,t, ec, evyyyyt(m) )
        OGDERIV3D( 1,0,0,4,i1,i2,i3,t, ec, evzzzzt(m) )

        OGDERIV3D( 1,2,2,0,i1,i2,i3,t, ec, evxxyyt(m) )
        OGDERIV3D( 1,2,0,2,i1,i2,i3,t, ec, evxxzzt(m) )
        OGDERIV3D( 1,0,2,2,i1,i2,i3,t, ec, evyyzzt(m) )

        fv(m) = fv(m) - (1./cf)*(cImp(-1,0)*dt**5/6.)*( cSq*(evxxttt(m) + evyyttt(m) + evzzttt(m)) \
                              - cSq**2*( evxxxxt(m) + evyyyyt(m) + evzzzzt(m) + 2.*(evxxyyt(m) + evxxzzt(m) + evyyzzt(m) )) ) 

      end if


    #End
   #End

 else if( forcingOption.eq.helmholtzForcing )then
   ! forcing for solving the Helmholtz equation   
   ! NOTE: change sign of forcing since for Helholtz we want to solve
   !      ( omega^2 I + c^2 Delta) w = f    
   ! Define
   !   coswtAve = cImp(-1)*cos(omega*(t-dt)) + cImp(0)*cos(omega*t) + cImp(1)*cos(omega*(t+dt))
    fv(m)=0. 
    do freq=0,numberOfFrequencies-1
      omega = frequencyArray(freq)
      #If #ORDERINTIME eq "2" 
        fv(m) = fv(m) -f(i1,i2,i3,freq)*coswtAve(freq)    
      #Else
        ! Add corrections for 4th order modified equation 
        !  fv = f + (dt^2/12)*( c^2 Delta(u) + ftt )
        #If #GRIDTYPE eq "rectangular"
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22r(i1,i2,i3,freq) + fyy22r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq)
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23r(i1,i2,i3,freq) + fyy23r(i1,i2,i3,freq) + fzz23r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq) 
          #End
        #Else
          #If #DIM eq "2"
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22(i1,i2,i3,freq) + fyy22(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq)
          #Else
            fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23(i1,i2,i3,freq) + fyy23(i1,i2,i3,freq) + fzz23(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswtAve(freq) 
          #End
        #End           
      #End
    end do
 else if( addForcing.ne.0 )then  
    fv(m) = f(i1,i2,i3,0)
 end if

#endMacro

! =========================================================================================
!
! Macro: FILL IN THE RHS FOR IMPLICIT TIME-STEPPING
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveImplicitOpt(DIM,ORDER,ORDERINTIME,GRIDTYPE,FORCING)

  if( (debug.gt.1) .and. t.lt.2*dt )then
    write(*,'("advWave: ADVANCE IMPLICIT dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE, t=",e10.2)') t
  end if
  

  ! --- IMPLICIT TAYLOR TIME-STEPPING --- 
  !  D+t D-t u = c^2 Delta( cImp(1) *u^{n+1} + cImp(0) *u^n + cImp(-1)* u^{n-1} )

  m=0 ! component number 
  ec = 0 ! component number

  #If #GRIDTYPE eq "curvilinear"
   #If #ORDER eq "4" && #ORDERINTIME eq "4"
     computeLaplacianOrder2(DIM,IMPLICIT)
   #End
  #End
      
  if( forcingOption.eq.helmholtzForcing .and. addForcing.ne.0 )then
    do freq=0,numberOfFrequencies-1
      coswt = cos(frequencyArray(freq)*t) ! is this used?
      omega = frequencyArray(freq)
      coswtAve(freq) = cImp(-1,0)*cos(omega*(t-dt)) + cImp(0,0)*cos(omega*t) + cImp(1,0)*cos(omega*(t+dt))
    end do

    ! coswt = cos(omega*t)
    ! coswtAve = cImp(-1,0)*cos(omega*(t-dt)) + cImp(0,0)*cos(omega*t) + cImp(1,0)*cos(omega*(t+dt))    
  end if 

  fv(m)=0.
  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

    getForcingImplicit(DIM,ORDER,ORDERINTIME,GRIDTYPE)



   #If #ORDER eq "2"

     ! --- SECOND ORDER ---

     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx22r(i1,i2,i3,0) +  uyy22r(i1,i2,i3,0) )  \
                                                              + ts4*(umxx22r(i1,i2,i3,0) + umyy22r(i1,i2,i3,0) )  \
                                                              + tsf*fv(m)       
                                            
       #Else

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx22(i1,i2,i3,0) +  uyy22(i1,i2,i3,0) )  \
                                                              + ts4*(umxx22(i1,i2,i3,0) + umyy22(i1,i2,i3,0) )  \
                                                              + tsf*fv(m) 
                                                  
       #End
     #Else
       ! --- THREE DIMENSIONS ---

       #If #GRIDTYPE eq "rectangular"

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx23r(i1,i2,i3,0) +  uyy23r(i1,i2,i3,0) +  uzz23r(i1,i2,i3,0) )  \
                                                               + ts4*( umxx23r(i1,i2,i3,0) + umyy23r(i1,i2,i3,0) + umzz23r(i1,i2,i3,0) )  \
                                                               + tsf*fv(m) 
 
       #Else
        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx23(i1,i2,i3,0) +  uyy23(i1,i2,i3,0) +  uzz23(i1,i2,i3,0) )  \
                                                               + ts4*( umxx23(i1,i2,i3,0) + umyy23(i1,i2,i3,0) + umzz23(i1,i2,i3,0) )  \
                                                               + tsf*fv(m)           

       #End
     #End

   #Else
     ! --- -FOURTH ORDER ---
      #If #FIRSTSTEP eq "firstStep"
         write(*,'(" TAKE IMPLICIT FIRST STEP : FINISH ME")')
         stop 2323
      #End     

     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 2D orderInSpace=4 and orderInTime=4 IMPLICIT
         #If #GRIDTYPE eq "rectangular"

           ! FD44 IMP RECT 2D
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42r(i1,i2,i3,0) +  uyy42r(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42r(i1,i2,i3,0) + umyy42r(i1,i2,i3,0) )  \
                                                                 + ts5*( LAP2D2POW2(u ,i1,i2,i3,0) ) \
                                                                 + ts6*( LAP2D2POW2(um,i1,i2,i3,0) ) \
                                                                 + tsf*fv(m)                                                               
         #Else
           ! FD44 IMP CURV 2D
           !    --- 2D CURVILINEAR FD44i ------
           ! v(i1,i2,i3,0) holds Lap(u) to 2nd-order  : computed above
           ! v(i1,i2,i3,1) holds Lap(um) to 2nd-order
           !
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42(i1,i2,i3,0) +  uyy42(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42(i1,i2,i3,0) + umyy42(i1,i2,i3,0) )  \
                                                                 + ts5*( vxx22(i1,i2,i3,0) + vyy22(i1,i2,i3,0) ) \
                                                                 + ts6*( vxx22(i1,i2,i3,1) + vyy22(i1,i2,i3,1) ) \
                                                                 + tsf*fv(m) 

         #End

         ! if( i1==2 .and. i2==2 )then
         !   write(*,'(" i1,i2=",2i4," un=",1pe22.14," u=",1pe22.14," um=",1pe22.14)') i1,i2,un(i1,i2,i3,m),u(i1,i2,i3,m),um(i1,i2,i3,m)
         !   write(*,'(" uxx42,uyy42,umxx42,umyy42=",8(1pe22.14,1x))') uxx42r(i1,i2,i3,0),uyy42r(i1,i2,i3,0),umxx42r(i1,i2,i3,0),umyy42r(i1,i2,i3,0)
         !   write(*,'(" uLap2,umLap2=",8(1pe22.14,1x))') LAP2D2POW2(u ,i1,i2,i3,0), LAP2D2POW2(um,i1,i2,i3,0)

         !   write(*,'(" ts1,ts2,ts3,ts3,ts5,ts6,tsf,fv(m)=",8(1pe22.14,1x))') ts1,ts2,ts3,ts3,ts5,ts6,tsf,fv(m) 
         ! end if

       #Else

         ! 2D orderInSpace==4 and orderInTime==2  IMPLICIT                                                 
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42r(i1,i2,i3,0) +  uyy42r(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42r(i1,i2,i3,0) + umyy42r(i1,i2,i3,0) )  \
                                                                 + tsf*fv(m)             
         #Else
           !  --- 2D FD24i CURVLINEAR ---
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42(i1,i2,i3,0) +  uyy42(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42(i1,i2,i3,0) + umyy42(i1,i2,i3,0) )  \
                                                                 + tsf*fv(m)               
         #End

       #End                                                          
     #Else

       ! --- THREE DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 3D orderInSpace=4 and orderInTime=4 IMPLICIT

         #If #GRIDTYPE eq "rectangular"
           ! FD44 IMPLICIT RECT 3D
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx43r(i1,i2,i3,0) +  uyy43r(i1,i2,i3,0) +  uzz43r(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx43r(i1,i2,i3,0) + umyy43r(i1,i2,i3,0) + umzz43r(i1,i2,i3,0) )  \
                                                                 + ts5*( LAP3D2POW2(u ,i1,i2,i3,0) ) \
                                                                 + ts6*( LAP3D2POW2(um,i1,i2,i3,0) ) \
                                                                 + tsf*fv(m)  
         #Else
           ! FD44 IMPLICIT CURV 3D
           ! NOTE: 
           ! v(i1,i2,i3,0) holds Lap(u) to 2nd-order  : computed above
           ! v(i1,i2,i3,1) holds Lap(um) to 2nd-order
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx43(i1,i2,i3,0) +  uyy43(i1,i2,i3,0) +  uzz43(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx43(i1,i2,i3,0) + umyy43(i1,i2,i3,0) + umzz43(i1,i2,i3,0) )  \
                                                                 + ts5*( vxx23(i1,i2,i3,0) +  vyy23(i1,i2,i3,0) +  vzz23(i1,i2,i3,0) )  \
                                                                 + ts6*( vxx23(i1,i2,i3,1) +  vyy23(i1,i2,i3,1) +  vzz23(i1,i2,i3,1) )  \
                                                                 + tsf*fv(m) 
         #End

       #Else

         ! 3D orderInSpace==4 and orderInTime==2 IMPLICIT                                                  
         #If #GRIDTYPE eq "rectangular"
           ! FD24 IMPLICIT RECT 3D
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx43r(i1,i2,i3,0) +  uyy43r(i1,i2,i3,0) +  uzz43r(i1,i2,i3,0) )  \
                                                                  + ts4*( umxx43r(i1,i2,i3,0) + umyy43r(i1,i2,i3,0) + umzz43r(i1,i2,i3,0) )  \
                                                                  + tsf*fv(m)          
         #Else
           ! FD24 IMPLICIT CURV 3D                                                     
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx43(i1,i2,i3,0) +  uyy43(i1,i2,i3,0) +  uzz43(i1,i2,i3,0) )  \
                                                                  + ts4*( umxx43(i1,i2,i3,0) + umyy43(i1,i2,i3,0) + umzz43(i1,i2,i3,0) )  \
                                                                  + tsf*fv(m)                     
         #End
      #End

     #End


   #End         

   ! write(*,'("i1,i2=",2i3," u-ue=",e10.2)') i1,i2,u(i1,i2,i3,m)-ev(m)

   ! write(*,'(" uxx-uxxe =",e10.2)') uxx22r(i1,i2,i3,0)-evxx(m)

   ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t+dt, ec, ev(m)  )
   ! write(*,'(" un-ue=",e10.2)') un(i1,i2,i3,m)-ev(m)


  else 

    un(i1,i2,i3,0)=0.  ! set value to zero at mask==0 (for active unused points)

  endLoopsMask()



#endMacro


! =========================================================================================
!
! Macro: FILL IN THE RHS FOR IMPLICIT TIME-STEPPING
!          RECTANGULAR GRID + SUPERGRID 
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveImplicitOptSuperGrid(DIM,ORDER,ORDERINTIME,GRIDTYPE,FORCING)

  if( (debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("advWave: ADVANCE IMPLICIT SUPERGRID dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE, t=",e10.2)') t
  end if

  

  ! --- IMPLICIT TAYLOR TIME-STEPPING --- 
  !  D+t D-t u = c^2 Delta( cImp(1) *u^{n+1} + cImp(0) *u^n + cImp(-1)* u^{n-1} )

  m=0 ! component number 
  ec = 0 ! component number

  ! #If #GRIDTYPE eq "curvilinear"
  !   #If #ORDER eq "4" && #ORDERINTIME eq "4"
  !     computeLaplacianOrder2(DIM,IMPLICIT)
  !   #End
  ! #End
      
  if( forcingOption.eq.helmholtzForcing .and. addForcing.ne.0 )then
    do freq=0,numberOfFrequencies-1
      coswt = cos(frequencyArray(freq)*t) ! is this used?
      omega = frequencyArray(freq)
      coswtAve(freq) = cImp(-1,0)*cos(omega*(t-dt)) + cImp(0,0)*cos(omega*t) + cImp(1,0)*cos(omega*(t+dt))
    end do

    ! coswt = cos(omega*t)
    ! coswtAve = cImp(-1,0)*cos(omega*(t-dt)) + cImp(0,0)*cos(omega*t) + cImp(1,0)*cos(omega*(t+dt))    
  end if 

  fv(m)=0.
  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

    getForcingImplicit(DIM,ORDER,ORDERINTIME,GRIDTYPE)



   #If #ORDER eq "2"

     ! --- SECOND ORDER ---

     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m)                       \
           + ts3*( etax(i1,0)*uxx22r(i1,i2,i3,0)  + etax(i1,1)*ux22r(i1,i2,i3,0)    \
                +  etay(i2,0)*uyy22r(i1,i2,i3,0)  + etay(i2,1)*uy22r(i1,i2,i3,0) )  \
           + ts4*( etax(i1,0)*umxx22r(i1,i2,i3,0) + etax(i1,1)*umx22r(i1,i2,i3,0)   \
                +  etay(i2,0)*umyy22r(i1,i2,i3,0) + etay(i2,1)*umy22r(i1,i2,i3,0) ) \
                + tsf*fv(m)   

        ! un(i1,i2,i3,m)= cn*u(i1,i2,i3,m) +cm*um(i1,i2,i3,m) \
        !          + cLap*( etax(i1,0)*uxx22r(i1,i2,i3,0) + etax(i1,1)*ux22r(i1,i2,i3,0) \
        !                 + etay(i2,0)*uyy22r(i1,i2,i3,0) + etay(i2,1)*uy22r(i1,i2,i3,0) ) FV(m)   

       #Else
        stop 8888                                                  
       #End
     #Else
       ! --- THREE DIMENSIONS ---

       #If #GRIDTYPE eq "rectangular"

        un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m)                         \
             + ts3*(  etax(i1,0)*uxx23r(i1,i2,i3,0)  + etax(i1,1)*ux23r(i1,i2,i3,0)    \
                   +  etay(i2,0)*uyy23r(i1,i2,i3,0)  + etay(i2,1)*uy23r(i1,i2,i3,0)    \
                   +  etaz(i3,0)*uzz23r(i1,i2,i3,0)  + etaz(i3,1)*uz23r(i1,i2,i3,0) )  \
             + ts4*( etax(i1,0)*umxx23r(i1,i2,i3,0)  + etax(i1,1)*umx23r(i1,i2,i3,0)   \
                   + etay(i2,0)*umyy23r(i1,i2,i3,0)  + etay(i2,1)*umy23r(i1,i2,i3,0)   \
                   + etaz(i3,0)*umzz23r(i1,i2,i3,0)  + etaz(i3,1)*umz23r(i1,i2,i3,0) ) \
             + tsf*fv(m)       

       #Else
         stop 888

       #End
     #End

   #Else
     ! --- -FOURTH ORDER ---
      #If #FIRSTSTEP eq "firstStep"
         write(*,'(" TAKE IMPLICIT FIRST STEP : FINISH ME")')
         stop 2323
      #End     

     write(*,'(" IMPLICIT RHS ORDER = 4 + SUPER GRID : FINISH ME")') 
     stop 5555

     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 2D orderInSpace=4 and orderInTime=4 IMPLICIT
         #If #GRIDTYPE eq "rectangular"

           write(*,'("advWave: finish me for GRIDTYPE IMPLICIT order=ORDER, dim=DIM")')
           stop 4444

           ! This could be maybe optimized by first computing w = cImp(0)*u + cImp(-1)*um and then computing laplacian(w)
           ! FIX ME : Need different Implicit weights for lap^2
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*( cImp( 0,0)*LAP2D4(u ,i1,i2,i3,m)       \
                                                          +          cImp(-1,0)*LAP2D4(um,i1,i2,i3,m) )     \
                                                         + cdtsq12*( cImp( 0,1)*LAP2D2POW2(u ,i1,i2,i3,m)   \
                                                         +           cImp(-1,1)*LAP2D2POW2(um,i1,i2,i3,m) ) \
                                                         + dtSq*fv(m)
         #Else
           stop 8888
         #End

       #Else

         ! 2D orderInSpace==4 and orderInTime==2  IMPLICIT                                                 
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42r(i1,i2,i3,0) +  uyy42r(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42r(i1,i2,i3,0) + umyy42r(i1,i2,i3,0) )  \
                                                                 + tsf*fv(m)             
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *( uxx42r(i1,i2,i3,0) +  uyy42r(i1,i2,i3,0) ) +  \
           !                                                               cImp(-1,0) *(umxx42r(i1,i2,i3,0) + umyy42r(i1,i2,i3,0) ) )  \
           !                                                   + dtSq*fv(m)         
         #Else
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx42(i1,i2,i3,0) +  uyy42(i1,i2,i3,0) )  \
                                                                 + ts4*(umxx42(i1,i2,i3,0) + umyy42(i1,i2,i3,0) )  \
                                                                 + tsf*fv(m)               
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *(  uxx42(i1,i2,i3,0) +  uyy42(i1,i2,i3,0) ) +   \
           !                                                               cImp(-1,0) *( umxx42(i1,i2,i3,0) + umyy42(i1,i2,i3,0) ) )   \
           !                                                   + dtSq*fv(m)                                                             
         #End

       #End                                                          
     #Else

       ! --- THREE DIMENSIONS ---
       #If #ORDERINTIME eq "4"
         ! 3D orderInSpace=4 and orderInTime=4 IMPLICIT
         #If #GRIDTYPE eq "rectangular"
           write(*,'("advWave: finish me for IMPLICIT order=ORDER, dim=DIM")')
           stop 4444
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*lap2d4(i1,i2,i3,m) + cdtsq12*lap2d2pow2(i1,i2,i3,m) + dtSq*fv(m)
         #Else
           write(*,'("advWave: finish me for IMPLICIT order=ORDER, dim=DIM")')
           stop 4444
           ! v is assumed to hold Lap(u) to 2nd-order
           ! write(*,'(" i1,i2=",2i4," uxx4=",e10.2," true=",e10.2)') i1,i2,uxx42(i1,i2,i3,m),evxx(m)
           un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m)-um(i1,i2,i3,m) + cdtSq*  ( uxx42(i1,i2,i3,m) + uyy42(i1,i2,i3,m) ) \
                                                           + cdtsq12*( vxx22(i1,i2,i3,m) + vyy22(i1,i2,i3,m) ) + dtSq*fv(m)
         #End

       #Else

         ! 3D orderInSpace==4 and orderInTime==2 IMPLICIT                                                  
         #If #GRIDTYPE eq "rectangular"
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx43r(i1,i2,i3,0) +  uyy43r(i1,i2,i3,0) +  uzz43r(i1,i2,i3,0) )  \
                                                                  + ts4*( umxx43r(i1,i2,i3,0) + umyy43r(i1,i2,i3,0) + umzz43r(i1,i2,i3,0) )  \
                                                                  + tsf*fv(m)          
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *( uxx43r(i1,i2,i3,0) +  uyy43r(i1,i2,i3,0) +  uzz43r(i1,i2,i3,0) ) +  \
           !                                                               cImp(-1,0) *(umxx43r(i1,i2,i3,0) + umyy43r(i1,i2,i3,0) + umzz43r(i1,i2,i3,0) ) )  \
           !                                                   + dtSq*fv(m)         
         #Else
           un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) + ts2*um(i1,i2,i3,m) + ts3*(  uxx43(i1,i2,i3,0) +  uyy43(i1,i2,i3,0) +  uzz43(i1,i2,i3,0) )  \
                                                                  + ts4*( umxx43(i1,i2,i3,0) + umyy43(i1,i2,i3,0) + umzz43(i1,i2,i3,0) )  \
                                                                  + tsf*fv(m)                     
           ! un(i1,i2,i3,m)= 2.*u(i1,i2,i3,m) - um(i1,i2,i3,m) + (cdtSq)*( cImp( 0,0) *(  uxx43(i1,i2,i3,0) +  uyy43(i1,i2,i3,0) +  uzz43(i1,i2,i3,0) ) +   \
           !                                                               cImp(-1,0) *( umxx43(i1,i2,i3,0) + umyy43(i1,i2,i3,0) + umzz43(i1,i2,i3,0) ) )   \
           !                                                   + dtSq*fv(m)                                                             
         #End
      #End

     #End


   #End         

   ! write(*,'("i1,i2=",2i3," u-ue=",e10.2)') i1,i2,u(i1,i2,i3,m)-ev(m)

   ! write(*,'(" uxx-uxxe =",e10.2)') uxx22r(i1,i2,i3,0)-evxx(m)

   ! OGDERIV2D( 0,0,0,0,i1,i2,i3,t+dt, ec, ev(m)  )
   ! write(*,'(" un-ue=",e10.2)') un(i1,i2,i3,m)-ev(m)

  else 

    un(i1,i2,i3,0)=0.  ! set value to zero at mask==0 (for active unused points)

  endLoopsMask()



#endMacro


! =========================================================================================
! Macro: ADD UPWIND DISSIPATION
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro addUpwindDiss(DIM,ORDER,GRIDTYPE,uDot)

  if( debug.gt.1 .and. t.lt.4*dt )then
    write(*,'("addUpwindDiss: UPWIND DISS using u.t=uDot dim=DIM order=ORDER grid=GRIDTYPE... t=",e10.2)') t
    if( gridType==rectangular )then
      write(*,'(" useSimplifiedDissipation=",i2," adxSosup=",3(1pe12.4))') useSimplifiedDissipation, adxSosup(0), adxSosup(1),adxSosup(2)
    else
      write(*,'(" useSimplifiedDissipation=",i2," adSosup=",(1pe12.4))') useSimplifiedDissipation, adSosup
    end if
  end if
  

  m=0 ! component number 
  ec = 0 ! component number
  
  ! +++ ADD UPWIND DISSIPATION +++
  
  ! beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

   #If #ORDER eq "2"
     ! --- SECOND ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d4(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d4(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d4(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d4(uDot,i1,i2,i3,ec)
       #End
     #End

   #Elif #ORDER eq "4"

     ! --- -FOURTH ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d6(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d6(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d6(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d6(uDot,i1,i2,i3,ec)
       #End
     #End

   #Elif #ORDER eq "6"

     ! ---- SIXTH ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d8(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d8(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d8(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d8(uDot,i1,i2,i3,ec)
       #End
     #End         

   #Elif #ORDER eq "8"

     ! ---- EIGHTH ORDER ---
     #If #DIM eq "2"
       ! --- TWO DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         ! write(*,*) "add upwind order ORDER"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d10(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff2d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss2d10(uDot,i1,i2,i3,ec)
       #End
     #Else
       ! --- THREE DIMENSIONS ---
       #If #GRIDTYPE eq "rectangular"
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d10(uDot,i1,i2,i3,ec)
       #Else
         getSosupDissipationCoeff3d(adxSosup)
         un(i1,i2,i3,ec)=un(i1,i2,i3,ec)+sosupDiss3d10(uDot,i1,i2,i3,ec)
       #End
     #End 


   #Else
      write(*,*) "upwind dissipation not implemented for order ORDER"
      stop 8888
   #End   

  endLoopsMask()
  ! endLoops()

#endMacro


! =========================================================================================
! Macro: ADD UPWIND DISSIPATION FOR IMPLICIT TIME-STEPPING
!
!    *** OLD ****
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro addUpwindDissImplicitOld(DIM,ORDER,GRIDTYPE)

  if( (.false. .or. debug.gt.3) .and. t.lt.4*dt )then
    write(*,'(/,"advWave:addUpwindDissImplicitOld: UPWIND DISS dim=DIM order=ORDER grid=GRIDTYPE... t=",e10.2)') t
    if( gridType==rectangular )then
      write(*,'(" upwind-diss-coeff: adxSosup=",3(1pe12.4,1x))') adxSosup(0), adxSosup(1),adxSosup(2)
    else
      write(*,'(" upwind-diss-coeff: adSosup=",1pe12.4)') adSosup
    end if
  end if

  ! from formImplicitTimeSteppingMatrix
    ! // fourth-order dissipation for 2nd-order scheme:
    ! Real upwindCoeff4[4][5] = { 1.,-4.,6.,-4.,1.,
    !                             1.,-3.,3.,-1.,0.,   // extrap right-most point D-^3 u(2)
    !                             0.,-1.,3.,-3.,1.,   // extrap left -most point D+^3 u(-2)
    !                             0.,-1.,2.,-1.,0.
    !                           };

    ! // sixth-order dissipation for 4th-order scheme
    ! Real upwindCoeff6[4][7] = {1.,-6.,15.,-20.,15.,-6.,1.,
    !                            1.,-5.,10.,-10., 5.,-1.,0.,  // extrap right-most point D-^5 u(3)
    !                            0.,-1., 5.,-10.,10., 5.,1.,  // extrap left -most point D+^5 u(-3)
    !                            0.,-1., 4., -6., 4.,-1.,0.
    !                           };
  

  ! -- Note: Could adjust loop bounds to avoid Dirichlet boundaries

  m=0 ! component number 
  ec = 0 ! component number
  
  ! Compute some things needed in the loops below
  if( adjustHelmholtzForUpwinding.eq.1 )then
    do freq=0,numberOfFrequencies-1
      cosineFactor(freq) = cos(frequencyArray(freq)*(t+dt)) - cos(frequencyArray(freq)*(t-dt))
    end do
  end if 
    
  ! stencil width = order + 1
  ! upwind stencil = stencilWidth + 2 = order+1 + 2
  upwindHalfStencilWidth = (orderOfAccuracy+2)/2 

  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

    #If #GRIDTYPE eq "curvilinear"
      ! --- Compute UPW coefficient for curvilinear grids ---
      #If #DIM eq "2"
        getSosupDissipationCoeff2d(adxSosup)
      #Else
        getSosupDissipationCoeff3d(adxSosup)
      #End
    #End

    ! --- loop over directions ---
    do dir=0,nd-1

      idv(0)=0; idv(1)=0; idv(2)=0
      idv(dir)=1 ! active direction

      ! check if left-most and right-most entries in the upwind stencil are valid 
      i1l = i1-upwindHalfStencilWidth*idv(0); i1r = i1+upwindHalfStencilWidth*idv(0);
      i2l = i2-upwindHalfStencilWidth*idv(1); i2r = i2+upwindHalfStencilWidth*idv(1);
      i3l = i3-upwindHalfStencilWidth*idv(2); i3r = i3+upwindHalfStencilWidth*idv(2);

      !  Note: there are at most four cases at any order, since we have order/2 layers of interpolation points 
      !   Example, order=2, upwind-order=4
      !     X---X---C---X---X           C = center point = valid discretization point
      !     X---X---C---X               missing right-most 
      !         X---C---X---X           missing left-most
      !         X---C---X               missing left and right-most

      upwCase=0 
      if( mask(i1l,i2l,i3l) .ne. 0 .and. mask(i1r,i2r,i3r) .ne. 0 ) then
        upwCase=0  ! centred, full-width stencil
      else if( mask(i1l,i2l,i3l) .ne. 0 ) then
        upwCase=1  ! left biased stencil
      else if( mask(i1r,i2r,i3r) .ne. 0 ) then
        upwCase=2  ! right biased stencil   
      else  
        upwCase=3  ! centred smaller stencil     
      end if



      upw = 0. 
      do iStencil=-upwindHalfStencilWidth,upwindHalfStencilWidth

        j1 = i1 + iStencil*idv(0);  j2 = i2 + iStencil*idv(1);  j3 = i3 + iStencil*idv(2)

        umj = um(j1,j2,j3,0)

        if( adjustHelmholtzForUpwinding.eq.1 )then
          do freq=0,numberOfFrequencies-1
            umj = umj + cosineFactor(freq)*vh(j1,j2,j3,freq)
          end do
        end if

        upw = upw + upwindCoeff(iStencil,upwCase)*umj

        ! upw = upw + upwindCoeff(iStencil,upwCase)*um(j1,j2,j3,ec)  ! *** CHECK ME 


        ! write(*,'("upw-rhs: i1,i2=",2i4," j1,j2=",2i4," upwindCoeff=",1pe9.2, " um=",1pe9.2," upw=",1pe9.2)') i1,i2,j1,j2,upwindCoeff(iStencil,upwCase),um(j1,j2,j3,ec),upw
      end do 
      ! if( abs(upw).gt.1e-10 )then
      !   write(*,'(">>upw-rhs: i1,i2=",2i4," upw=",1pe9.2)') i1,i2,upw
      ! end if 

      ! This is the coeff of um in
      !         + adxSosup(dir)*(UpwindStencil)( un - um )
      ! un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - adxSosup(dir)*upw 
      ! *wdh* July 3, 2023 CHANGE SIGN
      un(i1,i2,i3,ec) = un(i1,i2,i3,ec) + adxSosup(dir)*upw 

      ! TEST un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - adxSosup(dir)*upw 

    end do ! end do fir 

  endLoopsMask()



#endMacro

  
! =========================================================================================
! Macro: ADD UPWIND DISSIPATION FOR IMPLICIT TIME-STEPPING
!
!       ** NEW VERSION : July 10, 2023 **
!
!    Assumes that interpolation neighbours ahave been filled in the the implicitSolve 
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro addUpwindDissImplicit(DIM,ORDER,GRIDTYPE)

  if( (.true. .or. debug.gt.3) .and. t.lt.4*dt )then
    write(*,'(/,"advWave:addUpwindDissImplicit: UPWIND DISS dim=DIM order=ORDER grid=GRIDTYPE... t=",e10.2)') t
    if( gridType==rectangular )then
      write(*,'(" upwind-diss-coeff: adxSosup=",3(1pe12.4,1x))') adxSosup(0), adxSosup(1),adxSosup(2)
    else
      write(*,'(" upwind-diss-coeff: adSosup=",1pe12.4)') adSosup
    end if
  end if


  ! -- Note: Could adjust loop bounds to avoid Dirichlet boundaries

  m=0 ! component number 
  ec = 0 ! component number
  
  ! Compute some things needed in the loops below
  if(  solveHelmholtz==1 .and. adjustHelmholtzForUpwinding==1 )then
    do freq=0,numberOfFrequencies-1
      cosineFactor(freq) = cos(frequencyArray(freq)*(t+dt)) - cos(frequencyArray(freq)*(t-dt))
    end do
    write(*,'(" FINISH ME: add imp upwind : adjustHelmholtzForUpwinding")')
    stop 2964
  end if 
    
  beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)

    #If #GRIDTYPE eq "curvilinear"
      ! --- Compute UPW coefficient for curvilinear grids ---
      #If #DIM eq "2"
        getSosupDissipationCoeff2d(adxSosup)
      #Else
        getSosupDissipationCoeff3d(adxSosup)
      #End
    #End

    ! NOTE: USE um instead of uDot in the dissipation
    ! Note minus sign 
    #If #ORDER eq "2"
      #If #DIM eq "2"
        un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - sosupDiss2d4(um,i1,i2,i3,ec) 
      #Else
        un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - sosupDiss3d4(um,i1,i2,i3,ec) 
      #End
    #Elif #ORDER eq "4"       
      #If #DIM eq "2"
        un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - sosupDiss2d6(um,i1,i2,i3,ec)
      #Else
        un(i1,i2,i3,ec) = un(i1,i2,i3,ec) - sosupDiss3d6(um,i1,i2,i3,ec) 
      #End
    #Else
      write(*,'(" FINISH ME: add imp upwind order=ORDER")')
      stop 6666
    #End
  endLoopsMask()



#endMacro

! =========================================================================================
! Macro: COMPUTE uDot = (un -um )
!
! ========================================================================================
#beginMacro computeUDot()
  ! precompute "uDot" = dt*du/dt used in the dissipation and store in v 
  ! we need uDot at enough ghost points for the dissipation operator 
  if( debug.gt.3 .and. t.le.3.*dt )then
   write(*,'(" advWave: add UPWIND DISSIPATION: Evaluate v= uDot")') 
  end if
  numGhost=orderOfAccuracy/2
  numGhost=numGhost+1
  m1a=n1a-numGhost
  m1b=n1b+numGhost
  m2a=n2a-numGhost
  m2b=n2b+numGhost
  if( nd.eq.2 )then
  m3a=n3a
  m3b=n3b
  else
   m3a=n3a-numGhost
   m3b=n3b+numGhost
  end if

  ! write(*,'(" numGhost=",i2," m1a,m1b,m2a,m2b=",4i4)') numGhost,m1a,m1b,m2a,m2b

  ! We need v at ghost outside interpolation points -- do not use mask here
  
   
  if( (adjustHelmholtzForUpwinding.eq.0) .or. adjustOmega.eq.0 .or. solveHelmholtz.eq.0 )then 

    beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
      v(i1,i2,i3,0)=un(i1,i2,i3,0)-um(i1,i2,i3,0)
    endLoops()

  else 
    ! ***THIS OPTION IS UNDER DEVELOPMENT***


    ! subtract off upwinding applied to current Helmholtz solution to cancel the effect of upwinding.
    ! Periodic solution:
    !    up = vk * cos( omega * t )
    !   D0t( up  ) = vk * D0t( cos( omega * t ) )
    ! NOTE: upwinding is called at the start of the step to previous times (t) (t-dt) and (t-2*dt)

    ! write(*,'("advOpt: adjust upwinding: t=",e10.3," freq=",e14.6)') t,frequencyArray(0)

    ! cosineFactor = cos(frequencyArray(0)*(t+0.*dt)) - cos(frequencyArray(0)*(t-2.*dt))
    ! Compute some things needed in the loops below
    if( adjustHelmholtzForUpwinding.eq.1 )then
      do freq=0,numberOfFrequencies-1
        ! NOTE: upwinding is called at the start of the step to previous times (t) (t-dt) and (t-2*dt)
        cosineFactor(freq) = cos(frequencyArray(freq)*(t+0.*dt)) - cos(frequencyArray(freq)*(t-2.*dt))
      end do
    end if

    if( .true. )then

      ! ----- Adjustment for upwinding in Helmholtz solves ----
      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        v(i1,i2,i3,0)= (un(i1,i2,i3,0)-um(i1,i2,i3,0)) 
        do freq=0,numberOfFrequencies-1
          v(i1,i2,i3,0) = v(i1,i2,i3,0) - vh(i1,i2,i3,freq)*cosineFactor(freq)
        end do
      endLoops() 

    else if( .false. )then
      ! **TESTING : 
      !   CHECK: u = vk * cos( omega * t )
      ! BUT DO NOT ADD UPWINDING 
      maxDiff=0.
      ! beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
      beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
        v(i1,i2,i3,0)= um(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt))
        ! write(*,'("(i1,i2)=",2i4," um=",e12.4," vh*cos=",e12.4," diff=",e8.2)') i1,i2,um(i1,i2,i3,0), vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt)),v(i1,i2,i3,0)
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(um-vh*cos)=",e10.3," (no ghost)")') maxDiff

      maxDiff=0.
      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        v(i1,i2,i3,0)= um(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt))
        ! write(*,'("(i1,i2)=",2i4," um=",e12.4," vh*cos=",e12.4," diff=",e8.2)') i1,i2,um(i1,i2,i3,0), vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t-2.*dt)),v(i1,i2,i3,0)
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(um-vh*cos)=",e10.3," (with ghost)")') maxDiff      

      maxDiff=0.
      ! beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
      beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
        v(i1,i2,i3,0)= un(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t+0.*dt))
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(un-vh*cos)=",e10.3," (no ghost)")') maxDiff 

      maxDiff=0.
      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        v(i1,i2,i3,0)= un(i1,i2,i3,0) - vh(i1,i2,i3,0)*cos(frequencyArray(0)*(t+0.*dt))
        maxDiff = max(maxDiff,v(i1,i2,i3,0));
      endLoops()
      write(*,'("advOpt: adjust upwinding: check: maxDiff(un-vh*cos)=",e10.3, " (with ghost)")') maxDiff            

      beginLoops(i1,i2,i3,m1a,m1b,m2a,m2b,m3a,m3b)
        ! v(i1,i2,i3,0)= (un(i1,i2,i3,0)-um(i1,i2,i3,0)) - vh(i1,i2,i3,0)*cosineFactor
        v(i1,i2,i3,0)= 0.
      endLoops() 


    end if  
  end if

#endMacro 


! Argument list
#defineMacro ARGLIST() nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
                       mask,xy,rsxy,  um,u,un, f, stencilCoeff, v, vh, lapCoeff, \
                       etax, etay, etaz, bc, frequencyArray, pdb, ipar, rpar, ierr

! ==================================================================
! ==================================================================
#beginMacro declareInputVariables()
integer nd, n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

 real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real fa(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b,0:*)  ! forcings at different times
 real stencilCoeff(0:*)   ! holds stencil coeffs

 real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1) 
 real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real vh(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)  ! holds current Helmholtz solutions
 real lapCoeff(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)  ! holds coeff of Laplacian for HA scheme

 real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)

 real etax(nd1a:nd1b,0:*)  ! superGrid functions
 real etay(nd2a:nd2b,0:*)
 real etaz(nd3a:nd3b,0:*)

 integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
 integer bc(0:1,0:2),ierr  

 real frequencyArray(0:*)

 double precision pdb  ! pointer to the data base

 integer ipar(0:*)
 real rpar(0:*)

#endMacro                       

! **********************************************************************************
! Macro ADV_WAVE:
!  NAME: name of the subroutine
!  DIM : 2 or 3
!  ORDER : 2 ,4, 6 or 8
!  GRIDTYPE : rectangular, curvilinear
! **********************************************************************************
#beginMacro ADV_WAVE(NAME,DIM,ORDER,GRIDTYPE)
 subroutine NAME( ARGLIST() )
!======================================================================
!   Advance a time step for Waves equations
!
! nd : number of space dimensions
! um,u,un : u(t-dt), u(t), u(t+dt)
!
! ipar(0)  = option : option=0 - advance wave equation
!                           =1 - add upwind dissipation (predictor corrector mode)
!
!======================================================================
 implicit none

 declareInputVariables()

 ! integer nd, n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

 ! real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! ! real fa(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b,0:*)  ! forcings at different times
 ! real stencilCoeff(0:*)   ! holds stencil coeffs

 ! real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1) 
 ! real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 ! real vh(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)  ! holds current Helmholtz solutions
 ! real lapCoeff(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)  ! holds coeff of Laplacian for HA scheme

 ! real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)

 ! integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
 ! integer bc(0:1,0:2),ierr

 ! real frequencyArray(0:*)

 ! integer ipar(0:*)
 ! real rpar(0:*)
      
!     ---- local variables -----
 integer m1a,m1b,m2a,m2b,m3a,m3b,numGhost,nStart,nEnd,mt

 integer ic,i1,i2,i3,n,gridType,orderOfAccuracy,orderInTime,axis,dir,grid,freq
 integer addForcing,orderOfDissipation,option,gridIsImplicit,preComputeUpwindUt,modifiedEquationApproach
 integer useNewForcingMethod,numberOfForcingFunctions,fcur,fnext,fprev,numberOfFrequencies
 real t,tm,c,cc,dt,dy,dz,cdt,cdtdx,cdtdy,cdtdz
 ! ,adc,adcdt,add,adddt
 real dt4by12
 ! logical addDissipation
 integer debug
 integer adjustHelmholtzForUpwinding, useSuperGrid

 real dx(0:2),dr(0:2)

 real dx2i,dy2i,dz2i,dxsqi,dysqi,dzsqi,dxi,dyi,dzi
 real dx12i,dy12i,dz12i,dxsq12i,dysq12i,dzsq12i,dxy4i,dxz4i,dyz4,time0,time1

 real dxi4,dyi4,dzi4,dxdyi2,dxdzi2,dydzi2

 real c0,c1,csq,dtSq,cdtSq,cdtsq12,cdtSqBy12
 real gridCFL

 integer maxOrderOfAccuracy
 parameter( maxOrderOfAccuracy=12 )
 ! Coefficients in the implicit scheme
 real bImp(0:maxOrderOfAccuracy-1)
 real cImp(-1:1,0:maxOrderOfAccuracy-1)

 real alpha2,alpha4,alpha6,alpha8, beta2,beta4,beta6,beta8

 integer rectangular,curvilinear
 parameter( rectangular=0, curvilinear=1 )

 integer timeSteppingMethod
 integer defaultTimeStepping,adamsSymmetricOrder3,rungeKuttaFourthOrder,\
         stoermerTimeStepping,modifiedEquationTimeStepping
 parameter(defaultTimeStepping=0,adamsSymmetricOrder3=1,\
           rungeKuttaFourthOrder=2,stoermerTimeStepping=3,modifiedEquationTimeStepping=4)
!- ! Dispersion models
!- integer noDispersion,drude
!- parameter( noDispersion=0, drude=1 )

!...........start statement function
 integer kd,m
 real rx,ry,rz,sx,sy,sz,tx,ty,tz

  ! --- declare variables used in the difference approximations (defined below) ---
  declareDifferenceOrder2(u,RX)
  declareDifferenceOrder2(um,none)
  declareDifferenceOrder2(v,none)
!  declareDifferenceOrder2(um,none)
  declareDifferenceOrder2(f,none)

  declareDifferenceOrder4(u,RX)
  declareDifferenceOrder4(um,none)
  declareDifferenceOrder4(v,none)

  declareDifferenceOrder6(u,RX)
  declareDifferenceOrder6(um,none)
  declareDifferenceOrder6(v,none)

  declareDifferenceOrder8(u,RX)
  declareDifferenceOrder8(um,none)
  declareDifferenceOrder8(v,none)

 ! define variables for getDerivatives macros
 #Include "../include/declareGetSixthDerivativesMacrosVariables.h"

 ! real cdt4by360,cdt6by20160
 real cdtPow4By12,cdtPow6By360


 real lap2d2,lap3d2,lap2d4,lap3d4,lap2d6,lap3d6,lap2d8,lap3d8,lap2d2Pow2,lap3d2Pow2,lap2d2Pow3,lap3d2Pow3,\
      lap2d2Pow4,lap3d2Pow4,lap2d4Pow2,lap3d4Pow2,lap2d4Pow3,lap3d4Pow3,lap2d6Pow2,lap3d6Pow2
 real lap2d2m,lap3d2m
 real du,fd22d,fd23d,fd42d,fd43d,fd62d,fd63d,fd82d,fd83d
 real DztU

 ! forcing correction functions: 
 real lap2d2f,f2drme44, lap3d2f, f3drme44, f2dcme44, f3dcme44, ff

 ! real cdSosupx,cdSosupy,cdSosupz
 real adSosup,sosupParameter, uDotFactor, adxSosup(0:2), adSosupOld
 integer useSosupDissipation,sosupDissipationOption
 integer updateSolution,updateDissipation,computeUt

 integer ec 
 real ep 
 real fv(0:1) , ev(0:1), evt(0:1), evtt(0:1), evxx(0:1), evyy(0:1), evzz(0:1), evttt(0:1), evxxt(0:1), evyyt(0:1)
 real evxxxx(0:1), evxxyy(0:1), evyyyy(0:1), evxxzz(0:1), evyyzz(0:1), evzzzz(0:1), evtttt(0:1)
 real evxxttt(0:1), evyyttt(0:1), evxxxxt(0:1), evxxyyt(0:1), evyyyyt(0:1)
 real evzzt(0:1), evzzttt(0:1), evzzzzt(0:1), evxxzzt(0:1), evyyzzt(0:1)
 real evxxxxttt(0:1), evxxyyttt(0:1), evyyyyttt(0:1)
 real evtttttt(0:1)
 real evxxxxxx(0:1)
 real evyyyyyy(0:1)
 real evzzzzzz(0:1)       
 real evxxyyyy(0:1)
 real evxxxxyy(0:1)
 real evxxxxzz(0:1)
 real evxxzzzz(0:1)
 real evyyyyzz(0:1)
 real evyyzzzz(0:1)
 real evxxyyzz(0:1)

 real omega, coswt, damp

 integer maxFreq
 parameter( maxFreq=500 )
 real cosFreqt(0:maxFreq), coswtAve(0:maxFreq), cosineFactor(0:maxFreq)

 integer idv(0:2),j1,j2,j3
 integer iStencil,upwCase,upwindHalfStencilWidth,i1l,i2l,i3l, i1r,i2r,i3r
 integer useUpwindDissipation,useImplicitUpwindDissipation,adjustOmega,solveHelmholtz
 integer takeImplicitFirstStep
 real upw,maxDiff,umj
 real upwindCoeff(-3:3,0:3) 
 integer useSimplifiedDissipation
 real upwindDissipationCoefficient,dissSafetyFactor

 real cn,cm,cLap,cLapSq,cf
 real ts1,ts2,ts3,ts4,ts5,ts6,tsf

 
 integer ok,getInt,getReal
 
 integer forcingOption
 ! forcingOptions -- these should match ForcingEnum in CgWave.h 
 ! enum ForcingOptionEnum
 ! {
 !   noForcing=0,
 !   twilightZoneForcing,
 !   userForcing,
 !   helmholtzForcing
 ! };
 integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
 parameter(noForcing           =0,\
           twilightZoneForcing =1,\
           userForcing         =2,\
           helmholtzForcing    =3 )

           
! real unxx22r,unyy22r,unxy22r,unx22r

!.......statement functions for jacobian
 rx(i1,i2,i3)=rsxy(i1,i2,i3,0,0)
 ry(i1,i2,i3)=rsxy(i1,i2,i3,0,1)
 rz(i1,i2,i3)=rsxy(i1,i2,i3,0,2)
 sx(i1,i2,i3)=rsxy(i1,i2,i3,1,0)
 sy(i1,i2,i3)=rsxy(i1,i2,i3,1,1)
 sz(i1,i2,i3)=rsxy(i1,i2,i3,1,2)
 tx(i1,i2,i3)=rsxy(i1,i2,i3,2,0)
 ty(i1,i2,i3)=rsxy(i1,i2,i3,2,1)
 tz(i1,i2,i3)=rsxy(i1,i2,i3,2,2)

 !  The next macro will define the difference approximation statement functions for u
 defineDifferenceOrder2Components1(u,RX)
 defineDifferenceOrder4Components1(u,RX)
 defineDifferenceOrder6Components1(u,RX)
 defineDifferenceOrder8Components1(u,RX)

 ! Difference approximations um (old time)
 defineDifferenceOrder2Components1(um,none)
 defineDifferenceOrder4Components1(um,none)

 ! Define difference approximations for v
 defineDifferenceOrder2Components1(v,none)
 defineDifferenceOrder4Components1(v,none)

 defineDifferenceOrder2Components1(f,none)


  ! 2D laplacian squared = u.xxxx + 2 u.xxyy + u.yyyy
  lap2d2Pow2(i1,i2,i3,ic)= ( 6.*u(i1,i2,i3,ic)   \
    - 4.*(u(i1+1,i2,i3,ic)+u(i1-1,i2,i3,ic))    \
        +(u(i1+2,i2,i3,ic)+u(i1-2,i2,i3,ic)) )*dxi4 \
    +( 6.*u(i1,i2,i3,ic)    \
     -4.*(u(i1,i2+1,i3,ic)+u(i1,i2-1,i3,ic))    \
        +(u(i1,i2+2,i3,ic)+u(i1,i2-2,i3,ic)) )*dyi4  \
    +( 8.*u(i1,i2,i3,ic)     \
     -4.*(u(i1+1,i2,i3,ic)+u(i1-1,i2,i3,ic)+u(i1,i2+1,i3,ic)+u(i1,i2-1,i3,ic))   \
     +2.*(u(i1+1,i2+1,i3,ic)+u(i1-1,i2+1,i3,ic)+u(i1+1,i2-1,i3,ic)+u(i1-1,i2-1,i3,ic)) )*dxdyi2
 
  ! 3D laplacian squared = u.xxxx + u.yyyy + u.zzzz + 2 (u.xxyy + u.xxzz + u.yyzz )
  lap3d2Pow2(i1,i2,i3,ic)= ( 6.*u(i1,i2,i3,ic)   \
    - 4.*(u(i1+1,i2,i3,ic)+u(i1-1,i2,i3,ic))    \
        +(u(i1+2,i2,i3,ic)+u(i1-2,i2,i3,ic)) )*dxi4 \
   +(  +6.*u(i1,i2,i3,ic)    \
     -4.*(u(i1,i2+1,i3,ic)+u(i1,i2-1,i3,ic))    \
        +(u(i1,i2+2,i3,ic)+u(i1,i2-2,i3,ic)) )*dyi4\
   +(  +6.*u(i1,i2,i3,ic)    \
     -4.*(u(i1,i2,i3+1,ic)+u(i1,i2,i3-1,ic))    \
        +(u(i1,i2,i3+2,ic)+u(i1,i2,i3-2,ic)) )*dzi4\
    +(8.*u(i1,i2,i3,ic)     \
     -4.*(u(i1+1,i2,i3,ic)+u(i1-1,i2,i3,ic)+u(i1,i2+1,i3,ic)+u(i1,i2-1,i3,ic))   \
     +2.*(u(i1+1,i2+1,i3,ic)+u(i1-1,i2+1,i3,ic)+u(i1+1,i2-1,i3,ic)+u(i1-1,i2-1,i3,ic)) )*dxdyi2 \
    +(8.*u(i1,i2,i3,ic)     \
     -4.*(u(i1+1,i2,i3,ic)+u(i1-1,i2,i3,ic)+u(i1,i2,i3+1,ic)+u(i1,i2,i3-1,ic))   \
     +2.*(u(i1+1,i2,i3+1,ic)+u(i1-1,i2,i3+1,ic)+u(i1+1,i2,i3-1,ic)+u(i1-1,i2,i3-1,ic)) )*dxdzi2 \
    +(8.*u(i1,i2,i3,ic)     \
     -4.*(u(i1,i2+1,i3,ic)+u(i1,i2-1,i3,ic)+u(i1,i2,i3+1,ic)+u(i1,i2,i3-1,ic))   \
     +2.*(u(i1,i2+1,i3+1,ic)+u(i1,i2-1,i3+1,ic)+u(i1,i2+1,i3-1,ic)+u(i1,i2-1,i3-1,ic)) )*dydzi2 

!    ** 4th order ****

  lap2d4(i1,i2,i3,ic)=( -30.*u(i1,i2,i3,ic)     \
    +16.*(u(i1+1,i2,i3,ic)+u(i1-1,i2,i3,ic))     \
        -(u(i1+2,i2,i3,ic)+u(i1-2,i2,i3,ic)) )*dxsq12i + \
   ( -30.*u(i1,i2,i3,ic)     \
    +16.*(u(i1,i2+1,i3,ic)+u(i1,i2-1,i3,ic))     \
        -(u(i1,i2+2,i3,ic)+u(i1,i2-2,i3,ic)) )*dysq12i 
 
  lap3d4(i1,i2,i3,ic)=lap2d4(i1,i2,i3,ic)+ \
   ( -30.*u(i1,i2,i3,ic)      \
    +16.*(u(i1,i2,i3+1,ic)+u(i1,i2,i3-1,ic))      \
        -(u(i1,i2,i3+2,ic)+u(i1,i2,i3-2,ic)) )*dzsq12i 

  lap2d4Pow2(i1,i2,i3,ic)=LAP2D4(lap2d4,i1,i2,i3,ic)
  lap3d4Pow2(i1,i2,i3,ic)=LAP3D4(lap3d4,i1,i2,i3,ic)
 
  lap2d4Pow3(i1,i2,i3,ic)=LAP2D4(lap2d4Pow2,i1,i2,i3,ic)
  lap3d4Pow3(i1,i2,i3,ic)=LAP3D4(lap3d4Pow2,i1,i2,i3,ic)

  ! D-zero in time (really undivided)
  DztU(i1,i2,i3,n) = (un(i1,i2,i3,n)-um(i1,i2,i3,n))

  !...........end   statement functions


  ! write(*,*) 'Inside advWave...'
 
  cc                           = rpar( 0)  ! this is c
  dt                           = rpar( 1)
  dx(0)                        = rpar( 2)
  dx(1)                        = rpar( 3)
  dx(2)                        = rpar( 4)
  dr(0)                        = rpar( 5)
  dr(1)                        = rpar( 6)
  dr(2)                        = rpar( 7)
  t                            = rpar( 8)
  ep                           = rpar( 9)
  sosupParameter               = rpar(10)
  omega                        = rpar(11) ! for helmholtz 
  bImp( 0)                     = rpar(12) ! beta2 : coefficient for implicit time-stepping
  bImp( 1)                     = rpar(13) ! beta4 : coefficient for implicit time-stepping
  bImp( 2)                     = rpar(14) ! beta6 (for future)
  bImp( 3)                     = rpar(15) ! beta8 (for future)
  gridCFL                      = rpar(16)
  upwindDissipationCoefficient = rpar(17)
 
  c              = cc

  dy=dx(1)  ! Are these needed?
  dz=dx(2)

 
  option                       = ipar( 0)
  grid                         = ipar( 1)
  gridType                     = ipar( 2)
  orderOfAccuracy              = ipar( 3)
  orderInTime                  = ipar( 4)
  addForcing                   = ipar( 5)
  forcingOption                = ipar( 6)
  numberOfForcingFunctions     = ipar( 7)
  fcur                         = ipar( 8) 
  debug                        = ipar( 9)
  gridIsImplicit               = ipar(10)
  useUpwindDissipation         = ipar(11)  ! explicit upwind dissipation
  useImplicitUpwindDissipation = ipar(12)  ! true if upwind-dissipation is on for implicit time-stepping
  preComputeUpwindUt           = ipar(13)
  numberOfFrequencies          = ipar(14)
  adjustOmega                  = ipar(15)
  solveHelmholtz               = ipar(16)
  adjustHelmholtzForUpwinding  = ipar(17)
  modifiedEquationApproach     = ipar(18)
  takeImplicitFirstStep        = ipar(19)
  useSuperGrid                 = ipar(20)

  ! new way: extract parameters from the dataBase
  getRealParameter(damp)

  fprev = mod(fcur-1+numberOfForcingFunctions,max(1,numberOfForcingFunctions))
  fnext = mod(fcur+1                         ,max(1,numberOfForcingFunctions))
  

  ! ** fix me ***
  timeSteppingMethod=modifiedEquationTimeStepping

  ! Set dr(:) = dx(:) for 6th-order derivatives
  if( gridType.eq.rectangular )then
    do axis=0,2
      dr(axis)=dx(axis)
    end do
  else

    do axis=0,2
      dx(axis)=dr(axis)
    end do 
    dx = dx(0)
    dy = dx(1)
    dz = dx(2)
  end if

  ! ---- Compute the coefficients in the implicit time-stepping scheme ----

  beta2=bImp(0)
  beta4=bImp(1)
  alpha2 = (1.-beta2)/2.
  alpha4 = (alpha2-beta4-1./12.)/2. 
  cImp(-1,0)=alpha2
  cImp( 0,0)= beta2
  cImp( 1,0)=alpha2
  cImp(-1,1)=alpha4
  cImp( 0,1)= beta4
  cImp( 1,1)=alpha4  
 
  ! ! addDissipation=.true. if we add the dissipation in the dis(i1,i2,i3,c) array
  ! !  if combineDissipationWithAdvance.ne.0 we compute the dissipation on the fly in the time step
  ! !  rather than pre-computing it in diss(i1,i2,i3,c)
  ! addDissipation = adc.gt.0.
  ! adcdt=adc*dt
 
  csq=cc**2
  dtSq=dt**2
  cdtSq=(cc**2)*(dt**2)
 
  cdt=cc*dt
 
  ! new: 
  cdtPow4By12  = cdt**4/12.
  cdtPow6By360 = cdt**6/360 
 
  cdtsq12=cdtSq*cdtSq/12.  ! c^4 dt^4 /12 
  ! cdt4by360=(cdt)**4/360.  ! (c*dt)^4/360 
  ! cdt6by20160=cdt**6/(8.*7.*6.*5.*4.*3.)
 
  cdtSqBy12= cdtSq/12.   ! c^2*dt*2/12
 
  dt4by12=dtSq*dtSq/12.
 
  cdtdx = (cc*dt/dx(0))**2
  cdtdy = (cc*dt/dy)**2
  cdtdz = (cc*dt/dz)**2
 
  dxsqi=1./(dx(0)**2)
  dysqi=1./(dy**2)
  dzsqi=1./(dz**2)
 
  dxsq12i=1./(12.*dx(0)**2)
  dysq12i=1./(12.*dy**2)
  dzsq12i=1./(12.*dz**2)
 
  dxi4=1./(dx(0)**4)
  dyi4=1./(dy**4)
  dxdyi2=1./(dx(0)*dx(0)*dy*dy)
 
  dzi4=1./(dz**4)
  dxdzi2=1./(dx(0)*dx(0)*dz*dz)
  dydzi2=1./(dy*dy*dz*dz)
 
  if( option.eq.1 )then 
   useSosupDissipation = 1
  else
   useSosupDissipation = 0
  end if
 
   if( useImplicitUpwindDissipation.eq.1 )then

    ! Upwind dissipation for implicit time time-stepping
    ! from formImplicitTimeSteppingMatrix
    ! // fourth-order dissipation for 2nd-order scheme:
    ! Real upwindCoeff4[4][5] = { 1.,-4.,6.,-4.,1.,
    !                             1.,-3.,3.,-1.,0.,   // extrap right-most point D-^3 u(2)
    !                             0.,-1.,3.,-3.,1.,   // extrap left -most point D+^3 u(-2)
    !                             0.,-1.,2.,-1.,0.
    !                           };

    ! // sixth-order dissipation for 4th-order scheme
    ! Real upwindCoeff6[4][7] = {1.,-6.,15.,-20.,15.,-6.,1.,
    !                            1.,-5.,10.,-10., 5.,-1.,0.,  // extrap right-most point D-^5 u(3)
    !                            0.,-1., 5.,-10.,10.,-5.,1.,  // extrap left -most point D+^5 u(-3)
    !                            0.,-1., 4., -6., 4.,-1.,0.
    !                           };
    if( orderOfAccuracy.eq.2 )then
      ! UPW stencils for the 4 cases (depends on whether all points exist in the wider stencil )
      upwindCoeff(-2,0)=1.; upwindCoeff(-1,0)=-4.; upwindCoeff(0,0)=6.; upwindCoeff(1,0)=-4.; upwindCoeff(2,0)=1.   ! centred
      upwindCoeff(-2,1)=1.; upwindCoeff(-1,1)=-3.; upwindCoeff(0,1)=3.; upwindCoeff(1,1)=-1.; upwindCoeff(2,1)=0.   ! left biased
      upwindCoeff(-2,2)=0.; upwindCoeff(-1,2)=-1.; upwindCoeff(0,2)=3.; upwindCoeff(1,2)=-3.; upwindCoeff(2,2)=1.   ! right biased
      upwindCoeff(-2,3)=0.; upwindCoeff(-1,3)=-1.; upwindCoeff(0,3)=2.; upwindCoeff(1,3)=-1.; upwindCoeff(2,3)=0.   ! centred, lower-order

    else if( orderOfAccuracy.eq.4 )then

      upwindCoeff(-3,0)=1.; upwindCoeff(-2,0)=-6.; upwindCoeff(-1,0)=15.; upwindCoeff(0,0)=-20.; upwindCoeff(1,0)=15.; upwindCoeff(2,0)=-6.; upwindCoeff(3,0)=1.
      upwindCoeff(-3,1)=1.; upwindCoeff(-2,1)=-5.; upwindCoeff(-1,1)=10.; upwindCoeff(0,1)=-10.; upwindCoeff(1,1)= 5.; upwindCoeff(2,1)=-1.; upwindCoeff(3,1)=0.
      upwindCoeff(-3,2)=0.; upwindCoeff(-2,2)=-1.; upwindCoeff(-1,2)= 5.; upwindCoeff(0,2)=-10.; upwindCoeff(1,2)=10.; upwindCoeff(2,2)=-5.; upwindCoeff(3,2)=1.
      upwindCoeff(-3,3)=0.; upwindCoeff(-2,3)=-1.; upwindCoeff(-1,3)= 4.; upwindCoeff(0,3)= -6.; upwindCoeff(1,3)= 4.; upwindCoeff(2,3)=-1.; upwindCoeff(3,3)=0.

    else
      write(*,'("advWave: upwind coefficients are not set yet for orderOfAccuracy=",i4)') orderOfAccuracy
      stop 2222
    end if
   
   end if

  ! if( useSuperGrid==1 )then
  !   write(*,'("etax(:,0)=",200(1pe10.2,1x))') (etax(i1,0),i1=nd1a,nd1b)
  !   write(*,'("etax(:,1)=",200(1pe10.2,1x))') (etax(i1,1),i1=nd1a,nd1b)
  !   write(*,'("etay(:,0)=",200(1pe10.2,1x))') (etay(i2,0),i2=nd2a,nd2b)
  !   write(*,'("etay(:,1)=",200(1pe10.2,1x))') (etay(i2,1),i2=nd2a,nd2b)
  ! end if 

  ! ! ---- DAMPING COEFF ----
  ! cn    =               2./(1+damp*dt*.5);
  ! cm    = (-1 +damp*dt*.5)/(1+damp*dt*.5);
  ! cLap  =         (c*dt)^2/(1+damp*dt*.5);
  ! cf    =             dt^2/(1+damp*dt*.5); 

  ! ---- explicit ----
  cn     =                2./(1.+damp*dt*.5); 
  cm     = (-1. +damp*dt*.5)/(1.+damp*dt*.5); 
  cLap   =             cdtSq/(1.+damp*dt*.5); 
  cLapSq =           cdtsq12/(1.+damp*dt*.5); 
  cf     =              dtSq/(1.+damp*dt*.5); 


  if( gridIsImplicit==1 )then
    ! Implicit Scheme is 
    !   un(i1,i2,i3,m)= ts1*u(i1,i2,i3,m) +ts2*um(i1,i2,i3,m) + ts3*( uxx22r(i1,i2,i3,0) +  uyy22r(i1,i2,i3,0) )  
    !                                                         + ts4*(umxx22r(i1,i2,i3,0) + umyy22r(i1,i2,i3,0) ) )  
    !                                                         + tsf*fv(m)      
    ! if( damp.ne.0. )then
    !   write(*,*) "advWave: Finish Implicit for damping"
    !   stop 777
    ! end if
    if( takeImplicitFirstStep.eq.0 )then
      ts1=2. 
      ts2=( -1. + damp*dt*.5 )
      ts3=cdtSq*cImp( 0,0)
      ts4=cdtSq*cImp(-1,0)
      ! for order=4: 
      ts5 = - (cdtSq)**2 *( cImp( 0,1) )
      ts6 = - (cdtSq)**2 *( cImp(-1,1) )

      tsf=dtSq

    else
      ! first-step implicit:
      ! SEE NOTES IN CGWAVE DOCUMENTATIION
      !
      ! CHECK ME FOR DAMPING     
      ts1=1. + .5*damp*dt
      ts2=dt - .5*dt*dt*damp
      ts3= .5*cdtSq*cImp( 0,0)
      ts4=-dt*cdtSq*cImp(-1,0)

      tsf=.5*dtSq    

      if( orderInTime.eq.4 )then

        ! FIX ME FOR DAMPING 

        ts4 = ts4 + dt*cdtSq/6.
        ts5 = -.5*cdtSq**2 * cImp( 0,1) 
        ts6 =  dt*cdtSq**2 * cImp(-1,1)

        ! FORCING NEEDS ADJUSTMENT TOO 
        if( addForcing.ne.0 )then
          write(*,'(/,"**** advWave: TAKE IMPLICIT FIRST STEP : finish me for orderInTime=4 and ADD FORCING*****")') 
        ! stop 4445
        end if
      end if


    end if

    cf = tsf
  end if


  ! write(*,'("advWave: debug=",i3," damp=",1(1pe18.10,1x))') debug,damp

  if( (.false. .or. debug.gt.1) .and. t.le.3*dt )then
    write(*,'("advWave: option=",i4," grid=",i4)') option,grid
    write(*,'("advWave: orderOfAccuracy=",i2," orderInTime=",i2  )') orderOfAccuracy,orderInTime
    write(*,'("advWave: addForcing=",i2," forcingOption=",i2)') addForcing,forcingOption
    write(*,'("advWave: useUpwindDissipation=",i2," (explicit), useImplicitUpwindDissipation=",i2," (implicit)")') useUpwindDissipation,useImplicitUpwindDissipation
    write(*,'("advWave: useSosupDissipation=",i2," (1= add upwind dissipation in this stage)")') useSosupDissipation
    write(*,'("advWave: t=",1pe10.3," dt=",1pe10.3," c=",1pe10.2," omega=",1pe10.3," gridCFL=",1pe10.3)') t,dt,cc,omega,gridCFL
    write(*,'("advWave: damp=",1(1pe18.10,1x))') damp
    write(*,'("advWave: gridIsImplicit=",i2," takeImplicitFirstStep=",i2)') gridIsImplicit,takeImplicitFirstStep
    write(*,'("advWave: adjustOmega=",i2," solveHelmholtz=",i2," adjustHelmholtz=",i2)') adjustOmega,solveHelmholtz,adjustHelmholtzForUpwinding
    if( forcingOption.eq.helmholtzForcing )then
      write(*,'("advWave: numberOfFrequencies=",i2)') numberOfFrequencies
      write(*,'("advWave: frequencyArray=",(1pe12.4,1x))') (frequencyArray(freq),freq=0,numberOfFrequencies-1)
    end if
    if( gridIsImplicit.eq.1 )then
      write(*,'("  Implicit coeff: cImp(-1:1,0) = ",3(1pe10.2,1x), "(for 2nd-order)")') cImp(-1,0),cImp(0,0),cImp(1,0)
      write(*,'("  Implicit coeff: cImp(-1:1,1) = ",3(1pe10.2,1x), "(for 4th-order)")') cImp(-1,1),cImp(0,1),cImp(1,1)
    end if
  end if
 
  if( forcingOption.eq.helmholtzForcing )then
    ! --- solving the Helmholtz problem ---
    if( t.le.dt .and. debug.gt.1 )then
      write(*,'("advWave: numberOfFrequencies=",i6," omega=",1pe12.4," frequencyArray(0)=",1pe12.4)') numberOfFrequencies,omega,frequencyArray(0)
    end if
    if( numberOfFrequencies.le.0 )then
      write(*,'("advWave: ERROR: numberOfFrequencies=",i6," is <= 0")') numberOfFrequencies
      stop 0123
    end if

    if( numberOfFrequencies.eq.1  .and. frequencyArray(0) .ne. omega )then
      write(*,'("advWave: ERROR: frequencyArray(0)=",1pe12.4," is not equal to omega=",1pe12.4)') frequencyArray(0),omega
      stop 1234
    end if

    if( numberOfFrequencies.gt.maxFreq )then
      write(*,'("advWave: ERROR: numberOfFrequencies > maxFreq=",i6," .. FIX ME")') maxFreq
      stop 2345
    end if

    ! if( numberOfFrequencies.gt.1 .and. gridIsImplicit.eq.1 )then
    !   write(*,'("advWave: ERROR: numberOfFrequencies > 1 and implicit time-stepping : FINISH ME")') 
    !   stop 3456  
    ! end if
      
    do freq=0,numberOfFrequencies-1
      cosFreqt(freq) = cos(frequencyArray(freq)*t)
    end do

  end if

  uDotFactor=.5  ! By default uDot is D-zero and so we scale (un-um) by .5 --> .5*(un-um)/(dt)
  useSimplifiedDissipation=0


  ! if( .true. )then

  !   ! ************* OLD WAY *********

  !   if( .true. .and. useSosupDissipation.ne.0 .and. solveHelmholtz==1 .and. useSuperGrid==1 .and. useImplicitUpwindDissipation==0 )then

  !     useSimplifiedDissipation=1;

  !     ! Choose coefficient to kill the plus/minus mode: 
  !     ! CHECK ME: could be off by a factor of 2 because of D0t 
  !     dissSafetyFactor=.9

  !     ! adSosup =  dissSafetyFactor*uDotFactor/( nd * 2**(orderOfAccuracy+1) );
  !     adSosup =  dissSafetyFactor/( nd * 2**(orderOfAccuracy+2) );

  !     adxSosup(0)= adSosup
  !     adxSosup(1)= adSosup
  !     adxSosup(2)= adSosup    

  !     if( .false. .and. t.le.2*dt )then
  !       write(*,'("advWave: USE SIMPLIFIED UPWIND DISSIPATION: 1/coeff=",e10.2)') 1./adSosup
  !     end if    

  !   else if( useSosupDissipation.ne.0 .or. useImplicitUpwindDissipation.eq.1 )then
    
  !     ! ---- coefficients of upwind dissipation ---
  !     !   **NOTE**: These must match the values in implicit.bC 

  !     ! if( .true. )then

  !     ! *new* way to define coefficients: (see cgWave.pdf)
  !     adSosup = cc*dt/( sqrt(1.*nd) * 2**(orderOfAccuracy+1) ) 
    
  !     ! sosupParameter=gamma in sosup scheme  0<= gamma <=1   0=centered scheme
  !     adSosup=sosupParameter*adSosup

  !     if( gridIsImplicit.ne.0 .and. useImplicitUpwindDissipation==0 ) then

  !       if( solveHelmholtz==0 .and. useSuperGrid==0 )then
  !         if( t.le.2*dt )then
  !           write(*,'("advWave: gridIsImplicit: t=",e10.2," REDUCE UPWIND DISS COEFF by gridCFL=",e10.2)') t,gridCFL
  !         end if

  !         adSosup = adSosup/gridCFL

  !       elseif( .false. )then  ! TURN OFF -- July 1, 2023
          
  !         ! **** SOLVE HELMHOLTZ WITH SUPEGRID : TESTING *****

  !         !  +++++ gridCFL is not correct for superGrid since it uses the transformed metrics ++++++++++++++++

  !         gridCFL = cc*dt/dr(0)  ! TRY THIS ** TESTING ***
  !         adSosup = adSosup / gridCFL

  !         if( t.le.2*dt )then
  !           write(*,'("advWave: gridIsImplicit: solveHelmholtz with SuperGrid : t=",e10.2," SETUP upwindDiss coeff =",1pe10.2)') t,adSosup
  !         end if

  !       end if

  !     end if
  !   end if ! end old way 

  !   adSosupOld = adSosup
    
  ! *new* way : July 6, 2023 : coefficient is passed in 
  ! use new UPWIND coeff
  adSosup = upwindDissipationCoefficient

  ! Note: these next values are only used for rectangular grids. (curvilinear grid values are computed in the loops)
  if( gridType==rectangular )then
    adxSosup(0)=  uDotFactor*adSosup/dx(0)
    adxSosup(1)=  uDotFactor*adSosup/dx(1)
    adxSosup(2)=  uDotFactor*adSosup/dx(2)    
  end if

  if( (.false. .or. debug.gt.1) .and. t.le.2*dt )then
    write(*,'("XX advWave XX: grid=",i3," gridType=",i2," orderOfAccuracy=",i2," useImplicitUpwindDissipation=",i2)') grid,gridType,orderOfAccuracy,useImplicitUpwindDissipation
    write(*,'("         : t=",1pe10.2," dt=",1pe14.6)')t,dt
    if( useSosupDissipation==1 .or. useImplicitUpwindDissipation==1 )then
      write(*,'("  ****** useSosupDissipation *******")')
      ! write(*,'("         : adSosupOld=",1pe12.4," upwindDissipationCoefficient=",1pe12.4," adSosupOld/(c*dt)=",1pe12.4)') adSosupOld,upwindDissipationCoefficient,adSosupOld/(cc*dt)
      write(*,'("         : upwindDissipationCoefficient=",1pe12.4," adSosupOld/(c*dt)=",1pe12.4)') upwindDissipationCoefficient,adSosupOld/(cc*dt)
      write(*,'("         : useSosupDissipation=",i2," sosupParameter=",1pe10.2," preComputeUpwindUt=",i2)') useSosupDissipation,sosupParameter,preComputeUpwindUt
      if( gridType==rectangular )then
         write(*,'("         : adxSosup",3(1pe14.6))') adxSosup(0),adxSosup(1), adxSosup(2)
      end if
    end if
    ! write(*,'("advMxUp: updateDissipation=",i2)') updateDissipation
    ! write(*,'("advMxUp: useNewForcingMethod=",i2)') useNewForcingMethod
  end if


 
  if( useSosupDissipation.eq.1 .and. preComputeUpwindUt.eq.1 )then
    if( option.ne.1 )then
      write(*,'("advWaveOpt:ERROR: useSosupDissipation.eq.1 BUT option.ne.1")')
      stop 6663
    end if
 
    computeUDot()
 
  end if 


  ! write(*,'(" advWave: timeSteppingMethod=",i2)') timeSteppingMethod
  if( timeSteppingMethod.eq.defaultTimeStepping )then
   write(*,'(" advWave:ERROR: timeSteppingMethod=defaultTimeStepping -- this should be set")')
     ! '
   stop 83322
  end if



  if( useSosupDissipation.eq.0 )then
    
    if( gridIsImplicit.eq.0 )then 
 
      ! ------- EXPLICIT update the solution ---------

      if( useSuperGrid == 0 .or. gridType==curvilinear )then

        ! NOTE: superGrid is embedded the mectrics for curvilinear grids so we can use the normal version

        if( orderInTime.eq.2 )then
         ! FD24 : second-order in time and fourth-order in space
         ! FD26 : second-order in time and sixth-order in space

          if( addForcing.eq.0 )then
           updateWaveOpt(DIM,ORDER,2,GRIDTYPE,NOFORCING)
          else 
           updateWaveOpt(DIM,ORDER,2,GRIDTYPE,USEFORCING)
          end if
        else
          if( addForcing.eq.0 )then
            updateWaveOpt(DIM,ORDER,ORDER,GRIDTYPE,NOFORCING)
          else
            updateWaveOpt(DIM,ORDER,ORDER,GRIDTYPE,USEFORCING)
          end if
        end if 

      else
       
        ! write(*,'(" advWave: Use SUPER-GRID addForcing=",i3)') addForcing
        ! write(*,*) (((f(i1,i2,i3,0),i1=nd1a,nd1b),i2=nd2a,nd2b),i3=nd3a,nd3b)

        #If #GRIDTYPE eq "rectangular"

        if( orderInTime.eq.2 )then
         ! FD24 : second-order in time and fourth-order in space
         ! FD26 : second-order in time and sixth-order in space

          if( addForcing.eq.0 )then
           updateWaveOptSuperGrid(DIM,ORDER,2,GRIDTYPE,NOFORCING)
          else 
           updateWaveOptSuperGrid(DIM,ORDER,2,GRIDTYPE,USEFORCING)
          end if
        else
          if( addForcing.eq.0 )then
            updateWaveOptSuperGrid(DIM,ORDER,ORDER,GRIDTYPE,NOFORCING)
          else
            updateWaveOptSuperGrid(DIM,ORDER,ORDER,GRIDTYPE,USEFORCING)
          end if
        end if 

        #Else
          write(*,'("advWave: ADVANCE SUPERGRID: This function should not be called for curvilinear grids, use normal one.")' )
          stop 666        

        #End

      end if
 

    else

      ! --- IMPLICIT: Fill in RHS to implicit time-stepping -----

      if( takeImplicitFirstStep.eq.1 )then
        if( orderInTime.eq.2 .or. orderInTime.eq.4 )then
          write(*,'(" advWave: TAKE IMPLICIT FIRST STEP ")')
        else
          write(*,'(" advWave: TAKE IMPLICIT FIRST STEP : FINISH ME, orderInTime =",i2)') orderInTime
          stop 468
        end if
        #If #ORDER eq "6" || #ORDER eq "8" 
          write(*,'(" advWave: TAKE IMPLICIT FIRST STEP : FINISH ME, order=ORDER, orderInTime =",i2)') orderInTime
          stop 468
        #End
      end if           


      if( useSuperGrid == 0 .or. gridType==curvilinear )then
        #If #ORDER eq "4"

          if( orderOfAccuracy.eq.4 .and. orderInTime.eq.2 )then
           ! FD24 : second-order in time and fourth-order in space
           updateWaveImplicitOpt(DIM,ORDER,2,GRIDTYPE,FORCING)
          else
            updateWaveImplicitOpt(DIM,ORDER,ORDER,GRIDTYPE,FORCING)
          end if 
   
        #Else

          updateWaveImplicitOpt(DIM,ORDER,ORDER,GRIDTYPE,FORCING)
   
        #End

      else

        ! write(*,'(" advWave: Use SUPER-GRID + IMPLICIT + RECTANGULAR")') 
        !  stop 1111

        #If #ORDER eq "4"
          if( orderOfAccuracy.eq.4 .and. orderInTime.eq.2 )then
           ! FD24 : second-order in time and fourth-order in space
           updateWaveImplicitOptSuperGrid(DIM,ORDER,2,GRIDTYPE,FORCING)
          else
            updateWaveImplicitOptSuperGrid(DIM,ORDER,ORDER,GRIDTYPE,FORCING)
          end if 
   
        #Else

          updateWaveImplicitOptSuperGrid(DIM,ORDER,ORDER,GRIDTYPE,FORCING)
   
        #End        
      end if

      ! --- Add contributions from upwind dissipation ---
      if( useImplicitUpwindDissipation.eq.1 )then
        if( useSuperGrid==1 .and. gridType==curvilinear )then
          ! for superGrid and curvilinear grids use upwinding based on Cartesian grid 
          ! addUpwindDissImplicitOld(DIM,ORDER,rectangular)
          addUpwindDissImplicit(DIM,ORDER,rectangular)
        else
          ! addUpwindDissImplicitOld(DIM,ORDER,GRIDTYPE)
          addUpwindDissImplicit(DIM,ORDER,GRIDTYPE)
        end if
      end if 

    end if
    
  else

    ! ---- add upwind dissipation -----
    ! preComputeUpwindUt : true=precompute Ut in upwind dissipation,  (uses v=uDot computed above)
    !                      false=compute Ut inline in Gauss-Seidel fashion 
    if( useSimplifiedDissipation==0  )then
      if( preComputeUpwindUt.eq.1 )then
        ! precompute Ut in upwind dissipation,  (uses v=uDot computed above)
        addUpwindDiss(DIM,ORDER,GRIDTYPE,v)
      else
        ! compute Ut inline in Gauss-Seidel fashion (this is more stable)
        addUpwindDiss(DIM,ORDER,GRIDTYPE,Dztu)
      end if
    else
      ! -- simplified upwind dissipation ---
      !   Use rectangular grid formulation with special values 

      if( preComputeUpwindUt.eq.1 )then
        ! precompute Ut in upwind dissipation,  (uses v=uDot computed above)
        addUpwindDiss(DIM,ORDER,rectangular,v)
      else
        ! compute Ut inline in Gauss-Seidel fashion (this is more stable)
        addUpwindDiss(DIM,ORDER,rectangular,Dztu)
      end if
    end if
  
  end if
 
 
 
  return
  end

#endMacro


! Macro to build separate files 
#beginMacro buildFile(NAME,DIM,ORDER,GRIDTYPE)
#beginFile NAME.f90
 ADV_WAVE(NAME,DIM,ORDER,GRIDTYPE)
#endFile
#endMacro


  ! ==== Build separate f90 files for different cases ====

  ! buildFile(advWave2dOrder2r,2,2,rectangular)
  ! buildFile(advWave3dOrder2r,3,2,rectangular)
  ! buildFile(advWave2dOrder2c,2,2,curvilinear)
  ! buildFile(advWave3dOrder2c,3,2,curvilinear)

  buildFile(advWave2dOrder4r,2,4,rectangular)
  buildFile(advWave3dOrder4r,3,4,rectangular)
  buildFile(advWave2dOrder4c,2,4,curvilinear)
  buildFile(advWave3dOrder4c,3,4,curvilinear)

  ! !   ORDER=6 : BC's not implemented yet -- needed for upwinding, SuperGrid
  ! buildFile(advWave2dOrder6r,2,6,rectangular)
  ! buildFile(advWave3dOrder6r,3,6,rectangular)
  ! buildFile(advWave2dOrder6c,2,6,curvilinear)
  ! buildFile(advWave3dOrder6c,3,6,curvilinear)

  ! ! ORDER 8 -- needed for upwinding,  SuperGrid
  ! buildFile(advWave2dOrder8r,2,8,rectangular)
  ! buildFile(advWave3dOrder8r,3,8,rectangular)
  ! buildFile(advWave2dOrder8c,2,8,curvilinear)
  ! buildFile(advWave3dOrder8c,3,8,curvilinear)


      subroutine advWave( ARGLIST() )
!======================================================================
!   Advance a time step for Maxwells eqution
!     OPTIMIZED version for rectangular grids.
! nd : number of space dimensions
!
! ipar(0)  = option : option=0 - Maxwell+Artificial diffusion
!                           =1 - AD only
!======================================================================
 implicit none
 declareInputVariables()      


  !     ---- local variables -----
  integer c,i1,i2,i3,n,gridType,orderOfAccuracy,orderInTime
  integer addForcing,orderOfDissipation,option,addUpwinding,modifiedEquationApproach
  ! integer useImplicitUpwindDissipation,useUpwindDissipation
  integer useWhereMask,solveForE,solveForH,grid
  integer ex,ey,ez, hx,hy,hz

  integer rectangular,curvilinear
  parameter( rectangular=0, curvilinear=1 )

  integer standardME, hierarchicalME, stencilME
  parameter( standardME=0, hierarchicalME=1, stencilME=2 )

       
  option                    = ipar( 0)
  gridType                  = ipar( 2)
  orderOfAccuracy           = ipar( 3)
  orderInTime               = ipar( 4)
  modifiedEquationApproach  = ipar(18)

  ! write(*,*) 'Inside advWave...'
  ! write(*,*) 'f: '
  ! write(*,*) (((f(i1,i2,i3,0),i1=nd1a,nd1b),i2=nd2a,nd2b),i3=nd3a,nd3b)

  ! write(*,*) 'option, orderOfAccuracy, modifiedEquationApproach=',option, orderOfAccuracy, modifiedEquationApproach

        ! useUpwindDissipation         = ipar(11)  ! explicit upwind dissipation
  ! useImplicitUpwindDissipation = ipar(12)  ! true if upwind-dissipation is on for impliciit time-stepping 

  if( option.eq.1 )then 
   addUpwinding = 1
  else
   addUpwinding = 0
  end if


  if( orderOfAccuracy.eq.2 )then

    if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder2r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder2c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder2r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder2c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder2r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder2c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder2r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder2c( ARGLIST() )
      else
       stop 8843
      end if 
    else if( modifiedEquationApproach.eq.stencilME ) then

     if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveStencil2dOrder2r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveStencil2dOrder2c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
       call advWaveStencil3dOrder2r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       call advWaveStencil3dOrder2c( ARGLIST() )
      else
       stop 8843
      end if 

    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if

    ! if( nd.eq.2 .and. gridType.eq.rectangular ) then
    !   call advWave2dOrder2r( ARGLIST() )
    ! else if( nd.eq.2 .and. gridType.eq.curvilinear ) then
    !   call advWave2dOrder2c( ARGLIST() )
    ! else if( nd.eq.3 .and. gridType.eq.rectangular ) then
    !   call advWave3dOrder2r( ARGLIST() )
    ! else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
    !   call advWave3dOrder2c( ARGLIST() )
    ! else
    !   stop 2271
    ! end if

  else if( orderOfAccuracy.eq.4 ) then

    if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder4r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder4c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder4r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder4c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder4r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder4c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder4r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder4c( ARGLIST() )
      else
       stop 8843
      end if 

    else if( modifiedEquationApproach.eq.stencilME ) then

     if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveStencil2dOrder4r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveStencil2dOrder4c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveStencil3dOrder4r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       call advWaveStencil3dOrder4c( ARGLIST() )
      else
       stop 8843
      end if 

    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if

  else if( orderOfAccuracy.eq.6 ) then

    if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder6r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder6c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder6r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder6c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder6r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder6c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder6r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder6c( ARGLIST() )
      else
       stop 8843
      end if 
    else if( modifiedEquationApproach.eq.stencilME ) then

     if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveStencil2dOrder6r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveStencil2dOrder6c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
       call advWaveStencil3dOrder6r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       call advWaveStencil3dOrder6c( ARGLIST() )
      else
       stop 8843
      end if 

    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if


  else if( orderOfAccuracy.eq.8 ) then

  if( modifiedEquationApproach.eq.standardME .or. addUpwinding.ne.0 )then
      ! standard ME scheme, or upwind stage
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWave2dOrder8r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWave2dOrder8c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWave3dOrder8r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWave3dOrder8c( ARGLIST() )
      else
       stop 8843
      end if
    else if( modifiedEquationApproach.eq.hierarchicalME ) then
      ! new Hierarchical scheme
      if( nd.eq.2 .and. gridType.eq.rectangular )then
        call advWaveME2dOrder8r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        call advWaveME2dOrder8c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
        call advWaveME3dOrder8r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        call advWaveME3dOrder8c( ARGLIST() )
      else
       stop 8843
      end if 

    else if( modifiedEquationApproach.eq.stencilME ) then


     if( nd.eq.2 .and. gridType.eq.rectangular )then
       call advWaveStencil2dOrder8r( ARGLIST() )
      else if(nd.eq.2 .and. gridType.eq.curvilinear )then
       call advWaveStencil2dOrder8c( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.rectangular )then
       call advWaveStencil3dOrder8r( ARGLIST() )
      else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       ! call advWaveStencil3dOrder8c( ARGLIST() )
      else
       stop 8843
      end if                  
    else  
      write(*,'("Unknown modifiedEquationApproach=",i6)') modifiedEquationApproach
      stop 1111
    end if

  else
    write(*,'(" advWave:ERROR: un-implemented order of accuracy =",i6)') orderOfAccuracy
      ! '
    stop 11122
  end if

  return
  end








