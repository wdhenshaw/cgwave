! ==================================================================================
!
!        Evaluate higher derivatives for CgWave
!        --------------------------------------
!
! ==================================================================================


! These next include file will define the macros that will define the difference approximations (in op/src)
! Defines getDuDx2(u,aj,ff), getDuDxx2(u,aj,ff), getDuDx3(u,aj,ff), ...  etc. 
#Include "derivMacroDefinitions.h"

! Define 
!    defineParametricDerivativeMacros(u,dr,dx,DIM,ORDER,COMPONENTS,MAXDERIV)
!       defines -> ur2, us2, ux2, uy2, ...            (2D)
!                  ur3, us3, ut3, ux3, uy3, uz3, ...  (3D)
#Include "defineParametricDerivMacros.h"

 ! Define parametric derivatives of rsxy up to order=8
 ! #defineMacro rsxyr2(i1,i2,i3,m,n) 
 ! #defineMacro rsxyr2(i1,i2,i3,m,n) 
 defineParametricDerivativeMacros(rsxy,dr,dx,3,2,2,8)
 defineParametricDerivativeMacros(rsxy,dr,dx,3,4,2,6)
 defineParametricDerivativeMacros(rsxy,dr,dx,3,6,2,4)
 defineParametricDerivativeMacros(rsxy,dr,dx,3,8,2,2)

 ! Define parametric and spatial derivatives of u up to order=8
 ! #defineMacro ur2(i1,i2,i3,m) ...
 ! #defineMacro ux2(i1,i2,i3,m) ...
 defineParametricDerivativeMacros(u,dr,dx,3,2,1,8)
 defineParametricDerivativeMacros(u,dr,dx,3,4,1,6)
 defineParametricDerivativeMacros(u,dr,dx,3,6,1,4)
 defineParametricDerivativeMacros(u,dr,dx,3,8,1,2)


! ==========================================================================================
!  Evaluate the Jacobian and its derivatives (parametric and spatial). 
!    rsxy   : jacobian matrix name 
!    aj     : prefix for the name of the resulting jacobian variables, 
!             e.g. ajrx, ajsy, ajrxx, ajsxy, ...
!    MAXDER : number of derivatives to evaluate.  
! ==========================================================================================
#beginMacro opEvalJacobianDerivatives(rsxy,i1,i2,i3,aj,DIM,ORDER,GRIDTYPE,MAXDER)
  ! opEvalJacobianDerivatives called
  #If #GRIDTYPE eq "CURVILINEAR"
  ! this next call will define the jacobian and its derivatives (parametric and spatial)
  #peval evalJacobianDerivatives(rsxy,i1,i2,i3,aj,DIM,ORDER,MAXDER)
  
  #End

#endMacro 

! ==========================================================================================
!  Evaluate the parametric derivatives of u.
!    u      : evaluate derivatives of this function.
!    uc     : component to evaluate
!    uu     : prefix for the name of the resulting derivatives, e.g. uur, uus, uurr, ...
!    MAXDER : number of derivatives to evaluate.  
! ==========================================================================================
#beginMacro opEvalParametricDerivative(u,i1,i2,i3,uc,uu,DIM,ORDER,GRIDTYPE,MAXDER)
#If #GRIDTYPE eq "CURVILINEAR" 
 #peval evalParametricDerivativesComponents1(u,i1,i2,i3,uc, uu,DIM,ORDER,MAXDER)
#Else
 ! uu=u(i1,i2,i3,uc) ! in the rectangular case just eval the solution
#End
#endMacro

! ==========================================================================================
!  Evaluate a derivative. (assumes parametric derivatives have already been evaluated)
!   DERIV   : name of the derivative. One of 
!                x,y,z,xx,xy,xz,...
!    u      : evaluate derivatives of this function.
!    uc     : component to evaluate
!    uu     : prefix for the name of the resulting derivatives (same name used with opEvalParametricDerivative) 
!    aj     : prefix for the name of the jacobian variables.
!    ud     : derivative is assigned to this variable.
! ==========================================================================================
#beginMacro getOp(DERIV,DIM,ORDER,GRIDTYPE, u,i1,i2,i3,uc,uu,aj,ud )

 #If #GRIDTYPE eq "CURVILINEAR" 
  #peval getDuD ## DERIV ## DIM(uu,aj,ud) 
 #Else
  #peval ud = u ## DERIV ## ORDER(i1,i2,i3,uc)
 #End

#endMacro


! ******************************************************************************
!   This next macro is called by other macros to evaluate the first and second derivatives
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalSecondDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE,2)    ! computes uu1r, uu1s 
 getOp(x ,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## x)            ! u1.x
 getOp(y ,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## y)            ! u1.y
 getOp(xx,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xx)
 getOp(yy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## yy)
 uu ## Lap = uu ## xx+ uu ## yy
#endMacro 


! ******************************************************************************
!   ===== COMPUTE FIRST AND SECOND DERIVATIVES ====
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalSecondDerivs3d(rsxy1,aj1,u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE,2)    ! computes uu1r, uu1s 
 getOp(x ,u1,i1,i2,i3,ex,uu,aj1,uu ## x)            ! uux = u1.x
 getOp(y ,u1,i1,i2,i3,ex,uu,aj1,uu ## y)            ! uuy = u1.y
 getOp(z ,u1,i1,i2,i3,ex,uu,aj1,uu ## z)            ! uuz = u1.z
 getOp(xx,u1,i1,i2,i3,ex,uu,aj1,uu ## xx)
 getOp(yy,u1,i1,i2,i3,ex,uu,aj1,uu ## yy)
 getOp(zz,u1,i1,i2,i3,ex,uu,aj1,uu ## zz)
 uu ## Lap = uu ## xx+ uu ## yy+ uu ## zz
#endMacro 


! ******************************************************************************
!   ===== COMPUTE FOURTH DERIVATIVES ====
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalThirdDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE,3) 
 ! put results in uuxxx, uuxxy, uuxyy, uuyyy
 getOp(xxx,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxx)        
 getOp(xxy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxy)        
 getOp(xyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xyy)
 getOp(yyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## yyy)
#endMacro 

! ******************************************************************************
!   ===== COMPUTE FOURTH DERIVATIVES ====
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalFourthDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE,4)   
 getOp(xxxx,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxx)        
 getOp(yyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## yyyy)        
 getOp(xxyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxyy)
#endMacro 

! ******************************************************************************
!   ===== COMPUTE FIFTH DERIVATIVES ====
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalFifthDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE,5)   
 getOp(xxxxx,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxxx)        
 getOp(xxxxy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxxy)        
 getOp(xxxyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxyy)        
 getOp(xxyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxyyy)        
 getOp(xyyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xyyyy)        
 getOp(yyyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## yyyyy)        

#endMacro 


! ******************************************************************************
!   ===== COMPUTE SIXTH DERIVATIVES ====
!   This macro assumes that opEvalJacobianDerivatives has been called
! ******************************************************************************
#beginMacro evalSixthDerivs(rsxy1,aj1,u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE)
 opEvalParametricDerivative(u1,i1,i2,i3,ex,uu,DIM,ORDER,GRIDTYPE,6)   
 getOp(xxxxxx,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxxxx)        
 getOp(xxxxxy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxxxy)        
 getOp(xxxxyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxxyy)        
 getOp(xxxyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxxyyy)        
 getOp(xxyyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xxyyyy)        
 getOp(xyyyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## xyyyyy)        
 getOp(yyyyyy,DIM,ORDER,GRIDTYPE,u1,i1,i2,i3,ex,uu,aj1,uu ## yyyyyy)        

#endMacro 



! From bcOptSmFOS.bf
! DataBase *pdb = &parameters.dbase;
! double precision pdb  ! pointer to data base
! ====================================================================
! Look up an integer parameter from the data base
! ====================================================================
#beginMacro getIntParameter(name)
 ok=getInt(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** getWaveDerivatives:getInt:ERROR: unable to find name")') 
   stop 1122
 end if
#endMacro

! ====================================================================
! Look up a real parameter from the data base
! ====================================================================
#beginMacro getRealParameter(name)
 ok=getReal(pdb,'name',name) 
 if( ok.eq.0 )then
   write(*,'("*** getWaveDerivatives:getReal:ERROR: unable to find name")') 
   stop 1133
 end if
#endMacro




#beginMacro beginLoops(n1a,n1b,n2a,n2b,n3a,n3b,na,nb)
do i3=n3a,n3b
do i2=n2a,n2b
do i1=n1a,n1b
do n=na,nb
  ! write(*,'(" periodic i1,i2,i3,n=",4i4)') i1,i2,i3,n
#endMacro

#beginMacro endLoops()
end do
end do
end do
end do
#endMacro


#beginMacro beginLoops2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro
#beginMacro endLoops2d()
 end do
 end do
#endMacro

#beginMacro beginLoopsMask2d()
 i3=n3a
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro
#beginMacro endLoopsMask2d()
 end if
 end do
 end do
#endMacro

#beginMacro beginGhostLoops2d()
 i3=n3a
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro

#beginMacro beginLoops3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro

#beginMacro endLoops3d()
 end do
 end do
 end do
#endMacro

#beginMacro beginLoopsMask3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
 if( mask(i1,i2,i3).gt.0 )then
#endMacro

#beginMacro endLoopsMask3d()
 end if
 end do
 end do
 end do
#endMacro

#beginMacro beginGhostLoops3d()
 do i3=nn3a,nn3b
 do i2=nn2a,nn2b
 do i1=nn1a,nn1b
#endMacro




#beginMacro getNormal2d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2))
 an1=an1*aNormi
 an2=an2*aNormi
#endMacro

#beginMacro getNormal3d(i1,i2,i3,axis)
 an1 = rsxy(i1,i2,i3,axis,0)
 an2 = rsxy(i1,i2,i3,axis,1)
 an3 = rsxy(i1,i2,i3,axis,2)
 aNormi = -is/max(epsx,sqrt(an1**2 + an2**2+ an3**2))
 an1=an1*aNormi
 an2=an2*aNormi
 an3=an3*aNormi
#endMacro



! =========================================================================
! Compute the normal on a curvilinear grid.
!
! Assumes is=1-2*side is defined. 
! =========================================================================
#beginMacro getNormal(j1,j2,j3)
    an1 = rsxy(j1,j2,j3,axis,0)
    an2 = rsxy(j1,j2,j3,axis,1)
    if( nd.eq.2 )then
     aNormi = (-is)/sqrt(an1**2+an2**2)
     an1=an1*aNormi
     an2=an2*aNormi
    else
     an3 = rsxy(j1,j2,j3,axis,2)
     aNormi = (-is)/sqrt(an1**2+an2**2+an3**2)
     an1=an1*aNormi
     an2=an2*aNormi
     an3=an3*aNormi
    end if
#endMacro



   






subroutine getWaveDerivatives( nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,\
                               gridIndexRange, dimRange, isPeriodic, u, mask,rsxy, xy, boundaryCondition, \
                               ipar, rpar, maxErr, ierr )
! ===================================================================================
!  Evaluate derivatives for cgWave 
!
!  gridType : 0=rectangular, 1=curvilinear
!
! ===================================================================================

  implicit none

  integer nd, nd1a,nd1b,nd2a,nd2b,nd3a,nd3b, ndb, ierr

  real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)
  integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
  real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)
  real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
  integer gridIndexRange(0:1,0:2),boundaryCondition(0:1,0:2), dimRange(0:1,0:2), isPeriodic(0:*)
  real maxErr(1:*)

  ! double precision pdb  ! pointer to data base

  ! integer addBoundaryForcing(0:1,0:2)
  ! integer interfaceType(0:1,0:2,0:*)
  ! integer dim(0:1,0:2,0:1,0:2)

  ! real bcf0(0:*)
  ! integer*8 bcOffset(0:1,0:2)

  ! real bcData(0:ndb-1,0:1,0:nd-1,0:*)

  integer ipar(0:*)
  real rpar(0:*)

  !     --- local variables ----
  
  real maxSol(1:20)
  integer uc,numberOfComponents,assignTwilightZone,assignKnownSolutionAtBoundaries,freq
  integer grid,gridType,orderOfAccuracy,useWhereMask,gridIsImplicit,useUpwindDissipation
  integer twilightZone,numberOfProcessors,addForcing,assignBCForImplicitForImplicit
  integer debug,myid,ghost,d,maxDeriv

  integer ok,getInt,getReal
  real omega,cfl,c
  real kx,ky,kz,twoPi

  real t,dt,epsx,REAL_MIN 
  real ep
  real a0,a1,an1,an2,an3,aNormi, tn1,tn2,tn3
  real dx(0:2),dr(0:2)

  real dxn,b0,b1,ue,uex,uey,uez,ff,urv(0:2),ur0,cosPW
  real uett,uexx,ueyy,uezz,ueLap
  real uexxx,ueyyy,uezzz,uexxy,uexyy
  real uexxxx,ueyyyy,uezzzz,uexxyy
  real uexxxxx,uexxxxy,uexxxyy,uexxyyy,uexyyyy,ueyyyyy
  real uexxxxxx,uexxxxxy,uexxxxyy,uexxxyyy,uexxyyyy,uexyyyyy,ueyyyyyy




  integer side,axis,axisp1,axisp2,i1,i2,i3,is1,is2,is3,j1,j2,j3,js1,js2,js3,k1,k2,k3,ks1,ks2,ks3,is,js
  integer l1,l2,l3

  integer numGhost,numberOfGhostPoints,extraForNeumann,extraForDirichlet,numberOfFrequencies
  integer side1,side2,side3
  integer n1a,n1b,n2a,n2b,n3a,n3b
  integer nn1a,nn1b,nn2a,nn2b,nn3a,nn3b
  integer extra1a,extra1b,extra2a,extra2b,extra3a,extra3b

  ! integer cornerBC(0:2,0:2,0:2), iparc(0:10), orderOfExtrapolationForCorners
  ! real rparc(0:10)

  ! boundary conditions parameters and interfaceType values
  ! #Include "bcDefineFortran.h"
  ! These should mauch the values in Parameters.h
  ! integer dirichletBoundaryCondition,neumannBoundaryCondition,dirichletInterface,neumannInterface,mixedBoundaryCondition
  ! parameter( dirichletBoundaryCondition=12, neumannBoundaryCondition=18, dirichletInterface=21, neumannInterface=22, mixedBoundaryCondition=30 )

  integer rectangular,curvilinear
  parameter(\
    rectangular=0,\
    curvilinear=1)

  integer forcingOption
  integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
  parameter( noForcing=0, twilightZoneForcing=1, userForcing=2, helmholtzForcing=2 )


  ! variables for CBCs
  real cSq,r1,r2,r3,r4,gtt
  real a11,a12,a21,a22

  ! declareDifferenceNewOrder2(u,rsxy,dr,dx,RX)

  ! declareDifferenceNewOrder4(u,rsxy,dr,dx,RX)

  ! !     The next macro call will define the difference approximation statement functions
  ! defineDifferenceNewOrder2Components1(u,rsxy,dr,dx,RX)

  ! defineDifferenceNewOrder4Components1(u,rsxy,dr,dx,RX)

  ! 4th-order 1 sided derivative  extrap=(1 5 10 10 5 1)
  ! uxOneSided(i1,i2,i3,m)=-(10./3.)*u(i1,i2,i3,m)+6.*u(i1+is1,i2+is2,i3+is3,m)-2.*u(i1+2*is1,i2+2*is2,i3+2*is3,m)\
  !                        +(1./3.)*u(i1+3*is1,i2+3*is2,i3+3*is3,m)

  ! ! Here is the the generic boundary condition forcing array. It uses the bcOffset(side,axis) values as an
  ! ! an offset from the bcf0 array to access the bcf10, bcf01, bcf11, ... arrays
  ! bcf(side,axis,i1,i2,i3,m) = bcf0(bcOffset(side,axis) + \
  !     (i1-dim(0,0,side,axis)+(dim(1,0,side,axis)-dim(0,0,side,axis)+1)* \
  !     (i2-dim(0,1,side,axis)+(dim(1,1,side,axis)-dim(0,1,side,axis)+1)* \
  !     (i3-dim(0,2,side,axis)+(dim(1,2,side,axis)-dim(0,2,side,axis)+1)*(m)))))

  ! mixedRHS(component,side,axis,grid) = bcData(component+numberOfComponents*(0),side,axis,grid)
  ! mixedCoeff(component,side,axis,grid) = bcData(component+numberOfComponents*(1),side,axis,grid)
  ! mixedNormalCoeff(component,side,axis,grid) =  bcData(component+numberOfComponents*(2),side,axis,grid)

  real uux,uuy,uuz,uuxx,uuxy,uuyy,uuxz,uuyz,uuzz,uuLap
  real uuxxx,uuyyy,uuxxy,uuxyy
  real uuxxxx,uuyyyy,uuxxyy
  real uuxxxxx,uuxxxxy,uuxxxyy,uuxxyyy,uuxyyyy,uuyyyyy
  real uuxxxxxx,uuxxxxxy,uuxxxxyy,uuxxxyyy,uuxxyyyy,uuxyyyyy,uuyyyyyy

  ! real u1xxx,u1xxy,u1xyy,u1yyy, u1xxz,u1xzz,u1zzz, u1yyz, u1yzz
  ! real u1xxxx,u1xxyy,u1yyyy, u1xxzz,u1zzzz, u1yyzz

  declareTemporaryVariables(2,2)
  declareParametricDerivativeVariables(uu,3) 
  declareJacobianDerivativeVariables(aj,3)     ! declareJacobianDerivativeVariables(aj,DIM)

  !............... end statement functions

  ierr=0

  uc                              = ipar( 0)
  numberOfComponents              = ipar( 1)
  grid                            = ipar( 2)
  gridType                        = ipar( 3)
  orderOfAccuracy                 = ipar( 4)
  twilightZone                    = ipar( 5)
  debug                           = ipar( 6)
  numGhost                        = ipar( 7)  
  maxDeriv                        = ipar( 8)
 
  dx(0)     = rpar( 0)
  dx(1)     = rpar( 1)
  dx(2)     = rpar( 2)
  dr(0)     = rpar( 3)
  dr(1)     = rpar( 4)
  dr(2)     = rpar( 5)
  ep        = rpar( 6) ! pointer for exact solution -- new : 110311 
  REAL_MIN  = rpar( 7)


  twoPi = atan2(1.,1.)*8.; ! atan2(1,1)=pi/4

  if( .true. .or. (.false. .or. debug.gt.1) )then

    write(*,'(" getWaveDerivatives: grid=",i4," gridType=",i2," orderOfAccuracy=",i2," uc=",i3," twilightZone=",i2," maxDeriv=",i2)') grid,gridType,orderOfAccuracy,uc,twilightZone,maxDeriv
    write(*,'(" dx=",3(1pe9.2,1x))') (dx(axis),axis=0,2)
  end if
  


  if( uc.lt.0 .or. uc.ge.numberOfComponents )then
    write(*,'("getWaveDerivatives:ERROR: invalid uc=",i6," but numberOfComponents=",i3)')  uc,numberOfComponents
    stop 1111
  end if
    
  epsx=REAL_MIN*100.  ! for normal

  if( orderOfAccuracy.ne.2 .and. orderOfAccuracy.ne.4 .and. orderOfAccuracy.ne.6 .and. orderOfAccuracy.ne.8 )then
    write(*,'("getWaveDerivatives:ERROR: orderOfAccuracy is not 2, 4 or 6, orderOfAccuracy=",i4)') orderOfAccuracy
    stop 1111
  end if



#beginMacro evalDerivatives(DIM,ORDER2,ORDER4,ORDER6,ORDER8,GRIDTYPE)
  do d=1,maxDeriv
    maxErr(d)=0.; 
    maxSol(d)=0.; 
  end do
  beginLoops3d()
    if( mask(i1,i2,i3).ne.0 )then

      ! Evaluate jacobian derivatives (MAXDERIV=1 is the last argument)
      ! NOTE: we need ONE LESS derivative of the metrics 
      opEvalJacobianDerivatives(rsxy,i1,i2,i3,aj,DIM,ORDER2,GRIDTYPE,1)

      ! uu is the name for temp variables such as uur, uus, ...
      evalSecondDerivs(rsxy,aj,u,i1,i2,i3,0,uu,DIM,ORDER2,GRIDTYPE) 

      if( nd.eq.2 )then
        call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex  )
        call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
      else
        call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex  )
        call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey  )
        call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
        call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
      end if  
      if( debug.gt.3 )then  
        write(*,'(" (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uuxx,uexx,abs(uuxx-uexx),uuyy,abs(uuyy-ueyy)
      end if
      maxErr(1) = max( maxErr(1),abs(uux-uex), abs(uuy-uey) )
      maxSol(1) = max( maxSol(1),abs(uex),abs(uey))

      maxErr(2) = max( maxErr(2),abs(uuxx-uexx),abs(uuyy-ueyy) ) 
      maxSol(2) = max( maxSol(2),abs(uexx),abs(ueyy) )

      if( maxDeriv.ge.3 )then
        ! Evaluate jacobian derivatives (MAXDERIV is the last argument)
        ! NOTE: we need ONE LESS derivative of the metrics 
        opEvalJacobianDerivatives(rsxy,i1,i2,i3,aj,DIM,ORDER4,GRIDTYPE,2)        
        evalThirdDerivs(rsxy,aj,u,i1,i2,i3,0,uu,DIM,ORDER4,GRIDTYPE) 

        if( nd.eq.2 )then
          call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxx  )
          call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyy )
          call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxy )
          call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyy )
        else
          stop 3333
        end if  
        ! if( debug.gt.3 )then  
        !   write(*,'(" (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uuxx,uexx,abs(uuxx-uexx),uuyy,abs(uuyy-ueyy)
        ! end if
        maxErr(3) = max( maxErr(3),abs(uuxxx-uexxx), abs(uuyyy-ueyyy) )
        maxErr(3) = max( maxErr(3),abs(uuxxy-uexxy), abs(uuxyy-uexyy) )
        maxSol(3) = max( maxSol(3),abs(uexxx),abs(uexxy),abs(uexyy),abs(ueyyy) )
      end if


      if( maxDeriv.ge.4 )then
        ! Evaluate jacobian derivatives (MAXDERIV is the last argument)
        ! NOTE: we need ONE LESS derivative of the metrics 
        opEvalJacobianDerivatives(rsxy,i1,i2,i3,aj,DIM,ORDER4,GRIDTYPE,3)        
        evalFourthDerivs(rsxy,aj,u,i1,i2,i3,0,uu,DIM,ORDER4,GRIDTYPE) 

        if( nd.eq.2 )then
          call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx  )
          call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )
          call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
        else
          stop 3333
        end if  
        ! if( debug.gt.3 )then  
        !   write(*,'(" (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uuxx,uexx,abs(uuxx-uexx),uuyy,abs(uuyy-ueyy)
        ! end if
        maxErr(4) = max( maxErr(4),abs(uuxxxx-uexxxx), abs(uuyyyy-ueyyyy) )
        maxErr(4) = max( maxErr(4),abs(uuxxyy-uexxyy) )
        maxSol(4) = max( maxSol(4),abs(uexxxx),abs(uexxyy),abs(ueyyyy) )
      end if

      if( maxDeriv.ge.5 )then
        ! Evaluate jacobian derivatives (MAXDERIV is the last argument)
        ! NOTE: we need ONE LESS derivative of the metrics 
        opEvalJacobianDerivatives(rsxy,i1,i2,i3,aj,DIM,ORDER6,GRIDTYPE,4)        
        evalFifthDerivs(rsxy,aj,u,i1,i2,i3,0,uu,DIM,ORDER6,GRIDTYPE) 

        if( nd.eq.2 )then
          call ogDeriv(ep,0,5,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxx  )
          call ogDeriv(ep,0,0,5,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyy )
          call ogDeriv(ep,0,4,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxy )
          call ogDeriv(ep,0,3,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxyy )
          call ogDeriv(ep,0,2,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyy )
          call ogDeriv(ep,0,1,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyyyy )
        else
          stop 3333
        end if  
        ! if( debug.gt.3 )then  
        !   write(*,'(" (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uuxx,uexx,abs(uuxx-uexx),uuyy,abs(uuyy-ueyy)
        ! end if
        maxErr(5) = max( maxErr(5),abs(uuxxxxx-uexxxxx ), abs(uuyyyyy-ueyyyyy) )
        maxErr(5) = max( maxErr(5),abs(uuxxxxy-uexxxxy ), abs(uuxxxyy-uexxxyy) )
        maxErr(5) = max( maxErr(5),abs(uuxxyyy-uexxyyy ), abs(uuxyyyy-uexyyyy) )
        maxSol(5) = max( maxSol(5),abs(uexxxxx),abs(uexxxxy),abs(uexxxyy),abs(uexxyyy),abs(uexyyyy),abs(ueyyyyy) )
      end if 

      if( maxDeriv.ge.6)then
        ! Evaluate jacobian derivatives (MAXDERIV is the last argument)
        ! NOTE: we need ONE LESS derivative of the metrics 
        opEvalJacobianDerivatives(rsxy,i1,i2,i3,aj,DIM,ORDER6,GRIDTYPE,5)        
        evalSixthDerivs(rsxy,aj,u,i1,i2,i3,0,uu,DIM,ORDER6,GRIDTYPE) 

        if( nd.eq.2 )then
          call ogDeriv(ep,0,6,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxx  )
          call ogDeriv(ep,0,5,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxy )
          call ogDeriv(ep,0,4,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxyy )
          call ogDeriv(ep,0,3,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxyyy )
          call ogDeriv(ep,0,2,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyyy )
          call ogDeriv(ep,0,1,5,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyyyyy )
          call ogDeriv(ep,0,0,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyyy )
        else
          stop 3333
        end if  
        if( i1.eq.5 .and. i2.eq.6 )then  
          write(*,'(" (i1,i2)=(",2i3,") uxxxxxx=",1pe12.4," uexxxxxx=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uuxxxxxx,uexxxxxx,abs(uuxxxxxx-uexxxxxx)/max(1.,abs(uexxxxxx))
          write(*,'(" (i1,i2)=(",2i3,") uxxyyyy=",1pe12.4," uexxyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uuxxyyyy,uexxyyyy,abs(uuxxyyyy-uexxyyyy)/max(1.,abs(uexxyyyy))
          write(*,'(" (i1,i2)=(",2i3,") uxxxyyy=",1pe12.4," uexxxyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uuxxxyyy,uexxxyyy,abs(uuxxxyyy-uexxxyyy)/max(1.,abs(uexxxyyy))
          write(*,'(" (i1,i2)=(",2i3,") uxxxxxx=",1pe12.4," uexxxxxx=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uuxxxxxx,uexxxxxx,abs(uuxxxxxx-uexxxxxx)/max(1.,abs(uexxxxxx))
        end if
        maxErr(6) = max( maxErr(6),abs(uuxxxxxx-uexxxxxx  ) )
        maxErr(6) = max( maxErr(6),abs(uuxxxxxy-uexxxxxy  ) )
        maxErr(6) = max( maxErr(6),abs(uuxxxxyy-uexxxxyy  ) )
        maxErr(6) = max( maxErr(6),abs(uuxxxyyy-uexxxyyy  ) )
        maxErr(6) = max( maxErr(6),abs(uuxxyyyy-uexxyyyy  ) )
        maxErr(6) = max( maxErr(6),abs(uuxyyyyy-uexyyyyy  ) )
        maxErr(6) = max( maxErr(6),abs(uuyyyyyy-ueyyyyyy  ) )
        maxSol(6) = max( maxSol(6),abs(uexxxxxx),abs(uexxxxxy),abs(uexxxxyy),abs(uexxxyyy),abs(uexxyyyy),abs(uexyyyyy),abs(ueyyyyyy) )
      end if             

    end if ! mask .ne. 0
  endLoops3d()
  do d=1,maxDeriv
    maxErr(d) = maxErr(d)/maxSol(d)
    write(*,'(" grid=",i2," max-rel-err deriv",i2," = ",1pe8.2)') grid,d,maxErr(d)
  end do
#endMacro

  n1a=gridIndexRange(0,0)   
  n1b=gridIndexRange(1,0)
  n2a=gridIndexRange(0,1)
  n2b=gridIndexRange(1,1)
  n3a=gridIndexRange(0,2)
  n3b=gridIndexRange(1,2)
 
  if( gridType.eq.rectangular )then
    if( orderOfAccuracy.eq.2 )then
      evalDerivatives(2,2,2,2,2,RECTANGULAR)
    else if( orderOfAccuracy.eq.4 )then
      evalDerivatives(2,4,2,2,2,RECTANGULAR)
    else if( orderOfAccuracy.eq.6 )then
      evalDerivatives(2,6,4,2,2,RECTANGULAR) 
    else if( orderOfAccuracy.eq.8 )then
      evalDerivatives(2,8,6,4,2,RECTANGULAR)            
    else 
      stop 666
    end if
  else
    if( orderOfAccuracy.eq.2 )then
      evalDerivatives(2,2,2,2,2,CURVILINEAR)
    else if( orderOfAccuracy.eq.4 )then
      evalDerivatives(2,4,2,2,2,CURVILINEAR)
    else if( orderOfAccuracy.eq.6 )then
      evalDerivatives(2,6,4,2,2,CURVILINEAR)   
    else if( orderOfAccuracy.eq.8 )then
      evalDerivatives(2,8,6,4,2,CURVILINEAR)            
    else 
      stop 666
    end if    
  end if



  return
  end

