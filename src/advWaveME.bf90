!
! =======================================================================
! ============ Optimized advance routines for CgWave ====================
!              NEW MODIFIED EQUATION VERSIONS
!
! Feb 2022 : first version created from advWave.bf90 and hierDeriv.bf90
! =======================================================================
!
! These next include files will define the macros that will define the difference approximations
! The actual macro is called below
! #Include "defineDiffOrder2f.h"
! #Include "defineDiffOrder4f.h"

! ! 6th-order
! #Include "defineDiffOrder6f.h"

! ! 8th order
! #Include "defineDiffOrder8f.h"

! define macros to evaluate derivatives for the 6th order method (from maple/makeGetDerivativesMacros.maple)
! #Include "../maple/defineGetSixthDerivativesMacros.h"


! ======================================================================================
!   Evaluate the TZ exact solution in 2D
! ======================================================================================
#beginMacro OGDERIV2D( ntd,nxd,nyd,nzd,i1,i2,i3,t, n,val)
  call ogDeriv(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t, n,val )
#endMacro

! ======================================================================================
!   Evaluate the TZ exact solution in 3D
! ======================================================================================
#beginMacro OGDERIV3D( ntd,nxd,nyd,nzd,i1,i2,i3,t, n,val)
  call ogDeriv(ep, ntd,nxd,nyd,nzd, xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t, n,val )
#endMacro

  
#beginMacro beginLoops3d()
 do i3=n3a,n3b
 do i2=n2a,n2b
 do i1=n1a,n1b
#endMacro

#beginMacro endLoops3d()
 end do
 end do
 end do
#endMacro

! ---------------------------------------------------------------------------
! Macro : beginLoopsMask
! ---------------------------------------------------------------------------
#beginMacro beginLoopsMask(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
    if( mask(i1,i2,i3).gt.0 )then
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoopsMask
! ---------------------------------------------------------------------------
#beginMacro endLoopsMask()
    end if
  end do
  end do
  end do
#endMacro

! ---------------------------------------------------------------------------
! Macro : beginLoops
! ---------------------------------------------------------------------------
#beginMacro beginLoops(i1,i2,i3,n1a,n1b,n2a,n2b,n3a,n3b)
  do i3=n3a,n3b
  do i2=n2a,n2b
  do i1=n1a,n1b
#endMacro

! ---------------------------------------------------------------------------
! Macro : endLoopsMask
! ---------------------------------------------------------------------------
#beginMacro endLoops()
  end do
  end do
  end do
#endMacro




! ===========================================================================================
! Macro: Output some debug info for the first few time-steps 
! ===========================================================================================
#beginMacro INFO(string)
if( t.le.3.*dt )then
  write(*,'("advWaveME>>>",string)')
end if
#endMacro


!   Include files that define macros to define the curvilinear derivative coefficients using the chain rule
! files created by chainRuleCoefficients.maple
! #Include "../maple/chainRuleCoefficientsMacro2d.h"
! #Include "../maple/chainRuleCoefficientsMacro3d.h"




! =========================================================================================
! Macro: Compute the forcing for the update of u
! =========================================================================================
#beginMacro getForcing(DIM,ORDER,ORDERINTIME,GRIDTYPE)    
  if( forcingOption.eq.twilightZoneForcing )then
    #If #DIM eq "2"
      OGDERIV2D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      OGDERIV2D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      OGDERIV2D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      OGDERIV2D( 0,0,2,0,i1,i2,i3,t, ec, evyy(m) )
      fv(m) = evtt(m) - csq*( evxx(m) + evyy(m) )
    #Else
      OGDERIV3D( 0,0,0,0,i1,i2,i3,t, ec, ev(m)  )
      OGDERIV3D( 2,0,0,0,i1,i2,i3,t, ec, evtt(m) )
      OGDERIV3D( 0,2,0,0,i1,i2,i3,t, ec, evxx(m) )
      OGDERIV3D( 0,0,2,0,i1,i2,i3,t, ec, evyy(m) )
      OGDERIV3D( 0,0,0,2,i1,i2,i3,t, ec, evzz(m) )
      fv(m) = evtt(m) - csq*( evxx(m) + evyy(m)  + evzz(m) )
   #End
   #If ORDER ge 4 && ORDERINTIME ge 4
     #If #DIM eq "2"
       ! Correct forcing for fourth-order ME in2D
       OGDERIV2D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
       OGDERIV2D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(m) )
       OGDERIV2D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(m) )
       OGDERIV2D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(m) )
       fv(m) = fv(m) + (dtSq/12.)*evtttt(m) - (cdtsq12/dtSq)*( evxxxx(m) + 2.*evxxyy(m) + evyyyy(m) )
     #Else
       ! Correct forcing for fourth-order ME in 3D
       OGDERIV3D( 4,0,0,0,i1,i2,i3,t, ec, evtttt(m) )
       OGDERIV3D( 0,4,0,0,i1,i2,i3,t, ec, evxxxx(m) )
       OGDERIV3D( 0,2,2,0,i1,i2,i3,t, ec, evxxyy(m) )
       OGDERIV3D( 0,2,0,2,i1,i2,i3,t, ec, evxxzz(m) )
       OGDERIV3D( 0,0,2,2,i1,i2,i3,t, ec, evyyzz(m) )
       OGDERIV3D( 0,0,4,0,i1,i2,i3,t, ec, evyyyy(m) )
       OGDERIV3D( 0,0,0,4,i1,i2,i3,t, ec, evzzzz(m) )
       fv(m) = fv(m) + (dtSq/12.)*evtttt(m) - (cdtsq12/dtSq)*( evxxxx(m) + 2.*( evxxyy(m) + evxxzz(m) + evyyzz(m) ) + evyyyy(m) + evzzzz(m) )       
     #End
   #End
   #If ORDER ge 6 && ORDERINTIME ge 6
     #If #DIM eq "2"
       ! Correct forcing for sixth-order ME in 2D
       OGDERIV2D( 6,0,0,0,i1,i2,i3,t, ec, evtttttt(m) )
       OGDERIV2D( 0,6,0,0,i1,i2,i3,t, ec, evxxxxxx(m) )
       OGDERIV2D( 0,4,2,0,i1,i2,i3,t, ec, evxxxxyy(m) )
       OGDERIV2D( 0,2,4,0,i1,i2,i3,t, ec, evxxyyyy(m) )
       OGDERIV2D( 0,0,6,0,i1,i2,i3,t, ec, evyyyyyy(m) )
       fv(m) = fv(m) + (dtSq**2/360.)*evtttttt(m) - (cdtPow6By360/dtSq)*( evxxxxxx(m) + evyyyyyy(m) + 3.*(evxxxxyy(m) + evxxyyyy(m) )  )
     #Else
       ! Correct forcing for sixth-order ME in 3D
       OGDERIV3D( 6,0,0,0,i1,i2,i3,t, ec, evtttttt(m) )
       OGDERIV3D( 0,6,0,0,i1,i2,i3,t, ec, evxxxxxx(m) )
       OGDERIV3D( 0,0,6,0,i1,i2,i3,t, ec, evyyyyyy(m) )
       OGDERIV3D( 0,0,0,6,i1,i2,i3,t, ec, evzzzzzz(m) )       

       OGDERIV3D( 0,4,2,0,i1,i2,i3,t, ec, evxxxxyy(m) )
       OGDERIV3D( 0,2,4,0,i1,i2,i3,t, ec, evxxyyyy(m) )
       OGDERIV3D( 0,4,0,2,i1,i2,i3,t, ec, evxxxxzz(m) )
       OGDERIV3D( 0,2,0,4,i1,i2,i3,t, ec, evxxzzzz(m) )

       OGDERIV3D( 0,0,4,2,i1,i2,i3,t, ec, evyyyyzz(m) )
       OGDERIV3D( 0,0,2,4,i1,i2,i3,t, ec, evyyzzzz(m) )

       OGDERIV3D( 0,2,2,2,i1,i2,i3,t, ec, evxxyyzz(m) )

       fv(m) = fv(m) + (dtSq**2/360.)*evtttttt(m) \
            - (cdtPow6By360/dtSq)*( evxxxxxx(m) + \
                                    evyyyyyy(m) + \
                                    evzzzzzz(m) \
                              + 3.*(evxxxxyy(m) + \
                                    evxxyyyy(m) + \
                                    evxxxxzz(m) + \
                                    evxxzzzz(m) + \
                                    evyyyyzz(m) + \
                                    evyyzzzz(m) ) \
                               + 6.*evxxyyzz(m)  )
     #End
   #End  

   #If ORDER ge 8 && ORDERINTIME ge 8

     #If #DIM eq "2"
       ! Correct forcing for eighth-order ME in 2D
       OGDERIV2D( 8,0,0,0,i1,i2,i3,t, ec, uet8 )
       OGDERIV2D( 0,8,0,0,i1,i2,i3,t, ec, uex8 )
       OGDERIV2D( 0,6,2,0,i1,i2,i3,t, ec, uex6y2 )
       OGDERIV2D( 0,4,4,0,i1,i2,i3,t, ec, uex4y4 )
       OGDERIV2D( 0,2,6,0,i1,i2,i3,t, ec, uex2y6 )
       OGDERIV2D( 0,0,8,0,i1,i2,i3,t, ec, uey8 )
       ! (x*x + y*y)^4 = x^8 + 4*x^6*y^2 + 6*x^4*y^4 + 4*x^2*y^6 + y^8
       fv(m) = fv(m) + (dtSq**3/20160.)*uet8 - \
                (cdtPow8By20160/dtSq)*( uex8 + \
                                        uey8   \
                                  + 4.*(uex6y2 + \
                                        uex2y6 ) +\
                                     6.*uex4y4 )
     #Else
       ! Correct forcing for eighth-order ME in 3D

       OGDERIV3D( 8,0,0,0,i1,i2,i3,t, ec, uet8 )
       OGDERIV3D( 0,8,0,0,i1,i2,i3,t, ec, uex8 )
       OGDERIV3D( 0,0,8,0,i1,i2,i3,t, ec, uey8 )
       OGDERIV3D( 0,0,0,8,i1,i2,i3,t, ec, uez8 )       

       OGDERIV3D( 0,6,2,0,i1,i2,i3,t, ec, uex6y2 )
       OGDERIV3D( 0,4,4,0,i1,i2,i3,t, ec, uex4y4 )
       OGDERIV3D( 0,2,6,0,i1,i2,i3,t, ec, uex2y6 )

       OGDERIV3D( 0,6,0,2,i1,i2,i3,t, ec, uex6z2 )
       OGDERIV3D( 0,4,0,4,i1,i2,i3,t, ec, uex4z4 )
       OGDERIV3D( 0,2,0,6,i1,i2,i3,t, ec, uex2z6 )

       OGDERIV3D( 0,0,6,2,i1,i2,i3,t, ec, uey6z2 )
       OGDERIV3D( 0,0,4,4,i1,i2,i3,t, ec, uey4z4 )
       OGDERIV3D( 0,0,2,6,i1,i2,i3,t, ec, uey2z6 )

       OGDERIV3D( 0,4,2,2,i1,i2,i3,t, ec, uex4y2z2 )
       OGDERIV3D( 0,2,4,2,i1,i2,i3,t, ec, uex2y4z2 )
       OGDERIV3D( 0,2,2,4,i1,i2,i3,t, ec, uex2y2z4 )

       ! ( x*x _ y*y + z*z )^4 = x^8 + 4*x^6*y^2 + 4*x^6*z^2 + 6*x^4*y^4 + 12*x^4*y^2*z^2 + 6*x^4*z^4 + 4*x^2*y^6 + 12*x^2*y^4*z^2 + 12*x^2*y^2*z^4 + 4*x^2*z^6 + y^8 + 4*y^6*z^2 + 6*y^4*z^4 + 4*y^2*z^6 + z^8 
       fv(m) = fv(m) + (dtSq**3/20160.)*uet8       \
            - (cdtPow8By20160/dtSq)*( uex8 +       \
                                      uey8 +       \
                                      uez8         \
                                +  4.*(uex6y2 +    \
                                       uex2y6 +    \
                                       uex6z2 +    \
                                       uex2z6 +    \
                                       uey6z2 +    \
                                       uey2z6 )    \
                                +  6.*( uex4y4 +   \
                                        uex4z4 +   \
                                        uey4z4 )   \
                                + 12.*( uex4y2z2 + \
                                        uex2y4z2 + \
                                        uex2y2z4 ) \
                                )
     #End
   #End               

 else if( forcingOption.eq.helmholtzForcing )then

    ! forcing for solving the Helmholtz equation   
    ! NOTE: change sign of forcing since for Helholtz we want to solve
    !      ( omega^2 I + c^2 Delta) w = f 
    ! fv(m) = -f(i1,i2,i3,0)*coswt  

    fv(m)=0.
    do freq=0,numberOfFrequencies-1 
      omega = frequencyArray(freq)
      coswt = cosFreqt(freq)    
      #If #ORDERINTIME eq "2"
       ! if( i1.eq.2 .and. i2.eq.2 )then 
       !   write(*,'(" adv: forcing f(i1,i2,i3)=",1pe12.4," coswt=",1pe12.4," t=",1pe12.4," omega=",1pe12.4)') f(i1,i2,i3,0),coswt,t,omega
       ! end if

       ! fv(m) = -f(i1,i2,i3,0)*coswt  

       fv(m) = fv(m) - f(i1,i2,i3,freq)*coswt

      #Else
        ! Add corrections for 4th order modified equation 
        !  fv = f + (dt^2/12)*( c^2 Delta(u) + ftt )
        write(*,*) 'fix me'
        stop 4444
        #If #GRIDTYPE eq "rectangular"
          #If #DIM eq "2"
            !fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22r(i1,i2,i3,freq) + fyy22r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #Else
            !fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23r(i1,i2,i3,freq) + fyy23r(i1,i2,i3,freq) + fzz23r(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #End
        #Else
          #If #DIM eq "2"
            !fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx22(i1,i2,i3,freq) + fyy22(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #Else
            !fv(m) = fv(m) -( f(i1,i2,i3,freq) + cdtSqBy12*( cSq*(fxx23(i1,i2,i3,freq) + fyy23(i1,i2,i3,freq) + fzz23(i1,i2,i3,freq)) - omega*omega*f(i1,i2,i3,freq)) )*coswt 
          #End
        #End           
      #End
    end do ! do freq  
 else if( addForcing.ne.0 )then  
    fv(m) = f(i1,i2,i3,0)
 end if


#endMacro


! =========================================================================
! Compute errors in the derivatives and save the derivatives and errors
! =========================================================================
! #beginMacro computeErrors()
!   if( nd.eq.2 )then
!     call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uex  )
!     call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uey )
!     call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexx )
!     call ogDeriv(ep,0,1,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexy )
!     call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyy )
!   else
!     call ogDeriv(ep,0,1,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uex  )
!     call ogDeriv(ep,0,0,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uey  )
!     call ogDeriv(ep,0,2,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,uexx )
!     call ogDeriv(ep,0,0,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),xy(i1,i2,i3,2),t,uc,ueyy )
!   end if  

!   if( i1.eq.4 .and. i2.eq.6 )then  
!     write(*,'("hier: (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uxx,uexx,abs(uxx-uexx),uyy,abs(uyy-ueyy)
!   end if

!   maxErr(1) = max( maxErr(1),abs(ux-uex), abs(uy-uey) )
!   maxSol(1) = max( maxSol(1),abs(uex),abs(uey))

!   l2Err(1) = l2Err(1) + (ux-uex)**2 + (uy-uey)**2

!   maxErr(2) = max( maxErr(2),abs(uxx-uexx),abs(uyy-ueyy) ) 
!   maxErr(2) = max( maxErr(2),abs(uxy-uexy) )
!   maxSol(2) = max( maxSol(2),abs(uexx),abs(ueyy) )

!   l2Err(2) = l2Err(2) + (uxx-uexx)**2 + (uxy-uexy)**2 + (uyy-ueyy)**2

!   if( max( abs(uxx-uexx),abs(uyy-ueyy) )/maxSol(2) .gt. 1.e-3 )then
!     write(*,'("**hier: (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uxx,uexx,abs(uxx-uexx),uyy,abs(uyy-ueyy)
!   end if

!  ! Fill in the derivatives and errors:
!   d=0; 
!   ud(i1,i2,i3,d)=ux; ude(i1,i2,i3,d)=ux-uex; d=d+1;
!   ud(i1,i2,i3,d)=ux; ude(i1,i2,i3,d)=uy-uey; d=d+1;
!   if( maxDeriv.ge.2 )then
!     ud(i1,i2,i3,d)=uxx; ude(i1,i2,i3,d)=uxx-uexx; d=d+1;
!     ud(i1,i2,i3,d)=uxy; ude(i1,i2,i3,d)=uxy-uexy; d=d+1;
!     ud(i1,i2,i3,d)=uyy; ude(i1,i2,i3,d)=uyy-ueyy; d=d+1;
!   end if      

!   if( maxDeriv.ge.3 )then
!     if( nd.eq.2 )then
!       call ogDeriv(ep,0,3,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxx  )
!       call ogDeriv(ep,0,0,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyy )
!       call ogDeriv(ep,0,2,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxy )
!       call ogDeriv(ep,0,1,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyy )
!     else
!       stop 3333
!     end if  
!     ! if( debug.gt.3 )then  
!     !   write(*,'(" (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uxx,uexx,abs(uxx-uexx),uyy,abs(uyy-ueyy)
!     ! end if
!     maxErr(3) = max( maxErr(3),abs(uxxx-uexxx), abs(uyyy-ueyyy) )
!     maxErr(3) = max( maxErr(3),abs(uxxy-uexxy), abs(uxyy-uexyy) )
!     maxSol(3) = max( maxSol(3),abs(uexxx),abs(uexxy),abs(uexyy),abs(ueyyy) )

!     ud(i1,i2,i3,d)=uxxx; ude(i1,i2,i3,d)=uxxx-uexxx; d=d+1;
!     ud(i1,i2,i3,d)=uxxy; ude(i1,i2,i3,d)=uxxy-uexxy; d=d+1;
!     ud(i1,i2,i3,d)=uxyy; ude(i1,i2,i3,d)=uxyy-uexyy; d=d+1;        
!     ud(i1,i2,i3,d)=uyyy; ude(i1,i2,i3,d)=uyyy-ueyyy; d=d+1; 

!     l2Err(3) = l2Err(3) + (uxxx-uexxx)**2 + (uxxy-uexxy)**2 + (uxyy-uexyy)**2 + (uyyy-ueyyy)**2

!   end if    

!   if( maxDeriv.ge.4 )then

!     if( nd.eq.2 )then
!       call ogDeriv(ep,0,4,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxx  )
!       call ogDeriv(ep,0,3,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxy )
!       call ogDeriv(ep,0,2,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyy )
!       call ogDeriv(ep,0,1,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyyy )
!       call ogDeriv(ep,0,0,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyy )
!     else
!       stop 3333
!     end if  
!     ! if( debug.gt.3 )then  
!     !   write(*,'(" (i1,i2)=(",2i3,") uxx=",1pe12.4," uexx=",1pe12.4," err=",1pe8.2," uyy=",1pe12.4," err=",1pe8.2)') i1,i2,uxx,uexx,abs(uxx-uexx),uyy,abs(uyy-ueyy)
!     ! end if
!     maxErr(4) = max( maxErr(4),abs(uxxxx-uexxxx), abs(uyyyy-ueyyyy) )
!     maxErr(4) = max( maxErr(4),abs(uxxyy-uexxyy) )
!     maxErr(4) = max( maxErr(4),abs(uxyyy-uexyyy) )
!     maxErr(4) = max( maxErr(4),abs(uxxxy-uexxxy) )
!     maxSol(4) = max( maxSol(4),abs(uexxxx),abs(uexxyy),abs(ueyyyy) )

!     ud(i1,i2,i3,d)=uxxxx; ude(i1,i2,i3,d)=uxxxx-uexxxx; d=d+1;
!     ud(i1,i2,i3,d)=uxxxy; ude(i1,i2,i3,d)=uxxxy-uexxxy; d=d+1;
!     ud(i1,i2,i3,d)=uxxyy; ude(i1,i2,i3,d)=uxxyy-uexxyy; d=d+1;        
!     ud(i1,i2,i3,d)=uxyyy; ude(i1,i2,i3,d)=uxyyy-uexyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uyyyy; ude(i1,i2,i3,d)=uyyyy-ueyyyy; d=d+1; 

!    l2Err(4) = l2Err(4) + (uxxxx-uexxxx)**2 + (uxxxy-uexxxy)**2 + (uxxyy-uexxyy)**2 + (uxyyy-uexyyy)**2 + (uyyyy-ueyyyy)**2


!   end if 

!   if( maxDeriv.ge.5 )then
!     if( nd.eq.2 )then
!       call ogDeriv(ep,0,5,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxx  )
!       call ogDeriv(ep,0,0,5,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyy )
!       call ogDeriv(ep,0,4,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxy )
!       call ogDeriv(ep,0,3,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxyy )
!       call ogDeriv(ep,0,2,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyy )
!       call ogDeriv(ep,0,1,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyyyy )
!     else
!       stop 3333
!     end if  
!     maxErr(5) = max( maxErr(5),abs(uxxxxx-uexxxxx ), abs(uyyyyy-ueyyyyy) )
!     maxErr(5) = max( maxErr(5),abs(uxxxxy-uexxxxy ), abs(uxxxyy-uexxxyy) )
!     maxErr(5) = max( maxErr(5),abs(uxxyyy-uexxyyy ), abs(uxyyyy-uexyyyy) )
!     maxSol(5) = max( maxSol(5),abs(uexxxxx),abs(uexxxxy),abs(uexxxyy),abs(uexxyyy),abs(uexyyyy),abs(ueyyyyy) )

!     ud(i1,i2,i3,d)=uxxxx; ude(i1,i2,i3,d)=uxxxx-uexxxx; d=d+1;
!     ud(i1,i2,i3,d)=uxxxy; ude(i1,i2,i3,d)=uxxxy-uexxxy; d=d+1;
!     ud(i1,i2,i3,d)=uxxyy; ude(i1,i2,i3,d)=uxxyy-uexxyy; d=d+1;        
!     ud(i1,i2,i3,d)=uxyyy; ude(i1,i2,i3,d)=uxyyy-uexyyy; d=d+1;   
!     ud(i1,i2,i3,d)=uyyyy; ude(i1,i2,i3,d)=uyyyy-ueyyyy; d=d+1;   

!     l2Err(5) = l2Err(5) + (uxxxxx-uexxxxx)**2 + (uxxxxy-uexxxxy)**2 + (uxxxyy-uexxxyy)**2 + (uxxyyy-uexxyyy)**2 + (uxyyyy-uexyyyy)**2 + (uyyyyy-ueyyyyy)**2

!   end if 

!   if( maxDeriv.ge.6)then
!     if( nd.eq.2 )then
!       call ogDeriv(ep,0,6,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxx  )
!       call ogDeriv(ep,0,5,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxy )
!       call ogDeriv(ep,0,4,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxyy )
!       call ogDeriv(ep,0,3,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxyyy )
!       call ogDeriv(ep,0,2,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyyy )
!       call ogDeriv(ep,0,1,5,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyyyyy )
!       call ogDeriv(ep,0,0,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyyy )
!     else
!       stop 3333
!     end if  
!     if( i1.eq.5 .and. i2.eq.6 )then  
!       write(*,'(" (i1,i2)=(",2i3,") uxxxxxx=",1pe12.4," uexxxxxx=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxxx,uexxxxxx,abs(uxxxxxx-uexxxxxx)/max(1.,abs(uexxxxxx))
!       write(*,'(" (i1,i2)=(",2i3,") uxxxxxy=",1pe12.4," uexxxxxy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxxy,uexxxxxy,abs(uxxxxxy-uexxxxxy)/max(1.,abs(uexxxxxy))
!       write(*,'(" (i1,i2)=(",2i3,") uxxxxyy=",1pe12.4," uexxxxyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxyy,uexxxxyy,abs(uxxxxyy-uexxxxyy)/max(1.,abs(uexxxxyy))
!       write(*,'(" (i1,i2)=(",2i3,") uxxxyyy=",1pe12.4," uexxxyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxyyy,uexxxyyy,abs(uxxxyyy-uexxxyyy)/max(1.,abs(uexxxyyy))
!       write(*,'(" (i1,i2)=(",2i3,") uxxyyyy=",1pe12.4," uexxyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxyyyy,uexxyyyy,abs(uxxyyyy-uexxyyyy)/max(1.,abs(uexxyyyy))
!       write(*,'(" (i1,i2)=(",2i3,") uxyyyyy=",1pe12.4," uexyyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxyyyyy,uexyyyyy,abs(uxyyyyy-uexyyyyy)/max(1.,abs(uexyyyyy))
!       write(*,'(" (i1,i2)=(",2i3,") uyyyyyy=",1pe12.4," ueyyyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uyyyyyy,ueyyyyyy,abs(uyyyyyy-ueyyyyyy)/max(1.,abs(ueyyyyyy))
!     end if
!     maxErr(6) = max( maxErr(6),abs(uxxxxxx-uexxxxxx) )
!     maxErr(6) = max( maxErr(6),abs(uxxxxxy-uexxxxxy) )
!     maxErr(6) = max( maxErr(6),abs(uxxxxyy-uexxxxyy) )
!     maxErr(6) = max( maxErr(6),abs(uxxxyyy-uexxxyyy) )
!     maxErr(6) = max( maxErr(6),abs(uxxyyyy-uexxyyyy) )
!     maxErr(6) = max( maxErr(6),abs(uxyyyyy-uexyyyyy) )
!     maxErr(6) = max( maxErr(6),abs(uyyyyyy-ueyyyyyy) )
!     maxSol(6) = max( maxSol(6),abs(uexxxxxx),abs(uexxxxxy),abs(uexxxxyy),abs(uexxxyyy),abs(uexxyyyy),abs(uexyyyyy),abs(ueyyyyyy) )

!     ud(i1,i2,i3,d)=uxxxxx; ude(i1,i2,i3,d)=uxxxxx-uexxxxx; d=d+1;
!     ud(i1,i2,i3,d)=uxxxxy; ude(i1,i2,i3,d)=uxxxxy-uexxxxy; d=d+1;
!     ud(i1,i2,i3,d)=uxxxyy; ude(i1,i2,i3,d)=uxxxyy-uexxxyy; d=d+1;        
!     ud(i1,i2,i3,d)=uxxyyy; ude(i1,i2,i3,d)=uxxyyy-uexxyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uxyyyy; ude(i1,i2,i3,d)=uxyyyy-uexyyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uyyyyy; ude(i1,i2,i3,d)=uyyyyy-ueyyyyy; d=d+1; 

!     l2Err(6) = l2Err(6) + (uxxxxxx-uexxxxxx)**2 + (uxxxxxy-uexxxxxy)**2 + (uxxxxyy-uexxxxyy)**2 + (uxxxyyy-uexxxyyy)**2 + (uxxyyyy-uexxyyyy)**2 +\
!                           (uxyyyyy-uexyyyyy)**2 + (uyyyyyy-ueyyyyyy)**2

!   end if

!   if( maxDeriv.ge.7 )then
!     if( nd.eq.2 )then
!       call ogDeriv(ep,0,7,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxxx )
!       call ogDeriv(ep,0,6,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxxy )
!       call ogDeriv(ep,0,5,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxyy )
!       call ogDeriv(ep,0,4,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxyyy )
!       call ogDeriv(ep,0,3,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxyyyy )
!       call ogDeriv(ep,0,2,5,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyyyy )
!       call ogDeriv(ep,0,1,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyyyyyy )
!       call ogDeriv(ep,0,0,7,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyyyy )
!     else
!       stop 3333
!     end if  
!     if( i1.eq.5 .and. i2.eq.6 )then  
!       write(*,'(" (i1,i2)=(",2i3,") uxxxxxxx=",1pe12.4," uexxxxxxx=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxxxx,uexxxxxxx,abs(uxxxxxxx-uexxxxxxx)/max(1.,abs(uexxxxxxx))
!     end if        
!     maxErr(7) = max( maxErr(7),abs(uxxxxxxx-uexxxxxxx  ) )
!     maxErr(7) = max( maxErr(7),abs(uxxxxxxy-uexxxxxxy  ) )
!     maxErr(7) = max( maxErr(7),abs(uxxxxxyy-uexxxxxyy  ) )
!     maxErr(7) = max( maxErr(7),abs(uxxxxyyy-uexxxxyyy  ) )
!     maxErr(7) = max( maxErr(7),abs(uxxxyyyy-uexxxyyyy  ) )
!     maxErr(7) = max( maxErr(7),abs(uxxyyyyy-uexxyyyyy  ) )
!     maxErr(7) = max( maxErr(7),abs(uxyyyyyy-uexyyyyyy  ) )
!     maxErr(7) = max( maxErr(7),abs(uyyyyyyy-ueyyyyyyy  ) )
!     maxSol(7) = max( maxSol(7),abs(uexxxxxxx),abs(uexxxxxxy),abs(uexxxxxyy),abs(uexxxxyyy),abs(uexxxyyyy),abs(uexxyyyyy),abs(uexyyyyyy),abs(ueyyyyyyy) )

!     ud(i1,i2,i3,d)=uxxxxxx; ude(i1,i2,i3,d)=uxxxxxx-uexxxxxx; d=d+1;
!     ud(i1,i2,i3,d)=uxxxxxy; ude(i1,i2,i3,d)=uxxxxxy-uexxxxxy; d=d+1;
!     ud(i1,i2,i3,d)=uxxxxyy; ude(i1,i2,i3,d)=uxxxxyy-uexxxxyy; d=d+1;        
!     ud(i1,i2,i3,d)=uxxxyyy; ude(i1,i2,i3,d)=uxxxyyy-uexxxyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uxxyyyy; ude(i1,i2,i3,d)=uxxyyyy-uexxyyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uxyyyyy; ude(i1,i2,i3,d)=uxyyyyy-uexyyyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uyyyyyy; ude(i1,i2,i3,d)=uyyyyyy-ueyyyyyy; d=d+1; 

!     l2Err(7) = l2Err(7) + (uxxxxxxx-uexxxxxxx)**2 + (uxxxxxxy-uexxxxxxy)**2 + (uxxxxxyy-uexxxxxyy)**2 + (uxxxxyyy-uexxxxyyy)**2 + (uxxxyyyy-uexxxyyyy)**2+\
!                           (uxxyyyyy-uexxyyyyy)**2 + (uxyyyyyy-uexyyyyyy)**2 + (uyyyyyyy-ueyyyyyyy)**2    

!   end if

!   if( maxDeriv.ge.8 )then
!     if( nd.eq.2 )then
!       call ogDeriv(ep,0,8,0,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxxxx )
!       call ogDeriv(ep,0,7,1,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxxxy )
!       call ogDeriv(ep,0,6,2,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxxyy )
!       call ogDeriv(ep,0,5,3,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxxyyy )
!       call ogDeriv(ep,0,4,4,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxxyyyy )
!       call ogDeriv(ep,0,3,5,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxxyyyyy )
!       call ogDeriv(ep,0,2,6,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexxyyyyyy )
!       call ogDeriv(ep,0,1,7,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,uexyyyyyyy )
!       call ogDeriv(ep,0,0,8,0,xy(i1,i2,i3,0),xy(i1,i2,i3,1),0.,t,uc,ueyyyyyyyy )
!     else
!       stop 3333
!     end if  
!     if( i1.eq.5 .and. i2.eq.6 )then  
!       write(*,'("D8 (i1,i2)=(",2i3,") uxxxxxxxx=",1pe12.4," uexxxxxxxx=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxxxxx,uexxxxxxxx,abs(uxxxxxxxx-uexxxxxxxx)/max(1.,abs(uexxxxxxxx))
!       write(*,'("D8 (i1,i2)=(",2i3,") uxxxxxxxy=",1pe12.4," uexxxxxxxy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxxxxy,uexxxxxxxy,abs(uxxxxxxxy-uexxxxxxxy)/max(1.,abs(uexxxxxxxy))
!       write(*,'("D8 (i1,i2)=(",2i3,") uxxxxxxyy=",1pe12.4," uexxxxxxyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxxxyy,uexxxxxxyy,abs(uxxxxxxyy-uexxxxxxyy)/max(1.,abs(uexxxxxxyy))
!       write(*,'("D8 (i1,i2)=(",2i3,") uxxxxxyyy=",1pe12.4," uexxxxxyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxxyyy,uexxxxxyyy,abs(uxxxxxyyy-uexxxxxyyy)/max(1.,abs(uexxxxxyyy))
!       write(*,'("D8 (i1,i2)=(",2i3,") uxxxxyyyy=",1pe12.4," uexxxxyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxxyyyy,uexxxxyyyy,abs(uxxxxyyyy-uexxxxyyyy)/max(1.,abs(uexxxxyyyy))
!       write(*,'("D8 (i1,i2)=(",2i3,") uxxxyyyyy=",1pe12.4," uexxxyyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxxyyyyy,uexxxyyyyy,abs(uxxxyyyyy-uexxxyyyyy)/max(1.,abs(uexxxyyyyy))
!       write(*,'("D8 (i1,i2)=(",2i3,") uxxyyyyyy=",1pe12.4," uexxyyyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxxyyyyyy,uexxyyyyyy,abs(uxxyyyyyy-uexxyyyyyy)/max(1.,abs(uexxyyyyyy))
!       write(*,'("D8 (i1,i2)=(",2i3,") uxyyyyyyy=",1pe12.4," uexyyyyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uxyyyyyyy,uexyyyyyyy,abs(uxyyyyyyy-uexyyyyyyy)/max(1.,abs(uexyyyyyyy))
!       write(*,'("D8 (i1,i2)=(",2i3,") uyyyyyyyy=",1pe12.4," ueyyyyyyyy=",1pe12.4," rel-err=",1pe8.2)') i1,i2,uyyyyyyyy,ueyyyyyyyy,abs(uyyyyyyyy-ueyyyyyyyy)/max(1.,abs(ueyyyyyyyy))
!     end if

!     maxErr(8) = max( maxErr(8),abs(uxxxxxxxx-uexxxxxxxx  ) )
!     maxErr(8) = max( maxErr(8),abs(uxxxxxxxy-uexxxxxxxy  ) )
!     maxErr(8) = max( maxErr(8),abs(uxxxxxxyy-uexxxxxxyy  ) )
!     maxErr(8) = max( maxErr(8),abs(uxxxxxyyy-uexxxxxyyy  ) )
!     maxErr(8) = max( maxErr(8),abs(uxxxxyyyy-uexxxxyyyy  ) )
!     maxErr(8) = max( maxErr(8),abs(uxxxyyyyy-uexxxyyyyy  ) )
!     maxErr(8) = max( maxErr(8),abs(uxxyyyyyy-uexxyyyyyy  ) )
!     maxErr(8) = max( maxErr(8),abs(uxyyyyyyy-uexyyyyyyy  ) )
!     maxErr(8) = max( maxErr(8),abs(uyyyyyyyy-ueyyyyyyyy  ) )
!     maxSol(8) = max( maxSol(8),abs(uexxxxxxxx),abs(uexxxxxxxy),abs(uexxxxxxyy),abs(uexxxxxyyy),abs(uexxxxyyyy),abs(uexxxyyyyy),abs(uexxyyyyyy),abs(uexyyyyyyy),abs(ueyyyyyyyy) )

!     ud(i1,i2,i3,d)=uxxxxxxx; ude(i1,i2,i3,d)=uxxxxxxx-uexxxxxxx; d=d+1;
!     ud(i1,i2,i3,d)=uxxxxxxy; ude(i1,i2,i3,d)=uxxxxxxy-uexxxxxxy; d=d+1;
!     ud(i1,i2,i3,d)=uxxxxxyy; ude(i1,i2,i3,d)=uxxxxxyy-uexxxxxyy; d=d+1;        
!     ud(i1,i2,i3,d)=uxxxxyyy; ude(i1,i2,i3,d)=uxxxxyyy-uexxxxyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uxxxyyyy; ude(i1,i2,i3,d)=uxxxyyyy-uexxxyyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uxxyyyyy; ude(i1,i2,i3,d)=uxxyyyyy-uexxyyyyy; d=d+1; 
!     ud(i1,i2,i3,d)=uxyyyyyy; ude(i1,i2,i3,d)=uxyyyyyy-uexyyyyyy; d=d+1;         
!     ud(i1,i2,i3,d)=uyyyyyyy; ude(i1,i2,i3,d)=uyyyyyyy-ueyyyyyyy; d=d+1;   

!     l2Err(8) = l2Err(8) + (uxxxxxxxx-uexxxxxxxx)**2 + (uxxxxxxxy-uexxxxxxxy)**2 + (uxxxxxxyy-uexxxxxxyy)**2 + (uxxxxxyyy-uexxxxxyyy)**2 + (uxxxxyyyy-uexxxxyyyy)**2+\
!                           (uxxxyyyyy-uexxxyyyyy)**2 + (uxxyyyyyy-uexxyyyyyy)**2 + (uxyyyyyyy-uexyyyyyyy)**2 + (uyyyyyyyy-ueyyyyyyyy)**2             
!   end if  

!   count = count + 1                  
! #endMacro



! --------- include macros ORDER=2 --------
#Include "../maple/declare2dOrder2Rectangular.h"
#Include "../maple/update2dOrder2Rectangular.h"

#Include "../maple/declare2dOrder2Curvilinear.h"
#Include "../maple/update2dOrder2Curvilinear.h"

#Include "../maple/declare3dOrder2Rectangular.h"
#Include "../maple/update3dOrder2Rectangular.h"

#Include "../maple/declare3dOrder2Curvilinear.h"
#Include "../maple/update3dOrder2Curvilinear.h"


! --------- include macros ORDER=4 --------
! #Include "../maple/declare2dOrder4Rectangular.h"
! #Include "../maple/update2dOrder4Rectangular.h"

#Include "../maple/declare2dOrder4RectangularV1.h"
#Include "../maple/update2dOrder4RectangularV1.h"

#Include "../maple/declare2dOrder4Curvilinear.h"
#Include "../maple/update2dOrder4Curvilinear.h"

! #Include "../maple/declare3dOrder4Rectangular.h"
! #Include "../maple/update3dOrder4Rectangular.h"
#Include "../maple/declare3dOrder4RectangularV1.h"
#Include "../maple/update3dOrder4RectangularV1.h"

#Include "../maple/declare3dOrder4Curvilinear.h"
#Include "../maple/update3dOrder4Curvilinear.h"


! --------- include macros ORDER=6 --------
! #Include "../maple/declare2dOrder6Rectangular.h"
! #Include "../maple/update2dOrder6Rectangular.h"

#Include "../maple/declare2dOrder6RectangularV1.h"
#Include "../maple/update2dOrder6RectangularV1.h"

#Include "../maple/declare2dOrder6Curvilinear.h"
#Include "../maple/update2dOrder6Curvilinear.h"

#Include "../maple/declare3dOrder6RectangularV1.h"
#Include "../maple/update3dOrder6RectangularV1.h"

#Include "../maple/declare3dOrder6Curvilinear.h"
#Include "../maple/update3dOrder6Curvilinear.h"

! --------- include macros ORDER=8 --------
#Include "../maple/declare2dOrder8RectangularV1.h"
#Include "../maple/update2dOrder8RectangularV1.h"

#Include "../maple/declare2dOrder8Curvilinear.h"
#Include "../maple/update2dOrder8Curvilinear.h"

#Include "../maple/declare3dOrder8RectangularV1.h"
#Include "../maple/update3dOrder8RectangularV1.h"

#Include "../maple/declare3dOrder8Curvilinear.h"
#Include "../maple/update3dOrder8Curvilinear.h"


! =========================================================================================
!
! Macro: Advance the wave equation, EXPLICIT TIME-STEPPING
!
!   DIM : dimension : 2 or 3
!   ORDER : 2 or 4   
!   ORDERINTIME : 2 or 4 
!   GRIDTYPE : rectangular or curvilinear
! ========================================================================================
#beginMacro updateWaveOpt(DIM,ORDER,ORDERINTIME,GRIDTYPE)

  if( ( .true. .or. debug.gt.3) .and. t.lt.2*dt )then
    write(*,'("advWaveME: ADVANCE dim=DIM order=ORDER orderInTime=ORDERINTIME, grid=GRIDTYPE... t=",e10.2)') t
  end if

  m=0 ! component number 
  ec = 0 ! component number 

  ! -- call the appropriate macro:
  !  update2dOrder2Rectangular(DIM,ORDER,ORDERINTIME,GRIDTYPE)
  !  update3dOrder6Curvilinear(DIM,ORDER,ORDERINTIME,GRIDTYPE)

  if( useMask.eq.0 .and. addForcing.eq.0 )then
    ! No-mask, no-forcing
    #If #GRIDTYPE eq "rectangular"
      update ## DIM ## dOrder ## ORDER ## Rectangular(DIM,ORDER,ORDERINTIME,GRIDTYPE,NOMASK,NOFORCING)
    #Else
      update ## DIM ## dOrder ## ORDER ## Curvilinear(DIM,ORDER,ORDERINTIME,GRIDTYPE,NOMASK,NOFORCING)
    #End
  else
    #If #GRIDTYPE eq "rectangular"
      update ## DIM ## dOrder ## ORDER ## Rectangular(DIM,ORDER,ORDERINTIME,GRIDTYPE,USEMASK,USEFORCING)
    #Else
      update ## DIM ## dOrder ## ORDER ## Curvilinear(DIM,ORDER,ORDERINTIME,GRIDTYPE,USEMASK,USEFORCING)
    #End    
  end if


#endMacro




! Argument list
#defineMacro ARGLIST() nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
                       mask,xy,rsxy,  um,u,un, f,fa, v, vh, lapCoeff, bc, frequencyArray, ipar, rpar, ierr

! **********************************************************************************
! Macro ADV_WAVE:
!  NAME: name of the subroutine
!  DIM : 2 or 3
!  ORDER : 2 ,4, 6 or 8
!  GRIDTYPE : rectangular, curvilinear
! **********************************************************************************
#beginMacro ADV_WAVE(NAME,DIM,ORDER,GRIDTYPE)
 subroutine NAME( ARGLIST() )
 ! subroutine NAME(nd,n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b,\
 !                 mask,xy,rsxy,  um,u,un, f,fa, v, vh,  bc, frequencyArray, ipar, rpar, ierr )
!======================================================================
!   Advance a time step for Waves equations
!
! nd : number of space dimensions
! um,u,un : u(t-dt), u(t), u(t+dt)
!
! ipar(0)  = option : option=0 - advance wave equation
!                           =1 - add upwind dissipation (predictor corrector mode)
!
!======================================================================
 implicit none
 integer nd, n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

 real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real fa(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b,0:*)  ! forcings at different times

 real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1) 
 real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
 real vh(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)  ! holds current Helmholtz solutions
 real lapCoeff(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)  ! holds coeff of Laplacian for HA scheme

 real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)

 integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
 integer bc(0:1,0:2),ierr
 integer gridIndexRange(0:1,0:2)

 real frequencyArray(0:*)

 integer ipar(0:*)
 real rpar(0:*)
      
!     ---- local variables -----
 integer m1a,m1b,m2a,m2b,m3a,m3b,numGhost,nStart,nEnd,mt,ig,useMask

 integer c,i1,i2,i3,n,gridType,orderOfAccuracy,orderInTime,axis,dir,grid,freq
 integer addForcing,orderOfDissipation,option,gridIsImplicit,preComputeUpwindUt
 integer useNewForcingMethod,numberOfForcingFunctions,fcur,fnext,fprev,numberOfFrequencies
 real t,tm,cc,dt,dy,dz,cdt,cdtdx,cdtdy,cdtdz
 ! ,adc,adcdt,add,adddt
 real dt4by12
 ! logical addDissipation
 integer debug
 integer adjustHelmholtzForUpwinding

 real dx(0:2),dr(0:2)

 ! real dx2i,dy2i,dz2i,dxsqi,dysqi,dzsqi,dxi,dyi,dzi
 ! real dx12i,dy12i,dz12i,dxsq12i,dysq12i,dzsq12i,dxy4i,dxz4i,dyz4,time0,time1

 ! real dxi4,dyi4,dzi4,dxdyi2,dxdzi2,dydzi2

 real c0,c1,csq,dtsq,cdtsq,cdtsq12,cdtSqBy12

 integer maxOrderOfAccuracy
 parameter( maxOrderOfAccuracy=12 )
 ! Coefficients in the implicit scheme
 real bImp(0:maxOrderOfAccuracy-1)
 real cImp(-1:1,0:maxOrderOfAccuracy-1)
 real alpha2,alpha4,alpha6,alpha8, beta2,beta4,beta6,beta8

 integer rectangular,curvilinear
 parameter( rectangular=0, curvilinear=1 )

 integer timeSteppingMethod
 integer defaultTimeStepping,adamsSymmetricOrder3,rungeKuttaFourthOrder,\
         stoermerTimeStepping,modifiedEquationTimeStepping
 parameter(defaultTimeStepping=0,adamsSymmetricOrder3=1,\
           rungeKuttaFourthOrder=2,stoermerTimeStepping=3,modifiedEquationTimeStepping=4)

!...........start statement function
 integer kd,m
 ! real rx,ry,rz,sx,sy,sz,tx,ty,tz


 real cdtPow2,cdtPow4By12,cdtPow6By360,cdtPow8By20160
 real ff

 ! real cdSosupx,cdSosupy,cdSosupz
 real adSosup,sosupParameter, uDotFactor, adxSosup(0:2)
 integer useSosupDissipation,sosupDissipationOption
 integer updateSolution,updateDissipation,computeUt

 integer ec 
 real ep 
 real fv(0:1) , ev(0:1), evtt(0:1), evxx(0:1), evyy(0:1), evzz(0:1)
 real evxxxx(0:1), evxxyy(0:1), evyyyy(0:1), evxxzz(0:1), evyyzz(0:1), evzzzz(0:1), evtttt(0:1)
 real evtttttt(0:1)
 real evxxxxxx(0:1)
 real evyyyyyy(0:1)
 real evzzzzzz(0:1)       
 real evxxyyyy(0:1)
 real evxxxxyy(0:1)
 real evxxxxzz(0:1)
 real evxxzzzz(0:1)
 real evyyyyzz(0:1)
 real evyyzzzz(0:1)
 real evxxyyzz(0:1)

 real omega, coswt

 integer maxFreq
 parameter( maxFreq=500 )
 real cosFreqt(0:maxFreq), coswtAve(0:maxFreq), cosineFactor(0:maxFreq)

 integer idv(0:2),j1,j2,j3
 integer iStencil,upwCase,upwindHalfStencilWidth,i1l,i2l,i3l, i1r,i2r,i3r
 integer useUpwindDissipation,useImplicitUpwindDissipation,adjustOmega,solveHelmholtz
 real upw,maxDiff,umj
 ! real upwindCoeff(-3:3,0:3) 
 
 integer forcingOption
 ! forcingOptions -- these should match ForcingEnum in CgWave.h 
 ! enum ForcingOptionEnum
 ! {
 !   noForcing=0,
 !   twilightZoneForcing,
 !   userForcing,
 !   helmholtzForcing
 ! };
 integer noForcing,twilightZoneForcing,userForcing,helmholtzForcing
 parameter(noForcing           =0,\
           twilightZoneForcing =1,\
           userForcing         =2,\
           helmholtzForcing    =3 )


  real maxErr(1:30), l2Err(1:30)
  real maxSol(30)

  real ue
  real uet8 
  real uex8 
  real uey8 
  real uez8 
  real uex6y2
  real uex4y4
  real uex2y6
  real uex6z2
  real uex4z4
  real uex2z6
  real uey6z2
  real uey4z4
  real uey2z6
  real uex4y2z2
  real uex2y4z2
  real uex2y2z4


  #If #GRIDTYPE eq "rectangular"  
    declare ## DIM ## dOrder ## ORDER ## Rectangular()
  #Else
    declare ## DIM ## dOrder ## ORDER ## Curvilinear()
  #End 



  integer maxDeriv,d,uc,count,numGhost1,m1,m2,m3

! declare coefficients in the chain rule for curvilinear grids (from cgwave/maple/chainRuleCoefficients.mw)
! #If #GRIDTYPE eq "curvilinear"
!   #If DIM == 2
!     #Include "../maple/declareChainRuleCoefficients2d.h"
!   #Else
!     #Include "../maple/declareChainRuleCoefficients3d.h"
!   #End
! #End



 ! statement functions for coefficients
 ! real c200,c020,c002, c110, c101, c011, c100, c010, cux001
 ! #If DIM == 2
 !   c200(i1,i2,i3) = lapCoeff(i1,i2,i3,0)
 !   c020(i1,i2,i3) = lapCoeff(i1,i2,i3,1)
 !   c110(i1,i2,i3) = lapCoeff(i1,i2,i3,2)
 !   c100(i1,i2,i3) = lapCoeff(i1,i2,i3,3)
 !   c010(i1,i2,i3) = lapCoeff(i1,i2,i3,4)
 ! #Else
 !   c200(i1,i2,i3) = lapCoeff(i1,i2,i3,0)
 !   c020(i1,i2,i3) = lapCoeff(i1,i2,i3,1)
 !   c002(i1,i2,i3) = lapCoeff(i1,i2,i3,2)
 !   c110(i1,i2,i3) = lapCoeff(i1,i2,i3,3)
 !   c101(i1,i2,i3) = lapCoeff(i1,i2,i3,4)
 !   c011(i1,i2,i3) = lapCoeff(i1,i2,i3,5)
 !   c100(i1,i2,i3) = lapCoeff(i1,i2,i3,6)
 !   c010(i1,i2,i3) = lapCoeff(i1,i2,i3,7)   
 !   c001(i1,i2,i3) = lapCoeff(i1,i2,i3,8)   
 ! #End


! OLD  #Include "derivativesByChainRuleCoefficients.h"

  !...........end   statement functions


  ! write(*,*) 'Inside advWaveME...'
 
  cc             = rpar( 0)  ! this is c
  dt             = rpar( 1)
  dx(0)          = rpar( 2)
  dx(1)          = rpar( 3)
  dx(2)          = rpar( 4)
  dr(0)          = rpar( 5)
  dr(1)          = rpar( 6)
  dr(2)          = rpar( 7)
  t              = rpar( 8)
  ep             = rpar( 9)
  sosupParameter = rpar(10)
  omega          = rpar(11) ! for helmholtz 
  bImp( 0)       = rpar(12) ! beta2 : coefficient for implicit time-stepping
  bImp( 1)       = rpar(13) ! beta4 : coefficient for implicit time-stepping
  bImp( 2)       = rpar(14) ! beta6 (for future)
  bImp( 3)       = rpar(15) ! beta8 (for future)
 
  dy=dx(1)  ! Are these needed?
  dz=dx(2)

 
  option                       = ipar( 0)
  grid                         = ipar( 1)
  gridType                     = ipar( 2)
  orderOfAccuracy              = ipar( 3)
  orderInTime                  = ipar( 4)
  addForcing                   = ipar( 5)
  forcingOption                = ipar( 6)
  numberOfForcingFunctions     = ipar( 7)
  fcur                         = ipar( 8) 
  debug                        = ipar( 9)
  gridIsImplicit               = ipar(10)
  useUpwindDissipation         = ipar(11)  ! explicit upwind dissipation
  useImplicitUpwindDissipation = ipar(12)  ! true if upwind-dissipation is on for impliciit time-stepping
  preComputeUpwindUt           = ipar(13)
  numberOfFrequencies          = ipar(14)
  adjustOmega                  = ipar(15)
  solveHelmholtz               = ipar(16)
  adjustHelmholtzForUpwinding  = ipar(17)

  fprev = mod(fcur-1+numberOfForcingFunctions,max(1,numberOfForcingFunctions))
  fnext = mod(fcur+1                         ,max(1,numberOfForcingFunctions))


  ! ** fix me ***
  timeSteppingMethod=modifiedEquationTimeStepping

  useMask=0  ! do this for now -- do not check mask in loops, these seems faster

  ! Set dr(:) = dx(:) for 6th-order derivatives
  if( gridType.eq.rectangular )then
    do axis=0,2
      dr(axis)=dx(axis)
    end do
  else
    do axis=0,2
      dx(axis)=dr(axis)
    end do
  end if  

  ! Do this for now: 
  maxDeriv=6
  uc=0

  gridIndexRange(0,0)=n1a
  gridIndexRange(1,0)=n1b
  gridIndexRange(0,1)=n2a
  gridIndexRange(1,1)=n2b
  gridIndexRange(0,2)=n3a
  gridIndexRange(1,2)=n3b    

  ! ---- Compute the coefficients in the implicit time-stepping scheme ----

  beta2=bImp(0)
  beta4=bImp(1)
  alpha2 = (1.-beta2)/2.
  alpha4 = (alpha2-beta4-1./12.)/2. 
  cImp(-1,0)=alpha2
  cImp( 0,0)= beta2
  cImp( 1,0)=alpha2
  cImp(-1,1)=alpha4
  cImp( 0,1)= beta4
  cImp( 1,1)=alpha4  
 
  ! ! addDissipation=.true. if we add the dissipation in the dis(i1,i2,i3,c) array
  ! !  if combineDissipationWithAdvance.ne.0 we compute the dissipation on the fly in the time step
  ! !  rather than pre-computing it in diss(i1,i2,i3,c)
  ! addDissipation = adc.gt.0.
  ! adcdt=adc*dt
 
  csq=cc**2
  dtsq=dt**2
  cdtsq=(cc**2)*(dt**2)
 
  cdt=cc*dt
 
  ! new: 

  cdtPow2        = cdt**2
  cdtPow4By12    = cdt**4/12.
  cdtPow6By360   = cdt**6/360. 
  cdtPow8By20160 = cdt**8/20160.  
 
  cdtsq12=cdtsq*cdtsq/12.  ! c^4 dt^4 /12 
  ! cdt4by360=(cdt)**4/360.  ! (c*dt)^4/360 
  ! cdt6by20160=cdt**6/(8.*7.*6.*5.*4.*3.)
 
  cdtSqBy12= cdtsq/12.   ! c^2*dt*2/12
 
  dt4by12=dtsq*dtsq/12.
 
  cdtdx = (cc*dt/dx(0))**2
  cdtdy = (cc*dt/dy)**2
  cdtdz = (cc*dt/dz)**2
 
  ! dxsqi=1./(dx(0)**2)
  ! dysqi=1./(dy**2)
  ! dzsqi=1./(dz**2)
 
  ! dxsq12i=1./(12.*dx(0)**2)
  ! dysq12i=1./(12.*dy**2)
  ! dzsq12i=1./(12.*dz**2)
 
  ! dxi4=1./(dx(0)**4)
  ! dyi4=1./(dy**4)
  ! dxdyi2=1./(dx(0)*dx(0)*dy*dy)
 
  ! dzi4=1./(dz**4)
  ! dxdzi2=1./(dx(0)*dx(0)*dz*dz)
  ! dydzi2=1./(dy*dy*dz*dz)
 
  if( option.eq.1 )then 
   useSosupDissipation = 1
  else
   useSosupDissipation = 0
  end if
 

  if( (.false. .or. debug.gt.1) .and. t.le.dt )then
    write(*,'("advWaveME: option=",i4," grid=",i4)') option,grid
    write(*,'("advWaveME: orderOfAccuracy=",i2," orderInTime=",i2  )') orderOfAccuracy,orderInTime
    write(*,'("advWaveME: addForcing=",i2," forcingOption=",i2)') addForcing,forcingOption
    write(*,'("advWaveME: useUpwindDissipation=",i2,"(explicit), useImplicitUpwindDissipation=",i2," (implicit)")') useUpwindDissipation,useImplicitUpwindDissipation
    write(*,'("advWaveME: useSosupDissipation=",i2,"(1= add upwind dissipation in this stage)")') useSosupDissipation
    write(*,'("advWaveME: t,dt,c,omega=",4e10.2)') t,dt,cc,omega 
    write(*,'("advWaveME: gridIsImplicit=",i2," adjustOmega=",i2," solveHelmholtz=",i2)') gridIsImplicit,adjustOmega,solveHelmholtz
    if( forcingOption.eq.helmholtzForcing )then
      write(*,'("advWaveME: numberOfFrequencies=",i2)') numberOfFrequencies
      write(*,'("advWaveME: frequencyArray=",(1pe12.4,1x))') (frequencyArray(freq),freq=0,numberOfFrequencies-1)
    end if
    if( gridIsImplicit.eq.1 )then
      write(*,'("  Implicit coeff: cImp(-1:1,0) = ",3(1pe10.2,1x), "(for 2nd-order)")') cImp(-1,0),cImp(0,0),cImp(1,0)
      write(*,'("  Implicit coeff: cImp(-1:1,1) = ",3(1pe10.2,1x), "(for 4th-order)")') cImp(-1,1),cImp(0,1),cImp(1,1)
    end if
  end if
 
  if( forcingOption.eq.helmholtzForcing )then
    ! --- solving the Helmholtz problem ---
    if( t.le.dt .and. debug.gt.1 )then
      write(*,'("advWaveME: numberOfFrequencies=",i6," omega=",1pe12.4," frequencyArray(0)=",1pe12.4)') numberOfFrequencies,omega,frequencyArray(0)
    end if
    if( numberOfFrequencies.le.0 )then
      write(*,'("advWaveME: ERROR: numberOfFrequencies=",i6," is <= 0")') numberOfFrequencies
      stop 0123
    end if

    if( numberOfFrequencies.eq.1  .and. frequencyArray(0) .ne. omega )then
      write(*,'("advWaveME: ERROR: frequencyArray(0)=",1pe12.4," is not equal to omega=",1pe12.4)') frequencyArray(0),omega
      stop 1234
    end if

    if( numberOfFrequencies.gt.maxFreq )then
      write(*,'("advWaveME: ERROR: numberOfFrequencies > maxFreq=",i6," .. FIX ME")') maxFreq
      stop 2345
    end if

    ! if( numberOfFrequencies.gt.1 .and. gridIsImplicit.eq.1 )then
    !   write(*,'("advWave: ERROR: numberOfFrequencies > 1 and implicit time-stepping : FINISH ME")') 
    !   stop 3456  
    ! end if
      
    do freq=0,numberOfFrequencies-1
      cosFreqt(freq) = cos(frequencyArray(freq)*t)
    end do

  end if


 


  ! write(*,'(" advWave: timeSteppingMethod=",i2)') timeSteppingMethod
  if( timeSteppingMethod.eq.defaultTimeStepping )then
   write(*,'(" advWaveME:ERROR: timeSteppingMethod=defaultTimeStepping -- this should be set")')
     ! '
   stop 83322
  end if




    
  if( gridIsImplicit.eq.0 )then 

    ! ------- EXPLIICT update the solution ---------

    #If (#ORDER eq "2") || (#ORDER eq "4") || (#ORDER eq "6")  || (#ORDER eq "8")  

      if( orderInTime.eq.2 )then
       ! FD24 : second-order in time and fourth-order in space
       ! FD26 : second-order in time and sixth-order in space
       updateWaveOpt(DIM,ORDER,2,GRIDTYPE)
      else
        updateWaveOpt(DIM,ORDER,ORDER,GRIDTYPE)
      end if 

    #Else
      write(*,*) 'Unexpected order=ORDER'
      stop 6868
      ! updateWaveOpt(DIM,ORDER,ORDER,GRIDTYPE)

    #End

  else

    ! --- IMPLICIT: Fill in RHS to implicit time-stepping -----

    stop 1111

  end if
 
 
  return
  end

#endMacro



! ==============================================
! ============== CONSTRUCT A FILE ==============
! ==============================================
#beginMacro buildFile(NAME,DIM,ORDER,GRIDTYPE)
#beginFile NAME.f90
 ADV_WAVE(NAME,DIM,ORDER,GRIDTYPE)
#endFile
#endMacro


! buildFile(advWaveME2dOrder2r,2,2,rectangular)
! buildFile(advWaveME3dOrder2r,3,2,rectangular)
! buildFile(advWaveME2dOrder2c,2,2,curvilinear)
! buildFile(advWaveME3dOrder2c,3,2,curvilinear)

! buildFile(advWaveME2dOrder4r,2,4,rectangular)
! buildFile(advWaveME3dOrder4r,3,4,rectangular)
! buildFile(advWaveME2dOrder4c,2,4,curvilinear)
! buildFile(advWaveME3dOrder4c,3,4,curvilinear)

! buildFile(advWaveME2dOrder6r,2,6,rectangular)
! buildFile(advWaveME3dOrder6r,3,6,rectangular)
! buildFile(advWaveME2dOrder6c,2,6,curvilinear)
! buildFile(advWaveME3dOrder6c,3,6,curvilinear)

! buildFile(advWaveME2dOrder8r,2,8,rectangular)
! buildFile(advWaveME3dOrder8r,3,8,rectangular)
! buildFile(advWaveME2dOrder8c,2,8,curvilinear)
buildFile(advWaveME3dOrder8c,3,8,curvilinear)



      subroutine advWaveME( ARGLIST() )
!======================================================================
!   Advance a time step for Maxwells eqution
!     OPTIMIZED version for rectangular grids.
! nd : number of space dimensions
!
! ipar(0)  = option : option=0 - Maxwell+Artificial diffusion
!                           =1 - AD only
!======================================================================
      implicit none
      integer nd, n1a,n1b,n2a,n2b,n3a,n3b,nd1a,nd1b,nd2a,nd2b,nd3a,nd3b,nd4a,nd4b

      real um(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real u(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real un(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real f(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real fa(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b,0:*)  ! forcings at different times
      real v(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)
      real vh(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,nd4a:nd4b)  ! holds current Helmholtz solutions
      real lapCoeff(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:*)  ! holds coeff of Laplacian for HA scheme

      real xy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1)
      real rsxy(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b,0:nd-1,0:nd-1)

      integer mask(nd1a:nd1b,nd2a:nd2b,nd3a:nd3b)
      integer bc(0:1,0:2),ierr

      integer ipar(0:*)
      real rpar(0:*)

      real frequencyArray(0:*)
      
!     ---- local variables -----
      integer c,i1,i2,i3,n,gridType,orderOfAccuracy,orderInTime
      integer addForcing,orderOfDissipation,option
      integer useWhereMask,solveForE,solveForH,grid
      integer ex,ey,ez, hx,hy,hz

      integer rectangular,curvilinear
      parameter( rectangular=0, curvilinear=1 )
!...........end   statement functions


      ! write(*,*) 'Inside advWaveME...'

      gridType           =ipar(2)
      orderOfAccuracy    =ipar(3)

      if( orderOfAccuracy.eq.2 )then

        ! if( nd.eq.2 .and. gridType.eq.rectangular ) then
        !   call advWaveME2dOrder2r( ARGLIST() )
        ! else if( nd.eq.2 .and. gridType.eq.curvilinear ) then
        !   call advWaveME2dOrder2c( ARGLIST() )
        ! else if( nd.eq.3 .and. gridType.eq.rectangular ) then
        !   call advWaveME3dOrder2r( ARGLIST() )
        ! else if( nd.eq.3 .and. gridType.eq.curvilinear ) then
        !   call advWaveME3dOrder2c( ARGLIST() )
        ! else
        !   stop 2271
        ! end if
        stop 2222

      else if( orderOfAccuracy.eq.4 ) then
        if( nd.eq.2 .and. gridType.eq.rectangular )then
          call advWaveME2dOrder4r( ARGLIST() )
       !  else if(nd.eq.2 .and. gridType.eq.curvilinear )then
       !    call advWaveME2dOrder4c( ARGLIST() )
       !  else if(  nd.eq.3 .and. gridType.eq.rectangular )then
       !    call advWaveME3dOrder4r( ARGLIST() )
       !  else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
       !    call advWaveME3dOrder4c( ARGLIST() )
       ! else
       !   stop 8843
       end if
       stop 4444

      else if( orderOfAccuracy.eq.6 ) then

        if( nd.eq.2 .and. gridType.eq.rectangular )then
          call advWaveME2dOrder6r( ARGLIST() )
        ! else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        !   !call advWaveME2dOrder6c( ARGLIST() )
        else if(  nd.eq.3 .and. gridType.eq.rectangular )then
          call advWaveME3dOrder6r( ARGLIST() )
        ! else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        !   !call advWaveME3dOrder6c( ARGLIST() )
       else
         stop 8843
       end if

      else if( orderOfAccuracy.eq.8 ) then

        if( nd.eq.2 .and. gridType.eq.rectangular )then
          call advWaveME2dOrder8r( ARGLIST() )
        !  else if(nd.eq.2 .and. gridType.eq.curvilinear )then
        !    call advWaveME2dOrder8c( ARGLIST() )
        else if(  nd.eq.3 .and. gridType.eq.rectangular )then
          call advWaveME3dOrder8r( ARGLIST() )
        !  else if(  nd.eq.3 .and. gridType.eq.curvilinear )then
        !    call advWaveME3dOrder8c( ARGLIST() )
        else
          stop 8843
        end if

      else
        write(*,'(" advWaveME:ERROR: un-implemented order of accuracy =",i6)') orderOfAccuracy

        stop 11122
      end if

      return
      end








